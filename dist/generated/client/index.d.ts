
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model amazon_books
 * 
 */
export type amazon_books = {
  id: number
  activate: number | null
  reference_id: string
  print_book_isbn: string | null
  eisbn: string | null
  imprint: string | null
  title: string
  author: string
  editors: string | null
  illustrators: string | null
  contributors: string | null
  translators: string | null
  photographers: string | null
  language: string
  digital_list_price_usd: number
  digital_list_price_inr: number
  release_date: Date
  publishing_date: Date | null
  description: string | null
  bisac: string | null
  bic: string | null
  territory: string | null
  exclude_territory: string | null
  adult_flag: string | null
  edition: number | null
  series_title: string | null
  series_number: number | null
  volume: number | null
  keywords: string | null
  asin: string
  amazon_url: string | null
  book_id: number
  author_id: number
  copyright_owner: number | null
  language_id: number
  status: number | null
  ku_enabled: number | null
  ku_activation_date: Date | null
  ku_us_enabled: number | null
  ku_uk_enabled: number | null
}

/**
 * Model amazon_transactions
 * 
 */
export type amazon_transactions = {
  id: number
  invoice_date: Date
  original_invoice_date: Date | null
  asin: string
  physical_isbn10: string
  physical_isbn13: string
  digital_isbn: string
  title: string
  author: string
  units_purchased: number
  units_refunded: number
  net_units: number
  net_units_mtd: number
  adjustments_made: number
  list_price: number
  list_price_currency: string
  publisher_price: number
  publisher_price_currency: string
  discount_percentage: number
  payment_amount: number
  payment_currency: string
  program_type: string
  book_id: number
  author_id: number
  user_id: number | null
  copyright_owner: number | null
  language_id: number
  currency_exchange: number
  inr_value: number
  tax_value: number | null
  final_royalty_value: number
  status: string
}

/**
 * Model audible_books
 * 
 */
export type audible_books = {
  id: number
  product_id: string | null
  audible_asin: string | null
  amazon_asin: string | null
  title: string | null
  authors: string | null
  narrators: string | null
  first_online_date: Date | null
  language_id: number | null
  book_id: number
  author_id: number | null
  copyright_owner: number | null
}

/**
 * Model audible_transactions
 * 
 */
export type audible_transactions = {
  id: number
  royalty_earner: string | null
  parent_product_id: string | null
  name: string | null
  author: string | null
  isbn: string | null
  provider_product_id: string | null
  market_place: string | null
  offer: string | null
  royalty_rate: string | null
  alc_qty: number | null
  alc_net_sales: number | null
  alc_royalty: number | null
  al_qty: number | null
  al_net_sales: number | null
  al_royalty: number | null
  alop_qty: number | null
  alop_net_sales: number | null
  alop_royalty: number | null
  total_qty: number | null
  total_net_sales: number | null
  total_royalty: number | null
  book_id: number
  author_id: number | null
  language_id: number | null
  copyright_owner: number | null
  user_id: number | null
  final_royalty_value: number | null
  transaction_date: Date | null
  status: string | null
}

/**
 * Model audio_book_details
 * 
 */
export type audio_book_details = {
  id: number
  book_id: number | null
  chapter_id: number | null
  chapter_name: string | null
  chapter_name_english: string | null
  chapter_url: string | null
  chapter_duration: string | null
  created_at: Date | null
}

/**
 * Model author_gift_books
 * 
 */
export type author_gift_books = {
  id: number
  author_id: number | null
  book_id: number | null
  user_id: number
  date: Date | null
  bookId: number
}

/**
 * Model author_language
 * 
 */
export type author_language = {
  id: number
  author_id: number | null
  language_id: number
  display_name1: string | null
  display_name2: string | null
  regional_author_name: string | null
}

/**
 * Model author_royalty_details
 * 
 */
export type author_royalty_details = {
  id: number
  copyright_owner: number | null
  author_id: number | null
  pustaka: number | null
  amazon: number | null
  kobo: number | null
  scribd: number | null
  google: number | null
  overdrive: number | null
  storytel: number | null
  audible: number | null
  settlement_date: Date | null
  bank_transaction_details: string | null
}

/**
 * Model author_tbl
 * 
 */
export type author_tbl = {
  author_id: number
  author_name: string
  url_name: string | null
  author_type: number | null
  author_image: string | null
  copy_right_owner_name: string
  relationship: string
  mobile: string | null
  phone: string | null
  email: string | null
  address: string | null
  fb_url: string | null
  twitter_url: string | null
  blog_url: string | null
  description: string | null
  status: number
  created_at: Date
  activated_at: Date | null
  created_by: number
  gender: string
  copyright_owner: number | null
  user_id: number
  narrator_id: number | null
  amazon_link: string | null
  pratilipi_link: string | null
  audible_link: string | null
  odilo_link: string | null
  scribd_link: string | null
  googlebooks_link: string | null
  storytel_link: string | null
  overdrive_link: string | null
  pinterest_link: string | null
  agreement_details: string | null
  agreement_ebook_count: number | null
  agreement_audiobook_count: number | null
  agreement_paperback_count: number | null
}

/**
 * Model author_transaction
 * 
 */
export type author_transaction = {
  id: number
  order_id: bigint
  order_date: Date | null
  book_id: number
  author_id: number
  order_type: string
  copy_right_seller: number
  copy_right_lender: number
  copyright_owner: number | null
  currency: string | null
  book_final_royalty_value_inr: number
  book_final_royalty_value_usd: number
  discount_provided: number
  usd_exchange_rate: number
  converted_book_final_royalty_value_inr: number
  exchange_rate_comments: string
  selling_royalty_percentage: number
  lending_royalty_percentage: number
  pay_status: string
  comments: string
}

/**
 * Model blog_comments
 * 
 */
export type blog_comments = {
  id: number
  user_id: number
  user_name: string
  blog_name: string
  comments: string
  email_id: string | null
  status: number
  date_created: Date
}

/**
 * Model book_tbl
 * 
 */
export type book_tbl = {
  book_id: number
  author_name: number
  book_title: string
  url_name: string | null
  regional_book_title: string
  language: number
  isbn_number: string | null
  cover_image: string | null
  description: string | null
  cost: number
  number_of_page: number | null
  genre_id: number
  book_category: string
  type_of_book: number
  publisher: string | null
  download_link: string
  epub_url: string
  royalty: string | null
  copyright_owner: number | null
  status: boolean
  created_at: Date
  activated_at: Date | null
  created_by: number
  book_cost_international: number
  narrator_id: number | null
  rental_cost_inr: number | null
  rental_cost_usd: number | null
  paper_back_flag: number | null
  paper_back_inr: number | null
  paper_back_royalty: string | null
  paper_back_readiness_flag: number | null
  book_id_mapping: number | null
  agreement_flag: number | null
  paper_back_pages: number | null
  paper_back_weight: number | null
  paper_back_copyright_owner: number | null
  paper_back_isbn: string | null
  paper_back_remarks: string | null
  mintbook_cost: number | null
}

/**
 * Model book_types
 * 
 */
export type book_types = {
  book_type_id: number
  type_name: string
  url_name: string
  status: number
  created_at: Date
  updated_at: Date
  image_url: string | null
}

/**
 * Model books_metadata
 * 
 */
export type books_metadata = {
  id: number
  book_id: number
  description: boolean
  type_of_book: number
  content_type: string
  hard_copy_type: string
  soft_copy_type: string
  final_page_number: number
  allocated_date: Date | null
  start_date: Date | null
  completion_date: Date | null
  payment_date: Date
  settled_page_number: number
  payment_status: number
  assigned_by: number
  assigned_to: number
  price_per_page: number
  initial_page_number: number | null
  general_file_path: string
  url_title: string
  unique_key: string
  pustaka_cover_status: number
  general_cover_status: number
  general_epub_status: number
  pustaka_epub_status: number
  amazon_epub_status: number
  pustaka_flippdf_status: number
  pustaka_word_status: number
  priority: string
  current_state: number | null
  remarks: string | null
}

/**
 * Model books_processing
 * 
 */
export type books_processing = {
  id: number
  book_id: number | null
  stage_id: number | null
  type_of_book: string | null
  content_type: string | null
  hard_copy_type: string | null
  soft_copy_type: string | null
  initial_page_number: number | null
  pustaka_cover_status: number | null
  pustaka_epub_status: number | null
  pustaka_flippdf_status: number | null
  priority: string | null
  date_created: Date | null
  completed: number | null
  rework: number | null
}

/**
 * Model books_progress
 * 
 */
export type books_progress = {
  id: number
  book_id: number | null
  status: number | null
  stage: number | null
  startdate: Date | null
  enddate: Date | null
  on_hold_startdate: Date | null
  on_hold_enddate: Date | null
  remarks: string | null
}

/**
 * Model contact_us
 * 
 */
export type contact_us = {
  id: number
  user_id: number | null
  subject: string | null
  message: string | null
  date_created: Date | null
}

/**
 * Model copyright_mapping
 * 
 */
export type copyright_mapping = {
  id: number
  copyright_owner: number | null
  author_id: number | null
  date_created: Date | null
}

/**
 * Model episode_book_details
 * 
 */
export type episode_book_details = {
  id: number
  episode_book_id: number | null
  chapter_name: string | null
  chapter_name_english: string | null
  chapter_epub_url: string | null
  chapter_num_pages: number | null
  chapter_status: number | null
  chapter_activated_at: Date | null
}

/**
 * Model episode_book_tbl
 * 
 */
export type episode_book_tbl = {
  episode_book_id: number
  book_title: string | null
  author_id: number | null
  url_name: string | null
  cover_image: string | null
  regional_book_title: string | null
  language: number | null
  type_of_book: number | null
  genre_id: number | null
  book_category: string | null
  description: string | null
  status: number | null
  day_of_chapter: string | null
  activated_at: Date | null
}

/**
 * Model fixed_royalty
 * 
 */
export type fixed_royalty = {
  id: number
  transaction_date: Date | null
  user_id: number | null
  copyright_owner: number | null
  fixed_royalty_value: number | null
  author_id: number | null
  status: number | null
}

/**
 * Model free_book_subscription
 * 
 */
export type free_book_subscription = {
  seq_id: number
  user_id: bigint
  book_id: bigint
  date_subscribed: Date
  comments: string
}

/**
 * Model genre_details_tbl
 * 
 */
export type genre_details_tbl = {
  genre_id: number
  admin_id: number
  genre_name: string
  url_name: string
  lang_0: string | null
  lang_1: string
  lang_2: string
  lang_3: string
  lang_4: string
  lang_5: string | null
  status: number
  bisac_code: string | null
  image_url: string | null
}

/**
 * Model google_books
 * 
 */
export type google_books = {
  id: number
  identifier: string | null
  status: string | null
  label: string | null
  play_store_link: string | null
  enable_for_sale: boolean | null
  title: string | null
  subtitle: string | null
  book_format: string | null
  related_identifier: string | null
  contributor: string | null
  biographical_note: string | null
  language: string | null
  subject_code: string | null
  age_group: string | null
  description: string | null
  publication_date: string | null
  page_count: number | null
  series_name: string | null
  volume_in_series: number | null
  preview_type: string | null
  preview_territories: string | null
  buy_link_text: string | null
  buy_link: string | null
  publisher_name: string | null
  publisher_website: string | null
  show_photos_preview: boolean | null
  pdf_download: boolean | null
  on_sale_date: string | null
  drm_enabled: boolean | null
  show_photos_ebook: boolean | null
  include_scanned_pages: boolean | null
  mature_audiences: boolean | null
  copy_paste_percentage: string | null
  enable_school_use: boolean | null
  school_list_price_60: number | null
  school_list_price_180: number | null
  school_list_price_360: number | null
  school_use_countries: string | null
  duration: Date | null
  preview_length_minutes: number | null
  preview_length_percentage: number | null
  abridged_version: string | null
  inr_price_including_tax: number | null
  inr_countries_including_tax: string | null
  usd_price_including_tax: number | null
  usd_countries_including_tax: string | null
  inr_price_excluding_tax: number | null
  inr_countries_excluding_tax: string | null
  usd_price_excluding_tax: number | null
  usd_countries_excluding_tax: string | null
  eur_price_including_tax: number | null
  eur_price_excluding_tax: number | null
  eur_countries_including_tax: string | null
  eur_countries_excluding_tax: string | null
  book_id: number
  author_id: number | null
  copyright_owner: number | null
  language_id: number | null
  publish_date: Date | null
}

/**
 * Model google_transactions
 * 
 */
export type google_transactions = {
  id: number
  earnings_date: Date
  transaction_date: Date
  unique_id: string
  product: string
  type: string
  preorder: string
  qty: number
  primary_isbn: string
  imprint_name: string
  title: string
  author: string
  original_list_price_currency: string
  original_list_price: number
  list_price_currency: string
  list_price_tax_inclusive: number
  list_price_tax_exclusive: number
  country_of_sale: string
  publisher_revenue_percentage: string
  publisher_revenue: number
  earnings_currency: string
  earnings_amount: number
  currency_conversion_rate: number
  line_of_business: string
  book_id: number
  author_id: number
  language_id: number
  currency_exchange: number
  inr_value: number
  final_royalty_value: number
  user_id: number
  copyright_owner: number | null
  status: string | null
}

/**
 * Model kobo_transaction
 * 
 */
export type kobo_transaction = {
  id: number
  transaction_date: Date
  country: string
  state: string | null
  zipcode: string | null
  content_type: string | null
  quantity: number | null
  refund_reason: string | null
  dealID: string | null
  publisher_name: string | null
  imprint: string | null
  eISBN: string
  author_name: string
  book_title: string
  list_price: number
  tax_excluded: number | null
  COGS_percentage: number
  COGS_amount: number | null
  list_price_currency: string
  foreign_exchange: number
  COGS_payable: number
  COGS_based_lp: number | null
  COGS_based_lp_excluded_tax: number | null
  COGS_based_lp_currency: number | null
  COGS_adjustment: number | null
  net_due: number
  payable_currency: string
  total_tax: number | null
  book_id: number
  author_id: number
  paid_inr: number
  user_id: number
  copyright_owner: number | null
  status: string
}

/**
 * Model language_tbl
 * 
 */
export type language_tbl = {
  language_id: number
  admin_id: number
  language_name: string
  regional_language_name: string
  url_name: string | null
  image_url: string | null
  status: number
  created_at: Date
  updated_at: Date
}

/**
 * Model ledger_head_tbl
 * 
 */
export type ledger_head_tbl = {
  id: number
  ledger_head_name: string
  date_created: Date
}

/**
 * Model narrator_tbl
 * 
 */
export type narrator_tbl = {
  narrator_id: number
  narrator_name: string | null
  narrator_url: string | null
  narrator_image: string | null
  mobile: string | null
  email: string | null
  description: string | null
  status: number | null
  user_id: number | null
  image_alt_text: string | null
  image_title_text: string | null
  created_at: Date | null
}

/**
 * Model offline_payment
 * 
 */
export type offline_payment = {
  id: number
  cart_type: number
  cart_items: string
  user_id: number
  amount: number
  currency: string
  date_created: Date
  status: number
}

/**
 * Model order
 * 
 */
export type order = {
  id: number
  order_id: bigint
  tracking_id: string
  bank_ref_no: number
  order_status: string
  failure_message: string | null
  payment_mode: string | null
  card_name: string | null
  status_code: string | null
  status_message: string | null
  currency: string
  amount: number
  channel: string | null
  billing_name: string | null
  billing_address: string | null
  billing_city: string | null
  billing_state: string | null
  billing_zip: string | null
  billing_country: string | null
  billing_tel: string | null
  billing_email: string | null
  delivery_name: string | null
  delivery_address: string | null
  delivery_city: string | null
  delivery_state: string | null
  delivery_zip: string | null
  delivery_country: string | null
  delivery_tel: string | null
  user_id: number
  cart_type: string
  subtotal: number
  service_tax: number
  net_revenue: number | null
  net_total: number
  date_created: Date
  coupon_id: string | null
  coupon_discount_amt: Prisma.Decimal | null
}

/**
 * Model order_book_details
 * 
 */
export type order_book_details = {
  book_order_id: number
  order_id: number
  user_id: number
  book_id: number
  book_cost: number | null
  order_type: number
  start_date: Date | null
  end_date: Date | null
  order_date: string
  rent_plan: number
  author_id: number
  language_id: number | null
  copyright_owner: number | null
  channel: string | null
  status: number
  date_created: Date
  user_ip: string | null
}

/**
 * Model overdrive_books
 * 
 */
export type overdrive_books = {
  id: number
  overdrive_id: number
  catalogue_id: bigint
  isbn: bigint
  physical_isbn: string | null
  title: string
  subtitle: string | null
  edition: number | null
  series: number | null
  publisher: string
  imprint: string | null
  creators: string
  subject: string
  format: string
  filesize: number
  whs_usd: number
  whs_usddiscount: number
  lib_usd: number
  lib_usddiscount: number
  onsale_date: Date
  pub_date: Date | null
  status: string
  sample_link: string
  readbox_enabled: string | null
  special_features: string | null
  book_id: number
  author_id: number
  copyright_owner: number | null
  language_id: number
  type_of_book: number | null
}

/**
 * Model overdrive_transactions
 * 
 */
export type overdrive_transactions = {
  id: number
  transaction_date: Date
  overdrive_id: number
  isbn: number
  title: string
  subtitle: string
  author: string
  retailer: string
  country_of_sale: string
  format: string
  srp_usd: number
  discount: number
  amt_owed_usd: number
  book_id: number
  author_id: number
  language_id: number
  exchange_rate: number
  inr_value: number
  final_royalty_value: number
  user_id: number
  copyright_owner: number | null
  status: string
}

/**
 * Model payout_session
 * 
 */
export type payout_session = {
  session_id: number
  session_data: string
  user_id: number
  order_id: bigint
}

/**
 * Model plan_tbl
 * 
 */
export type plan_tbl = {
  plan_id: number
  plan_name: string
  plan_display_name: string | null
  plan_url_name: string | null
  plan_type: number | null
  plan_image: string
  plan_cost: number
  plan_caption: string | null
  plan_cost_international: number
  validity_days: number
  book_validity_days: number
  available_books: number
  discount: Prisma.Decimal
  plan_intro_date: Date
  status: number
}

/**
 * Model pod_cost_notification
 * 
 */
export type pod_cost_notification = {
  id: number
  user_id: number | null
  book_id: number | null
  date_created: Date | null
  mail_status: number | null
}

/**
 * Model pod_order
 * 
 */
export type pod_order = {
  id: number
  order_id: number | null
  user_id: string | null
  shipping_charges: number | null
  discount: number | null
  order_status: number | null
  split_flag: number | null
  tracking_id: string | null
  tracking_url: string | null
  order_date: Date | null
}

/**
 * Model pod_order_details
 * 
 */
export type pod_order_details = {
  id: number
  order_id: number | null
  user_id: number | null
  book_id: number | null
  quantity: number | null
  wrapper_type: number | null
  personalised_message: string | null
  tracking_id: string | null
  tracking_url: string | null
  status: number | null
  price: number | null
  order_date: Date | null
}

/**
 * Model pod_processing
 * 
 */
export type pod_processing = {
  id: number
  book_id: number | null
  stage_id: number | null
  content_type: string | null
  word_page_number: number | null
  pod_estimation_pages: number | null
  cover_status: number | null
  priority: string | null
  date_created: Date | null
  completed: number | null
  rework: number | null
}

/**
 * Model pod_progress
 * 
 */
export type pod_progress = {
  id: number
  book_id: number | null
  status: number | null
  stage: number | null
  startdate: Date | null
  enddate: Date | null
  on_hold_startdate: Date | null
  on_hold_enddate: Date | null
  remarks: string | null
  pause_startdate: Date | null
  pause_enddate: Date | null
}

/**
 * Model publisher_tbl
 * 
 */
export type publisher_tbl = {
  publisher_id: number
  publisher_name: string | null
  publisher_url_name: string | null
  publisher_regional_name: string | null
  publisher_image: string | null
  publisher_description: string | null
  email_id: string | null
  mobile: string | null
  address: string | null
  bank_acc_no: string | null
  bank_acc_name: string | null
  bank_acc_type: string | null
  ifsc_code: string | null
  pan_number: string | null
  copyright_owner: string | null
  bonus_percentage: number | null
  status: number | null
  created_at: Date | null
  tds_flag: number | null
}

/**
 * Model rating_review
 * 
 */
export type rating_review = {
  id: number
  name: string
  user_id: number
  book_id: number
  comment: string
  rating: number
  status: number
  date_created: Date
}

/**
 * Model razorpay_requests
 * 
 */
export type razorpay_requests = {
  id: number
  user_id: number | null
  plan_id: number | null
  razorpay_payload: string | null
  created: Date | null
}

/**
 * Model royalty_settlement
 * 
 */
export type royalty_settlement = {
  id: number
  copy_right_owner_id: number
  author_id: number | null
  settlement_date: Date
  settlement_amount: number
  tds_amount: number | null
  payment_type: string
  bank_transaction_details: string
  comments: string
  pustaka: number | null
  amazon: number | null
  kobo: number | null
  scribd: number | null
  google: number | null
  overdrive: number | null
  storytel: number | null
  audible: number | null
  bonus_value: number | null
}

/**
 * Model sales_consolidation
 * 
 */
export type sales_consolidation = {
  id: number
  author_id: number | null
  book_id: number | null
  month_year: Date | null
  genre_id: number | null
  language_id: number | null
  type_of_book: number | null
  book_cost: number | null
  downloads: number
}

/**
 * Model scribd_books
 * 
 */
export type scribd_books = {
  id: number
  updated_at: Date
  import_id: number
  doc_id: number
  identifier: string
  title: string
  published: boolean
  in_subscription: boolean
  product_page_url: string | null
  imprints: string | null
  status: string
  publisher_tools_config_id: number | null
  metadata_status: string | null
  conversion_status: string | null
  product_page_pending: string | null
  subscription_pending: string | null
  book_id: number
  author_id: number
  copyright_owner: number | null
  language_id: number
  duplicate_flag: number | null
}

/**
 * Model scribd_transaction
 * 
 */
export type scribd_transaction = {
  S_No: number
  Payout_month: Date
  Publisher: string
  Amount_owed_for_this_interaction: number
  Amount_owed_currency: string
  Price_in_original_currency: number
  Digital_list_price: number
  Original_currency: string
  Price_type: string
  ISBN: bigint
  Title: string
  Authors: string
  Imprints: string
  Viewed: string
  Payout_type: string
  Start_date_of_interaction: Date
  Last_date_of_interaction: Date
  Country_of_reader: string
  Unique_interaction_ID: string
  ISO_Country_Code: string
  Threshold_Date: Date
  book_id: number
  author_id: number
  language_id: number | null
  converted_inr: number
  user_id: number | null
  copyright_owner: number | null
  status: string
  exchange_rate: number
  converted_inr_full: number | null
}

/**
 * Model storytel_books
 * 
 */
export type storytel_books = {
  id: number
  storytel_book_id: string | null
  isbn: string | null
  title: string | null
  author_name: string | null
  narrator: string | null
  category: string | null
  publication_date: Date | null
  book_id: number
  author_id: number | null
  copyright_owner: number | null
  language_id: number | null
  genre_id: number | null
  type_of_book: number | null
}

/**
 * Model storytel_transactions
 * 
 */
export type storytel_transactions = {
  id: number
  author: string | null
  title: string | null
  isbn: string | null
  country: string | null
  price_model: string | null
  no_of_units: number | null
  net_receipts_per_hour_local: number | null
  ecb_exchange_rate: string | null
  net_receipts_per_hour_inr: number | null
  book_length_in_hours: number | null
  price_per_unit: number | null
  remuneration_eur: number | null
  remuneration_inr: number | null
  publisher: string | null
  imprint: string | null
  consumption_dates: string | null
  book_type: string | null
  book_id: number
  author_id: number | null
  language_id: number | null
  user_id: bigint | null
  copyright_owner: number | null
  final_royalty_value: number | null
  transaction_date: Date | null
  status: string | null
}

/**
 * Model subscribe_newsletter
 * 
 */
export type subscribe_newsletter = {
  id: number
  email_id: string | null
  subscribe_date: Date | null
}

/**
 * Model subscription
 * 
 */
export type subscription = {
  id: number
  order_id: bigint
  user_id: number
  subscription_id: number
  plan_type: number | null
  number_of_days: number
  start_date: Date | null
  end_date: Date
  total_books_applicable: number
  date_inserted: Date
  status: number
}

/**
 * Model today_deals
 * 
 */
export type today_deals = {
  id: number
  date: Date
  book_id: number
  language_id: number | null
  discount: number
  status: string
  type: string
}

/**
 * Model top_books
 * 
 */
export type top_books = {
  id: number
  purpose: string | null
  sales_count_by_bk_id: number | null
  book_id: number | null
  book_title: string | null
  url_name: string | null
  regional_book_title: string | null
  language_id: number | null
  language_id_tmp: number | null
  type_of_book: number | null
  author_id: number | null
  author_name: string | null
  description: string | null
  download_link: string | null
  cover_image: string | null
  epub_url: string | null
  cost: number | null
  number_of_page: number | null
  genre_id: number | null
  genre_id_tmp: number | null
  genre_name: string | null
  book_category: string | null
}

/**
 * Model user_address
 * 
 */
export type user_address = {
  user_id: number
  billing_name: string | null
  billing_address1: string | null
  billing_address2: string | null
  billing_area_name: string | null
  billing_landmark: string | null
  billing_city: string | null
  billing_state: string | null
  billing_pincode: string | null
  billing_mobile_no: string | null
  billing_alternate_no: string | null
  shipping_name: string | null
  shipping_address1: string | null
  shipping_address2: string | null
  shipping_area_name: string | null
  shipping_landmark: string | null
  shipping_city: string | null
  shipping_state: string | null
  shipping_pincode: string | null
  shipping_mobile_no: string | null
  shipping_alternate_no: string | null
}

/**
 * Model user_devices
 * 
 */
export type user_devices = {
  user_id: number
  device_id1: string
  device_info1: string
  device_id2: string
  device_info2: string
  device_id3: string
  device_info3: string
  created_at: Date
  updated_at: Date
}

/**
 * Model user_subscription_tbl
 * 
 */
export type user_subscription_tbl = {
  subscription_id: number
  user_id: number
  user_email_id: string
  created_at: Date
  updated_at: Date | null
  created_by: number
  updated_by: number
}

/**
 * Model user_wallet
 * 
 */
export type user_wallet = {
  id: number
  user_id: number
  balance_inr: number
  balance_usd: number
  date: Date
}

/**
 * Model user_wallet_transaction
 * 
 */
export type user_wallet_transaction = {
  id: number
  user_id: number
  order_id: bigint
  amount: number
  currency: string
  transaction_type: number
  balance_inr: number
  balance_usd: number
  date: Date
}

/**
 * Model users_tbl
 * 
 */
export type users_tbl = {
  user_id: number
  username: string
  password: string
  dob: Date | null
  gender: string | null
  phone: string | null
  language_id: number | null
  genre_ids: string | null
  address: string
  city: string | null
  zipcode: number
  country: string
  user_type: string
  created_at: Date
  email: string
  secret_code: string | null
  channel: string | null
  profile_img_url: string | null
}

/**
 * Model wallet_order_tbl
 * 
 */
export type wallet_order_tbl = {
  id: number
  order_id: bigint
  user_id: number
  cart_type: string
  currency: string
  subtotal: number
  service_tax: number
  net_total: number
  discount: Prisma.Decimal
}

/**
 * Model wallet_transaction_type
 * 
 */
export type wallet_transaction_type = {
  transaction_type: number
  transaction_value: string
}

/**
 * Model wishlist
 * 
 */
export type wishlist = {
  id: number
  book_id: number
  user_id: number
  date_created: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Amazon_books
 * const amazon_books = await prisma.amazon_books.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Amazon_books
   * const amazon_books = await prisma.amazon_books.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.amazon_books`: Exposes CRUD operations for the **amazon_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amazon_books
    * const amazon_books = await prisma.amazon_books.findMany()
    * ```
    */
  get amazon_books(): Prisma.amazon_booksDelegate<GlobalReject>;

  /**
   * `prisma.amazon_transactions`: Exposes CRUD operations for the **amazon_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amazon_transactions
    * const amazon_transactions = await prisma.amazon_transactions.findMany()
    * ```
    */
  get amazon_transactions(): Prisma.amazon_transactionsDelegate<GlobalReject>;

  /**
   * `prisma.audible_books`: Exposes CRUD operations for the **audible_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audible_books
    * const audible_books = await prisma.audible_books.findMany()
    * ```
    */
  get audible_books(): Prisma.audible_booksDelegate<GlobalReject>;

  /**
   * `prisma.audible_transactions`: Exposes CRUD operations for the **audible_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audible_transactions
    * const audible_transactions = await prisma.audible_transactions.findMany()
    * ```
    */
  get audible_transactions(): Prisma.audible_transactionsDelegate<GlobalReject>;

  /**
   * `prisma.audio_book_details`: Exposes CRUD operations for the **audio_book_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audio_book_details
    * const audio_book_details = await prisma.audio_book_details.findMany()
    * ```
    */
  get audio_book_details(): Prisma.audio_book_detailsDelegate<GlobalReject>;

  /**
   * `prisma.author_gift_books`: Exposes CRUD operations for the **author_gift_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Author_gift_books
    * const author_gift_books = await prisma.author_gift_books.findMany()
    * ```
    */
  get author_gift_books(): Prisma.author_gift_booksDelegate<GlobalReject>;

  /**
   * `prisma.author_language`: Exposes CRUD operations for the **author_language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Author_languages
    * const author_languages = await prisma.author_language.findMany()
    * ```
    */
  get author_language(): Prisma.author_languageDelegate<GlobalReject>;

  /**
   * `prisma.author_royalty_details`: Exposes CRUD operations for the **author_royalty_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Author_royalty_details
    * const author_royalty_details = await prisma.author_royalty_details.findMany()
    * ```
    */
  get author_royalty_details(): Prisma.author_royalty_detailsDelegate<GlobalReject>;

  /**
   * `prisma.author_tbl`: Exposes CRUD operations for the **author_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Author_tbls
    * const author_tbls = await prisma.author_tbl.findMany()
    * ```
    */
  get author_tbl(): Prisma.author_tblDelegate<GlobalReject>;

  /**
   * `prisma.author_transaction`: Exposes CRUD operations for the **author_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Author_transactions
    * const author_transactions = await prisma.author_transaction.findMany()
    * ```
    */
  get author_transaction(): Prisma.author_transactionDelegate<GlobalReject>;

  /**
   * `prisma.blog_comments`: Exposes CRUD operations for the **blog_comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_comments
    * const blog_comments = await prisma.blog_comments.findMany()
    * ```
    */
  get blog_comments(): Prisma.blog_commentsDelegate<GlobalReject>;

  /**
   * `prisma.book_tbl`: Exposes CRUD operations for the **book_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_tbls
    * const book_tbls = await prisma.book_tbl.findMany()
    * ```
    */
  get book_tbl(): Prisma.book_tblDelegate<GlobalReject>;

  /**
   * `prisma.book_types`: Exposes CRUD operations for the **book_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_types
    * const book_types = await prisma.book_types.findMany()
    * ```
    */
  get book_types(): Prisma.book_typesDelegate<GlobalReject>;

  /**
   * `prisma.books_metadata`: Exposes CRUD operations for the **books_metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books_metadata
    * const books_metadata = await prisma.books_metadata.findMany()
    * ```
    */
  get books_metadata(): Prisma.books_metadataDelegate<GlobalReject>;

  /**
   * `prisma.books_processing`: Exposes CRUD operations for the **books_processing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books_processings
    * const books_processings = await prisma.books_processing.findMany()
    * ```
    */
  get books_processing(): Prisma.books_processingDelegate<GlobalReject>;

  /**
   * `prisma.books_progress`: Exposes CRUD operations for the **books_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books_progresses
    * const books_progresses = await prisma.books_progress.findMany()
    * ```
    */
  get books_progress(): Prisma.books_progressDelegate<GlobalReject>;

  /**
   * `prisma.contact_us`: Exposes CRUD operations for the **contact_us** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_uses
    * const contact_uses = await prisma.contact_us.findMany()
    * ```
    */
  get contact_us(): Prisma.contact_usDelegate<GlobalReject>;

  /**
   * `prisma.copyright_mapping`: Exposes CRUD operations for the **copyright_mapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Copyright_mappings
    * const copyright_mappings = await prisma.copyright_mapping.findMany()
    * ```
    */
  get copyright_mapping(): Prisma.copyright_mappingDelegate<GlobalReject>;

  /**
   * `prisma.episode_book_details`: Exposes CRUD operations for the **episode_book_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episode_book_details
    * const episode_book_details = await prisma.episode_book_details.findMany()
    * ```
    */
  get episode_book_details(): Prisma.episode_book_detailsDelegate<GlobalReject>;

  /**
   * `prisma.episode_book_tbl`: Exposes CRUD operations for the **episode_book_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episode_book_tbls
    * const episode_book_tbls = await prisma.episode_book_tbl.findMany()
    * ```
    */
  get episode_book_tbl(): Prisma.episode_book_tblDelegate<GlobalReject>;

  /**
   * `prisma.fixed_royalty`: Exposes CRUD operations for the **fixed_royalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fixed_royalties
    * const fixed_royalties = await prisma.fixed_royalty.findMany()
    * ```
    */
  get fixed_royalty(): Prisma.fixed_royaltyDelegate<GlobalReject>;

  /**
   * `prisma.free_book_subscription`: Exposes CRUD operations for the **free_book_subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Free_book_subscriptions
    * const free_book_subscriptions = await prisma.free_book_subscription.findMany()
    * ```
    */
  get free_book_subscription(): Prisma.free_book_subscriptionDelegate<GlobalReject>;

  /**
   * `prisma.genre_details_tbl`: Exposes CRUD operations for the **genre_details_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genre_details_tbls
    * const genre_details_tbls = await prisma.genre_details_tbl.findMany()
    * ```
    */
  get genre_details_tbl(): Prisma.genre_details_tblDelegate<GlobalReject>;

  /**
   * `prisma.google_books`: Exposes CRUD operations for the **google_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Google_books
    * const google_books = await prisma.google_books.findMany()
    * ```
    */
  get google_books(): Prisma.google_booksDelegate<GlobalReject>;

  /**
   * `prisma.google_transactions`: Exposes CRUD operations for the **google_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Google_transactions
    * const google_transactions = await prisma.google_transactions.findMany()
    * ```
    */
  get google_transactions(): Prisma.google_transactionsDelegate<GlobalReject>;

  /**
   * `prisma.kobo_transaction`: Exposes CRUD operations for the **kobo_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kobo_transactions
    * const kobo_transactions = await prisma.kobo_transaction.findMany()
    * ```
    */
  get kobo_transaction(): Prisma.kobo_transactionDelegate<GlobalReject>;

  /**
   * `prisma.language_tbl`: Exposes CRUD operations for the **language_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Language_tbls
    * const language_tbls = await prisma.language_tbl.findMany()
    * ```
    */
  get language_tbl(): Prisma.language_tblDelegate<GlobalReject>;

  /**
   * `prisma.ledger_head_tbl`: Exposes CRUD operations for the **ledger_head_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ledger_head_tbls
    * const ledger_head_tbls = await prisma.ledger_head_tbl.findMany()
    * ```
    */
  get ledger_head_tbl(): Prisma.ledger_head_tblDelegate<GlobalReject>;

  /**
   * `prisma.narrator_tbl`: Exposes CRUD operations for the **narrator_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Narrator_tbls
    * const narrator_tbls = await prisma.narrator_tbl.findMany()
    * ```
    */
  get narrator_tbl(): Prisma.narrator_tblDelegate<GlobalReject>;

  /**
   * `prisma.offline_payment`: Exposes CRUD operations for the **offline_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offline_payments
    * const offline_payments = await prisma.offline_payment.findMany()
    * ```
    */
  get offline_payment(): Prisma.offline_paymentDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<GlobalReject>;

  /**
   * `prisma.order_book_details`: Exposes CRUD operations for the **order_book_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_book_details
    * const order_book_details = await prisma.order_book_details.findMany()
    * ```
    */
  get order_book_details(): Prisma.order_book_detailsDelegate<GlobalReject>;

  /**
   * `prisma.overdrive_books`: Exposes CRUD operations for the **overdrive_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overdrive_books
    * const overdrive_books = await prisma.overdrive_books.findMany()
    * ```
    */
  get overdrive_books(): Prisma.overdrive_booksDelegate<GlobalReject>;

  /**
   * `prisma.overdrive_transactions`: Exposes CRUD operations for the **overdrive_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overdrive_transactions
    * const overdrive_transactions = await prisma.overdrive_transactions.findMany()
    * ```
    */
  get overdrive_transactions(): Prisma.overdrive_transactionsDelegate<GlobalReject>;

  /**
   * `prisma.payout_session`: Exposes CRUD operations for the **payout_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payout_sessions
    * const payout_sessions = await prisma.payout_session.findMany()
    * ```
    */
  get payout_session(): Prisma.payout_sessionDelegate<GlobalReject>;

  /**
   * `prisma.plan_tbl`: Exposes CRUD operations for the **plan_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_tbls
    * const plan_tbls = await prisma.plan_tbl.findMany()
    * ```
    */
  get plan_tbl(): Prisma.plan_tblDelegate<GlobalReject>;

  /**
   * `prisma.pod_cost_notification`: Exposes CRUD operations for the **pod_cost_notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pod_cost_notifications
    * const pod_cost_notifications = await prisma.pod_cost_notification.findMany()
    * ```
    */
  get pod_cost_notification(): Prisma.pod_cost_notificationDelegate<GlobalReject>;

  /**
   * `prisma.pod_order`: Exposes CRUD operations for the **pod_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pod_orders
    * const pod_orders = await prisma.pod_order.findMany()
    * ```
    */
  get pod_order(): Prisma.pod_orderDelegate<GlobalReject>;

  /**
   * `prisma.pod_order_details`: Exposes CRUD operations for the **pod_order_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pod_order_details
    * const pod_order_details = await prisma.pod_order_details.findMany()
    * ```
    */
  get pod_order_details(): Prisma.pod_order_detailsDelegate<GlobalReject>;

  /**
   * `prisma.pod_processing`: Exposes CRUD operations for the **pod_processing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pod_processings
    * const pod_processings = await prisma.pod_processing.findMany()
    * ```
    */
  get pod_processing(): Prisma.pod_processingDelegate<GlobalReject>;

  /**
   * `prisma.pod_progress`: Exposes CRUD operations for the **pod_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pod_progresses
    * const pod_progresses = await prisma.pod_progress.findMany()
    * ```
    */
  get pod_progress(): Prisma.pod_progressDelegate<GlobalReject>;

  /**
   * `prisma.publisher_tbl`: Exposes CRUD operations for the **publisher_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publisher_tbls
    * const publisher_tbls = await prisma.publisher_tbl.findMany()
    * ```
    */
  get publisher_tbl(): Prisma.publisher_tblDelegate<GlobalReject>;

  /**
   * `prisma.rating_review`: Exposes CRUD operations for the **rating_review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rating_reviews
    * const rating_reviews = await prisma.rating_review.findMany()
    * ```
    */
  get rating_review(): Prisma.rating_reviewDelegate<GlobalReject>;

  /**
   * `prisma.razorpay_requests`: Exposes CRUD operations for the **razorpay_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Razorpay_requests
    * const razorpay_requests = await prisma.razorpay_requests.findMany()
    * ```
    */
  get razorpay_requests(): Prisma.razorpay_requestsDelegate<GlobalReject>;

  /**
   * `prisma.royalty_settlement`: Exposes CRUD operations for the **royalty_settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Royalty_settlements
    * const royalty_settlements = await prisma.royalty_settlement.findMany()
    * ```
    */
  get royalty_settlement(): Prisma.royalty_settlementDelegate<GlobalReject>;

  /**
   * `prisma.sales_consolidation`: Exposes CRUD operations for the **sales_consolidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales_consolidations
    * const sales_consolidations = await prisma.sales_consolidation.findMany()
    * ```
    */
  get sales_consolidation(): Prisma.sales_consolidationDelegate<GlobalReject>;

  /**
   * `prisma.scribd_books`: Exposes CRUD operations for the **scribd_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scribd_books
    * const scribd_books = await prisma.scribd_books.findMany()
    * ```
    */
  get scribd_books(): Prisma.scribd_booksDelegate<GlobalReject>;

  /**
   * `prisma.scribd_transaction`: Exposes CRUD operations for the **scribd_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scribd_transactions
    * const scribd_transactions = await prisma.scribd_transaction.findMany()
    * ```
    */
  get scribd_transaction(): Prisma.scribd_transactionDelegate<GlobalReject>;

  /**
   * `prisma.storytel_books`: Exposes CRUD operations for the **storytel_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storytel_books
    * const storytel_books = await prisma.storytel_books.findMany()
    * ```
    */
  get storytel_books(): Prisma.storytel_booksDelegate<GlobalReject>;

  /**
   * `prisma.storytel_transactions`: Exposes CRUD operations for the **storytel_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storytel_transactions
    * const storytel_transactions = await prisma.storytel_transactions.findMany()
    * ```
    */
  get storytel_transactions(): Prisma.storytel_transactionsDelegate<GlobalReject>;

  /**
   * `prisma.subscribe_newsletter`: Exposes CRUD operations for the **subscribe_newsletter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribe_newsletters
    * const subscribe_newsletters = await prisma.subscribe_newsletter.findMany()
    * ```
    */
  get subscribe_newsletter(): Prisma.subscribe_newsletterDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<GlobalReject>;

  /**
   * `prisma.today_deals`: Exposes CRUD operations for the **today_deals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Today_deals
    * const today_deals = await prisma.today_deals.findMany()
    * ```
    */
  get today_deals(): Prisma.today_dealsDelegate<GlobalReject>;

  /**
   * `prisma.top_books`: Exposes CRUD operations for the **top_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Top_books
    * const top_books = await prisma.top_books.findMany()
    * ```
    */
  get top_books(): Prisma.top_booksDelegate<GlobalReject>;

  /**
   * `prisma.user_address`: Exposes CRUD operations for the **user_address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_addresses
    * const user_addresses = await prisma.user_address.findMany()
    * ```
    */
  get user_address(): Prisma.user_addressDelegate<GlobalReject>;

  /**
   * `prisma.user_devices`: Exposes CRUD operations for the **user_devices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_devices
    * const user_devices = await prisma.user_devices.findMany()
    * ```
    */
  get user_devices(): Prisma.user_devicesDelegate<GlobalReject>;

  /**
   * `prisma.user_subscription_tbl`: Exposes CRUD operations for the **user_subscription_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_subscription_tbls
    * const user_subscription_tbls = await prisma.user_subscription_tbl.findMany()
    * ```
    */
  get user_subscription_tbl(): Prisma.user_subscription_tblDelegate<GlobalReject>;

  /**
   * `prisma.user_wallet`: Exposes CRUD operations for the **user_wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_wallets
    * const user_wallets = await prisma.user_wallet.findMany()
    * ```
    */
  get user_wallet(): Prisma.user_walletDelegate<GlobalReject>;

  /**
   * `prisma.user_wallet_transaction`: Exposes CRUD operations for the **user_wallet_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_wallet_transactions
    * const user_wallet_transactions = await prisma.user_wallet_transaction.findMany()
    * ```
    */
  get user_wallet_transaction(): Prisma.user_wallet_transactionDelegate<GlobalReject>;

  /**
   * `prisma.users_tbl`: Exposes CRUD operations for the **users_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_tbls
    * const users_tbls = await prisma.users_tbl.findMany()
    * ```
    */
  get users_tbl(): Prisma.users_tblDelegate<GlobalReject>;

  /**
   * `prisma.wallet_order_tbl`: Exposes CRUD operations for the **wallet_order_tbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_order_tbls
    * const wallet_order_tbls = await prisma.wallet_order_tbl.findMany()
    * ```
    */
  get wallet_order_tbl(): Prisma.wallet_order_tblDelegate<GlobalReject>;

  /**
   * `prisma.wallet_transaction_type`: Exposes CRUD operations for the **wallet_transaction_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_transaction_types
    * const wallet_transaction_types = await prisma.wallet_transaction_type.findMany()
    * ```
    */
  get wallet_transaction_type(): Prisma.wallet_transaction_typeDelegate<GlobalReject>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.wishlistDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.6.1
   * Query Engine version: 694eea289a8462c80264df36757e4fdc129b1b32
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    amazon_books: 'amazon_books',
    amazon_transactions: 'amazon_transactions',
    audible_books: 'audible_books',
    audible_transactions: 'audible_transactions',
    audio_book_details: 'audio_book_details',
    author_gift_books: 'author_gift_books',
    author_language: 'author_language',
    author_royalty_details: 'author_royalty_details',
    author_tbl: 'author_tbl',
    author_transaction: 'author_transaction',
    blog_comments: 'blog_comments',
    book_tbl: 'book_tbl',
    book_types: 'book_types',
    books_metadata: 'books_metadata',
    books_processing: 'books_processing',
    books_progress: 'books_progress',
    contact_us: 'contact_us',
    copyright_mapping: 'copyright_mapping',
    episode_book_details: 'episode_book_details',
    episode_book_tbl: 'episode_book_tbl',
    fixed_royalty: 'fixed_royalty',
    free_book_subscription: 'free_book_subscription',
    genre_details_tbl: 'genre_details_tbl',
    google_books: 'google_books',
    google_transactions: 'google_transactions',
    kobo_transaction: 'kobo_transaction',
    language_tbl: 'language_tbl',
    ledger_head_tbl: 'ledger_head_tbl',
    narrator_tbl: 'narrator_tbl',
    offline_payment: 'offline_payment',
    order: 'order',
    order_book_details: 'order_book_details',
    overdrive_books: 'overdrive_books',
    overdrive_transactions: 'overdrive_transactions',
    payout_session: 'payout_session',
    plan_tbl: 'plan_tbl',
    pod_cost_notification: 'pod_cost_notification',
    pod_order: 'pod_order',
    pod_order_details: 'pod_order_details',
    pod_processing: 'pod_processing',
    pod_progress: 'pod_progress',
    publisher_tbl: 'publisher_tbl',
    rating_review: 'rating_review',
    razorpay_requests: 'razorpay_requests',
    royalty_settlement: 'royalty_settlement',
    sales_consolidation: 'sales_consolidation',
    scribd_books: 'scribd_books',
    scribd_transaction: 'scribd_transaction',
    storytel_books: 'storytel_books',
    storytel_transactions: 'storytel_transactions',
    subscribe_newsletter: 'subscribe_newsletter',
    subscription: 'subscription',
    today_deals: 'today_deals',
    top_books: 'top_books',
    user_address: 'user_address',
    user_devices: 'user_devices',
    user_subscription_tbl: 'user_subscription_tbl',
    user_wallet: 'user_wallet',
    user_wallet_transaction: 'user_wallet_transaction',
    users_tbl: 'users_tbl',
    wallet_order_tbl: 'wallet_order_tbl',
    wallet_transaction_type: 'wallet_transaction_type',
    wishlist: 'wishlist'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Book_tblCountOutputType
   */


  export type Book_tblCountOutputType = {
    giftBooks: number
  }

  export type Book_tblCountOutputTypeSelect = {
    giftBooks?: boolean
  }

  export type Book_tblCountOutputTypeGetPayload<S extends boolean | null | undefined | Book_tblCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Book_tblCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Book_tblCountOutputTypeArgs)
    ? Book_tblCountOutputType 
    : S extends { select: any } & (Book_tblCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Book_tblCountOutputType ? Book_tblCountOutputType[P] : never
  } 
      : Book_tblCountOutputType




  // Custom InputTypes

  /**
   * Book_tblCountOutputType without action
   */
  export type Book_tblCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Book_tblCountOutputType
     * 
    **/
    select?: Book_tblCountOutputTypeSelect | null
  }



  /**
   * Count Type Genre_details_tblCountOutputType
   */


  export type Genre_details_tblCountOutputType = {
    books: number
  }

  export type Genre_details_tblCountOutputTypeSelect = {
    books?: boolean
  }

  export type Genre_details_tblCountOutputTypeGetPayload<S extends boolean | null | undefined | Genre_details_tblCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Genre_details_tblCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Genre_details_tblCountOutputTypeArgs)
    ? Genre_details_tblCountOutputType 
    : S extends { select: any } & (Genre_details_tblCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Genre_details_tblCountOutputType ? Genre_details_tblCountOutputType[P] : never
  } 
      : Genre_details_tblCountOutputType




  // Custom InputTypes

  /**
   * Genre_details_tblCountOutputType without action
   */
  export type Genre_details_tblCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Genre_details_tblCountOutputType
     * 
    **/
    select?: Genre_details_tblCountOutputTypeSelect | null
  }



  /**
   * Count Type Language_tblCountOutputType
   */


  export type Language_tblCountOutputType = {
    books: number
    authorLanguages: number
  }

  export type Language_tblCountOutputTypeSelect = {
    books?: boolean
    authorLanguages?: boolean
  }

  export type Language_tblCountOutputTypeGetPayload<S extends boolean | null | undefined | Language_tblCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Language_tblCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Language_tblCountOutputTypeArgs)
    ? Language_tblCountOutputType 
    : S extends { select: any } & (Language_tblCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Language_tblCountOutputType ? Language_tblCountOutputType[P] : never
  } 
      : Language_tblCountOutputType




  // Custom InputTypes

  /**
   * Language_tblCountOutputType without action
   */
  export type Language_tblCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Language_tblCountOutputType
     * 
    **/
    select?: Language_tblCountOutputTypeSelect | null
  }



  /**
   * Count Type Users_tblCountOutputType
   */


  export type Users_tblCountOutputType = {
    giftBooks: number
  }

  export type Users_tblCountOutputTypeSelect = {
    giftBooks?: boolean
  }

  export type Users_tblCountOutputTypeGetPayload<S extends boolean | null | undefined | Users_tblCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Users_tblCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Users_tblCountOutputTypeArgs)
    ? Users_tblCountOutputType 
    : S extends { select: any } & (Users_tblCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Users_tblCountOutputType ? Users_tblCountOutputType[P] : never
  } 
      : Users_tblCountOutputType




  // Custom InputTypes

  /**
   * Users_tblCountOutputType without action
   */
  export type Users_tblCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Users_tblCountOutputType
     * 
    **/
    select?: Users_tblCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model amazon_books
   */


  export type AggregateAmazon_books = {
    _count: Amazon_booksCountAggregateOutputType | null
    _avg: Amazon_booksAvgAggregateOutputType | null
    _sum: Amazon_booksSumAggregateOutputType | null
    _min: Amazon_booksMinAggregateOutputType | null
    _max: Amazon_booksMaxAggregateOutputType | null
  }

  export type Amazon_booksAvgAggregateOutputType = {
    id: number | null
    activate: number | null
    digital_list_price_usd: number | null
    digital_list_price_inr: number | null
    edition: number | null
    series_number: number | null
    volume: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    status: number | null
    ku_enabled: number | null
    ku_us_enabled: number | null
    ku_uk_enabled: number | null
  }

  export type Amazon_booksSumAggregateOutputType = {
    id: number | null
    activate: number | null
    digital_list_price_usd: number | null
    digital_list_price_inr: number | null
    edition: number | null
    series_number: number | null
    volume: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    status: number | null
    ku_enabled: number | null
    ku_us_enabled: number | null
    ku_uk_enabled: number | null
  }

  export type Amazon_booksMinAggregateOutputType = {
    id: number | null
    activate: number | null
    reference_id: string | null
    print_book_isbn: string | null
    eisbn: string | null
    imprint: string | null
    title: string | null
    author: string | null
    editors: string | null
    illustrators: string | null
    contributors: string | null
    translators: string | null
    photographers: string | null
    language: string | null
    digital_list_price_usd: number | null
    digital_list_price_inr: number | null
    release_date: Date | null
    publishing_date: Date | null
    description: string | null
    bisac: string | null
    bic: string | null
    territory: string | null
    exclude_territory: string | null
    adult_flag: string | null
    edition: number | null
    series_title: string | null
    series_number: number | null
    volume: number | null
    keywords: string | null
    asin: string | null
    amazon_url: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    status: number | null
    ku_enabled: number | null
    ku_activation_date: Date | null
    ku_us_enabled: number | null
    ku_uk_enabled: number | null
  }

  export type Amazon_booksMaxAggregateOutputType = {
    id: number | null
    activate: number | null
    reference_id: string | null
    print_book_isbn: string | null
    eisbn: string | null
    imprint: string | null
    title: string | null
    author: string | null
    editors: string | null
    illustrators: string | null
    contributors: string | null
    translators: string | null
    photographers: string | null
    language: string | null
    digital_list_price_usd: number | null
    digital_list_price_inr: number | null
    release_date: Date | null
    publishing_date: Date | null
    description: string | null
    bisac: string | null
    bic: string | null
    territory: string | null
    exclude_territory: string | null
    adult_flag: string | null
    edition: number | null
    series_title: string | null
    series_number: number | null
    volume: number | null
    keywords: string | null
    asin: string | null
    amazon_url: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    status: number | null
    ku_enabled: number | null
    ku_activation_date: Date | null
    ku_us_enabled: number | null
    ku_uk_enabled: number | null
  }

  export type Amazon_booksCountAggregateOutputType = {
    id: number
    activate: number
    reference_id: number
    print_book_isbn: number
    eisbn: number
    imprint: number
    title: number
    author: number
    editors: number
    illustrators: number
    contributors: number
    translators: number
    photographers: number
    language: number
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: number
    publishing_date: number
    description: number
    bisac: number
    bic: number
    territory: number
    exclude_territory: number
    adult_flag: number
    edition: number
    series_title: number
    series_number: number
    volume: number
    keywords: number
    asin: number
    amazon_url: number
    book_id: number
    author_id: number
    copyright_owner: number
    language_id: number
    status: number
    ku_enabled: number
    ku_activation_date: number
    ku_us_enabled: number
    ku_uk_enabled: number
    _all: number
  }


  export type Amazon_booksAvgAggregateInputType = {
    id?: true
    activate?: true
    digital_list_price_usd?: true
    digital_list_price_inr?: true
    edition?: true
    series_number?: true
    volume?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    status?: true
    ku_enabled?: true
    ku_us_enabled?: true
    ku_uk_enabled?: true
  }

  export type Amazon_booksSumAggregateInputType = {
    id?: true
    activate?: true
    digital_list_price_usd?: true
    digital_list_price_inr?: true
    edition?: true
    series_number?: true
    volume?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    status?: true
    ku_enabled?: true
    ku_us_enabled?: true
    ku_uk_enabled?: true
  }

  export type Amazon_booksMinAggregateInputType = {
    id?: true
    activate?: true
    reference_id?: true
    print_book_isbn?: true
    eisbn?: true
    imprint?: true
    title?: true
    author?: true
    editors?: true
    illustrators?: true
    contributors?: true
    translators?: true
    photographers?: true
    language?: true
    digital_list_price_usd?: true
    digital_list_price_inr?: true
    release_date?: true
    publishing_date?: true
    description?: true
    bisac?: true
    bic?: true
    territory?: true
    exclude_territory?: true
    adult_flag?: true
    edition?: true
    series_title?: true
    series_number?: true
    volume?: true
    keywords?: true
    asin?: true
    amazon_url?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    status?: true
    ku_enabled?: true
    ku_activation_date?: true
    ku_us_enabled?: true
    ku_uk_enabled?: true
  }

  export type Amazon_booksMaxAggregateInputType = {
    id?: true
    activate?: true
    reference_id?: true
    print_book_isbn?: true
    eisbn?: true
    imprint?: true
    title?: true
    author?: true
    editors?: true
    illustrators?: true
    contributors?: true
    translators?: true
    photographers?: true
    language?: true
    digital_list_price_usd?: true
    digital_list_price_inr?: true
    release_date?: true
    publishing_date?: true
    description?: true
    bisac?: true
    bic?: true
    territory?: true
    exclude_territory?: true
    adult_flag?: true
    edition?: true
    series_title?: true
    series_number?: true
    volume?: true
    keywords?: true
    asin?: true
    amazon_url?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    status?: true
    ku_enabled?: true
    ku_activation_date?: true
    ku_us_enabled?: true
    ku_uk_enabled?: true
  }

  export type Amazon_booksCountAggregateInputType = {
    id?: true
    activate?: true
    reference_id?: true
    print_book_isbn?: true
    eisbn?: true
    imprint?: true
    title?: true
    author?: true
    editors?: true
    illustrators?: true
    contributors?: true
    translators?: true
    photographers?: true
    language?: true
    digital_list_price_usd?: true
    digital_list_price_inr?: true
    release_date?: true
    publishing_date?: true
    description?: true
    bisac?: true
    bic?: true
    territory?: true
    exclude_territory?: true
    adult_flag?: true
    edition?: true
    series_title?: true
    series_number?: true
    volume?: true
    keywords?: true
    asin?: true
    amazon_url?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    status?: true
    ku_enabled?: true
    ku_activation_date?: true
    ku_us_enabled?: true
    ku_uk_enabled?: true
    _all?: true
  }

  export type Amazon_booksAggregateArgs = {
    /**
     * Filter which amazon_books to aggregate.
     * 
    **/
    where?: amazon_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_books to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: amazon_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned amazon_books
    **/
    _count?: true | Amazon_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Amazon_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Amazon_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Amazon_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Amazon_booksMaxAggregateInputType
  }

  export type GetAmazon_booksAggregateType<T extends Amazon_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazon_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazon_books[P]>
      : GetScalarType<T[P], AggregateAmazon_books[P]>
  }




  export type Amazon_booksGroupByArgs = {
    where?: amazon_booksWhereInput
    orderBy?: Enumerable<amazon_booksOrderByWithAggregationInput>
    by: Array<Amazon_booksScalarFieldEnum>
    having?: amazon_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Amazon_booksCountAggregateInputType | true
    _avg?: Amazon_booksAvgAggregateInputType
    _sum?: Amazon_booksSumAggregateInputType
    _min?: Amazon_booksMinAggregateInputType
    _max?: Amazon_booksMaxAggregateInputType
  }


  export type Amazon_booksGroupByOutputType = {
    id: number
    activate: number | null
    reference_id: string
    print_book_isbn: string | null
    eisbn: string | null
    imprint: string | null
    title: string
    author: string
    editors: string | null
    illustrators: string | null
    contributors: string | null
    translators: string | null
    photographers: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date
    publishing_date: Date | null
    description: string | null
    bisac: string | null
    bic: string | null
    territory: string | null
    exclude_territory: string | null
    adult_flag: string | null
    edition: number | null
    series_title: string | null
    series_number: number | null
    volume: number | null
    keywords: string | null
    asin: string
    amazon_url: string | null
    book_id: number
    author_id: number
    copyright_owner: number | null
    language_id: number
    status: number | null
    ku_enabled: number | null
    ku_activation_date: Date | null
    ku_us_enabled: number | null
    ku_uk_enabled: number | null
    _count: Amazon_booksCountAggregateOutputType | null
    _avg: Amazon_booksAvgAggregateOutputType | null
    _sum: Amazon_booksSumAggregateOutputType | null
    _min: Amazon_booksMinAggregateOutputType | null
    _max: Amazon_booksMaxAggregateOutputType | null
  }

  type GetAmazon_booksGroupByPayload<T extends Amazon_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Amazon_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Amazon_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Amazon_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Amazon_booksGroupByOutputType[P]>
        }
      >
    >


  export type amazon_booksSelect = {
    id?: boolean
    activate?: boolean
    reference_id?: boolean
    print_book_isbn?: boolean
    eisbn?: boolean
    imprint?: boolean
    title?: boolean
    author?: boolean
    editors?: boolean
    illustrators?: boolean
    contributors?: boolean
    translators?: boolean
    photographers?: boolean
    language?: boolean
    digital_list_price_usd?: boolean
    digital_list_price_inr?: boolean
    release_date?: boolean
    publishing_date?: boolean
    description?: boolean
    bisac?: boolean
    bic?: boolean
    territory?: boolean
    exclude_territory?: boolean
    adult_flag?: boolean
    edition?: boolean
    series_title?: boolean
    series_number?: boolean
    volume?: boolean
    keywords?: boolean
    asin?: boolean
    amazon_url?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    status?: boolean
    ku_enabled?: boolean
    ku_activation_date?: boolean
    ku_us_enabled?: boolean
    ku_uk_enabled?: boolean
  }


  export type amazon_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type amazon_booksGetPayload<S extends boolean | null | undefined | amazon_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? amazon_books :
    S extends undefined ? never :
    S extends { include: any } & (amazon_booksArgs | amazon_booksFindManyArgs)
    ? amazon_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (amazon_booksArgs | amazon_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof amazon_books ? amazon_books[P] : never
  } 
      : amazon_books


  type amazon_booksCountArgs = Merge<
    Omit<amazon_booksFindManyArgs, 'select' | 'include'> & {
      select?: Amazon_booksCountAggregateInputType | true
    }
  >

  export interface amazon_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Amazon_books that matches the filter.
     * @param {amazon_booksFindUniqueArgs} args - Arguments to find a Amazon_books
     * @example
     * // Get one Amazon_books
     * const amazon_books = await prisma.amazon_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends amazon_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, amazon_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'amazon_books'> extends True ? Prisma__amazon_booksClient<amazon_booksGetPayload<T>> : Prisma__amazon_booksClient<amazon_booksGetPayload<T> | null, null>

    /**
     * Find the first Amazon_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_booksFindFirstArgs} args - Arguments to find a Amazon_books
     * @example
     * // Get one Amazon_books
     * const amazon_books = await prisma.amazon_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends amazon_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, amazon_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'amazon_books'> extends True ? Prisma__amazon_booksClient<amazon_booksGetPayload<T>> : Prisma__amazon_booksClient<amazon_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Amazon_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amazon_books
     * const amazon_books = await prisma.amazon_books.findMany()
     * 
     * // Get first 10 Amazon_books
     * const amazon_books = await prisma.amazon_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazon_booksWithIdOnly = await prisma.amazon_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends amazon_booksFindManyArgs>(
      args?: SelectSubset<T, amazon_booksFindManyArgs>
    ): PrismaPromise<Array<amazon_booksGetPayload<T>>>

    /**
     * Create a Amazon_books.
     * @param {amazon_booksCreateArgs} args - Arguments to create a Amazon_books.
     * @example
     * // Create one Amazon_books
     * const Amazon_books = await prisma.amazon_books.create({
     *   data: {
     *     // ... data to create a Amazon_books
     *   }
     * })
     * 
    **/
    create<T extends amazon_booksCreateArgs>(
      args: SelectSubset<T, amazon_booksCreateArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Create many Amazon_books.
     *     @param {amazon_booksCreateManyArgs} args - Arguments to create many Amazon_books.
     *     @example
     *     // Create many Amazon_books
     *     const amazon_books = await prisma.amazon_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends amazon_booksCreateManyArgs>(
      args?: SelectSubset<T, amazon_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Amazon_books.
     * @param {amazon_booksDeleteArgs} args - Arguments to delete one Amazon_books.
     * @example
     * // Delete one Amazon_books
     * const Amazon_books = await prisma.amazon_books.delete({
     *   where: {
     *     // ... filter to delete one Amazon_books
     *   }
     * })
     * 
    **/
    delete<T extends amazon_booksDeleteArgs>(
      args: SelectSubset<T, amazon_booksDeleteArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Update one Amazon_books.
     * @param {amazon_booksUpdateArgs} args - Arguments to update one Amazon_books.
     * @example
     * // Update one Amazon_books
     * const amazon_books = await prisma.amazon_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends amazon_booksUpdateArgs>(
      args: SelectSubset<T, amazon_booksUpdateArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Delete zero or more Amazon_books.
     * @param {amazon_booksDeleteManyArgs} args - Arguments to filter Amazon_books to delete.
     * @example
     * // Delete a few Amazon_books
     * const { count } = await prisma.amazon_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends amazon_booksDeleteManyArgs>(
      args?: SelectSubset<T, amazon_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amazon_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amazon_books
     * const amazon_books = await prisma.amazon_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends amazon_booksUpdateManyArgs>(
      args: SelectSubset<T, amazon_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Amazon_books.
     * @param {amazon_booksUpsertArgs} args - Arguments to update or create a Amazon_books.
     * @example
     * // Update or create a Amazon_books
     * const amazon_books = await prisma.amazon_books.upsert({
     *   create: {
     *     // ... data to create a Amazon_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amazon_books we want to update
     *   }
     * })
    **/
    upsert<T extends amazon_booksUpsertArgs>(
      args: SelectSubset<T, amazon_booksUpsertArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Find one Amazon_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {amazon_booksFindUniqueOrThrowArgs} args - Arguments to find a Amazon_books
     * @example
     * // Get one Amazon_books
     * const amazon_books = await prisma.amazon_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends amazon_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, amazon_booksFindUniqueOrThrowArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Find the first Amazon_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_booksFindFirstOrThrowArgs} args - Arguments to find a Amazon_books
     * @example
     * // Get one Amazon_books
     * const amazon_books = await prisma.amazon_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends amazon_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, amazon_booksFindFirstOrThrowArgs>
    ): Prisma__amazon_booksClient<amazon_booksGetPayload<T>>

    /**
     * Count the number of Amazon_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_booksCountArgs} args - Arguments to filter Amazon_books to count.
     * @example
     * // Count the number of Amazon_books
     * const count = await prisma.amazon_books.count({
     *   where: {
     *     // ... the filter for the Amazon_books we want to count
     *   }
     * })
    **/
    count<T extends amazon_booksCountArgs>(
      args?: Subset<T, amazon_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Amazon_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amazon_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Amazon_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Amazon_booksAggregateArgs>(args: Subset<T, Amazon_booksAggregateArgs>): PrismaPromise<GetAmazon_booksAggregateType<T>>

    /**
     * Group by Amazon_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Amazon_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Amazon_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Amazon_booksGroupByArgs['orderBy'] }
        : { orderBy?: Amazon_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Amazon_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazon_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for amazon_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__amazon_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * amazon_books base type for findUnique actions
   */
  export type amazon_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * Filter, which amazon_books to fetch.
     * 
    **/
    where: amazon_booksWhereUniqueInput
  }

  /**
   * amazon_books: findUnique
   */
  export interface amazon_booksFindUniqueArgs extends amazon_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * amazon_books base type for findFirst actions
   */
  export type amazon_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * Filter, which amazon_books to fetch.
     * 
    **/
    where?: amazon_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_books to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for amazon_books.
     * 
    **/
    cursor?: amazon_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of amazon_books.
     * 
    **/
    distinct?: Enumerable<Amazon_booksScalarFieldEnum>
  }

  /**
   * amazon_books: findFirst
   */
  export interface amazon_booksFindFirstArgs extends amazon_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * amazon_books findMany
   */
  export type amazon_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * Filter, which amazon_books to fetch.
     * 
    **/
    where?: amazon_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_books to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing amazon_books.
     * 
    **/
    cursor?: amazon_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Amazon_booksScalarFieldEnum>
  }


  /**
   * amazon_books create
   */
  export type amazon_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * The data needed to create a amazon_books.
     * 
    **/
    data: XOR<amazon_booksCreateInput, amazon_booksUncheckedCreateInput>
  }


  /**
   * amazon_books createMany
   */
  export type amazon_booksCreateManyArgs = {
    /**
     * The data used to create many amazon_books.
     * 
    **/
    data: Enumerable<amazon_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * amazon_books update
   */
  export type amazon_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * The data needed to update a amazon_books.
     * 
    **/
    data: XOR<amazon_booksUpdateInput, amazon_booksUncheckedUpdateInput>
    /**
     * Choose, which amazon_books to update.
     * 
    **/
    where: amazon_booksWhereUniqueInput
  }


  /**
   * amazon_books updateMany
   */
  export type amazon_booksUpdateManyArgs = {
    /**
     * The data used to update amazon_books.
     * 
    **/
    data: XOR<amazon_booksUpdateManyMutationInput, amazon_booksUncheckedUpdateManyInput>
    /**
     * Filter which amazon_books to update
     * 
    **/
    where?: amazon_booksWhereInput
  }


  /**
   * amazon_books upsert
   */
  export type amazon_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * The filter to search for the amazon_books to update in case it exists.
     * 
    **/
    where: amazon_booksWhereUniqueInput
    /**
     * In case the amazon_books found by the `where` argument doesn't exist, create a new amazon_books with this data.
     * 
    **/
    create: XOR<amazon_booksCreateInput, amazon_booksUncheckedCreateInput>
    /**
     * In case the amazon_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<amazon_booksUpdateInput, amazon_booksUncheckedUpdateInput>
  }


  /**
   * amazon_books delete
   */
  export type amazon_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
    /**
     * Filter which amazon_books to delete.
     * 
    **/
    where: amazon_booksWhereUniqueInput
  }


  /**
   * amazon_books deleteMany
   */
  export type amazon_booksDeleteManyArgs = {
    /**
     * Filter which amazon_books to delete
     * 
    **/
    where?: amazon_booksWhereInput
  }


  /**
   * amazon_books: findUniqueOrThrow
   */
  export type amazon_booksFindUniqueOrThrowArgs = amazon_booksFindUniqueArgsBase
      

  /**
   * amazon_books: findFirstOrThrow
   */
  export type amazon_booksFindFirstOrThrowArgs = amazon_booksFindFirstArgsBase
      

  /**
   * amazon_books without action
   */
  export type amazon_booksArgs = {
    /**
     * Select specific fields to fetch from the amazon_books
     * 
    **/
    select?: amazon_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_booksInclude | null
  }



  /**
   * Model amazon_transactions
   */


  export type AggregateAmazon_transactions = {
    _count: Amazon_transactionsCountAggregateOutputType | null
    _avg: Amazon_transactionsAvgAggregateOutputType | null
    _sum: Amazon_transactionsSumAggregateOutputType | null
    _min: Amazon_transactionsMinAggregateOutputType | null
    _max: Amazon_transactionsMaxAggregateOutputType | null
  }

  export type Amazon_transactionsAvgAggregateOutputType = {
    id: number | null
    units_purchased: number | null
    units_refunded: number | null
    net_units: number | null
    net_units_mtd: number | null
    adjustments_made: number | null
    list_price: number | null
    publisher_price: number | null
    discount_percentage: number | null
    payment_amount: number | null
    book_id: number | null
    author_id: number | null
    user_id: number | null
    copyright_owner: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    tax_value: number | null
    final_royalty_value: number | null
  }

  export type Amazon_transactionsSumAggregateOutputType = {
    id: number | null
    units_purchased: number | null
    units_refunded: number | null
    net_units: number | null
    net_units_mtd: number | null
    adjustments_made: number | null
    list_price: number | null
    publisher_price: number | null
    discount_percentage: number | null
    payment_amount: number | null
    book_id: number | null
    author_id: number | null
    user_id: number | null
    copyright_owner: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    tax_value: number | null
    final_royalty_value: number | null
  }

  export type Amazon_transactionsMinAggregateOutputType = {
    id: number | null
    invoice_date: Date | null
    original_invoice_date: Date | null
    asin: string | null
    physical_isbn10: string | null
    physical_isbn13: string | null
    digital_isbn: string | null
    title: string | null
    author: string | null
    units_purchased: number | null
    units_refunded: number | null
    net_units: number | null
    net_units_mtd: number | null
    adjustments_made: number | null
    list_price: number | null
    list_price_currency: string | null
    publisher_price: number | null
    publisher_price_currency: string | null
    discount_percentage: number | null
    payment_amount: number | null
    payment_currency: string | null
    program_type: string | null
    book_id: number | null
    author_id: number | null
    user_id: number | null
    copyright_owner: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    tax_value: number | null
    final_royalty_value: number | null
    status: string | null
  }

  export type Amazon_transactionsMaxAggregateOutputType = {
    id: number | null
    invoice_date: Date | null
    original_invoice_date: Date | null
    asin: string | null
    physical_isbn10: string | null
    physical_isbn13: string | null
    digital_isbn: string | null
    title: string | null
    author: string | null
    units_purchased: number | null
    units_refunded: number | null
    net_units: number | null
    net_units_mtd: number | null
    adjustments_made: number | null
    list_price: number | null
    list_price_currency: string | null
    publisher_price: number | null
    publisher_price_currency: string | null
    discount_percentage: number | null
    payment_amount: number | null
    payment_currency: string | null
    program_type: string | null
    book_id: number | null
    author_id: number | null
    user_id: number | null
    copyright_owner: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    tax_value: number | null
    final_royalty_value: number | null
    status: string | null
  }

  export type Amazon_transactionsCountAggregateOutputType = {
    id: number
    invoice_date: number
    original_invoice_date: number
    asin: number
    physical_isbn10: number
    physical_isbn13: number
    digital_isbn: number
    title: number
    author: number
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: number
    publisher_price: number
    publisher_price_currency: number
    discount_percentage: number
    payment_amount: number
    payment_currency: number
    program_type: number
    book_id: number
    author_id: number
    user_id: number
    copyright_owner: number
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value: number
    final_royalty_value: number
    status: number
    _all: number
  }


  export type Amazon_transactionsAvgAggregateInputType = {
    id?: true
    units_purchased?: true
    units_refunded?: true
    net_units?: true
    net_units_mtd?: true
    adjustments_made?: true
    list_price?: true
    publisher_price?: true
    discount_percentage?: true
    payment_amount?: true
    book_id?: true
    author_id?: true
    user_id?: true
    copyright_owner?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    tax_value?: true
    final_royalty_value?: true
  }

  export type Amazon_transactionsSumAggregateInputType = {
    id?: true
    units_purchased?: true
    units_refunded?: true
    net_units?: true
    net_units_mtd?: true
    adjustments_made?: true
    list_price?: true
    publisher_price?: true
    discount_percentage?: true
    payment_amount?: true
    book_id?: true
    author_id?: true
    user_id?: true
    copyright_owner?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    tax_value?: true
    final_royalty_value?: true
  }

  export type Amazon_transactionsMinAggregateInputType = {
    id?: true
    invoice_date?: true
    original_invoice_date?: true
    asin?: true
    physical_isbn10?: true
    physical_isbn13?: true
    digital_isbn?: true
    title?: true
    author?: true
    units_purchased?: true
    units_refunded?: true
    net_units?: true
    net_units_mtd?: true
    adjustments_made?: true
    list_price?: true
    list_price_currency?: true
    publisher_price?: true
    publisher_price_currency?: true
    discount_percentage?: true
    payment_amount?: true
    payment_currency?: true
    program_type?: true
    book_id?: true
    author_id?: true
    user_id?: true
    copyright_owner?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    tax_value?: true
    final_royalty_value?: true
    status?: true
  }

  export type Amazon_transactionsMaxAggregateInputType = {
    id?: true
    invoice_date?: true
    original_invoice_date?: true
    asin?: true
    physical_isbn10?: true
    physical_isbn13?: true
    digital_isbn?: true
    title?: true
    author?: true
    units_purchased?: true
    units_refunded?: true
    net_units?: true
    net_units_mtd?: true
    adjustments_made?: true
    list_price?: true
    list_price_currency?: true
    publisher_price?: true
    publisher_price_currency?: true
    discount_percentage?: true
    payment_amount?: true
    payment_currency?: true
    program_type?: true
    book_id?: true
    author_id?: true
    user_id?: true
    copyright_owner?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    tax_value?: true
    final_royalty_value?: true
    status?: true
  }

  export type Amazon_transactionsCountAggregateInputType = {
    id?: true
    invoice_date?: true
    original_invoice_date?: true
    asin?: true
    physical_isbn10?: true
    physical_isbn13?: true
    digital_isbn?: true
    title?: true
    author?: true
    units_purchased?: true
    units_refunded?: true
    net_units?: true
    net_units_mtd?: true
    adjustments_made?: true
    list_price?: true
    list_price_currency?: true
    publisher_price?: true
    publisher_price_currency?: true
    discount_percentage?: true
    payment_amount?: true
    payment_currency?: true
    program_type?: true
    book_id?: true
    author_id?: true
    user_id?: true
    copyright_owner?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    tax_value?: true
    final_royalty_value?: true
    status?: true
    _all?: true
  }

  export type Amazon_transactionsAggregateArgs = {
    /**
     * Filter which amazon_transactions to aggregate.
     * 
    **/
    where?: amazon_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: amazon_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned amazon_transactions
    **/
    _count?: true | Amazon_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Amazon_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Amazon_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Amazon_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Amazon_transactionsMaxAggregateInputType
  }

  export type GetAmazon_transactionsAggregateType<T extends Amazon_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazon_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazon_transactions[P]>
      : GetScalarType<T[P], AggregateAmazon_transactions[P]>
  }




  export type Amazon_transactionsGroupByArgs = {
    where?: amazon_transactionsWhereInput
    orderBy?: Enumerable<amazon_transactionsOrderByWithAggregationInput>
    by: Array<Amazon_transactionsScalarFieldEnum>
    having?: amazon_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Amazon_transactionsCountAggregateInputType | true
    _avg?: Amazon_transactionsAvgAggregateInputType
    _sum?: Amazon_transactionsSumAggregateInputType
    _min?: Amazon_transactionsMinAggregateInputType
    _max?: Amazon_transactionsMaxAggregateInputType
  }


  export type Amazon_transactionsGroupByOutputType = {
    id: number
    invoice_date: Date
    original_invoice_date: Date | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    book_id: number
    author_id: number
    user_id: number | null
    copyright_owner: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value: number | null
    final_royalty_value: number
    status: string
    _count: Amazon_transactionsCountAggregateOutputType | null
    _avg: Amazon_transactionsAvgAggregateOutputType | null
    _sum: Amazon_transactionsSumAggregateOutputType | null
    _min: Amazon_transactionsMinAggregateOutputType | null
    _max: Amazon_transactionsMaxAggregateOutputType | null
  }

  type GetAmazon_transactionsGroupByPayload<T extends Amazon_transactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Amazon_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Amazon_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Amazon_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Amazon_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type amazon_transactionsSelect = {
    id?: boolean
    invoice_date?: boolean
    original_invoice_date?: boolean
    asin?: boolean
    physical_isbn10?: boolean
    physical_isbn13?: boolean
    digital_isbn?: boolean
    title?: boolean
    author?: boolean
    units_purchased?: boolean
    units_refunded?: boolean
    net_units?: boolean
    net_units_mtd?: boolean
    adjustments_made?: boolean
    list_price?: boolean
    list_price_currency?: boolean
    publisher_price?: boolean
    publisher_price_currency?: boolean
    discount_percentage?: boolean
    payment_amount?: boolean
    payment_currency?: boolean
    program_type?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    currency_exchange?: boolean
    inr_value?: boolean
    tax_value?: boolean
    final_royalty_value?: boolean
    status?: boolean
  }


  export type amazon_transactionsInclude = {
    book?: boolean | book_tblArgs
  } 

  export type amazon_transactionsGetPayload<S extends boolean | null | undefined | amazon_transactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? amazon_transactions :
    S extends undefined ? never :
    S extends { include: any } & (amazon_transactionsArgs | amazon_transactionsFindManyArgs)
    ? amazon_transactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (amazon_transactionsArgs | amazon_transactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof amazon_transactions ? amazon_transactions[P] : never
  } 
      : amazon_transactions


  type amazon_transactionsCountArgs = Merge<
    Omit<amazon_transactionsFindManyArgs, 'select' | 'include'> & {
      select?: Amazon_transactionsCountAggregateInputType | true
    }
  >

  export interface amazon_transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Amazon_transactions that matches the filter.
     * @param {amazon_transactionsFindUniqueArgs} args - Arguments to find a Amazon_transactions
     * @example
     * // Get one Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends amazon_transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, amazon_transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'amazon_transactions'> extends True ? Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>> : Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T> | null, null>

    /**
     * Find the first Amazon_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_transactionsFindFirstArgs} args - Arguments to find a Amazon_transactions
     * @example
     * // Get one Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends amazon_transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, amazon_transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'amazon_transactions'> extends True ? Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>> : Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T> | null, null>

    /**
     * Find zero or more Amazon_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findMany()
     * 
     * // Get first 10 Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazon_transactionsWithIdOnly = await prisma.amazon_transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends amazon_transactionsFindManyArgs>(
      args?: SelectSubset<T, amazon_transactionsFindManyArgs>
    ): PrismaPromise<Array<amazon_transactionsGetPayload<T>>>

    /**
     * Create a Amazon_transactions.
     * @param {amazon_transactionsCreateArgs} args - Arguments to create a Amazon_transactions.
     * @example
     * // Create one Amazon_transactions
     * const Amazon_transactions = await prisma.amazon_transactions.create({
     *   data: {
     *     // ... data to create a Amazon_transactions
     *   }
     * })
     * 
    **/
    create<T extends amazon_transactionsCreateArgs>(
      args: SelectSubset<T, amazon_transactionsCreateArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Create many Amazon_transactions.
     *     @param {amazon_transactionsCreateManyArgs} args - Arguments to create many Amazon_transactions.
     *     @example
     *     // Create many Amazon_transactions
     *     const amazon_transactions = await prisma.amazon_transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends amazon_transactionsCreateManyArgs>(
      args?: SelectSubset<T, amazon_transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Amazon_transactions.
     * @param {amazon_transactionsDeleteArgs} args - Arguments to delete one Amazon_transactions.
     * @example
     * // Delete one Amazon_transactions
     * const Amazon_transactions = await prisma.amazon_transactions.delete({
     *   where: {
     *     // ... filter to delete one Amazon_transactions
     *   }
     * })
     * 
    **/
    delete<T extends amazon_transactionsDeleteArgs>(
      args: SelectSubset<T, amazon_transactionsDeleteArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Update one Amazon_transactions.
     * @param {amazon_transactionsUpdateArgs} args - Arguments to update one Amazon_transactions.
     * @example
     * // Update one Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends amazon_transactionsUpdateArgs>(
      args: SelectSubset<T, amazon_transactionsUpdateArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Delete zero or more Amazon_transactions.
     * @param {amazon_transactionsDeleteManyArgs} args - Arguments to filter Amazon_transactions to delete.
     * @example
     * // Delete a few Amazon_transactions
     * const { count } = await prisma.amazon_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends amazon_transactionsDeleteManyArgs>(
      args?: SelectSubset<T, amazon_transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amazon_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends amazon_transactionsUpdateManyArgs>(
      args: SelectSubset<T, amazon_transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Amazon_transactions.
     * @param {amazon_transactionsUpsertArgs} args - Arguments to update or create a Amazon_transactions.
     * @example
     * // Update or create a Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.upsert({
     *   create: {
     *     // ... data to create a Amazon_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amazon_transactions we want to update
     *   }
     * })
    **/
    upsert<T extends amazon_transactionsUpsertArgs>(
      args: SelectSubset<T, amazon_transactionsUpsertArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Find one Amazon_transactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {amazon_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Amazon_transactions
     * @example
     * // Get one Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends amazon_transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, amazon_transactionsFindUniqueOrThrowArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Find the first Amazon_transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_transactionsFindFirstOrThrowArgs} args - Arguments to find a Amazon_transactions
     * @example
     * // Get one Amazon_transactions
     * const amazon_transactions = await prisma.amazon_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends amazon_transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, amazon_transactionsFindFirstOrThrowArgs>
    ): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T>>

    /**
     * Count the number of Amazon_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amazon_transactionsCountArgs} args - Arguments to filter Amazon_transactions to count.
     * @example
     * // Count the number of Amazon_transactions
     * const count = await prisma.amazon_transactions.count({
     *   where: {
     *     // ... the filter for the Amazon_transactions we want to count
     *   }
     * })
    **/
    count<T extends amazon_transactionsCountArgs>(
      args?: Subset<T, amazon_transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Amazon_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amazon_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Amazon_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Amazon_transactionsAggregateArgs>(args: Subset<T, Amazon_transactionsAggregateArgs>): PrismaPromise<GetAmazon_transactionsAggregateType<T>>

    /**
     * Group by Amazon_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Amazon_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Amazon_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Amazon_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: Amazon_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Amazon_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazon_transactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for amazon_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__amazon_transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * amazon_transactions base type for findUnique actions
   */
  export type amazon_transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * Filter, which amazon_transactions to fetch.
     * 
    **/
    where: amazon_transactionsWhereUniqueInput
  }

  /**
   * amazon_transactions: findUnique
   */
  export interface amazon_transactionsFindUniqueArgs extends amazon_transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * amazon_transactions base type for findFirst actions
   */
  export type amazon_transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * Filter, which amazon_transactions to fetch.
     * 
    **/
    where?: amazon_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for amazon_transactions.
     * 
    **/
    cursor?: amazon_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of amazon_transactions.
     * 
    **/
    distinct?: Enumerable<Amazon_transactionsScalarFieldEnum>
  }

  /**
   * amazon_transactions: findFirst
   */
  export interface amazon_transactionsFindFirstArgs extends amazon_transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * amazon_transactions findMany
   */
  export type amazon_transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * Filter, which amazon_transactions to fetch.
     * 
    **/
    where?: amazon_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amazon_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<amazon_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing amazon_transactions.
     * 
    **/
    cursor?: amazon_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amazon_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amazon_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Amazon_transactionsScalarFieldEnum>
  }


  /**
   * amazon_transactions create
   */
  export type amazon_transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * The data needed to create a amazon_transactions.
     * 
    **/
    data: XOR<amazon_transactionsCreateInput, amazon_transactionsUncheckedCreateInput>
  }


  /**
   * amazon_transactions createMany
   */
  export type amazon_transactionsCreateManyArgs = {
    /**
     * The data used to create many amazon_transactions.
     * 
    **/
    data: Enumerable<amazon_transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * amazon_transactions update
   */
  export type amazon_transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * The data needed to update a amazon_transactions.
     * 
    **/
    data: XOR<amazon_transactionsUpdateInput, amazon_transactionsUncheckedUpdateInput>
    /**
     * Choose, which amazon_transactions to update.
     * 
    **/
    where: amazon_transactionsWhereUniqueInput
  }


  /**
   * amazon_transactions updateMany
   */
  export type amazon_transactionsUpdateManyArgs = {
    /**
     * The data used to update amazon_transactions.
     * 
    **/
    data: XOR<amazon_transactionsUpdateManyMutationInput, amazon_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which amazon_transactions to update
     * 
    **/
    where?: amazon_transactionsWhereInput
  }


  /**
   * amazon_transactions upsert
   */
  export type amazon_transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * The filter to search for the amazon_transactions to update in case it exists.
     * 
    **/
    where: amazon_transactionsWhereUniqueInput
    /**
     * In case the amazon_transactions found by the `where` argument doesn't exist, create a new amazon_transactions with this data.
     * 
    **/
    create: XOR<amazon_transactionsCreateInput, amazon_transactionsUncheckedCreateInput>
    /**
     * In case the amazon_transactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<amazon_transactionsUpdateInput, amazon_transactionsUncheckedUpdateInput>
  }


  /**
   * amazon_transactions delete
   */
  export type amazon_transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
    /**
     * Filter which amazon_transactions to delete.
     * 
    **/
    where: amazon_transactionsWhereUniqueInput
  }


  /**
   * amazon_transactions deleteMany
   */
  export type amazon_transactionsDeleteManyArgs = {
    /**
     * Filter which amazon_transactions to delete
     * 
    **/
    where?: amazon_transactionsWhereInput
  }


  /**
   * amazon_transactions: findUniqueOrThrow
   */
  export type amazon_transactionsFindUniqueOrThrowArgs = amazon_transactionsFindUniqueArgsBase
      

  /**
   * amazon_transactions: findFirstOrThrow
   */
  export type amazon_transactionsFindFirstOrThrowArgs = amazon_transactionsFindFirstArgsBase
      

  /**
   * amazon_transactions without action
   */
  export type amazon_transactionsArgs = {
    /**
     * Select specific fields to fetch from the amazon_transactions
     * 
    **/
    select?: amazon_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: amazon_transactionsInclude | null
  }



  /**
   * Model audible_books
   */


  export type AggregateAudible_books = {
    _count: Audible_booksCountAggregateOutputType | null
    _avg: Audible_booksAvgAggregateOutputType | null
    _sum: Audible_booksSumAggregateOutputType | null
    _min: Audible_booksMinAggregateOutputType | null
    _max: Audible_booksMaxAggregateOutputType | null
  }

  export type Audible_booksAvgAggregateOutputType = {
    id: number | null
    language_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
  }

  export type Audible_booksSumAggregateOutputType = {
    id: number | null
    language_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
  }

  export type Audible_booksMinAggregateOutputType = {
    id: number | null
    product_id: string | null
    audible_asin: string | null
    amazon_asin: string | null
    title: string | null
    authors: string | null
    narrators: string | null
    first_online_date: Date | null
    language_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
  }

  export type Audible_booksMaxAggregateOutputType = {
    id: number | null
    product_id: string | null
    audible_asin: string | null
    amazon_asin: string | null
    title: string | null
    authors: string | null
    narrators: string | null
    first_online_date: Date | null
    language_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
  }

  export type Audible_booksCountAggregateOutputType = {
    id: number
    product_id: number
    audible_asin: number
    amazon_asin: number
    title: number
    authors: number
    narrators: number
    first_online_date: number
    language_id: number
    book_id: number
    author_id: number
    copyright_owner: number
    _all: number
  }


  export type Audible_booksAvgAggregateInputType = {
    id?: true
    language_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
  }

  export type Audible_booksSumAggregateInputType = {
    id?: true
    language_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
  }

  export type Audible_booksMinAggregateInputType = {
    id?: true
    product_id?: true
    audible_asin?: true
    amazon_asin?: true
    title?: true
    authors?: true
    narrators?: true
    first_online_date?: true
    language_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
  }

  export type Audible_booksMaxAggregateInputType = {
    id?: true
    product_id?: true
    audible_asin?: true
    amazon_asin?: true
    title?: true
    authors?: true
    narrators?: true
    first_online_date?: true
    language_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
  }

  export type Audible_booksCountAggregateInputType = {
    id?: true
    product_id?: true
    audible_asin?: true
    amazon_asin?: true
    title?: true
    authors?: true
    narrators?: true
    first_online_date?: true
    language_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    _all?: true
  }

  export type Audible_booksAggregateArgs = {
    /**
     * Filter which audible_books to aggregate.
     * 
    **/
    where?: audible_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_books to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: audible_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audible_books
    **/
    _count?: true | Audible_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audible_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audible_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audible_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audible_booksMaxAggregateInputType
  }

  export type GetAudible_booksAggregateType<T extends Audible_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateAudible_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudible_books[P]>
      : GetScalarType<T[P], AggregateAudible_books[P]>
  }




  export type Audible_booksGroupByArgs = {
    where?: audible_booksWhereInput
    orderBy?: Enumerable<audible_booksOrderByWithAggregationInput>
    by: Array<Audible_booksScalarFieldEnum>
    having?: audible_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audible_booksCountAggregateInputType | true
    _avg?: Audible_booksAvgAggregateInputType
    _sum?: Audible_booksSumAggregateInputType
    _min?: Audible_booksMinAggregateInputType
    _max?: Audible_booksMaxAggregateInputType
  }


  export type Audible_booksGroupByOutputType = {
    id: number
    product_id: string | null
    audible_asin: string | null
    amazon_asin: string | null
    title: string | null
    authors: string | null
    narrators: string | null
    first_online_date: Date | null
    language_id: number | null
    book_id: number
    author_id: number | null
    copyright_owner: number | null
    _count: Audible_booksCountAggregateOutputType | null
    _avg: Audible_booksAvgAggregateOutputType | null
    _sum: Audible_booksSumAggregateOutputType | null
    _min: Audible_booksMinAggregateOutputType | null
    _max: Audible_booksMaxAggregateOutputType | null
  }

  type GetAudible_booksGroupByPayload<T extends Audible_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Audible_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audible_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audible_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Audible_booksGroupByOutputType[P]>
        }
      >
    >


  export type audible_booksSelect = {
    id?: boolean
    product_id?: boolean
    audible_asin?: boolean
    amazon_asin?: boolean
    title?: boolean
    authors?: boolean
    narrators?: boolean
    first_online_date?: boolean
    language_id?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
  }


  export type audible_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type audible_booksGetPayload<S extends boolean | null | undefined | audible_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? audible_books :
    S extends undefined ? never :
    S extends { include: any } & (audible_booksArgs | audible_booksFindManyArgs)
    ? audible_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (audible_booksArgs | audible_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof audible_books ? audible_books[P] : never
  } 
      : audible_books


  type audible_booksCountArgs = Merge<
    Omit<audible_booksFindManyArgs, 'select' | 'include'> & {
      select?: Audible_booksCountAggregateInputType | true
    }
  >

  export interface audible_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Audible_books that matches the filter.
     * @param {audible_booksFindUniqueArgs} args - Arguments to find a Audible_books
     * @example
     * // Get one Audible_books
     * const audible_books = await prisma.audible_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends audible_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, audible_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'audible_books'> extends True ? Prisma__audible_booksClient<audible_booksGetPayload<T>> : Prisma__audible_booksClient<audible_booksGetPayload<T> | null, null>

    /**
     * Find the first Audible_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_booksFindFirstArgs} args - Arguments to find a Audible_books
     * @example
     * // Get one Audible_books
     * const audible_books = await prisma.audible_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends audible_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, audible_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'audible_books'> extends True ? Prisma__audible_booksClient<audible_booksGetPayload<T>> : Prisma__audible_booksClient<audible_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Audible_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audible_books
     * const audible_books = await prisma.audible_books.findMany()
     * 
     * // Get first 10 Audible_books
     * const audible_books = await prisma.audible_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audible_booksWithIdOnly = await prisma.audible_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends audible_booksFindManyArgs>(
      args?: SelectSubset<T, audible_booksFindManyArgs>
    ): PrismaPromise<Array<audible_booksGetPayload<T>>>

    /**
     * Create a Audible_books.
     * @param {audible_booksCreateArgs} args - Arguments to create a Audible_books.
     * @example
     * // Create one Audible_books
     * const Audible_books = await prisma.audible_books.create({
     *   data: {
     *     // ... data to create a Audible_books
     *   }
     * })
     * 
    **/
    create<T extends audible_booksCreateArgs>(
      args: SelectSubset<T, audible_booksCreateArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Create many Audible_books.
     *     @param {audible_booksCreateManyArgs} args - Arguments to create many Audible_books.
     *     @example
     *     // Create many Audible_books
     *     const audible_books = await prisma.audible_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends audible_booksCreateManyArgs>(
      args?: SelectSubset<T, audible_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Audible_books.
     * @param {audible_booksDeleteArgs} args - Arguments to delete one Audible_books.
     * @example
     * // Delete one Audible_books
     * const Audible_books = await prisma.audible_books.delete({
     *   where: {
     *     // ... filter to delete one Audible_books
     *   }
     * })
     * 
    **/
    delete<T extends audible_booksDeleteArgs>(
      args: SelectSubset<T, audible_booksDeleteArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Update one Audible_books.
     * @param {audible_booksUpdateArgs} args - Arguments to update one Audible_books.
     * @example
     * // Update one Audible_books
     * const audible_books = await prisma.audible_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends audible_booksUpdateArgs>(
      args: SelectSubset<T, audible_booksUpdateArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Delete zero or more Audible_books.
     * @param {audible_booksDeleteManyArgs} args - Arguments to filter Audible_books to delete.
     * @example
     * // Delete a few Audible_books
     * const { count } = await prisma.audible_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends audible_booksDeleteManyArgs>(
      args?: SelectSubset<T, audible_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audible_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audible_books
     * const audible_books = await prisma.audible_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends audible_booksUpdateManyArgs>(
      args: SelectSubset<T, audible_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Audible_books.
     * @param {audible_booksUpsertArgs} args - Arguments to update or create a Audible_books.
     * @example
     * // Update or create a Audible_books
     * const audible_books = await prisma.audible_books.upsert({
     *   create: {
     *     // ... data to create a Audible_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audible_books we want to update
     *   }
     * })
    **/
    upsert<T extends audible_booksUpsertArgs>(
      args: SelectSubset<T, audible_booksUpsertArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Find one Audible_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {audible_booksFindUniqueOrThrowArgs} args - Arguments to find a Audible_books
     * @example
     * // Get one Audible_books
     * const audible_books = await prisma.audible_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends audible_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, audible_booksFindUniqueOrThrowArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Find the first Audible_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_booksFindFirstOrThrowArgs} args - Arguments to find a Audible_books
     * @example
     * // Get one Audible_books
     * const audible_books = await prisma.audible_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends audible_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, audible_booksFindFirstOrThrowArgs>
    ): Prisma__audible_booksClient<audible_booksGetPayload<T>>

    /**
     * Count the number of Audible_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_booksCountArgs} args - Arguments to filter Audible_books to count.
     * @example
     * // Count the number of Audible_books
     * const count = await prisma.audible_books.count({
     *   where: {
     *     // ... the filter for the Audible_books we want to count
     *   }
     * })
    **/
    count<T extends audible_booksCountArgs>(
      args?: Subset<T, audible_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audible_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audible_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audible_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audible_booksAggregateArgs>(args: Subset<T, Audible_booksAggregateArgs>): PrismaPromise<GetAudible_booksAggregateType<T>>

    /**
     * Group by Audible_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audible_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Audible_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Audible_booksGroupByArgs['orderBy'] }
        : { orderBy?: Audible_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Audible_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudible_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for audible_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__audible_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * audible_books base type for findUnique actions
   */
  export type audible_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * Filter, which audible_books to fetch.
     * 
    **/
    where: audible_booksWhereUniqueInput
  }

  /**
   * audible_books: findUnique
   */
  export interface audible_booksFindUniqueArgs extends audible_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audible_books base type for findFirst actions
   */
  export type audible_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * Filter, which audible_books to fetch.
     * 
    **/
    where?: audible_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_books to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audible_books.
     * 
    **/
    cursor?: audible_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audible_books.
     * 
    **/
    distinct?: Enumerable<Audible_booksScalarFieldEnum>
  }

  /**
   * audible_books: findFirst
   */
  export interface audible_booksFindFirstArgs extends audible_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audible_books findMany
   */
  export type audible_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * Filter, which audible_books to fetch.
     * 
    **/
    where?: audible_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_books to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audible_books.
     * 
    **/
    cursor?: audible_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Audible_booksScalarFieldEnum>
  }


  /**
   * audible_books create
   */
  export type audible_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * The data needed to create a audible_books.
     * 
    **/
    data: XOR<audible_booksCreateInput, audible_booksUncheckedCreateInput>
  }


  /**
   * audible_books createMany
   */
  export type audible_booksCreateManyArgs = {
    /**
     * The data used to create many audible_books.
     * 
    **/
    data: Enumerable<audible_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * audible_books update
   */
  export type audible_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * The data needed to update a audible_books.
     * 
    **/
    data: XOR<audible_booksUpdateInput, audible_booksUncheckedUpdateInput>
    /**
     * Choose, which audible_books to update.
     * 
    **/
    where: audible_booksWhereUniqueInput
  }


  /**
   * audible_books updateMany
   */
  export type audible_booksUpdateManyArgs = {
    /**
     * The data used to update audible_books.
     * 
    **/
    data: XOR<audible_booksUpdateManyMutationInput, audible_booksUncheckedUpdateManyInput>
    /**
     * Filter which audible_books to update
     * 
    **/
    where?: audible_booksWhereInput
  }


  /**
   * audible_books upsert
   */
  export type audible_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * The filter to search for the audible_books to update in case it exists.
     * 
    **/
    where: audible_booksWhereUniqueInput
    /**
     * In case the audible_books found by the `where` argument doesn't exist, create a new audible_books with this data.
     * 
    **/
    create: XOR<audible_booksCreateInput, audible_booksUncheckedCreateInput>
    /**
     * In case the audible_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<audible_booksUpdateInput, audible_booksUncheckedUpdateInput>
  }


  /**
   * audible_books delete
   */
  export type audible_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
    /**
     * Filter which audible_books to delete.
     * 
    **/
    where: audible_booksWhereUniqueInput
  }


  /**
   * audible_books deleteMany
   */
  export type audible_booksDeleteManyArgs = {
    /**
     * Filter which audible_books to delete
     * 
    **/
    where?: audible_booksWhereInput
  }


  /**
   * audible_books: findUniqueOrThrow
   */
  export type audible_booksFindUniqueOrThrowArgs = audible_booksFindUniqueArgsBase
      

  /**
   * audible_books: findFirstOrThrow
   */
  export type audible_booksFindFirstOrThrowArgs = audible_booksFindFirstArgsBase
      

  /**
   * audible_books without action
   */
  export type audible_booksArgs = {
    /**
     * Select specific fields to fetch from the audible_books
     * 
    **/
    select?: audible_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_booksInclude | null
  }



  /**
   * Model audible_transactions
   */


  export type AggregateAudible_transactions = {
    _count: Audible_transactionsCountAggregateOutputType | null
    _avg: Audible_transactionsAvgAggregateOutputType | null
    _sum: Audible_transactionsSumAggregateOutputType | null
    _min: Audible_transactionsMinAggregateOutputType | null
    _max: Audible_transactionsMaxAggregateOutputType | null
  }

  export type Audible_transactionsAvgAggregateOutputType = {
    id: number | null
    alc_qty: number | null
    alc_net_sales: number | null
    alc_royalty: number | null
    al_qty: number | null
    al_net_sales: number | null
    al_royalty: number | null
    alop_qty: number | null
    alop_net_sales: number | null
    alop_royalty: number | null
    total_qty: number | null
    total_net_sales: number | null
    total_royalty: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    user_id: number | null
    final_royalty_value: number | null
  }

  export type Audible_transactionsSumAggregateOutputType = {
    id: number | null
    alc_qty: number | null
    alc_net_sales: number | null
    alc_royalty: number | null
    al_qty: number | null
    al_net_sales: number | null
    al_royalty: number | null
    alop_qty: number | null
    alop_net_sales: number | null
    alop_royalty: number | null
    total_qty: number | null
    total_net_sales: number | null
    total_royalty: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    user_id: number | null
    final_royalty_value: number | null
  }

  export type Audible_transactionsMinAggregateOutputType = {
    id: number | null
    royalty_earner: string | null
    parent_product_id: string | null
    name: string | null
    author: string | null
    isbn: string | null
    provider_product_id: string | null
    market_place: string | null
    offer: string | null
    royalty_rate: string | null
    alc_qty: number | null
    alc_net_sales: number | null
    alc_royalty: number | null
    al_qty: number | null
    al_net_sales: number | null
    al_royalty: number | null
    alop_qty: number | null
    alop_net_sales: number | null
    alop_royalty: number | null
    total_qty: number | null
    total_net_sales: number | null
    total_royalty: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    user_id: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
  }

  export type Audible_transactionsMaxAggregateOutputType = {
    id: number | null
    royalty_earner: string | null
    parent_product_id: string | null
    name: string | null
    author: string | null
    isbn: string | null
    provider_product_id: string | null
    market_place: string | null
    offer: string | null
    royalty_rate: string | null
    alc_qty: number | null
    alc_net_sales: number | null
    alc_royalty: number | null
    al_qty: number | null
    al_net_sales: number | null
    al_royalty: number | null
    alop_qty: number | null
    alop_net_sales: number | null
    alop_royalty: number | null
    total_qty: number | null
    total_net_sales: number | null
    total_royalty: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    user_id: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
  }

  export type Audible_transactionsCountAggregateOutputType = {
    id: number
    royalty_earner: number
    parent_product_id: number
    name: number
    author: number
    isbn: number
    provider_product_id: number
    market_place: number
    offer: number
    royalty_rate: number
    alc_qty: number
    alc_net_sales: number
    alc_royalty: number
    al_qty: number
    al_net_sales: number
    al_royalty: number
    alop_qty: number
    alop_net_sales: number
    alop_royalty: number
    total_qty: number
    total_net_sales: number
    total_royalty: number
    book_id: number
    author_id: number
    language_id: number
    copyright_owner: number
    user_id: number
    final_royalty_value: number
    transaction_date: number
    status: number
    _all: number
  }


  export type Audible_transactionsAvgAggregateInputType = {
    id?: true
    alc_qty?: true
    alc_net_sales?: true
    alc_royalty?: true
    al_qty?: true
    al_net_sales?: true
    al_royalty?: true
    alop_qty?: true
    alop_net_sales?: true
    alop_royalty?: true
    total_qty?: true
    total_net_sales?: true
    total_royalty?: true
    book_id?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    user_id?: true
    final_royalty_value?: true
  }

  export type Audible_transactionsSumAggregateInputType = {
    id?: true
    alc_qty?: true
    alc_net_sales?: true
    alc_royalty?: true
    al_qty?: true
    al_net_sales?: true
    al_royalty?: true
    alop_qty?: true
    alop_net_sales?: true
    alop_royalty?: true
    total_qty?: true
    total_net_sales?: true
    total_royalty?: true
    book_id?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    user_id?: true
    final_royalty_value?: true
  }

  export type Audible_transactionsMinAggregateInputType = {
    id?: true
    royalty_earner?: true
    parent_product_id?: true
    name?: true
    author?: true
    isbn?: true
    provider_product_id?: true
    market_place?: true
    offer?: true
    royalty_rate?: true
    alc_qty?: true
    alc_net_sales?: true
    alc_royalty?: true
    al_qty?: true
    al_net_sales?: true
    al_royalty?: true
    alop_qty?: true
    alop_net_sales?: true
    alop_royalty?: true
    total_qty?: true
    total_net_sales?: true
    total_royalty?: true
    book_id?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    user_id?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
  }

  export type Audible_transactionsMaxAggregateInputType = {
    id?: true
    royalty_earner?: true
    parent_product_id?: true
    name?: true
    author?: true
    isbn?: true
    provider_product_id?: true
    market_place?: true
    offer?: true
    royalty_rate?: true
    alc_qty?: true
    alc_net_sales?: true
    alc_royalty?: true
    al_qty?: true
    al_net_sales?: true
    al_royalty?: true
    alop_qty?: true
    alop_net_sales?: true
    alop_royalty?: true
    total_qty?: true
    total_net_sales?: true
    total_royalty?: true
    book_id?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    user_id?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
  }

  export type Audible_transactionsCountAggregateInputType = {
    id?: true
    royalty_earner?: true
    parent_product_id?: true
    name?: true
    author?: true
    isbn?: true
    provider_product_id?: true
    market_place?: true
    offer?: true
    royalty_rate?: true
    alc_qty?: true
    alc_net_sales?: true
    alc_royalty?: true
    al_qty?: true
    al_net_sales?: true
    al_royalty?: true
    alop_qty?: true
    alop_net_sales?: true
    alop_royalty?: true
    total_qty?: true
    total_net_sales?: true
    total_royalty?: true
    book_id?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    user_id?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
    _all?: true
  }

  export type Audible_transactionsAggregateArgs = {
    /**
     * Filter which audible_transactions to aggregate.
     * 
    **/
    where?: audible_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: audible_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audible_transactions
    **/
    _count?: true | Audible_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audible_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audible_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audible_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audible_transactionsMaxAggregateInputType
  }

  export type GetAudible_transactionsAggregateType<T extends Audible_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudible_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudible_transactions[P]>
      : GetScalarType<T[P], AggregateAudible_transactions[P]>
  }




  export type Audible_transactionsGroupByArgs = {
    where?: audible_transactionsWhereInput
    orderBy?: Enumerable<audible_transactionsOrderByWithAggregationInput>
    by: Array<Audible_transactionsScalarFieldEnum>
    having?: audible_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audible_transactionsCountAggregateInputType | true
    _avg?: Audible_transactionsAvgAggregateInputType
    _sum?: Audible_transactionsSumAggregateInputType
    _min?: Audible_transactionsMinAggregateInputType
    _max?: Audible_transactionsMaxAggregateInputType
  }


  export type Audible_transactionsGroupByOutputType = {
    id: number
    royalty_earner: string | null
    parent_product_id: string | null
    name: string | null
    author: string | null
    isbn: string | null
    provider_product_id: string | null
    market_place: string | null
    offer: string | null
    royalty_rate: string | null
    alc_qty: number | null
    alc_net_sales: number | null
    alc_royalty: number | null
    al_qty: number | null
    al_net_sales: number | null
    al_royalty: number | null
    alop_qty: number | null
    alop_net_sales: number | null
    alop_royalty: number | null
    total_qty: number | null
    total_net_sales: number | null
    total_royalty: number | null
    book_id: number
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    user_id: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
    _count: Audible_transactionsCountAggregateOutputType | null
    _avg: Audible_transactionsAvgAggregateOutputType | null
    _sum: Audible_transactionsSumAggregateOutputType | null
    _min: Audible_transactionsMinAggregateOutputType | null
    _max: Audible_transactionsMaxAggregateOutputType | null
  }

  type GetAudible_transactionsGroupByPayload<T extends Audible_transactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Audible_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audible_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audible_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Audible_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type audible_transactionsSelect = {
    id?: boolean
    royalty_earner?: boolean
    parent_product_id?: boolean
    name?: boolean
    author?: boolean
    isbn?: boolean
    provider_product_id?: boolean
    market_place?: boolean
    offer?: boolean
    royalty_rate?: boolean
    alc_qty?: boolean
    alc_net_sales?: boolean
    alc_royalty?: boolean
    al_qty?: boolean
    al_net_sales?: boolean
    al_royalty?: boolean
    alop_qty?: boolean
    alop_net_sales?: boolean
    alop_royalty?: boolean
    total_qty?: boolean
    total_net_sales?: boolean
    total_royalty?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    language_id?: boolean
    copyright_owner?: boolean
    user_id?: boolean
    final_royalty_value?: boolean
    transaction_date?: boolean
    status?: boolean
  }


  export type audible_transactionsInclude = {
    book?: boolean | book_tblArgs
  } 

  export type audible_transactionsGetPayload<S extends boolean | null | undefined | audible_transactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? audible_transactions :
    S extends undefined ? never :
    S extends { include: any } & (audible_transactionsArgs | audible_transactionsFindManyArgs)
    ? audible_transactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (audible_transactionsArgs | audible_transactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof audible_transactions ? audible_transactions[P] : never
  } 
      : audible_transactions


  type audible_transactionsCountArgs = Merge<
    Omit<audible_transactionsFindManyArgs, 'select' | 'include'> & {
      select?: Audible_transactionsCountAggregateInputType | true
    }
  >

  export interface audible_transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Audible_transactions that matches the filter.
     * @param {audible_transactionsFindUniqueArgs} args - Arguments to find a Audible_transactions
     * @example
     * // Get one Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends audible_transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, audible_transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'audible_transactions'> extends True ? Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>> : Prisma__audible_transactionsClient<audible_transactionsGetPayload<T> | null, null>

    /**
     * Find the first Audible_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_transactionsFindFirstArgs} args - Arguments to find a Audible_transactions
     * @example
     * // Get one Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends audible_transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, audible_transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'audible_transactions'> extends True ? Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>> : Prisma__audible_transactionsClient<audible_transactionsGetPayload<T> | null, null>

    /**
     * Find zero or more Audible_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findMany()
     * 
     * // Get first 10 Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audible_transactionsWithIdOnly = await prisma.audible_transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends audible_transactionsFindManyArgs>(
      args?: SelectSubset<T, audible_transactionsFindManyArgs>
    ): PrismaPromise<Array<audible_transactionsGetPayload<T>>>

    /**
     * Create a Audible_transactions.
     * @param {audible_transactionsCreateArgs} args - Arguments to create a Audible_transactions.
     * @example
     * // Create one Audible_transactions
     * const Audible_transactions = await prisma.audible_transactions.create({
     *   data: {
     *     // ... data to create a Audible_transactions
     *   }
     * })
     * 
    **/
    create<T extends audible_transactionsCreateArgs>(
      args: SelectSubset<T, audible_transactionsCreateArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Create many Audible_transactions.
     *     @param {audible_transactionsCreateManyArgs} args - Arguments to create many Audible_transactions.
     *     @example
     *     // Create many Audible_transactions
     *     const audible_transactions = await prisma.audible_transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends audible_transactionsCreateManyArgs>(
      args?: SelectSubset<T, audible_transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Audible_transactions.
     * @param {audible_transactionsDeleteArgs} args - Arguments to delete one Audible_transactions.
     * @example
     * // Delete one Audible_transactions
     * const Audible_transactions = await prisma.audible_transactions.delete({
     *   where: {
     *     // ... filter to delete one Audible_transactions
     *   }
     * })
     * 
    **/
    delete<T extends audible_transactionsDeleteArgs>(
      args: SelectSubset<T, audible_transactionsDeleteArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Update one Audible_transactions.
     * @param {audible_transactionsUpdateArgs} args - Arguments to update one Audible_transactions.
     * @example
     * // Update one Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends audible_transactionsUpdateArgs>(
      args: SelectSubset<T, audible_transactionsUpdateArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Delete zero or more Audible_transactions.
     * @param {audible_transactionsDeleteManyArgs} args - Arguments to filter Audible_transactions to delete.
     * @example
     * // Delete a few Audible_transactions
     * const { count } = await prisma.audible_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends audible_transactionsDeleteManyArgs>(
      args?: SelectSubset<T, audible_transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audible_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends audible_transactionsUpdateManyArgs>(
      args: SelectSubset<T, audible_transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Audible_transactions.
     * @param {audible_transactionsUpsertArgs} args - Arguments to update or create a Audible_transactions.
     * @example
     * // Update or create a Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.upsert({
     *   create: {
     *     // ... data to create a Audible_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audible_transactions we want to update
     *   }
     * })
    **/
    upsert<T extends audible_transactionsUpsertArgs>(
      args: SelectSubset<T, audible_transactionsUpsertArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Find one Audible_transactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {audible_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Audible_transactions
     * @example
     * // Get one Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends audible_transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, audible_transactionsFindUniqueOrThrowArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Find the first Audible_transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_transactionsFindFirstOrThrowArgs} args - Arguments to find a Audible_transactions
     * @example
     * // Get one Audible_transactions
     * const audible_transactions = await prisma.audible_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends audible_transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, audible_transactionsFindFirstOrThrowArgs>
    ): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T>>

    /**
     * Count the number of Audible_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audible_transactionsCountArgs} args - Arguments to filter Audible_transactions to count.
     * @example
     * // Count the number of Audible_transactions
     * const count = await prisma.audible_transactions.count({
     *   where: {
     *     // ... the filter for the Audible_transactions we want to count
     *   }
     * })
    **/
    count<T extends audible_transactionsCountArgs>(
      args?: Subset<T, audible_transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audible_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audible_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audible_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audible_transactionsAggregateArgs>(args: Subset<T, Audible_transactionsAggregateArgs>): PrismaPromise<GetAudible_transactionsAggregateType<T>>

    /**
     * Group by Audible_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audible_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Audible_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Audible_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: Audible_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Audible_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudible_transactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for audible_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__audible_transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * audible_transactions base type for findUnique actions
   */
  export type audible_transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * Filter, which audible_transactions to fetch.
     * 
    **/
    where: audible_transactionsWhereUniqueInput
  }

  /**
   * audible_transactions: findUnique
   */
  export interface audible_transactionsFindUniqueArgs extends audible_transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audible_transactions base type for findFirst actions
   */
  export type audible_transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * Filter, which audible_transactions to fetch.
     * 
    **/
    where?: audible_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audible_transactions.
     * 
    **/
    cursor?: audible_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audible_transactions.
     * 
    **/
    distinct?: Enumerable<Audible_transactionsScalarFieldEnum>
  }

  /**
   * audible_transactions: findFirst
   */
  export interface audible_transactionsFindFirstArgs extends audible_transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audible_transactions findMany
   */
  export type audible_transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * Filter, which audible_transactions to fetch.
     * 
    **/
    where?: audible_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audible_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<audible_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audible_transactions.
     * 
    **/
    cursor?: audible_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audible_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audible_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Audible_transactionsScalarFieldEnum>
  }


  /**
   * audible_transactions create
   */
  export type audible_transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * The data needed to create a audible_transactions.
     * 
    **/
    data: XOR<audible_transactionsCreateInput, audible_transactionsUncheckedCreateInput>
  }


  /**
   * audible_transactions createMany
   */
  export type audible_transactionsCreateManyArgs = {
    /**
     * The data used to create many audible_transactions.
     * 
    **/
    data: Enumerable<audible_transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * audible_transactions update
   */
  export type audible_transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * The data needed to update a audible_transactions.
     * 
    **/
    data: XOR<audible_transactionsUpdateInput, audible_transactionsUncheckedUpdateInput>
    /**
     * Choose, which audible_transactions to update.
     * 
    **/
    where: audible_transactionsWhereUniqueInput
  }


  /**
   * audible_transactions updateMany
   */
  export type audible_transactionsUpdateManyArgs = {
    /**
     * The data used to update audible_transactions.
     * 
    **/
    data: XOR<audible_transactionsUpdateManyMutationInput, audible_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which audible_transactions to update
     * 
    **/
    where?: audible_transactionsWhereInput
  }


  /**
   * audible_transactions upsert
   */
  export type audible_transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * The filter to search for the audible_transactions to update in case it exists.
     * 
    **/
    where: audible_transactionsWhereUniqueInput
    /**
     * In case the audible_transactions found by the `where` argument doesn't exist, create a new audible_transactions with this data.
     * 
    **/
    create: XOR<audible_transactionsCreateInput, audible_transactionsUncheckedCreateInput>
    /**
     * In case the audible_transactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<audible_transactionsUpdateInput, audible_transactionsUncheckedUpdateInput>
  }


  /**
   * audible_transactions delete
   */
  export type audible_transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
    /**
     * Filter which audible_transactions to delete.
     * 
    **/
    where: audible_transactionsWhereUniqueInput
  }


  /**
   * audible_transactions deleteMany
   */
  export type audible_transactionsDeleteManyArgs = {
    /**
     * Filter which audible_transactions to delete
     * 
    **/
    where?: audible_transactionsWhereInput
  }


  /**
   * audible_transactions: findUniqueOrThrow
   */
  export type audible_transactionsFindUniqueOrThrowArgs = audible_transactionsFindUniqueArgsBase
      

  /**
   * audible_transactions: findFirstOrThrow
   */
  export type audible_transactionsFindFirstOrThrowArgs = audible_transactionsFindFirstArgsBase
      

  /**
   * audible_transactions without action
   */
  export type audible_transactionsArgs = {
    /**
     * Select specific fields to fetch from the audible_transactions
     * 
    **/
    select?: audible_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: audible_transactionsInclude | null
  }



  /**
   * Model audio_book_details
   */


  export type AggregateAudio_book_details = {
    _count: Audio_book_detailsCountAggregateOutputType | null
    _avg: Audio_book_detailsAvgAggregateOutputType | null
    _sum: Audio_book_detailsSumAggregateOutputType | null
    _min: Audio_book_detailsMinAggregateOutputType | null
    _max: Audio_book_detailsMaxAggregateOutputType | null
  }

  export type Audio_book_detailsAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    chapter_id: number | null
  }

  export type Audio_book_detailsSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    chapter_id: number | null
  }

  export type Audio_book_detailsMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    chapter_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_url: string | null
    chapter_duration: string | null
    created_at: Date | null
  }

  export type Audio_book_detailsMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    chapter_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_url: string | null
    chapter_duration: string | null
    created_at: Date | null
  }

  export type Audio_book_detailsCountAggregateOutputType = {
    id: number
    book_id: number
    chapter_id: number
    chapter_name: number
    chapter_name_english: number
    chapter_url: number
    chapter_duration: number
    created_at: number
    _all: number
  }


  export type Audio_book_detailsAvgAggregateInputType = {
    id?: true
    book_id?: true
    chapter_id?: true
  }

  export type Audio_book_detailsSumAggregateInputType = {
    id?: true
    book_id?: true
    chapter_id?: true
  }

  export type Audio_book_detailsMinAggregateInputType = {
    id?: true
    book_id?: true
    chapter_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_url?: true
    chapter_duration?: true
    created_at?: true
  }

  export type Audio_book_detailsMaxAggregateInputType = {
    id?: true
    book_id?: true
    chapter_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_url?: true
    chapter_duration?: true
    created_at?: true
  }

  export type Audio_book_detailsCountAggregateInputType = {
    id?: true
    book_id?: true
    chapter_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_url?: true
    chapter_duration?: true
    created_at?: true
    _all?: true
  }

  export type Audio_book_detailsAggregateArgs = {
    /**
     * Filter which audio_book_details to aggregate.
     * 
    **/
    where?: audio_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audio_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<audio_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: audio_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audio_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audio_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audio_book_details
    **/
    _count?: true | Audio_book_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audio_book_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audio_book_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audio_book_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audio_book_detailsMaxAggregateInputType
  }

  export type GetAudio_book_detailsAggregateType<T extends Audio_book_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudio_book_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudio_book_details[P]>
      : GetScalarType<T[P], AggregateAudio_book_details[P]>
  }




  export type Audio_book_detailsGroupByArgs = {
    where?: audio_book_detailsWhereInput
    orderBy?: Enumerable<audio_book_detailsOrderByWithAggregationInput>
    by: Array<Audio_book_detailsScalarFieldEnum>
    having?: audio_book_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audio_book_detailsCountAggregateInputType | true
    _avg?: Audio_book_detailsAvgAggregateInputType
    _sum?: Audio_book_detailsSumAggregateInputType
    _min?: Audio_book_detailsMinAggregateInputType
    _max?: Audio_book_detailsMaxAggregateInputType
  }


  export type Audio_book_detailsGroupByOutputType = {
    id: number
    book_id: number | null
    chapter_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_url: string | null
    chapter_duration: string | null
    created_at: Date | null
    _count: Audio_book_detailsCountAggregateOutputType | null
    _avg: Audio_book_detailsAvgAggregateOutputType | null
    _sum: Audio_book_detailsSumAggregateOutputType | null
    _min: Audio_book_detailsMinAggregateOutputType | null
    _max: Audio_book_detailsMaxAggregateOutputType | null
  }

  type GetAudio_book_detailsGroupByPayload<T extends Audio_book_detailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Audio_book_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audio_book_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audio_book_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Audio_book_detailsGroupByOutputType[P]>
        }
      >
    >


  export type audio_book_detailsSelect = {
    id?: boolean
    book_id?: boolean
    chapter_id?: boolean
    chapter_name?: boolean
    chapter_name_english?: boolean
    chapter_url?: boolean
    chapter_duration?: boolean
    created_at?: boolean
  }


  export type audio_book_detailsGetPayload<S extends boolean | null | undefined | audio_book_detailsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? audio_book_details :
    S extends undefined ? never :
    S extends { include: any } & (audio_book_detailsArgs | audio_book_detailsFindManyArgs)
    ? audio_book_details 
    : S extends { select: any } & (audio_book_detailsArgs | audio_book_detailsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof audio_book_details ? audio_book_details[P] : never
  } 
      : audio_book_details


  type audio_book_detailsCountArgs = Merge<
    Omit<audio_book_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Audio_book_detailsCountAggregateInputType | true
    }
  >

  export interface audio_book_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Audio_book_details that matches the filter.
     * @param {audio_book_detailsFindUniqueArgs} args - Arguments to find a Audio_book_details
     * @example
     * // Get one Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends audio_book_detailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, audio_book_detailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'audio_book_details'> extends True ? Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>> : Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T> | null, null>

    /**
     * Find the first Audio_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audio_book_detailsFindFirstArgs} args - Arguments to find a Audio_book_details
     * @example
     * // Get one Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends audio_book_detailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, audio_book_detailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'audio_book_details'> extends True ? Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>> : Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T> | null, null>

    /**
     * Find zero or more Audio_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audio_book_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findMany()
     * 
     * // Get first 10 Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audio_book_detailsWithIdOnly = await prisma.audio_book_details.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends audio_book_detailsFindManyArgs>(
      args?: SelectSubset<T, audio_book_detailsFindManyArgs>
    ): PrismaPromise<Array<audio_book_detailsGetPayload<T>>>

    /**
     * Create a Audio_book_details.
     * @param {audio_book_detailsCreateArgs} args - Arguments to create a Audio_book_details.
     * @example
     * // Create one Audio_book_details
     * const Audio_book_details = await prisma.audio_book_details.create({
     *   data: {
     *     // ... data to create a Audio_book_details
     *   }
     * })
     * 
    **/
    create<T extends audio_book_detailsCreateArgs>(
      args: SelectSubset<T, audio_book_detailsCreateArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Create many Audio_book_details.
     *     @param {audio_book_detailsCreateManyArgs} args - Arguments to create many Audio_book_details.
     *     @example
     *     // Create many Audio_book_details
     *     const audio_book_details = await prisma.audio_book_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends audio_book_detailsCreateManyArgs>(
      args?: SelectSubset<T, audio_book_detailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Audio_book_details.
     * @param {audio_book_detailsDeleteArgs} args - Arguments to delete one Audio_book_details.
     * @example
     * // Delete one Audio_book_details
     * const Audio_book_details = await prisma.audio_book_details.delete({
     *   where: {
     *     // ... filter to delete one Audio_book_details
     *   }
     * })
     * 
    **/
    delete<T extends audio_book_detailsDeleteArgs>(
      args: SelectSubset<T, audio_book_detailsDeleteArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Update one Audio_book_details.
     * @param {audio_book_detailsUpdateArgs} args - Arguments to update one Audio_book_details.
     * @example
     * // Update one Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends audio_book_detailsUpdateArgs>(
      args: SelectSubset<T, audio_book_detailsUpdateArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Delete zero or more Audio_book_details.
     * @param {audio_book_detailsDeleteManyArgs} args - Arguments to filter Audio_book_details to delete.
     * @example
     * // Delete a few Audio_book_details
     * const { count } = await prisma.audio_book_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends audio_book_detailsDeleteManyArgs>(
      args?: SelectSubset<T, audio_book_detailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audio_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audio_book_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends audio_book_detailsUpdateManyArgs>(
      args: SelectSubset<T, audio_book_detailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Audio_book_details.
     * @param {audio_book_detailsUpsertArgs} args - Arguments to update or create a Audio_book_details.
     * @example
     * // Update or create a Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.upsert({
     *   create: {
     *     // ... data to create a Audio_book_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audio_book_details we want to update
     *   }
     * })
    **/
    upsert<T extends audio_book_detailsUpsertArgs>(
      args: SelectSubset<T, audio_book_detailsUpsertArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Find one Audio_book_details that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {audio_book_detailsFindUniqueOrThrowArgs} args - Arguments to find a Audio_book_details
     * @example
     * // Get one Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends audio_book_detailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, audio_book_detailsFindUniqueOrThrowArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Find the first Audio_book_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audio_book_detailsFindFirstOrThrowArgs} args - Arguments to find a Audio_book_details
     * @example
     * // Get one Audio_book_details
     * const audio_book_details = await prisma.audio_book_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends audio_book_detailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, audio_book_detailsFindFirstOrThrowArgs>
    ): Prisma__audio_book_detailsClient<audio_book_detailsGetPayload<T>>

    /**
     * Count the number of Audio_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audio_book_detailsCountArgs} args - Arguments to filter Audio_book_details to count.
     * @example
     * // Count the number of Audio_book_details
     * const count = await prisma.audio_book_details.count({
     *   where: {
     *     // ... the filter for the Audio_book_details we want to count
     *   }
     * })
    **/
    count<T extends audio_book_detailsCountArgs>(
      args?: Subset<T, audio_book_detailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audio_book_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audio_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audio_book_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audio_book_detailsAggregateArgs>(args: Subset<T, Audio_book_detailsAggregateArgs>): PrismaPromise<GetAudio_book_detailsAggregateType<T>>

    /**
     * Group by Audio_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audio_book_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Audio_book_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Audio_book_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Audio_book_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Audio_book_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudio_book_detailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for audio_book_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__audio_book_detailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * audio_book_details base type for findUnique actions
   */
  export type audio_book_detailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * Filter, which audio_book_details to fetch.
     * 
    **/
    where: audio_book_detailsWhereUniqueInput
  }

  /**
   * audio_book_details: findUnique
   */
  export interface audio_book_detailsFindUniqueArgs extends audio_book_detailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audio_book_details base type for findFirst actions
   */
  export type audio_book_detailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * Filter, which audio_book_details to fetch.
     * 
    **/
    where?: audio_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audio_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<audio_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audio_book_details.
     * 
    **/
    cursor?: audio_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audio_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audio_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audio_book_details.
     * 
    **/
    distinct?: Enumerable<Audio_book_detailsScalarFieldEnum>
  }

  /**
   * audio_book_details: findFirst
   */
  export interface audio_book_detailsFindFirstArgs extends audio_book_detailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * audio_book_details findMany
   */
  export type audio_book_detailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * Filter, which audio_book_details to fetch.
     * 
    **/
    where?: audio_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audio_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<audio_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audio_book_details.
     * 
    **/
    cursor?: audio_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audio_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audio_book_details.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Audio_book_detailsScalarFieldEnum>
  }


  /**
   * audio_book_details create
   */
  export type audio_book_detailsCreateArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * The data needed to create a audio_book_details.
     * 
    **/
    data: XOR<audio_book_detailsCreateInput, audio_book_detailsUncheckedCreateInput>
  }


  /**
   * audio_book_details createMany
   */
  export type audio_book_detailsCreateManyArgs = {
    /**
     * The data used to create many audio_book_details.
     * 
    **/
    data: Enumerable<audio_book_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * audio_book_details update
   */
  export type audio_book_detailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * The data needed to update a audio_book_details.
     * 
    **/
    data: XOR<audio_book_detailsUpdateInput, audio_book_detailsUncheckedUpdateInput>
    /**
     * Choose, which audio_book_details to update.
     * 
    **/
    where: audio_book_detailsWhereUniqueInput
  }


  /**
   * audio_book_details updateMany
   */
  export type audio_book_detailsUpdateManyArgs = {
    /**
     * The data used to update audio_book_details.
     * 
    **/
    data: XOR<audio_book_detailsUpdateManyMutationInput, audio_book_detailsUncheckedUpdateManyInput>
    /**
     * Filter which audio_book_details to update
     * 
    **/
    where?: audio_book_detailsWhereInput
  }


  /**
   * audio_book_details upsert
   */
  export type audio_book_detailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * The filter to search for the audio_book_details to update in case it exists.
     * 
    **/
    where: audio_book_detailsWhereUniqueInput
    /**
     * In case the audio_book_details found by the `where` argument doesn't exist, create a new audio_book_details with this data.
     * 
    **/
    create: XOR<audio_book_detailsCreateInput, audio_book_detailsUncheckedCreateInput>
    /**
     * In case the audio_book_details was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<audio_book_detailsUpdateInput, audio_book_detailsUncheckedUpdateInput>
  }


  /**
   * audio_book_details delete
   */
  export type audio_book_detailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
    /**
     * Filter which audio_book_details to delete.
     * 
    **/
    where: audio_book_detailsWhereUniqueInput
  }


  /**
   * audio_book_details deleteMany
   */
  export type audio_book_detailsDeleteManyArgs = {
    /**
     * Filter which audio_book_details to delete
     * 
    **/
    where?: audio_book_detailsWhereInput
  }


  /**
   * audio_book_details: findUniqueOrThrow
   */
  export type audio_book_detailsFindUniqueOrThrowArgs = audio_book_detailsFindUniqueArgsBase
      

  /**
   * audio_book_details: findFirstOrThrow
   */
  export type audio_book_detailsFindFirstOrThrowArgs = audio_book_detailsFindFirstArgsBase
      

  /**
   * audio_book_details without action
   */
  export type audio_book_detailsArgs = {
    /**
     * Select specific fields to fetch from the audio_book_details
     * 
    **/
    select?: audio_book_detailsSelect | null
  }



  /**
   * Model author_gift_books
   */


  export type AggregateAuthor_gift_books = {
    _count: Author_gift_booksCountAggregateOutputType | null
    _avg: Author_gift_booksAvgAggregateOutputType | null
    _sum: Author_gift_booksSumAggregateOutputType | null
    _min: Author_gift_booksMinAggregateOutputType | null
    _max: Author_gift_booksMaxAggregateOutputType | null
  }

  export type Author_gift_booksAvgAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    user_id: number | null
    bookId: number | null
  }

  export type Author_gift_booksSumAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    user_id: number | null
    bookId: number | null
  }

  export type Author_gift_booksMinAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    user_id: number | null
    date: Date | null
    bookId: number | null
  }

  export type Author_gift_booksMaxAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    user_id: number | null
    date: Date | null
    bookId: number | null
  }

  export type Author_gift_booksCountAggregateOutputType = {
    id: number
    author_id: number
    book_id: number
    user_id: number
    date: number
    bookId: number
    _all: number
  }


  export type Author_gift_booksAvgAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    user_id?: true
    bookId?: true
  }

  export type Author_gift_booksSumAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    user_id?: true
    bookId?: true
  }

  export type Author_gift_booksMinAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    user_id?: true
    date?: true
    bookId?: true
  }

  export type Author_gift_booksMaxAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    user_id?: true
    date?: true
    bookId?: true
  }

  export type Author_gift_booksCountAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    user_id?: true
    date?: true
    bookId?: true
    _all?: true
  }

  export type Author_gift_booksAggregateArgs = {
    /**
     * Filter which author_gift_books to aggregate.
     * 
    **/
    where?: author_gift_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_gift_books to fetch.
     * 
    **/
    orderBy?: Enumerable<author_gift_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: author_gift_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_gift_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_gift_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned author_gift_books
    **/
    _count?: true | Author_gift_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Author_gift_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Author_gift_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Author_gift_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Author_gift_booksMaxAggregateInputType
  }

  export type GetAuthor_gift_booksAggregateType<T extends Author_gift_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor_gift_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor_gift_books[P]>
      : GetScalarType<T[P], AggregateAuthor_gift_books[P]>
  }




  export type Author_gift_booksGroupByArgs = {
    where?: author_gift_booksWhereInput
    orderBy?: Enumerable<author_gift_booksOrderByWithAggregationInput>
    by: Array<Author_gift_booksScalarFieldEnum>
    having?: author_gift_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Author_gift_booksCountAggregateInputType | true
    _avg?: Author_gift_booksAvgAggregateInputType
    _sum?: Author_gift_booksSumAggregateInputType
    _min?: Author_gift_booksMinAggregateInputType
    _max?: Author_gift_booksMaxAggregateInputType
  }


  export type Author_gift_booksGroupByOutputType = {
    id: number
    author_id: number | null
    book_id: number | null
    user_id: number
    date: Date | null
    bookId: number
    _count: Author_gift_booksCountAggregateOutputType | null
    _avg: Author_gift_booksAvgAggregateOutputType | null
    _sum: Author_gift_booksSumAggregateOutputType | null
    _min: Author_gift_booksMinAggregateOutputType | null
    _max: Author_gift_booksMaxAggregateOutputType | null
  }

  type GetAuthor_gift_booksGroupByPayload<T extends Author_gift_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Author_gift_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Author_gift_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Author_gift_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Author_gift_booksGroupByOutputType[P]>
        }
      >
    >


  export type author_gift_booksSelect = {
    id?: boolean
    author_id?: boolean
    book_id?: boolean
    user_id?: boolean
    date?: boolean
    book?: boolean | book_tblArgs
    bookId?: boolean
    user?: boolean | users_tblArgs
  }


  export type author_gift_booksInclude = {
    book?: boolean | book_tblArgs
    user?: boolean | users_tblArgs
  } 

  export type author_gift_booksGetPayload<S extends boolean | null | undefined | author_gift_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? author_gift_books :
    S extends undefined ? never :
    S extends { include: any } & (author_gift_booksArgs | author_gift_booksFindManyArgs)
    ? author_gift_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? users_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (author_gift_booksArgs | author_gift_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? users_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof author_gift_books ? author_gift_books[P] : never
  } 
      : author_gift_books


  type author_gift_booksCountArgs = Merge<
    Omit<author_gift_booksFindManyArgs, 'select' | 'include'> & {
      select?: Author_gift_booksCountAggregateInputType | true
    }
  >

  export interface author_gift_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Author_gift_books that matches the filter.
     * @param {author_gift_booksFindUniqueArgs} args - Arguments to find a Author_gift_books
     * @example
     * // Get one Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends author_gift_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, author_gift_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'author_gift_books'> extends True ? Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>> : Prisma__author_gift_booksClient<author_gift_booksGetPayload<T> | null, null>

    /**
     * Find the first Author_gift_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_gift_booksFindFirstArgs} args - Arguments to find a Author_gift_books
     * @example
     * // Get one Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends author_gift_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, author_gift_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'author_gift_books'> extends True ? Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>> : Prisma__author_gift_booksClient<author_gift_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Author_gift_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_gift_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findMany()
     * 
     * // Get first 10 Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const author_gift_booksWithIdOnly = await prisma.author_gift_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends author_gift_booksFindManyArgs>(
      args?: SelectSubset<T, author_gift_booksFindManyArgs>
    ): PrismaPromise<Array<author_gift_booksGetPayload<T>>>

    /**
     * Create a Author_gift_books.
     * @param {author_gift_booksCreateArgs} args - Arguments to create a Author_gift_books.
     * @example
     * // Create one Author_gift_books
     * const Author_gift_books = await prisma.author_gift_books.create({
     *   data: {
     *     // ... data to create a Author_gift_books
     *   }
     * })
     * 
    **/
    create<T extends author_gift_booksCreateArgs>(
      args: SelectSubset<T, author_gift_booksCreateArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Create many Author_gift_books.
     *     @param {author_gift_booksCreateManyArgs} args - Arguments to create many Author_gift_books.
     *     @example
     *     // Create many Author_gift_books
     *     const author_gift_books = await prisma.author_gift_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends author_gift_booksCreateManyArgs>(
      args?: SelectSubset<T, author_gift_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Author_gift_books.
     * @param {author_gift_booksDeleteArgs} args - Arguments to delete one Author_gift_books.
     * @example
     * // Delete one Author_gift_books
     * const Author_gift_books = await prisma.author_gift_books.delete({
     *   where: {
     *     // ... filter to delete one Author_gift_books
     *   }
     * })
     * 
    **/
    delete<T extends author_gift_booksDeleteArgs>(
      args: SelectSubset<T, author_gift_booksDeleteArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Update one Author_gift_books.
     * @param {author_gift_booksUpdateArgs} args - Arguments to update one Author_gift_books.
     * @example
     * // Update one Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends author_gift_booksUpdateArgs>(
      args: SelectSubset<T, author_gift_booksUpdateArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Delete zero or more Author_gift_books.
     * @param {author_gift_booksDeleteManyArgs} args - Arguments to filter Author_gift_books to delete.
     * @example
     * // Delete a few Author_gift_books
     * const { count } = await prisma.author_gift_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends author_gift_booksDeleteManyArgs>(
      args?: SelectSubset<T, author_gift_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Author_gift_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_gift_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends author_gift_booksUpdateManyArgs>(
      args: SelectSubset<T, author_gift_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author_gift_books.
     * @param {author_gift_booksUpsertArgs} args - Arguments to update or create a Author_gift_books.
     * @example
     * // Update or create a Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.upsert({
     *   create: {
     *     // ... data to create a Author_gift_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author_gift_books we want to update
     *   }
     * })
    **/
    upsert<T extends author_gift_booksUpsertArgs>(
      args: SelectSubset<T, author_gift_booksUpsertArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Find one Author_gift_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {author_gift_booksFindUniqueOrThrowArgs} args - Arguments to find a Author_gift_books
     * @example
     * // Get one Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends author_gift_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, author_gift_booksFindUniqueOrThrowArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Find the first Author_gift_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_gift_booksFindFirstOrThrowArgs} args - Arguments to find a Author_gift_books
     * @example
     * // Get one Author_gift_books
     * const author_gift_books = await prisma.author_gift_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends author_gift_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, author_gift_booksFindFirstOrThrowArgs>
    ): Prisma__author_gift_booksClient<author_gift_booksGetPayload<T>>

    /**
     * Count the number of Author_gift_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_gift_booksCountArgs} args - Arguments to filter Author_gift_books to count.
     * @example
     * // Count the number of Author_gift_books
     * const count = await prisma.author_gift_books.count({
     *   where: {
     *     // ... the filter for the Author_gift_books we want to count
     *   }
     * })
    **/
    count<T extends author_gift_booksCountArgs>(
      args?: Subset<T, author_gift_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Author_gift_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author_gift_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_gift_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Author_gift_booksAggregateArgs>(args: Subset<T, Author_gift_booksAggregateArgs>): PrismaPromise<GetAuthor_gift_booksAggregateType<T>>

    /**
     * Group by Author_gift_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_gift_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Author_gift_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Author_gift_booksGroupByArgs['orderBy'] }
        : { orderBy?: Author_gift_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Author_gift_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthor_gift_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for author_gift_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__author_gift_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    user<T extends users_tblArgs= {}>(args?: Subset<T, users_tblArgs>): Prisma__users_tblClient<users_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * author_gift_books base type for findUnique actions
   */
  export type author_gift_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * Filter, which author_gift_books to fetch.
     * 
    **/
    where: author_gift_booksWhereUniqueInput
  }

  /**
   * author_gift_books: findUnique
   */
  export interface author_gift_booksFindUniqueArgs extends author_gift_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_gift_books base type for findFirst actions
   */
  export type author_gift_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * Filter, which author_gift_books to fetch.
     * 
    **/
    where?: author_gift_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_gift_books to fetch.
     * 
    **/
    orderBy?: Enumerable<author_gift_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for author_gift_books.
     * 
    **/
    cursor?: author_gift_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_gift_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_gift_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of author_gift_books.
     * 
    **/
    distinct?: Enumerable<Author_gift_booksScalarFieldEnum>
  }

  /**
   * author_gift_books: findFirst
   */
  export interface author_gift_booksFindFirstArgs extends author_gift_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_gift_books findMany
   */
  export type author_gift_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * Filter, which author_gift_books to fetch.
     * 
    **/
    where?: author_gift_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_gift_books to fetch.
     * 
    **/
    orderBy?: Enumerable<author_gift_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing author_gift_books.
     * 
    **/
    cursor?: author_gift_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_gift_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_gift_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Author_gift_booksScalarFieldEnum>
  }


  /**
   * author_gift_books create
   */
  export type author_gift_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * The data needed to create a author_gift_books.
     * 
    **/
    data: XOR<author_gift_booksCreateInput, author_gift_booksUncheckedCreateInput>
  }


  /**
   * author_gift_books createMany
   */
  export type author_gift_booksCreateManyArgs = {
    /**
     * The data used to create many author_gift_books.
     * 
    **/
    data: Enumerable<author_gift_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * author_gift_books update
   */
  export type author_gift_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * The data needed to update a author_gift_books.
     * 
    **/
    data: XOR<author_gift_booksUpdateInput, author_gift_booksUncheckedUpdateInput>
    /**
     * Choose, which author_gift_books to update.
     * 
    **/
    where: author_gift_booksWhereUniqueInput
  }


  /**
   * author_gift_books updateMany
   */
  export type author_gift_booksUpdateManyArgs = {
    /**
     * The data used to update author_gift_books.
     * 
    **/
    data: XOR<author_gift_booksUpdateManyMutationInput, author_gift_booksUncheckedUpdateManyInput>
    /**
     * Filter which author_gift_books to update
     * 
    **/
    where?: author_gift_booksWhereInput
  }


  /**
   * author_gift_books upsert
   */
  export type author_gift_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * The filter to search for the author_gift_books to update in case it exists.
     * 
    **/
    where: author_gift_booksWhereUniqueInput
    /**
     * In case the author_gift_books found by the `where` argument doesn't exist, create a new author_gift_books with this data.
     * 
    **/
    create: XOR<author_gift_booksCreateInput, author_gift_booksUncheckedCreateInput>
    /**
     * In case the author_gift_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<author_gift_booksUpdateInput, author_gift_booksUncheckedUpdateInput>
  }


  /**
   * author_gift_books delete
   */
  export type author_gift_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
    /**
     * Filter which author_gift_books to delete.
     * 
    **/
    where: author_gift_booksWhereUniqueInput
  }


  /**
   * author_gift_books deleteMany
   */
  export type author_gift_booksDeleteManyArgs = {
    /**
     * Filter which author_gift_books to delete
     * 
    **/
    where?: author_gift_booksWhereInput
  }


  /**
   * author_gift_books: findUniqueOrThrow
   */
  export type author_gift_booksFindUniqueOrThrowArgs = author_gift_booksFindUniqueArgsBase
      

  /**
   * author_gift_books: findFirstOrThrow
   */
  export type author_gift_booksFindFirstOrThrowArgs = author_gift_booksFindFirstArgsBase
      

  /**
   * author_gift_books without action
   */
  export type author_gift_booksArgs = {
    /**
     * Select specific fields to fetch from the author_gift_books
     * 
    **/
    select?: author_gift_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_gift_booksInclude | null
  }



  /**
   * Model author_language
   */


  export type AggregateAuthor_language = {
    _count: Author_languageCountAggregateOutputType | null
    _avg: Author_languageAvgAggregateOutputType | null
    _sum: Author_languageSumAggregateOutputType | null
    _min: Author_languageMinAggregateOutputType | null
    _max: Author_languageMaxAggregateOutputType | null
  }

  export type Author_languageAvgAggregateOutputType = {
    id: number | null
    author_id: number | null
    language_id: number | null
  }

  export type Author_languageSumAggregateOutputType = {
    id: number | null
    author_id: number | null
    language_id: number | null
  }

  export type Author_languageMinAggregateOutputType = {
    id: number | null
    author_id: number | null
    language_id: number | null
    display_name1: string | null
    display_name2: string | null
    regional_author_name: string | null
  }

  export type Author_languageMaxAggregateOutputType = {
    id: number | null
    author_id: number | null
    language_id: number | null
    display_name1: string | null
    display_name2: string | null
    regional_author_name: string | null
  }

  export type Author_languageCountAggregateOutputType = {
    id: number
    author_id: number
    language_id: number
    display_name1: number
    display_name2: number
    regional_author_name: number
    _all: number
  }


  export type Author_languageAvgAggregateInputType = {
    id?: true
    author_id?: true
    language_id?: true
  }

  export type Author_languageSumAggregateInputType = {
    id?: true
    author_id?: true
    language_id?: true
  }

  export type Author_languageMinAggregateInputType = {
    id?: true
    author_id?: true
    language_id?: true
    display_name1?: true
    display_name2?: true
    regional_author_name?: true
  }

  export type Author_languageMaxAggregateInputType = {
    id?: true
    author_id?: true
    language_id?: true
    display_name1?: true
    display_name2?: true
    regional_author_name?: true
  }

  export type Author_languageCountAggregateInputType = {
    id?: true
    author_id?: true
    language_id?: true
    display_name1?: true
    display_name2?: true
    regional_author_name?: true
    _all?: true
  }

  export type Author_languageAggregateArgs = {
    /**
     * Filter which author_language to aggregate.
     * 
    **/
    where?: author_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_languages to fetch.
     * 
    **/
    orderBy?: Enumerable<author_languageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: author_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_languages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned author_languages
    **/
    _count?: true | Author_languageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Author_languageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Author_languageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Author_languageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Author_languageMaxAggregateInputType
  }

  export type GetAuthor_languageAggregateType<T extends Author_languageAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor_language]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor_language[P]>
      : GetScalarType<T[P], AggregateAuthor_language[P]>
  }




  export type Author_languageGroupByArgs = {
    where?: author_languageWhereInput
    orderBy?: Enumerable<author_languageOrderByWithAggregationInput>
    by: Array<Author_languageScalarFieldEnum>
    having?: author_languageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Author_languageCountAggregateInputType | true
    _avg?: Author_languageAvgAggregateInputType
    _sum?: Author_languageSumAggregateInputType
    _min?: Author_languageMinAggregateInputType
    _max?: Author_languageMaxAggregateInputType
  }


  export type Author_languageGroupByOutputType = {
    id: number
    author_id: number | null
    language_id: number
    display_name1: string | null
    display_name2: string | null
    regional_author_name: string | null
    _count: Author_languageCountAggregateOutputType | null
    _avg: Author_languageAvgAggregateOutputType | null
    _sum: Author_languageSumAggregateOutputType | null
    _min: Author_languageMinAggregateOutputType | null
    _max: Author_languageMaxAggregateOutputType | null
  }

  type GetAuthor_languageGroupByPayload<T extends Author_languageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Author_languageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Author_languageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Author_languageGroupByOutputType[P]>
            : GetScalarType<T[P], Author_languageGroupByOutputType[P]>
        }
      >
    >


  export type author_languageSelect = {
    id?: boolean
    author_id?: boolean
    language?: boolean | language_tblArgs
    language_id?: boolean
    display_name1?: boolean
    display_name2?: boolean
    regional_author_name?: boolean
  }


  export type author_languageInclude = {
    language?: boolean | language_tblArgs
  } 

  export type author_languageGetPayload<S extends boolean | null | undefined | author_languageArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? author_language :
    S extends undefined ? never :
    S extends { include: any } & (author_languageArgs | author_languageFindManyArgs)
    ? author_language  & {
    [P in TrueKeys<S['include']>]:
        P extends 'language' ? language_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (author_languageArgs | author_languageFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'language' ? language_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof author_language ? author_language[P] : never
  } 
      : author_language


  type author_languageCountArgs = Merge<
    Omit<author_languageFindManyArgs, 'select' | 'include'> & {
      select?: Author_languageCountAggregateInputType | true
    }
  >

  export interface author_languageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Author_language that matches the filter.
     * @param {author_languageFindUniqueArgs} args - Arguments to find a Author_language
     * @example
     * // Get one Author_language
     * const author_language = await prisma.author_language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends author_languageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, author_languageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'author_language'> extends True ? Prisma__author_languageClient<author_languageGetPayload<T>> : Prisma__author_languageClient<author_languageGetPayload<T> | null, null>

    /**
     * Find the first Author_language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_languageFindFirstArgs} args - Arguments to find a Author_language
     * @example
     * // Get one Author_language
     * const author_language = await prisma.author_language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends author_languageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, author_languageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'author_language'> extends True ? Prisma__author_languageClient<author_languageGetPayload<T>> : Prisma__author_languageClient<author_languageGetPayload<T> | null, null>

    /**
     * Find zero or more Author_languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_languageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Author_languages
     * const author_languages = await prisma.author_language.findMany()
     * 
     * // Get first 10 Author_languages
     * const author_languages = await prisma.author_language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const author_languageWithIdOnly = await prisma.author_language.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends author_languageFindManyArgs>(
      args?: SelectSubset<T, author_languageFindManyArgs>
    ): PrismaPromise<Array<author_languageGetPayload<T>>>

    /**
     * Create a Author_language.
     * @param {author_languageCreateArgs} args - Arguments to create a Author_language.
     * @example
     * // Create one Author_language
     * const Author_language = await prisma.author_language.create({
     *   data: {
     *     // ... data to create a Author_language
     *   }
     * })
     * 
    **/
    create<T extends author_languageCreateArgs>(
      args: SelectSubset<T, author_languageCreateArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Create many Author_languages.
     *     @param {author_languageCreateManyArgs} args - Arguments to create many Author_languages.
     *     @example
     *     // Create many Author_languages
     *     const author_language = await prisma.author_language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends author_languageCreateManyArgs>(
      args?: SelectSubset<T, author_languageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Author_language.
     * @param {author_languageDeleteArgs} args - Arguments to delete one Author_language.
     * @example
     * // Delete one Author_language
     * const Author_language = await prisma.author_language.delete({
     *   where: {
     *     // ... filter to delete one Author_language
     *   }
     * })
     * 
    **/
    delete<T extends author_languageDeleteArgs>(
      args: SelectSubset<T, author_languageDeleteArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Update one Author_language.
     * @param {author_languageUpdateArgs} args - Arguments to update one Author_language.
     * @example
     * // Update one Author_language
     * const author_language = await prisma.author_language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends author_languageUpdateArgs>(
      args: SelectSubset<T, author_languageUpdateArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Delete zero or more Author_languages.
     * @param {author_languageDeleteManyArgs} args - Arguments to filter Author_languages to delete.
     * @example
     * // Delete a few Author_languages
     * const { count } = await prisma.author_language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends author_languageDeleteManyArgs>(
      args?: SelectSubset<T, author_languageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Author_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_languageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Author_languages
     * const author_language = await prisma.author_language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends author_languageUpdateManyArgs>(
      args: SelectSubset<T, author_languageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author_language.
     * @param {author_languageUpsertArgs} args - Arguments to update or create a Author_language.
     * @example
     * // Update or create a Author_language
     * const author_language = await prisma.author_language.upsert({
     *   create: {
     *     // ... data to create a Author_language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author_language we want to update
     *   }
     * })
    **/
    upsert<T extends author_languageUpsertArgs>(
      args: SelectSubset<T, author_languageUpsertArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Find one Author_language that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {author_languageFindUniqueOrThrowArgs} args - Arguments to find a Author_language
     * @example
     * // Get one Author_language
     * const author_language = await prisma.author_language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends author_languageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, author_languageFindUniqueOrThrowArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Find the first Author_language that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_languageFindFirstOrThrowArgs} args - Arguments to find a Author_language
     * @example
     * // Get one Author_language
     * const author_language = await prisma.author_language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends author_languageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, author_languageFindFirstOrThrowArgs>
    ): Prisma__author_languageClient<author_languageGetPayload<T>>

    /**
     * Count the number of Author_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_languageCountArgs} args - Arguments to filter Author_languages to count.
     * @example
     * // Count the number of Author_languages
     * const count = await prisma.author_language.count({
     *   where: {
     *     // ... the filter for the Author_languages we want to count
     *   }
     * })
    **/
    count<T extends author_languageCountArgs>(
      args?: Subset<T, author_languageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Author_languageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_languageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Author_languageAggregateArgs>(args: Subset<T, Author_languageAggregateArgs>): PrismaPromise<GetAuthor_languageAggregateType<T>>

    /**
     * Group by Author_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_languageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Author_languageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Author_languageGroupByArgs['orderBy'] }
        : { orderBy?: Author_languageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Author_languageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthor_languageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for author_language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__author_languageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    language<T extends language_tblArgs= {}>(args?: Subset<T, language_tblArgs>): Prisma__language_tblClient<language_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * author_language base type for findUnique actions
   */
  export type author_languageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * Filter, which author_language to fetch.
     * 
    **/
    where: author_languageWhereUniqueInput
  }

  /**
   * author_language: findUnique
   */
  export interface author_languageFindUniqueArgs extends author_languageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_language base type for findFirst actions
   */
  export type author_languageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * Filter, which author_language to fetch.
     * 
    **/
    where?: author_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_languages to fetch.
     * 
    **/
    orderBy?: Enumerable<author_languageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for author_languages.
     * 
    **/
    cursor?: author_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_languages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of author_languages.
     * 
    **/
    distinct?: Enumerable<Author_languageScalarFieldEnum>
  }

  /**
   * author_language: findFirst
   */
  export interface author_languageFindFirstArgs extends author_languageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_language findMany
   */
  export type author_languageFindManyArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * Filter, which author_languages to fetch.
     * 
    **/
    where?: author_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_languages to fetch.
     * 
    **/
    orderBy?: Enumerable<author_languageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing author_languages.
     * 
    **/
    cursor?: author_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_languages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Author_languageScalarFieldEnum>
  }


  /**
   * author_language create
   */
  export type author_languageCreateArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * The data needed to create a author_language.
     * 
    **/
    data: XOR<author_languageCreateInput, author_languageUncheckedCreateInput>
  }


  /**
   * author_language createMany
   */
  export type author_languageCreateManyArgs = {
    /**
     * The data used to create many author_languages.
     * 
    **/
    data: Enumerable<author_languageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * author_language update
   */
  export type author_languageUpdateArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * The data needed to update a author_language.
     * 
    **/
    data: XOR<author_languageUpdateInput, author_languageUncheckedUpdateInput>
    /**
     * Choose, which author_language to update.
     * 
    **/
    where: author_languageWhereUniqueInput
  }


  /**
   * author_language updateMany
   */
  export type author_languageUpdateManyArgs = {
    /**
     * The data used to update author_languages.
     * 
    **/
    data: XOR<author_languageUpdateManyMutationInput, author_languageUncheckedUpdateManyInput>
    /**
     * Filter which author_languages to update
     * 
    **/
    where?: author_languageWhereInput
  }


  /**
   * author_language upsert
   */
  export type author_languageUpsertArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * The filter to search for the author_language to update in case it exists.
     * 
    **/
    where: author_languageWhereUniqueInput
    /**
     * In case the author_language found by the `where` argument doesn't exist, create a new author_language with this data.
     * 
    **/
    create: XOR<author_languageCreateInput, author_languageUncheckedCreateInput>
    /**
     * In case the author_language was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<author_languageUpdateInput, author_languageUncheckedUpdateInput>
  }


  /**
   * author_language delete
   */
  export type author_languageDeleteArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
    /**
     * Filter which author_language to delete.
     * 
    **/
    where: author_languageWhereUniqueInput
  }


  /**
   * author_language deleteMany
   */
  export type author_languageDeleteManyArgs = {
    /**
     * Filter which author_languages to delete
     * 
    **/
    where?: author_languageWhereInput
  }


  /**
   * author_language: findUniqueOrThrow
   */
  export type author_languageFindUniqueOrThrowArgs = author_languageFindUniqueArgsBase
      

  /**
   * author_language: findFirstOrThrow
   */
  export type author_languageFindFirstOrThrowArgs = author_languageFindFirstArgsBase
      

  /**
   * author_language without action
   */
  export type author_languageArgs = {
    /**
     * Select specific fields to fetch from the author_language
     * 
    **/
    select?: author_languageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_languageInclude | null
  }



  /**
   * Model author_royalty_details
   */


  export type AggregateAuthor_royalty_details = {
    _count: Author_royalty_detailsCountAggregateOutputType | null
    _avg: Author_royalty_detailsAvgAggregateOutputType | null
    _sum: Author_royalty_detailsSumAggregateOutputType | null
    _min: Author_royalty_detailsMinAggregateOutputType | null
    _max: Author_royalty_detailsMaxAggregateOutputType | null
  }

  export type Author_royalty_detailsAvgAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
  }

  export type Author_royalty_detailsSumAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
  }

  export type Author_royalty_detailsMinAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    settlement_date: Date | null
    bank_transaction_details: string | null
  }

  export type Author_royalty_detailsMaxAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    settlement_date: Date | null
    bank_transaction_details: string | null
  }

  export type Author_royalty_detailsCountAggregateOutputType = {
    id: number
    copyright_owner: number
    author_id: number
    pustaka: number
    amazon: number
    kobo: number
    scribd: number
    google: number
    overdrive: number
    storytel: number
    audible: number
    settlement_date: number
    bank_transaction_details: number
    _all: number
  }


  export type Author_royalty_detailsAvgAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
  }

  export type Author_royalty_detailsSumAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
  }

  export type Author_royalty_detailsMinAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    settlement_date?: true
    bank_transaction_details?: true
  }

  export type Author_royalty_detailsMaxAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    settlement_date?: true
    bank_transaction_details?: true
  }

  export type Author_royalty_detailsCountAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    settlement_date?: true
    bank_transaction_details?: true
    _all?: true
  }

  export type Author_royalty_detailsAggregateArgs = {
    /**
     * Filter which author_royalty_details to aggregate.
     * 
    **/
    where?: author_royalty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_royalty_details to fetch.
     * 
    **/
    orderBy?: Enumerable<author_royalty_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: author_royalty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_royalty_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_royalty_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned author_royalty_details
    **/
    _count?: true | Author_royalty_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Author_royalty_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Author_royalty_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Author_royalty_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Author_royalty_detailsMaxAggregateInputType
  }

  export type GetAuthor_royalty_detailsAggregateType<T extends Author_royalty_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor_royalty_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor_royalty_details[P]>
      : GetScalarType<T[P], AggregateAuthor_royalty_details[P]>
  }




  export type Author_royalty_detailsGroupByArgs = {
    where?: author_royalty_detailsWhereInput
    orderBy?: Enumerable<author_royalty_detailsOrderByWithAggregationInput>
    by: Array<Author_royalty_detailsScalarFieldEnum>
    having?: author_royalty_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Author_royalty_detailsCountAggregateInputType | true
    _avg?: Author_royalty_detailsAvgAggregateInputType
    _sum?: Author_royalty_detailsSumAggregateInputType
    _min?: Author_royalty_detailsMinAggregateInputType
    _max?: Author_royalty_detailsMaxAggregateInputType
  }


  export type Author_royalty_detailsGroupByOutputType = {
    id: number
    copyright_owner: number | null
    author_id: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    settlement_date: Date | null
    bank_transaction_details: string | null
    _count: Author_royalty_detailsCountAggregateOutputType | null
    _avg: Author_royalty_detailsAvgAggregateOutputType | null
    _sum: Author_royalty_detailsSumAggregateOutputType | null
    _min: Author_royalty_detailsMinAggregateOutputType | null
    _max: Author_royalty_detailsMaxAggregateOutputType | null
  }

  type GetAuthor_royalty_detailsGroupByPayload<T extends Author_royalty_detailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Author_royalty_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Author_royalty_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Author_royalty_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Author_royalty_detailsGroupByOutputType[P]>
        }
      >
    >


  export type author_royalty_detailsSelect = {
    id?: boolean
    copyright_owner?: boolean
    author_id?: boolean
    pustaka?: boolean
    amazon?: boolean
    kobo?: boolean
    scribd?: boolean
    google?: boolean
    overdrive?: boolean
    storytel?: boolean
    audible?: boolean
    settlement_date?: boolean
    bank_transaction_details?: boolean
  }


  export type author_royalty_detailsGetPayload<S extends boolean | null | undefined | author_royalty_detailsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? author_royalty_details :
    S extends undefined ? never :
    S extends { include: any } & (author_royalty_detailsArgs | author_royalty_detailsFindManyArgs)
    ? author_royalty_details 
    : S extends { select: any } & (author_royalty_detailsArgs | author_royalty_detailsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof author_royalty_details ? author_royalty_details[P] : never
  } 
      : author_royalty_details


  type author_royalty_detailsCountArgs = Merge<
    Omit<author_royalty_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Author_royalty_detailsCountAggregateInputType | true
    }
  >

  export interface author_royalty_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Author_royalty_details that matches the filter.
     * @param {author_royalty_detailsFindUniqueArgs} args - Arguments to find a Author_royalty_details
     * @example
     * // Get one Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends author_royalty_detailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, author_royalty_detailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'author_royalty_details'> extends True ? Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>> : Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T> | null, null>

    /**
     * Find the first Author_royalty_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_royalty_detailsFindFirstArgs} args - Arguments to find a Author_royalty_details
     * @example
     * // Get one Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends author_royalty_detailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, author_royalty_detailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'author_royalty_details'> extends True ? Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>> : Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T> | null, null>

    /**
     * Find zero or more Author_royalty_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_royalty_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findMany()
     * 
     * // Get first 10 Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const author_royalty_detailsWithIdOnly = await prisma.author_royalty_details.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends author_royalty_detailsFindManyArgs>(
      args?: SelectSubset<T, author_royalty_detailsFindManyArgs>
    ): PrismaPromise<Array<author_royalty_detailsGetPayload<T>>>

    /**
     * Create a Author_royalty_details.
     * @param {author_royalty_detailsCreateArgs} args - Arguments to create a Author_royalty_details.
     * @example
     * // Create one Author_royalty_details
     * const Author_royalty_details = await prisma.author_royalty_details.create({
     *   data: {
     *     // ... data to create a Author_royalty_details
     *   }
     * })
     * 
    **/
    create<T extends author_royalty_detailsCreateArgs>(
      args: SelectSubset<T, author_royalty_detailsCreateArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Create many Author_royalty_details.
     *     @param {author_royalty_detailsCreateManyArgs} args - Arguments to create many Author_royalty_details.
     *     @example
     *     // Create many Author_royalty_details
     *     const author_royalty_details = await prisma.author_royalty_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends author_royalty_detailsCreateManyArgs>(
      args?: SelectSubset<T, author_royalty_detailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Author_royalty_details.
     * @param {author_royalty_detailsDeleteArgs} args - Arguments to delete one Author_royalty_details.
     * @example
     * // Delete one Author_royalty_details
     * const Author_royalty_details = await prisma.author_royalty_details.delete({
     *   where: {
     *     // ... filter to delete one Author_royalty_details
     *   }
     * })
     * 
    **/
    delete<T extends author_royalty_detailsDeleteArgs>(
      args: SelectSubset<T, author_royalty_detailsDeleteArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Update one Author_royalty_details.
     * @param {author_royalty_detailsUpdateArgs} args - Arguments to update one Author_royalty_details.
     * @example
     * // Update one Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends author_royalty_detailsUpdateArgs>(
      args: SelectSubset<T, author_royalty_detailsUpdateArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Delete zero or more Author_royalty_details.
     * @param {author_royalty_detailsDeleteManyArgs} args - Arguments to filter Author_royalty_details to delete.
     * @example
     * // Delete a few Author_royalty_details
     * const { count } = await prisma.author_royalty_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends author_royalty_detailsDeleteManyArgs>(
      args?: SelectSubset<T, author_royalty_detailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Author_royalty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_royalty_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends author_royalty_detailsUpdateManyArgs>(
      args: SelectSubset<T, author_royalty_detailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author_royalty_details.
     * @param {author_royalty_detailsUpsertArgs} args - Arguments to update or create a Author_royalty_details.
     * @example
     * // Update or create a Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.upsert({
     *   create: {
     *     // ... data to create a Author_royalty_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author_royalty_details we want to update
     *   }
     * })
    **/
    upsert<T extends author_royalty_detailsUpsertArgs>(
      args: SelectSubset<T, author_royalty_detailsUpsertArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Find one Author_royalty_details that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {author_royalty_detailsFindUniqueOrThrowArgs} args - Arguments to find a Author_royalty_details
     * @example
     * // Get one Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends author_royalty_detailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, author_royalty_detailsFindUniqueOrThrowArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Find the first Author_royalty_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_royalty_detailsFindFirstOrThrowArgs} args - Arguments to find a Author_royalty_details
     * @example
     * // Get one Author_royalty_details
     * const author_royalty_details = await prisma.author_royalty_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends author_royalty_detailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, author_royalty_detailsFindFirstOrThrowArgs>
    ): Prisma__author_royalty_detailsClient<author_royalty_detailsGetPayload<T>>

    /**
     * Count the number of Author_royalty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_royalty_detailsCountArgs} args - Arguments to filter Author_royalty_details to count.
     * @example
     * // Count the number of Author_royalty_details
     * const count = await prisma.author_royalty_details.count({
     *   where: {
     *     // ... the filter for the Author_royalty_details we want to count
     *   }
     * })
    **/
    count<T extends author_royalty_detailsCountArgs>(
      args?: Subset<T, author_royalty_detailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Author_royalty_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author_royalty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_royalty_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Author_royalty_detailsAggregateArgs>(args: Subset<T, Author_royalty_detailsAggregateArgs>): PrismaPromise<GetAuthor_royalty_detailsAggregateType<T>>

    /**
     * Group by Author_royalty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_royalty_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Author_royalty_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Author_royalty_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Author_royalty_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Author_royalty_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthor_royalty_detailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for author_royalty_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__author_royalty_detailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * author_royalty_details base type for findUnique actions
   */
  export type author_royalty_detailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * Filter, which author_royalty_details to fetch.
     * 
    **/
    where: author_royalty_detailsWhereUniqueInput
  }

  /**
   * author_royalty_details: findUnique
   */
  export interface author_royalty_detailsFindUniqueArgs extends author_royalty_detailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_royalty_details base type for findFirst actions
   */
  export type author_royalty_detailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * Filter, which author_royalty_details to fetch.
     * 
    **/
    where?: author_royalty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_royalty_details to fetch.
     * 
    **/
    orderBy?: Enumerable<author_royalty_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for author_royalty_details.
     * 
    **/
    cursor?: author_royalty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_royalty_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_royalty_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of author_royalty_details.
     * 
    **/
    distinct?: Enumerable<Author_royalty_detailsScalarFieldEnum>
  }

  /**
   * author_royalty_details: findFirst
   */
  export interface author_royalty_detailsFindFirstArgs extends author_royalty_detailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_royalty_details findMany
   */
  export type author_royalty_detailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * Filter, which author_royalty_details to fetch.
     * 
    **/
    where?: author_royalty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_royalty_details to fetch.
     * 
    **/
    orderBy?: Enumerable<author_royalty_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing author_royalty_details.
     * 
    **/
    cursor?: author_royalty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_royalty_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_royalty_details.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Author_royalty_detailsScalarFieldEnum>
  }


  /**
   * author_royalty_details create
   */
  export type author_royalty_detailsCreateArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * The data needed to create a author_royalty_details.
     * 
    **/
    data: XOR<author_royalty_detailsCreateInput, author_royalty_detailsUncheckedCreateInput>
  }


  /**
   * author_royalty_details createMany
   */
  export type author_royalty_detailsCreateManyArgs = {
    /**
     * The data used to create many author_royalty_details.
     * 
    **/
    data: Enumerable<author_royalty_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * author_royalty_details update
   */
  export type author_royalty_detailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * The data needed to update a author_royalty_details.
     * 
    **/
    data: XOR<author_royalty_detailsUpdateInput, author_royalty_detailsUncheckedUpdateInput>
    /**
     * Choose, which author_royalty_details to update.
     * 
    **/
    where: author_royalty_detailsWhereUniqueInput
  }


  /**
   * author_royalty_details updateMany
   */
  export type author_royalty_detailsUpdateManyArgs = {
    /**
     * The data used to update author_royalty_details.
     * 
    **/
    data: XOR<author_royalty_detailsUpdateManyMutationInput, author_royalty_detailsUncheckedUpdateManyInput>
    /**
     * Filter which author_royalty_details to update
     * 
    **/
    where?: author_royalty_detailsWhereInput
  }


  /**
   * author_royalty_details upsert
   */
  export type author_royalty_detailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * The filter to search for the author_royalty_details to update in case it exists.
     * 
    **/
    where: author_royalty_detailsWhereUniqueInput
    /**
     * In case the author_royalty_details found by the `where` argument doesn't exist, create a new author_royalty_details with this data.
     * 
    **/
    create: XOR<author_royalty_detailsCreateInput, author_royalty_detailsUncheckedCreateInput>
    /**
     * In case the author_royalty_details was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<author_royalty_detailsUpdateInput, author_royalty_detailsUncheckedUpdateInput>
  }


  /**
   * author_royalty_details delete
   */
  export type author_royalty_detailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
    /**
     * Filter which author_royalty_details to delete.
     * 
    **/
    where: author_royalty_detailsWhereUniqueInput
  }


  /**
   * author_royalty_details deleteMany
   */
  export type author_royalty_detailsDeleteManyArgs = {
    /**
     * Filter which author_royalty_details to delete
     * 
    **/
    where?: author_royalty_detailsWhereInput
  }


  /**
   * author_royalty_details: findUniqueOrThrow
   */
  export type author_royalty_detailsFindUniqueOrThrowArgs = author_royalty_detailsFindUniqueArgsBase
      

  /**
   * author_royalty_details: findFirstOrThrow
   */
  export type author_royalty_detailsFindFirstOrThrowArgs = author_royalty_detailsFindFirstArgsBase
      

  /**
   * author_royalty_details without action
   */
  export type author_royalty_detailsArgs = {
    /**
     * Select specific fields to fetch from the author_royalty_details
     * 
    **/
    select?: author_royalty_detailsSelect | null
  }



  /**
   * Model author_tbl
   */


  export type AggregateAuthor_tbl = {
    _count: Author_tblCountAggregateOutputType | null
    _avg: Author_tblAvgAggregateOutputType | null
    _sum: Author_tblSumAggregateOutputType | null
    _min: Author_tblMinAggregateOutputType | null
    _max: Author_tblMaxAggregateOutputType | null
  }

  export type Author_tblAvgAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    status: number | null
    created_by: number | null
    copyright_owner: number | null
    user_id: number | null
    narrator_id: number | null
    agreement_ebook_count: number | null
    agreement_audiobook_count: number | null
    agreement_paperback_count: number | null
  }

  export type Author_tblSumAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    status: number | null
    created_by: number | null
    copyright_owner: number | null
    user_id: number | null
    narrator_id: number | null
    agreement_ebook_count: number | null
    agreement_audiobook_count: number | null
    agreement_paperback_count: number | null
  }

  export type Author_tblMinAggregateOutputType = {
    author_id: number | null
    author_name: string | null
    url_name: string | null
    author_type: number | null
    author_image: string | null
    copy_right_owner_name: string | null
    relationship: string | null
    mobile: string | null
    phone: string | null
    email: string | null
    address: string | null
    fb_url: string | null
    twitter_url: string | null
    blog_url: string | null
    description: string | null
    status: number | null
    created_at: Date | null
    activated_at: Date | null
    created_by: number | null
    gender: string | null
    copyright_owner: number | null
    user_id: number | null
    narrator_id: number | null
    amazon_link: string | null
    pratilipi_link: string | null
    audible_link: string | null
    odilo_link: string | null
    scribd_link: string | null
    googlebooks_link: string | null
    storytel_link: string | null
    overdrive_link: string | null
    pinterest_link: string | null
    agreement_details: string | null
    agreement_ebook_count: number | null
    agreement_audiobook_count: number | null
    agreement_paperback_count: number | null
  }

  export type Author_tblMaxAggregateOutputType = {
    author_id: number | null
    author_name: string | null
    url_name: string | null
    author_type: number | null
    author_image: string | null
    copy_right_owner_name: string | null
    relationship: string | null
    mobile: string | null
    phone: string | null
    email: string | null
    address: string | null
    fb_url: string | null
    twitter_url: string | null
    blog_url: string | null
    description: string | null
    status: number | null
    created_at: Date | null
    activated_at: Date | null
    created_by: number | null
    gender: string | null
    copyright_owner: number | null
    user_id: number | null
    narrator_id: number | null
    amazon_link: string | null
    pratilipi_link: string | null
    audible_link: string | null
    odilo_link: string | null
    scribd_link: string | null
    googlebooks_link: string | null
    storytel_link: string | null
    overdrive_link: string | null
    pinterest_link: string | null
    agreement_details: string | null
    agreement_ebook_count: number | null
    agreement_audiobook_count: number | null
    agreement_paperback_count: number | null
  }

  export type Author_tblCountAggregateOutputType = {
    author_id: number
    author_name: number
    url_name: number
    author_type: number
    author_image: number
    copy_right_owner_name: number
    relationship: number
    mobile: number
    phone: number
    email: number
    address: number
    fb_url: number
    twitter_url: number
    blog_url: number
    description: number
    status: number
    created_at: number
    activated_at: number
    created_by: number
    gender: number
    copyright_owner: number
    user_id: number
    narrator_id: number
    amazon_link: number
    pratilipi_link: number
    audible_link: number
    odilo_link: number
    scribd_link: number
    googlebooks_link: number
    storytel_link: number
    overdrive_link: number
    pinterest_link: number
    agreement_details: number
    agreement_ebook_count: number
    agreement_audiobook_count: number
    agreement_paperback_count: number
    _all: number
  }


  export type Author_tblAvgAggregateInputType = {
    author_id?: true
    author_type?: true
    status?: true
    created_by?: true
    copyright_owner?: true
    user_id?: true
    narrator_id?: true
    agreement_ebook_count?: true
    agreement_audiobook_count?: true
    agreement_paperback_count?: true
  }

  export type Author_tblSumAggregateInputType = {
    author_id?: true
    author_type?: true
    status?: true
    created_by?: true
    copyright_owner?: true
    user_id?: true
    narrator_id?: true
    agreement_ebook_count?: true
    agreement_audiobook_count?: true
    agreement_paperback_count?: true
  }

  export type Author_tblMinAggregateInputType = {
    author_id?: true
    author_name?: true
    url_name?: true
    author_type?: true
    author_image?: true
    copy_right_owner_name?: true
    relationship?: true
    mobile?: true
    phone?: true
    email?: true
    address?: true
    fb_url?: true
    twitter_url?: true
    blog_url?: true
    description?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    gender?: true
    copyright_owner?: true
    user_id?: true
    narrator_id?: true
    amazon_link?: true
    pratilipi_link?: true
    audible_link?: true
    odilo_link?: true
    scribd_link?: true
    googlebooks_link?: true
    storytel_link?: true
    overdrive_link?: true
    pinterest_link?: true
    agreement_details?: true
    agreement_ebook_count?: true
    agreement_audiobook_count?: true
    agreement_paperback_count?: true
  }

  export type Author_tblMaxAggregateInputType = {
    author_id?: true
    author_name?: true
    url_name?: true
    author_type?: true
    author_image?: true
    copy_right_owner_name?: true
    relationship?: true
    mobile?: true
    phone?: true
    email?: true
    address?: true
    fb_url?: true
    twitter_url?: true
    blog_url?: true
    description?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    gender?: true
    copyright_owner?: true
    user_id?: true
    narrator_id?: true
    amazon_link?: true
    pratilipi_link?: true
    audible_link?: true
    odilo_link?: true
    scribd_link?: true
    googlebooks_link?: true
    storytel_link?: true
    overdrive_link?: true
    pinterest_link?: true
    agreement_details?: true
    agreement_ebook_count?: true
    agreement_audiobook_count?: true
    agreement_paperback_count?: true
  }

  export type Author_tblCountAggregateInputType = {
    author_id?: true
    author_name?: true
    url_name?: true
    author_type?: true
    author_image?: true
    copy_right_owner_name?: true
    relationship?: true
    mobile?: true
    phone?: true
    email?: true
    address?: true
    fb_url?: true
    twitter_url?: true
    blog_url?: true
    description?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    gender?: true
    copyright_owner?: true
    user_id?: true
    narrator_id?: true
    amazon_link?: true
    pratilipi_link?: true
    audible_link?: true
    odilo_link?: true
    scribd_link?: true
    googlebooks_link?: true
    storytel_link?: true
    overdrive_link?: true
    pinterest_link?: true
    agreement_details?: true
    agreement_ebook_count?: true
    agreement_audiobook_count?: true
    agreement_paperback_count?: true
    _all?: true
  }

  export type Author_tblAggregateArgs = {
    /**
     * Filter which author_tbl to aggregate.
     * 
    **/
    where?: author_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<author_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: author_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned author_tbls
    **/
    _count?: true | Author_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Author_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Author_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Author_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Author_tblMaxAggregateInputType
  }

  export type GetAuthor_tblAggregateType<T extends Author_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor_tbl[P]>
      : GetScalarType<T[P], AggregateAuthor_tbl[P]>
  }




  export type Author_tblGroupByArgs = {
    where?: author_tblWhereInput
    orderBy?: Enumerable<author_tblOrderByWithAggregationInput>
    by: Array<Author_tblScalarFieldEnum>
    having?: author_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Author_tblCountAggregateInputType | true
    _avg?: Author_tblAvgAggregateInputType
    _sum?: Author_tblSumAggregateInputType
    _min?: Author_tblMinAggregateInputType
    _max?: Author_tblMaxAggregateInputType
  }


  export type Author_tblGroupByOutputType = {
    author_id: number
    author_name: string
    url_name: string | null
    author_type: number | null
    author_image: string | null
    copy_right_owner_name: string
    relationship: string
    mobile: string | null
    phone: string | null
    email: string | null
    address: string | null
    fb_url: string | null
    twitter_url: string | null
    blog_url: string | null
    description: string | null
    status: number
    created_at: Date
    activated_at: Date | null
    created_by: number
    gender: string
    copyright_owner: number | null
    user_id: number
    narrator_id: number | null
    amazon_link: string | null
    pratilipi_link: string | null
    audible_link: string | null
    odilo_link: string | null
    scribd_link: string | null
    googlebooks_link: string | null
    storytel_link: string | null
    overdrive_link: string | null
    pinterest_link: string | null
    agreement_details: string | null
    agreement_ebook_count: number | null
    agreement_audiobook_count: number | null
    agreement_paperback_count: number | null
    _count: Author_tblCountAggregateOutputType | null
    _avg: Author_tblAvgAggregateOutputType | null
    _sum: Author_tblSumAggregateOutputType | null
    _min: Author_tblMinAggregateOutputType | null
    _max: Author_tblMaxAggregateOutputType | null
  }

  type GetAuthor_tblGroupByPayload<T extends Author_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Author_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Author_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Author_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Author_tblGroupByOutputType[P]>
        }
      >
    >


  export type author_tblSelect = {
    author_id?: boolean
    author_name?: boolean
    url_name?: boolean
    author_type?: boolean
    author_image?: boolean
    copy_right_owner_name?: boolean
    relationship?: boolean
    mobile?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    fb_url?: boolean
    twitter_url?: boolean
    blog_url?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    activated_at?: boolean
    created_by?: boolean
    gender?: boolean
    copyright_owner?: boolean
    user_id?: boolean
    narrator_id?: boolean
    amazon_link?: boolean
    pratilipi_link?: boolean
    audible_link?: boolean
    odilo_link?: boolean
    scribd_link?: boolean
    googlebooks_link?: boolean
    storytel_link?: boolean
    overdrive_link?: boolean
    pinterest_link?: boolean
    agreement_details?: boolean
    agreement_ebook_count?: boolean
    agreement_audiobook_count?: boolean
    agreement_paperback_count?: boolean
  }


  export type author_tblGetPayload<S extends boolean | null | undefined | author_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? author_tbl :
    S extends undefined ? never :
    S extends { include: any } & (author_tblArgs | author_tblFindManyArgs)
    ? author_tbl 
    : S extends { select: any } & (author_tblArgs | author_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof author_tbl ? author_tbl[P] : never
  } 
      : author_tbl


  type author_tblCountArgs = Merge<
    Omit<author_tblFindManyArgs, 'select' | 'include'> & {
      select?: Author_tblCountAggregateInputType | true
    }
  >

  export interface author_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Author_tbl that matches the filter.
     * @param {author_tblFindUniqueArgs} args - Arguments to find a Author_tbl
     * @example
     * // Get one Author_tbl
     * const author_tbl = await prisma.author_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends author_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, author_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'author_tbl'> extends True ? Prisma__author_tblClient<author_tblGetPayload<T>> : Prisma__author_tblClient<author_tblGetPayload<T> | null, null>

    /**
     * Find the first Author_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_tblFindFirstArgs} args - Arguments to find a Author_tbl
     * @example
     * // Get one Author_tbl
     * const author_tbl = await prisma.author_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends author_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, author_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'author_tbl'> extends True ? Prisma__author_tblClient<author_tblGetPayload<T>> : Prisma__author_tblClient<author_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Author_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Author_tbls
     * const author_tbls = await prisma.author_tbl.findMany()
     * 
     * // Get first 10 Author_tbls
     * const author_tbls = await prisma.author_tbl.findMany({ take: 10 })
     * 
     * // Only select the `author_id`
     * const author_tblWithAuthor_idOnly = await prisma.author_tbl.findMany({ select: { author_id: true } })
     * 
    **/
    findMany<T extends author_tblFindManyArgs>(
      args?: SelectSubset<T, author_tblFindManyArgs>
    ): PrismaPromise<Array<author_tblGetPayload<T>>>

    /**
     * Create a Author_tbl.
     * @param {author_tblCreateArgs} args - Arguments to create a Author_tbl.
     * @example
     * // Create one Author_tbl
     * const Author_tbl = await prisma.author_tbl.create({
     *   data: {
     *     // ... data to create a Author_tbl
     *   }
     * })
     * 
    **/
    create<T extends author_tblCreateArgs>(
      args: SelectSubset<T, author_tblCreateArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Create many Author_tbls.
     *     @param {author_tblCreateManyArgs} args - Arguments to create many Author_tbls.
     *     @example
     *     // Create many Author_tbls
     *     const author_tbl = await prisma.author_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends author_tblCreateManyArgs>(
      args?: SelectSubset<T, author_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Author_tbl.
     * @param {author_tblDeleteArgs} args - Arguments to delete one Author_tbl.
     * @example
     * // Delete one Author_tbl
     * const Author_tbl = await prisma.author_tbl.delete({
     *   where: {
     *     // ... filter to delete one Author_tbl
     *   }
     * })
     * 
    **/
    delete<T extends author_tblDeleteArgs>(
      args: SelectSubset<T, author_tblDeleteArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Update one Author_tbl.
     * @param {author_tblUpdateArgs} args - Arguments to update one Author_tbl.
     * @example
     * // Update one Author_tbl
     * const author_tbl = await prisma.author_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends author_tblUpdateArgs>(
      args: SelectSubset<T, author_tblUpdateArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Delete zero or more Author_tbls.
     * @param {author_tblDeleteManyArgs} args - Arguments to filter Author_tbls to delete.
     * @example
     * // Delete a few Author_tbls
     * const { count } = await prisma.author_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends author_tblDeleteManyArgs>(
      args?: SelectSubset<T, author_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Author_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Author_tbls
     * const author_tbl = await prisma.author_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends author_tblUpdateManyArgs>(
      args: SelectSubset<T, author_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author_tbl.
     * @param {author_tblUpsertArgs} args - Arguments to update or create a Author_tbl.
     * @example
     * // Update or create a Author_tbl
     * const author_tbl = await prisma.author_tbl.upsert({
     *   create: {
     *     // ... data to create a Author_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends author_tblUpsertArgs>(
      args: SelectSubset<T, author_tblUpsertArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Find one Author_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {author_tblFindUniqueOrThrowArgs} args - Arguments to find a Author_tbl
     * @example
     * // Get one Author_tbl
     * const author_tbl = await prisma.author_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends author_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, author_tblFindUniqueOrThrowArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Find the first Author_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_tblFindFirstOrThrowArgs} args - Arguments to find a Author_tbl
     * @example
     * // Get one Author_tbl
     * const author_tbl = await prisma.author_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends author_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, author_tblFindFirstOrThrowArgs>
    ): Prisma__author_tblClient<author_tblGetPayload<T>>

    /**
     * Count the number of Author_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_tblCountArgs} args - Arguments to filter Author_tbls to count.
     * @example
     * // Count the number of Author_tbls
     * const count = await prisma.author_tbl.count({
     *   where: {
     *     // ... the filter for the Author_tbls we want to count
     *   }
     * })
    **/
    count<T extends author_tblCountArgs>(
      args?: Subset<T, author_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Author_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Author_tblAggregateArgs>(args: Subset<T, Author_tblAggregateArgs>): PrismaPromise<GetAuthor_tblAggregateType<T>>

    /**
     * Group by Author_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Author_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Author_tblGroupByArgs['orderBy'] }
        : { orderBy?: Author_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Author_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthor_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for author_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__author_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * author_tbl base type for findUnique actions
   */
  export type author_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * Filter, which author_tbl to fetch.
     * 
    **/
    where: author_tblWhereUniqueInput
  }

  /**
   * author_tbl: findUnique
   */
  export interface author_tblFindUniqueArgs extends author_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_tbl base type for findFirst actions
   */
  export type author_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * Filter, which author_tbl to fetch.
     * 
    **/
    where?: author_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<author_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for author_tbls.
     * 
    **/
    cursor?: author_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of author_tbls.
     * 
    **/
    distinct?: Enumerable<Author_tblScalarFieldEnum>
  }

  /**
   * author_tbl: findFirst
   */
  export interface author_tblFindFirstArgs extends author_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_tbl findMany
   */
  export type author_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * Filter, which author_tbls to fetch.
     * 
    **/
    where?: author_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<author_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing author_tbls.
     * 
    **/
    cursor?: author_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Author_tblScalarFieldEnum>
  }


  /**
   * author_tbl create
   */
  export type author_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * The data needed to create a author_tbl.
     * 
    **/
    data: XOR<author_tblCreateInput, author_tblUncheckedCreateInput>
  }


  /**
   * author_tbl createMany
   */
  export type author_tblCreateManyArgs = {
    /**
     * The data used to create many author_tbls.
     * 
    **/
    data: Enumerable<author_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * author_tbl update
   */
  export type author_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * The data needed to update a author_tbl.
     * 
    **/
    data: XOR<author_tblUpdateInput, author_tblUncheckedUpdateInput>
    /**
     * Choose, which author_tbl to update.
     * 
    **/
    where: author_tblWhereUniqueInput
  }


  /**
   * author_tbl updateMany
   */
  export type author_tblUpdateManyArgs = {
    /**
     * The data used to update author_tbls.
     * 
    **/
    data: XOR<author_tblUpdateManyMutationInput, author_tblUncheckedUpdateManyInput>
    /**
     * Filter which author_tbls to update
     * 
    **/
    where?: author_tblWhereInput
  }


  /**
   * author_tbl upsert
   */
  export type author_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * The filter to search for the author_tbl to update in case it exists.
     * 
    **/
    where: author_tblWhereUniqueInput
    /**
     * In case the author_tbl found by the `where` argument doesn't exist, create a new author_tbl with this data.
     * 
    **/
    create: XOR<author_tblCreateInput, author_tblUncheckedCreateInput>
    /**
     * In case the author_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<author_tblUpdateInput, author_tblUncheckedUpdateInput>
  }


  /**
   * author_tbl delete
   */
  export type author_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
    /**
     * Filter which author_tbl to delete.
     * 
    **/
    where: author_tblWhereUniqueInput
  }


  /**
   * author_tbl deleteMany
   */
  export type author_tblDeleteManyArgs = {
    /**
     * Filter which author_tbls to delete
     * 
    **/
    where?: author_tblWhereInput
  }


  /**
   * author_tbl: findUniqueOrThrow
   */
  export type author_tblFindUniqueOrThrowArgs = author_tblFindUniqueArgsBase
      

  /**
   * author_tbl: findFirstOrThrow
   */
  export type author_tblFindFirstOrThrowArgs = author_tblFindFirstArgsBase
      

  /**
   * author_tbl without action
   */
  export type author_tblArgs = {
    /**
     * Select specific fields to fetch from the author_tbl
     * 
    **/
    select?: author_tblSelect | null
  }



  /**
   * Model author_transaction
   */


  export type AggregateAuthor_transaction = {
    _count: Author_transactionCountAggregateOutputType | null
    _avg: Author_transactionAvgAggregateOutputType | null
    _sum: Author_transactionSumAggregateOutputType | null
    _min: Author_transactionMinAggregateOutputType | null
    _max: Author_transactionMaxAggregateOutputType | null
  }

  export type Author_transactionAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    book_id: number | null
    author_id: number | null
    copy_right_seller: number | null
    copy_right_lender: number | null
    copyright_owner: number | null
    book_final_royalty_value_inr: number | null
    book_final_royalty_value_usd: number | null
    discount_provided: number | null
    usd_exchange_rate: number | null
    converted_book_final_royalty_value_inr: number | null
    selling_royalty_percentage: number | null
    lending_royalty_percentage: number | null
  }

  export type Author_transactionSumAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    book_id: number | null
    author_id: number | null
    copy_right_seller: number | null
    copy_right_lender: number | null
    copyright_owner: number | null
    book_final_royalty_value_inr: number | null
    book_final_royalty_value_usd: number | null
    discount_provided: number | null
    usd_exchange_rate: number | null
    converted_book_final_royalty_value_inr: number | null
    selling_royalty_percentage: number | null
    lending_royalty_percentage: number | null
  }

  export type Author_transactionMinAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    order_date: Date | null
    book_id: number | null
    author_id: number | null
    order_type: string | null
    copy_right_seller: number | null
    copy_right_lender: number | null
    copyright_owner: number | null
    currency: string | null
    book_final_royalty_value_inr: number | null
    book_final_royalty_value_usd: number | null
    discount_provided: number | null
    usd_exchange_rate: number | null
    converted_book_final_royalty_value_inr: number | null
    exchange_rate_comments: string | null
    selling_royalty_percentage: number | null
    lending_royalty_percentage: number | null
    pay_status: string | null
    comments: string | null
  }

  export type Author_transactionMaxAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    order_date: Date | null
    book_id: number | null
    author_id: number | null
    order_type: string | null
    copy_right_seller: number | null
    copy_right_lender: number | null
    copyright_owner: number | null
    currency: string | null
    book_final_royalty_value_inr: number | null
    book_final_royalty_value_usd: number | null
    discount_provided: number | null
    usd_exchange_rate: number | null
    converted_book_final_royalty_value_inr: number | null
    exchange_rate_comments: string | null
    selling_royalty_percentage: number | null
    lending_royalty_percentage: number | null
    pay_status: string | null
    comments: string | null
  }

  export type Author_transactionCountAggregateOutputType = {
    id: number
    order_id: number
    order_date: number
    book_id: number
    author_id: number
    order_type: number
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner: number
    currency: number
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: number
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: number
    comments: number
    _all: number
  }


  export type Author_transactionAvgAggregateInputType = {
    id?: true
    order_id?: true
    book_id?: true
    author_id?: true
    copy_right_seller?: true
    copy_right_lender?: true
    copyright_owner?: true
    book_final_royalty_value_inr?: true
    book_final_royalty_value_usd?: true
    discount_provided?: true
    usd_exchange_rate?: true
    converted_book_final_royalty_value_inr?: true
    selling_royalty_percentage?: true
    lending_royalty_percentage?: true
  }

  export type Author_transactionSumAggregateInputType = {
    id?: true
    order_id?: true
    book_id?: true
    author_id?: true
    copy_right_seller?: true
    copy_right_lender?: true
    copyright_owner?: true
    book_final_royalty_value_inr?: true
    book_final_royalty_value_usd?: true
    discount_provided?: true
    usd_exchange_rate?: true
    converted_book_final_royalty_value_inr?: true
    selling_royalty_percentage?: true
    lending_royalty_percentage?: true
  }

  export type Author_transactionMinAggregateInputType = {
    id?: true
    order_id?: true
    order_date?: true
    book_id?: true
    author_id?: true
    order_type?: true
    copy_right_seller?: true
    copy_right_lender?: true
    copyright_owner?: true
    currency?: true
    book_final_royalty_value_inr?: true
    book_final_royalty_value_usd?: true
    discount_provided?: true
    usd_exchange_rate?: true
    converted_book_final_royalty_value_inr?: true
    exchange_rate_comments?: true
    selling_royalty_percentage?: true
    lending_royalty_percentage?: true
    pay_status?: true
    comments?: true
  }

  export type Author_transactionMaxAggregateInputType = {
    id?: true
    order_id?: true
    order_date?: true
    book_id?: true
    author_id?: true
    order_type?: true
    copy_right_seller?: true
    copy_right_lender?: true
    copyright_owner?: true
    currency?: true
    book_final_royalty_value_inr?: true
    book_final_royalty_value_usd?: true
    discount_provided?: true
    usd_exchange_rate?: true
    converted_book_final_royalty_value_inr?: true
    exchange_rate_comments?: true
    selling_royalty_percentage?: true
    lending_royalty_percentage?: true
    pay_status?: true
    comments?: true
  }

  export type Author_transactionCountAggregateInputType = {
    id?: true
    order_id?: true
    order_date?: true
    book_id?: true
    author_id?: true
    order_type?: true
    copy_right_seller?: true
    copy_right_lender?: true
    copyright_owner?: true
    currency?: true
    book_final_royalty_value_inr?: true
    book_final_royalty_value_usd?: true
    discount_provided?: true
    usd_exchange_rate?: true
    converted_book_final_royalty_value_inr?: true
    exchange_rate_comments?: true
    selling_royalty_percentage?: true
    lending_royalty_percentage?: true
    pay_status?: true
    comments?: true
    _all?: true
  }

  export type Author_transactionAggregateArgs = {
    /**
     * Filter which author_transaction to aggregate.
     * 
    **/
    where?: author_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<author_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: author_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned author_transactions
    **/
    _count?: true | Author_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Author_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Author_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Author_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Author_transactionMaxAggregateInputType
  }

  export type GetAuthor_transactionAggregateType<T extends Author_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor_transaction[P]>
      : GetScalarType<T[P], AggregateAuthor_transaction[P]>
  }




  export type Author_transactionGroupByArgs = {
    where?: author_transactionWhereInput
    orderBy?: Enumerable<author_transactionOrderByWithAggregationInput>
    by: Array<Author_transactionScalarFieldEnum>
    having?: author_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Author_transactionCountAggregateInputType | true
    _avg?: Author_transactionAvgAggregateInputType
    _sum?: Author_transactionSumAggregateInputType
    _min?: Author_transactionMinAggregateInputType
    _max?: Author_transactionMaxAggregateInputType
  }


  export type Author_transactionGroupByOutputType = {
    id: number
    order_id: bigint
    order_date: Date | null
    book_id: number
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner: number | null
    currency: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
    _count: Author_transactionCountAggregateOutputType | null
    _avg: Author_transactionAvgAggregateOutputType | null
    _sum: Author_transactionSumAggregateOutputType | null
    _min: Author_transactionMinAggregateOutputType | null
    _max: Author_transactionMaxAggregateOutputType | null
  }

  type GetAuthor_transactionGroupByPayload<T extends Author_transactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Author_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Author_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Author_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Author_transactionGroupByOutputType[P]>
        }
      >
    >


  export type author_transactionSelect = {
    id?: boolean
    order_id?: boolean
    order_date?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    order_type?: boolean
    copy_right_seller?: boolean
    copy_right_lender?: boolean
    copyright_owner?: boolean
    currency?: boolean
    book_final_royalty_value_inr?: boolean
    book_final_royalty_value_usd?: boolean
    discount_provided?: boolean
    usd_exchange_rate?: boolean
    converted_book_final_royalty_value_inr?: boolean
    exchange_rate_comments?: boolean
    selling_royalty_percentage?: boolean
    lending_royalty_percentage?: boolean
    pay_status?: boolean
    comments?: boolean
  }


  export type author_transactionInclude = {
    book?: boolean | book_tblArgs
  } 

  export type author_transactionGetPayload<S extends boolean | null | undefined | author_transactionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? author_transaction :
    S extends undefined ? never :
    S extends { include: any } & (author_transactionArgs | author_transactionFindManyArgs)
    ? author_transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (author_transactionArgs | author_transactionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof author_transaction ? author_transaction[P] : never
  } 
      : author_transaction


  type author_transactionCountArgs = Merge<
    Omit<author_transactionFindManyArgs, 'select' | 'include'> & {
      select?: Author_transactionCountAggregateInputType | true
    }
  >

  export interface author_transactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Author_transaction that matches the filter.
     * @param {author_transactionFindUniqueArgs} args - Arguments to find a Author_transaction
     * @example
     * // Get one Author_transaction
     * const author_transaction = await prisma.author_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends author_transactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, author_transactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'author_transaction'> extends True ? Prisma__author_transactionClient<author_transactionGetPayload<T>> : Prisma__author_transactionClient<author_transactionGetPayload<T> | null, null>

    /**
     * Find the first Author_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_transactionFindFirstArgs} args - Arguments to find a Author_transaction
     * @example
     * // Get one Author_transaction
     * const author_transaction = await prisma.author_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends author_transactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, author_transactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'author_transaction'> extends True ? Prisma__author_transactionClient<author_transactionGetPayload<T>> : Prisma__author_transactionClient<author_transactionGetPayload<T> | null, null>

    /**
     * Find zero or more Author_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Author_transactions
     * const author_transactions = await prisma.author_transaction.findMany()
     * 
     * // Get first 10 Author_transactions
     * const author_transactions = await prisma.author_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const author_transactionWithIdOnly = await prisma.author_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends author_transactionFindManyArgs>(
      args?: SelectSubset<T, author_transactionFindManyArgs>
    ): PrismaPromise<Array<author_transactionGetPayload<T>>>

    /**
     * Create a Author_transaction.
     * @param {author_transactionCreateArgs} args - Arguments to create a Author_transaction.
     * @example
     * // Create one Author_transaction
     * const Author_transaction = await prisma.author_transaction.create({
     *   data: {
     *     // ... data to create a Author_transaction
     *   }
     * })
     * 
    **/
    create<T extends author_transactionCreateArgs>(
      args: SelectSubset<T, author_transactionCreateArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Create many Author_transactions.
     *     @param {author_transactionCreateManyArgs} args - Arguments to create many Author_transactions.
     *     @example
     *     // Create many Author_transactions
     *     const author_transaction = await prisma.author_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends author_transactionCreateManyArgs>(
      args?: SelectSubset<T, author_transactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Author_transaction.
     * @param {author_transactionDeleteArgs} args - Arguments to delete one Author_transaction.
     * @example
     * // Delete one Author_transaction
     * const Author_transaction = await prisma.author_transaction.delete({
     *   where: {
     *     // ... filter to delete one Author_transaction
     *   }
     * })
     * 
    **/
    delete<T extends author_transactionDeleteArgs>(
      args: SelectSubset<T, author_transactionDeleteArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Update one Author_transaction.
     * @param {author_transactionUpdateArgs} args - Arguments to update one Author_transaction.
     * @example
     * // Update one Author_transaction
     * const author_transaction = await prisma.author_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends author_transactionUpdateArgs>(
      args: SelectSubset<T, author_transactionUpdateArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Delete zero or more Author_transactions.
     * @param {author_transactionDeleteManyArgs} args - Arguments to filter Author_transactions to delete.
     * @example
     * // Delete a few Author_transactions
     * const { count } = await prisma.author_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends author_transactionDeleteManyArgs>(
      args?: SelectSubset<T, author_transactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Author_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Author_transactions
     * const author_transaction = await prisma.author_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends author_transactionUpdateManyArgs>(
      args: SelectSubset<T, author_transactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author_transaction.
     * @param {author_transactionUpsertArgs} args - Arguments to update or create a Author_transaction.
     * @example
     * // Update or create a Author_transaction
     * const author_transaction = await prisma.author_transaction.upsert({
     *   create: {
     *     // ... data to create a Author_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends author_transactionUpsertArgs>(
      args: SelectSubset<T, author_transactionUpsertArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Find one Author_transaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {author_transactionFindUniqueOrThrowArgs} args - Arguments to find a Author_transaction
     * @example
     * // Get one Author_transaction
     * const author_transaction = await prisma.author_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends author_transactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, author_transactionFindUniqueOrThrowArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Find the first Author_transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_transactionFindFirstOrThrowArgs} args - Arguments to find a Author_transaction
     * @example
     * // Get one Author_transaction
     * const author_transaction = await prisma.author_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends author_transactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, author_transactionFindFirstOrThrowArgs>
    ): Prisma__author_transactionClient<author_transactionGetPayload<T>>

    /**
     * Count the number of Author_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {author_transactionCountArgs} args - Arguments to filter Author_transactions to count.
     * @example
     * // Count the number of Author_transactions
     * const count = await prisma.author_transaction.count({
     *   where: {
     *     // ... the filter for the Author_transactions we want to count
     *   }
     * })
    **/
    count<T extends author_transactionCountArgs>(
      args?: Subset<T, author_transactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Author_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Author_transactionAggregateArgs>(args: Subset<T, Author_transactionAggregateArgs>): PrismaPromise<GetAuthor_transactionAggregateType<T>>

    /**
     * Group by Author_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Author_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Author_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Author_transactionGroupByArgs['orderBy'] }
        : { orderBy?: Author_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Author_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthor_transactionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for author_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__author_transactionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * author_transaction base type for findUnique actions
   */
  export type author_transactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * Filter, which author_transaction to fetch.
     * 
    **/
    where: author_transactionWhereUniqueInput
  }

  /**
   * author_transaction: findUnique
   */
  export interface author_transactionFindUniqueArgs extends author_transactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_transaction base type for findFirst actions
   */
  export type author_transactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * Filter, which author_transaction to fetch.
     * 
    **/
    where?: author_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<author_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for author_transactions.
     * 
    **/
    cursor?: author_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of author_transactions.
     * 
    **/
    distinct?: Enumerable<Author_transactionScalarFieldEnum>
  }

  /**
   * author_transaction: findFirst
   */
  export interface author_transactionFindFirstArgs extends author_transactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * author_transaction findMany
   */
  export type author_transactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * Filter, which author_transactions to fetch.
     * 
    **/
    where?: author_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of author_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<author_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing author_transactions.
     * 
    **/
    cursor?: author_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` author_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` author_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Author_transactionScalarFieldEnum>
  }


  /**
   * author_transaction create
   */
  export type author_transactionCreateArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * The data needed to create a author_transaction.
     * 
    **/
    data: XOR<author_transactionCreateInput, author_transactionUncheckedCreateInput>
  }


  /**
   * author_transaction createMany
   */
  export type author_transactionCreateManyArgs = {
    /**
     * The data used to create many author_transactions.
     * 
    **/
    data: Enumerable<author_transactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * author_transaction update
   */
  export type author_transactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * The data needed to update a author_transaction.
     * 
    **/
    data: XOR<author_transactionUpdateInput, author_transactionUncheckedUpdateInput>
    /**
     * Choose, which author_transaction to update.
     * 
    **/
    where: author_transactionWhereUniqueInput
  }


  /**
   * author_transaction updateMany
   */
  export type author_transactionUpdateManyArgs = {
    /**
     * The data used to update author_transactions.
     * 
    **/
    data: XOR<author_transactionUpdateManyMutationInput, author_transactionUncheckedUpdateManyInput>
    /**
     * Filter which author_transactions to update
     * 
    **/
    where?: author_transactionWhereInput
  }


  /**
   * author_transaction upsert
   */
  export type author_transactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * The filter to search for the author_transaction to update in case it exists.
     * 
    **/
    where: author_transactionWhereUniqueInput
    /**
     * In case the author_transaction found by the `where` argument doesn't exist, create a new author_transaction with this data.
     * 
    **/
    create: XOR<author_transactionCreateInput, author_transactionUncheckedCreateInput>
    /**
     * In case the author_transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<author_transactionUpdateInput, author_transactionUncheckedUpdateInput>
  }


  /**
   * author_transaction delete
   */
  export type author_transactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
    /**
     * Filter which author_transaction to delete.
     * 
    **/
    where: author_transactionWhereUniqueInput
  }


  /**
   * author_transaction deleteMany
   */
  export type author_transactionDeleteManyArgs = {
    /**
     * Filter which author_transactions to delete
     * 
    **/
    where?: author_transactionWhereInput
  }


  /**
   * author_transaction: findUniqueOrThrow
   */
  export type author_transactionFindUniqueOrThrowArgs = author_transactionFindUniqueArgsBase
      

  /**
   * author_transaction: findFirstOrThrow
   */
  export type author_transactionFindFirstOrThrowArgs = author_transactionFindFirstArgsBase
      

  /**
   * author_transaction without action
   */
  export type author_transactionArgs = {
    /**
     * Select specific fields to fetch from the author_transaction
     * 
    **/
    select?: author_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: author_transactionInclude | null
  }



  /**
   * Model blog_comments
   */


  export type AggregateBlog_comments = {
    _count: Blog_commentsCountAggregateOutputType | null
    _avg: Blog_commentsAvgAggregateOutputType | null
    _sum: Blog_commentsSumAggregateOutputType | null
    _min: Blog_commentsMinAggregateOutputType | null
    _max: Blog_commentsMaxAggregateOutputType | null
  }

  export type Blog_commentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: number | null
  }

  export type Blog_commentsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: number | null
  }

  export type Blog_commentsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_name: string | null
    blog_name: string | null
    comments: string | null
    email_id: string | null
    status: number | null
    date_created: Date | null
  }

  export type Blog_commentsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_name: string | null
    blog_name: string | null
    comments: string | null
    email_id: string | null
    status: number | null
    date_created: Date | null
  }

  export type Blog_commentsCountAggregateOutputType = {
    id: number
    user_id: number
    user_name: number
    blog_name: number
    comments: number
    email_id: number
    status: number
    date_created: number
    _all: number
  }


  export type Blog_commentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
  }

  export type Blog_commentsSumAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
  }

  export type Blog_commentsMinAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    blog_name?: true
    comments?: true
    email_id?: true
    status?: true
    date_created?: true
  }

  export type Blog_commentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    blog_name?: true
    comments?: true
    email_id?: true
    status?: true
    date_created?: true
  }

  export type Blog_commentsCountAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    blog_name?: true
    comments?: true
    email_id?: true
    status?: true
    date_created?: true
    _all?: true
  }

  export type Blog_commentsAggregateArgs = {
    /**
     * Filter which blog_comments to aggregate.
     * 
    **/
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     * 
    **/
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_comments
    **/
    _count?: true | Blog_commentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Blog_commentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Blog_commentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_commentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_commentsMaxAggregateInputType
  }

  export type GetBlog_commentsAggregateType<T extends Blog_commentsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_comments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_comments[P]>
      : GetScalarType<T[P], AggregateBlog_comments[P]>
  }




  export type Blog_commentsGroupByArgs = {
    where?: blog_commentsWhereInput
    orderBy?: Enumerable<blog_commentsOrderByWithAggregationInput>
    by: Array<Blog_commentsScalarFieldEnum>
    having?: blog_commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_commentsCountAggregateInputType | true
    _avg?: Blog_commentsAvgAggregateInputType
    _sum?: Blog_commentsSumAggregateInputType
    _min?: Blog_commentsMinAggregateInputType
    _max?: Blog_commentsMaxAggregateInputType
  }


  export type Blog_commentsGroupByOutputType = {
    id: number
    user_id: number
    user_name: string
    blog_name: string
    comments: string
    email_id: string | null
    status: number
    date_created: Date
    _count: Blog_commentsCountAggregateOutputType | null
    _avg: Blog_commentsAvgAggregateOutputType | null
    _sum: Blog_commentsSumAggregateOutputType | null
    _min: Blog_commentsMinAggregateOutputType | null
    _max: Blog_commentsMaxAggregateOutputType | null
  }

  type GetBlog_commentsGroupByPayload<T extends Blog_commentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Blog_commentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_commentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_commentsGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_commentsGroupByOutputType[P]>
        }
      >
    >


  export type blog_commentsSelect = {
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    blog_name?: boolean
    comments?: boolean
    email_id?: boolean
    status?: boolean
    date_created?: boolean
  }


  export type blog_commentsGetPayload<S extends boolean | null | undefined | blog_commentsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? blog_comments :
    S extends undefined ? never :
    S extends { include: any } & (blog_commentsArgs | blog_commentsFindManyArgs)
    ? blog_comments 
    : S extends { select: any } & (blog_commentsArgs | blog_commentsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof blog_comments ? blog_comments[P] : never
  } 
      : blog_comments


  type blog_commentsCountArgs = Merge<
    Omit<blog_commentsFindManyArgs, 'select' | 'include'> & {
      select?: Blog_commentsCountAggregateInputType | true
    }
  >

  export interface blog_commentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Blog_comments that matches the filter.
     * @param {blog_commentsFindUniqueArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blog_commentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blog_commentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blog_comments'> extends True ? Prisma__blog_commentsClient<blog_commentsGetPayload<T>> : Prisma__blog_commentsClient<blog_commentsGetPayload<T> | null, null>

    /**
     * Find the first Blog_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindFirstArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blog_commentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blog_commentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blog_comments'> extends True ? Prisma__blog_commentsClient<blog_commentsGetPayload<T>> : Prisma__blog_commentsClient<blog_commentsGetPayload<T> | null, null>

    /**
     * Find zero or more Blog_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_comments
     * const blog_comments = await prisma.blog_comments.findMany()
     * 
     * // Get first 10 Blog_comments
     * const blog_comments = await prisma.blog_comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blog_commentsWithIdOnly = await prisma.blog_comments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blog_commentsFindManyArgs>(
      args?: SelectSubset<T, blog_commentsFindManyArgs>
    ): PrismaPromise<Array<blog_commentsGetPayload<T>>>

    /**
     * Create a Blog_comments.
     * @param {blog_commentsCreateArgs} args - Arguments to create a Blog_comments.
     * @example
     * // Create one Blog_comments
     * const Blog_comments = await prisma.blog_comments.create({
     *   data: {
     *     // ... data to create a Blog_comments
     *   }
     * })
     * 
    **/
    create<T extends blog_commentsCreateArgs>(
      args: SelectSubset<T, blog_commentsCreateArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Create many Blog_comments.
     *     @param {blog_commentsCreateManyArgs} args - Arguments to create many Blog_comments.
     *     @example
     *     // Create many Blog_comments
     *     const blog_comments = await prisma.blog_comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blog_commentsCreateManyArgs>(
      args?: SelectSubset<T, blog_commentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_comments.
     * @param {blog_commentsDeleteArgs} args - Arguments to delete one Blog_comments.
     * @example
     * // Delete one Blog_comments
     * const Blog_comments = await prisma.blog_comments.delete({
     *   where: {
     *     // ... filter to delete one Blog_comments
     *   }
     * })
     * 
    **/
    delete<T extends blog_commentsDeleteArgs>(
      args: SelectSubset<T, blog_commentsDeleteArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Update one Blog_comments.
     * @param {blog_commentsUpdateArgs} args - Arguments to update one Blog_comments.
     * @example
     * // Update one Blog_comments
     * const blog_comments = await prisma.blog_comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blog_commentsUpdateArgs>(
      args: SelectSubset<T, blog_commentsUpdateArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Delete zero or more Blog_comments.
     * @param {blog_commentsDeleteManyArgs} args - Arguments to filter Blog_comments to delete.
     * @example
     * // Delete a few Blog_comments
     * const { count } = await prisma.blog_comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blog_commentsDeleteManyArgs>(
      args?: SelectSubset<T, blog_commentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_comments
     * const blog_comments = await prisma.blog_comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blog_commentsUpdateManyArgs>(
      args: SelectSubset<T, blog_commentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_comments.
     * @param {blog_commentsUpsertArgs} args - Arguments to update or create a Blog_comments.
     * @example
     * // Update or create a Blog_comments
     * const blog_comments = await prisma.blog_comments.upsert({
     *   create: {
     *     // ... data to create a Blog_comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_comments we want to update
     *   }
     * })
    **/
    upsert<T extends blog_commentsUpsertArgs>(
      args: SelectSubset<T, blog_commentsUpsertArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Find one Blog_comments that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {blog_commentsFindUniqueOrThrowArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blog_commentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, blog_commentsFindUniqueOrThrowArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Find the first Blog_comments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindFirstOrThrowArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blog_commentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blog_commentsFindFirstOrThrowArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Count the number of Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsCountArgs} args - Arguments to filter Blog_comments to count.
     * @example
     * // Count the number of Blog_comments
     * const count = await prisma.blog_comments.count({
     *   where: {
     *     // ... the filter for the Blog_comments we want to count
     *   }
     * })
    **/
    count<T extends blog_commentsCountArgs>(
      args?: Subset<T, blog_commentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_commentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_commentsAggregateArgs>(args: Subset<T, Blog_commentsAggregateArgs>): PrismaPromise<GetBlog_commentsAggregateType<T>>

    /**
     * Group by Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Blog_commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Blog_commentsGroupByArgs['orderBy'] }
        : { orderBy?: Blog_commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Blog_commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_commentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blog_commentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * blog_comments base type for findUnique actions
   */
  export type blog_commentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     * 
    **/
    where: blog_commentsWhereUniqueInput
  }

  /**
   * blog_comments: findUnique
   */
  export interface blog_commentsFindUniqueArgs extends blog_commentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_comments base type for findFirst actions
   */
  export type blog_commentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     * 
    **/
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     * 
    **/
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_comments.
     * 
    **/
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_comments.
     * 
    **/
    distinct?: Enumerable<Blog_commentsScalarFieldEnum>
  }

  /**
   * blog_comments: findFirst
   */
  export interface blog_commentsFindFirstArgs extends blog_commentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_comments findMany
   */
  export type blog_commentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     * 
    **/
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     * 
    **/
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_comments.
     * 
    **/
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Blog_commentsScalarFieldEnum>
  }


  /**
   * blog_comments create
   */
  export type blog_commentsCreateArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * The data needed to create a blog_comments.
     * 
    **/
    data: XOR<blog_commentsCreateInput, blog_commentsUncheckedCreateInput>
  }


  /**
   * blog_comments createMany
   */
  export type blog_commentsCreateManyArgs = {
    /**
     * The data used to create many blog_comments.
     * 
    **/
    data: Enumerable<blog_commentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * blog_comments update
   */
  export type blog_commentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * The data needed to update a blog_comments.
     * 
    **/
    data: XOR<blog_commentsUpdateInput, blog_commentsUncheckedUpdateInput>
    /**
     * Choose, which blog_comments to update.
     * 
    **/
    where: blog_commentsWhereUniqueInput
  }


  /**
   * blog_comments updateMany
   */
  export type blog_commentsUpdateManyArgs = {
    /**
     * The data used to update blog_comments.
     * 
    **/
    data: XOR<blog_commentsUpdateManyMutationInput, blog_commentsUncheckedUpdateManyInput>
    /**
     * Filter which blog_comments to update
     * 
    **/
    where?: blog_commentsWhereInput
  }


  /**
   * blog_comments upsert
   */
  export type blog_commentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * The filter to search for the blog_comments to update in case it exists.
     * 
    **/
    where: blog_commentsWhereUniqueInput
    /**
     * In case the blog_comments found by the `where` argument doesn't exist, create a new blog_comments with this data.
     * 
    **/
    create: XOR<blog_commentsCreateInput, blog_commentsUncheckedCreateInput>
    /**
     * In case the blog_comments was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<blog_commentsUpdateInput, blog_commentsUncheckedUpdateInput>
  }


  /**
   * blog_comments delete
   */
  export type blog_commentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
    /**
     * Filter which blog_comments to delete.
     * 
    **/
    where: blog_commentsWhereUniqueInput
  }


  /**
   * blog_comments deleteMany
   */
  export type blog_commentsDeleteManyArgs = {
    /**
     * Filter which blog_comments to delete
     * 
    **/
    where?: blog_commentsWhereInput
  }


  /**
   * blog_comments: findUniqueOrThrow
   */
  export type blog_commentsFindUniqueOrThrowArgs = blog_commentsFindUniqueArgsBase
      

  /**
   * blog_comments: findFirstOrThrow
   */
  export type blog_commentsFindFirstOrThrowArgs = blog_commentsFindFirstArgsBase
      

  /**
   * blog_comments without action
   */
  export type blog_commentsArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     * 
    **/
    select?: blog_commentsSelect | null
  }



  /**
   * Model book_tbl
   */


  export type AggregateBook_tbl = {
    _count: Book_tblCountAggregateOutputType | null
    _avg: Book_tblAvgAggregateOutputType | null
    _sum: Book_tblSumAggregateOutputType | null
    _min: Book_tblMinAggregateOutputType | null
    _max: Book_tblMaxAggregateOutputType | null
  }

  export type Book_tblAvgAggregateOutputType = {
    book_id: number | null
    author_name: number | null
    language: number | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    type_of_book: number | null
    copyright_owner: number | null
    created_by: number | null
    book_cost_international: number | null
    narrator_id: number | null
    rental_cost_inr: number | null
    rental_cost_usd: number | null
    paper_back_flag: number | null
    paper_back_inr: number | null
    paper_back_readiness_flag: number | null
    book_id_mapping: number | null
    agreement_flag: number | null
    paper_back_pages: number | null
    paper_back_weight: number | null
    paper_back_copyright_owner: number | null
    mintbook_cost: number | null
  }

  export type Book_tblSumAggregateOutputType = {
    book_id: number | null
    author_name: number | null
    language: number | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    type_of_book: number | null
    copyright_owner: number | null
    created_by: number | null
    book_cost_international: number | null
    narrator_id: number | null
    rental_cost_inr: number | null
    rental_cost_usd: number | null
    paper_back_flag: number | null
    paper_back_inr: number | null
    paper_back_readiness_flag: number | null
    book_id_mapping: number | null
    agreement_flag: number | null
    paper_back_pages: number | null
    paper_back_weight: number | null
    paper_back_copyright_owner: number | null
    mintbook_cost: number | null
  }

  export type Book_tblMinAggregateOutputType = {
    book_id: number | null
    author_name: number | null
    book_title: string | null
    url_name: string | null
    regional_book_title: string | null
    language: number | null
    isbn_number: string | null
    cover_image: string | null
    description: string | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    book_category: string | null
    type_of_book: number | null
    publisher: string | null
    download_link: string | null
    epub_url: string | null
    royalty: string | null
    copyright_owner: number | null
    status: boolean | null
    created_at: Date | null
    activated_at: Date | null
    created_by: number | null
    book_cost_international: number | null
    narrator_id: number | null
    rental_cost_inr: number | null
    rental_cost_usd: number | null
    paper_back_flag: number | null
    paper_back_inr: number | null
    paper_back_royalty: string | null
    paper_back_readiness_flag: number | null
    book_id_mapping: number | null
    agreement_flag: number | null
    paper_back_pages: number | null
    paper_back_weight: number | null
    paper_back_copyright_owner: number | null
    paper_back_isbn: string | null
    paper_back_remarks: string | null
    mintbook_cost: number | null
  }

  export type Book_tblMaxAggregateOutputType = {
    book_id: number | null
    author_name: number | null
    book_title: string | null
    url_name: string | null
    regional_book_title: string | null
    language: number | null
    isbn_number: string | null
    cover_image: string | null
    description: string | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    book_category: string | null
    type_of_book: number | null
    publisher: string | null
    download_link: string | null
    epub_url: string | null
    royalty: string | null
    copyright_owner: number | null
    status: boolean | null
    created_at: Date | null
    activated_at: Date | null
    created_by: number | null
    book_cost_international: number | null
    narrator_id: number | null
    rental_cost_inr: number | null
    rental_cost_usd: number | null
    paper_back_flag: number | null
    paper_back_inr: number | null
    paper_back_royalty: string | null
    paper_back_readiness_flag: number | null
    book_id_mapping: number | null
    agreement_flag: number | null
    paper_back_pages: number | null
    paper_back_weight: number | null
    paper_back_copyright_owner: number | null
    paper_back_isbn: string | null
    paper_back_remarks: string | null
    mintbook_cost: number | null
  }

  export type Book_tblCountAggregateOutputType = {
    book_id: number
    author_name: number
    book_title: number
    url_name: number
    regional_book_title: number
    language: number
    isbn_number: number
    cover_image: number
    description: number
    cost: number
    number_of_page: number
    genre_id: number
    book_category: number
    type_of_book: number
    publisher: number
    download_link: number
    epub_url: number
    royalty: number
    copyright_owner: number
    status: number
    created_at: number
    activated_at: number
    created_by: number
    book_cost_international: number
    narrator_id: number
    rental_cost_inr: number
    rental_cost_usd: number
    paper_back_flag: number
    paper_back_inr: number
    paper_back_royalty: number
    paper_back_readiness_flag: number
    book_id_mapping: number
    agreement_flag: number
    paper_back_pages: number
    paper_back_weight: number
    paper_back_copyright_owner: number
    paper_back_isbn: number
    paper_back_remarks: number
    mintbook_cost: number
    _all: number
  }


  export type Book_tblAvgAggregateInputType = {
    book_id?: true
    author_name?: true
    language?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    type_of_book?: true
    copyright_owner?: true
    created_by?: true
    book_cost_international?: true
    narrator_id?: true
    rental_cost_inr?: true
    rental_cost_usd?: true
    paper_back_flag?: true
    paper_back_inr?: true
    paper_back_readiness_flag?: true
    book_id_mapping?: true
    agreement_flag?: true
    paper_back_pages?: true
    paper_back_weight?: true
    paper_back_copyright_owner?: true
    mintbook_cost?: true
  }

  export type Book_tblSumAggregateInputType = {
    book_id?: true
    author_name?: true
    language?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    type_of_book?: true
    copyright_owner?: true
    created_by?: true
    book_cost_international?: true
    narrator_id?: true
    rental_cost_inr?: true
    rental_cost_usd?: true
    paper_back_flag?: true
    paper_back_inr?: true
    paper_back_readiness_flag?: true
    book_id_mapping?: true
    agreement_flag?: true
    paper_back_pages?: true
    paper_back_weight?: true
    paper_back_copyright_owner?: true
    mintbook_cost?: true
  }

  export type Book_tblMinAggregateInputType = {
    book_id?: true
    author_name?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language?: true
    isbn_number?: true
    cover_image?: true
    description?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    book_category?: true
    type_of_book?: true
    publisher?: true
    download_link?: true
    epub_url?: true
    royalty?: true
    copyright_owner?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    book_cost_international?: true
    narrator_id?: true
    rental_cost_inr?: true
    rental_cost_usd?: true
    paper_back_flag?: true
    paper_back_inr?: true
    paper_back_royalty?: true
    paper_back_readiness_flag?: true
    book_id_mapping?: true
    agreement_flag?: true
    paper_back_pages?: true
    paper_back_weight?: true
    paper_back_copyright_owner?: true
    paper_back_isbn?: true
    paper_back_remarks?: true
    mintbook_cost?: true
  }

  export type Book_tblMaxAggregateInputType = {
    book_id?: true
    author_name?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language?: true
    isbn_number?: true
    cover_image?: true
    description?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    book_category?: true
    type_of_book?: true
    publisher?: true
    download_link?: true
    epub_url?: true
    royalty?: true
    copyright_owner?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    book_cost_international?: true
    narrator_id?: true
    rental_cost_inr?: true
    rental_cost_usd?: true
    paper_back_flag?: true
    paper_back_inr?: true
    paper_back_royalty?: true
    paper_back_readiness_flag?: true
    book_id_mapping?: true
    agreement_flag?: true
    paper_back_pages?: true
    paper_back_weight?: true
    paper_back_copyright_owner?: true
    paper_back_isbn?: true
    paper_back_remarks?: true
    mintbook_cost?: true
  }

  export type Book_tblCountAggregateInputType = {
    book_id?: true
    author_name?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language?: true
    isbn_number?: true
    cover_image?: true
    description?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    book_category?: true
    type_of_book?: true
    publisher?: true
    download_link?: true
    epub_url?: true
    royalty?: true
    copyright_owner?: true
    status?: true
    created_at?: true
    activated_at?: true
    created_by?: true
    book_cost_international?: true
    narrator_id?: true
    rental_cost_inr?: true
    rental_cost_usd?: true
    paper_back_flag?: true
    paper_back_inr?: true
    paper_back_royalty?: true
    paper_back_readiness_flag?: true
    book_id_mapping?: true
    agreement_flag?: true
    paper_back_pages?: true
    paper_back_weight?: true
    paper_back_copyright_owner?: true
    paper_back_isbn?: true
    paper_back_remarks?: true
    mintbook_cost?: true
    _all?: true
  }

  export type Book_tblAggregateArgs = {
    /**
     * Filter which book_tbl to aggregate.
     * 
    **/
    where?: book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_tbls
    **/
    _count?: true | Book_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Book_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Book_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_tblMaxAggregateInputType
  }

  export type GetBook_tblAggregateType<T extends Book_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_tbl[P]>
      : GetScalarType<T[P], AggregateBook_tbl[P]>
  }




  export type Book_tblGroupByArgs = {
    where?: book_tblWhereInput
    orderBy?: Enumerable<book_tblOrderByWithAggregationInput>
    by: Array<Book_tblScalarFieldEnum>
    having?: book_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_tblCountAggregateInputType | true
    _avg?: Book_tblAvgAggregateInputType
    _sum?: Book_tblSumAggregateInputType
    _min?: Book_tblMinAggregateInputType
    _max?: Book_tblMaxAggregateInputType
  }


  export type Book_tblGroupByOutputType = {
    book_id: number
    author_name: number
    book_title: string
    url_name: string | null
    regional_book_title: string
    language: number
    isbn_number: string | null
    cover_image: string | null
    description: string | null
    cost: number
    number_of_page: number | null
    genre_id: number
    book_category: string
    type_of_book: number
    publisher: string | null
    download_link: string
    epub_url: string
    royalty: string | null
    copyright_owner: number | null
    status: boolean
    created_at: Date
    activated_at: Date | null
    created_by: number
    book_cost_international: number
    narrator_id: number | null
    rental_cost_inr: number | null
    rental_cost_usd: number | null
    paper_back_flag: number | null
    paper_back_inr: number | null
    paper_back_royalty: string | null
    paper_back_readiness_flag: number | null
    book_id_mapping: number | null
    agreement_flag: number | null
    paper_back_pages: number | null
    paper_back_weight: number | null
    paper_back_copyright_owner: number | null
    paper_back_isbn: string | null
    paper_back_remarks: string | null
    mintbook_cost: number | null
    _count: Book_tblCountAggregateOutputType | null
    _avg: Book_tblAvgAggregateOutputType | null
    _sum: Book_tblSumAggregateOutputType | null
    _min: Book_tblMinAggregateOutputType | null
    _max: Book_tblMaxAggregateOutputType | null
  }

  type GetBook_tblGroupByPayload<T extends Book_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Book_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Book_tblGroupByOutputType[P]>
        }
      >
    >


  export type book_tblSelect = {
    book_id?: boolean
    author_name?: boolean
    book_title?: boolean
    url_name?: boolean
    regional_book_title?: boolean
    language_tbl_relation?: boolean | language_tblArgs
    language?: boolean
    isbn_number?: boolean
    cover_image?: boolean
    description?: boolean
    cost?: boolean
    number_of_page?: boolean
    genre?: boolean | genre_details_tblArgs
    genre_id?: boolean
    book_category?: boolean
    type_of_book?: boolean
    publisher?: boolean
    download_link?: boolean
    epub_url?: boolean
    royalty?: boolean
    copyright_owner?: boolean
    status?: boolean
    created_at?: boolean
    activated_at?: boolean
    created_by?: boolean
    book_cost_international?: boolean
    narrator_id?: boolean
    rental_cost_inr?: boolean
    rental_cost_usd?: boolean
    paper_back_flag?: boolean
    paper_back_inr?: boolean
    paper_back_royalty?: boolean
    paper_back_readiness_flag?: boolean
    book_id_mapping?: boolean
    agreement_flag?: boolean
    paper_back_pages?: boolean
    paper_back_weight?: boolean
    paper_back_copyright_owner?: boolean
    paper_back_isbn?: boolean
    paper_back_remarks?: boolean
    mintbook_cost?: boolean
    amazonBookId?: boolean | amazon_booksArgs
    scribdBookId?: boolean | scribd_booksArgs
    googleBookId?: boolean | google_booksArgs
    storytelBookId?: boolean | storytel_booksArgs
    overdriveBookId?: boolean | overdrive_booksArgs
    audibleBookId?: boolean | audible_booksArgs
    giftBooks?: boolean | author_gift_booksFindManyArgs
    amazon_transactions?: boolean | amazon_transactionsArgs
    audible_transactions?: boolean | audible_transactionsArgs
    author_transaction?: boolean | author_transactionArgs
    google_transactions?: boolean | google_transactionsArgs
    kobo_transaction?: boolean | kobo_transactionArgs
    overdrive_transactions?: boolean | overdrive_transactionsArgs
    scribd_transaction?: boolean | scribd_transactionArgs
    storytel_transactions?: boolean | storytel_transactionsArgs
    _count?: boolean | Book_tblCountOutputTypeArgs
  }


  export type book_tblInclude = {
    language_tbl_relation?: boolean | language_tblArgs
    genre?: boolean | genre_details_tblArgs
    amazonBookId?: boolean | amazon_booksArgs
    scribdBookId?: boolean | scribd_booksArgs
    googleBookId?: boolean | google_booksArgs
    storytelBookId?: boolean | storytel_booksArgs
    overdriveBookId?: boolean | overdrive_booksArgs
    audibleBookId?: boolean | audible_booksArgs
    giftBooks?: boolean | author_gift_booksFindManyArgs
    amazon_transactions?: boolean | amazon_transactionsArgs
    audible_transactions?: boolean | audible_transactionsArgs
    author_transaction?: boolean | author_transactionArgs
    google_transactions?: boolean | google_transactionsArgs
    kobo_transaction?: boolean | kobo_transactionArgs
    overdrive_transactions?: boolean | overdrive_transactionsArgs
    scribd_transaction?: boolean | scribd_transactionArgs
    storytel_transactions?: boolean | storytel_transactionsArgs
    _count?: boolean | Book_tblCountOutputTypeArgs
  } 

  export type book_tblGetPayload<S extends boolean | null | undefined | book_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? book_tbl :
    S extends undefined ? never :
    S extends { include: any } & (book_tblArgs | book_tblFindManyArgs)
    ? book_tbl  & {
    [P in TrueKeys<S['include']>]:
        P extends 'language_tbl_relation' ? language_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'genre' ? genre_details_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'amazonBookId' ? amazon_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'scribdBookId' ? scribd_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'googleBookId' ? google_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'storytelBookId' ? storytel_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'overdriveBookId' ? overdrive_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'audibleBookId' ? audible_booksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'giftBooks' ? Array < author_gift_booksGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'amazon_transactions' ? amazon_transactionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'audible_transactions' ? audible_transactionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'author_transaction' ? author_transactionGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'google_transactions' ? google_transactionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'kobo_transaction' ? kobo_transactionGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'overdrive_transactions' ? overdrive_transactionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'scribd_transaction' ? scribd_transactionGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'storytel_transactions' ? storytel_transactionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? Book_tblCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (book_tblArgs | book_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'language_tbl_relation' ? language_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'genre' ? genre_details_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'amazonBookId' ? amazon_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'scribdBookId' ? scribd_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'googleBookId' ? google_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'storytelBookId' ? storytel_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'overdriveBookId' ? overdrive_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'audibleBookId' ? audible_booksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'giftBooks' ? Array < author_gift_booksGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'amazon_transactions' ? amazon_transactionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'audible_transactions' ? audible_transactionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'author_transaction' ? author_transactionGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'google_transactions' ? google_transactionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'kobo_transaction' ? kobo_transactionGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'overdrive_transactions' ? overdrive_transactionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'scribd_transaction' ? scribd_transactionGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'storytel_transactions' ? storytel_transactionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? Book_tblCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof book_tbl ? book_tbl[P] : never
  } 
      : book_tbl


  type book_tblCountArgs = Merge<
    Omit<book_tblFindManyArgs, 'select' | 'include'> & {
      select?: Book_tblCountAggregateInputType | true
    }
  >

  export interface book_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Book_tbl that matches the filter.
     * @param {book_tblFindUniqueArgs} args - Arguments to find a Book_tbl
     * @example
     * // Get one Book_tbl
     * const book_tbl = await prisma.book_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends book_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, book_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'book_tbl'> extends True ? Prisma__book_tblClient<book_tblGetPayload<T>> : Prisma__book_tblClient<book_tblGetPayload<T> | null, null>

    /**
     * Find the first Book_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tblFindFirstArgs} args - Arguments to find a Book_tbl
     * @example
     * // Get one Book_tbl
     * const book_tbl = await prisma.book_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends book_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, book_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'book_tbl'> extends True ? Prisma__book_tblClient<book_tblGetPayload<T>> : Prisma__book_tblClient<book_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Book_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_tbls
     * const book_tbls = await prisma.book_tbl.findMany()
     * 
     * // Get first 10 Book_tbls
     * const book_tbls = await prisma.book_tbl.findMany({ take: 10 })
     * 
     * // Only select the `book_id`
     * const book_tblWithBook_idOnly = await prisma.book_tbl.findMany({ select: { book_id: true } })
     * 
    **/
    findMany<T extends book_tblFindManyArgs>(
      args?: SelectSubset<T, book_tblFindManyArgs>
    ): PrismaPromise<Array<book_tblGetPayload<T>>>

    /**
     * Create a Book_tbl.
     * @param {book_tblCreateArgs} args - Arguments to create a Book_tbl.
     * @example
     * // Create one Book_tbl
     * const Book_tbl = await prisma.book_tbl.create({
     *   data: {
     *     // ... data to create a Book_tbl
     *   }
     * })
     * 
    **/
    create<T extends book_tblCreateArgs>(
      args: SelectSubset<T, book_tblCreateArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Create many Book_tbls.
     *     @param {book_tblCreateManyArgs} args - Arguments to create many Book_tbls.
     *     @example
     *     // Create many Book_tbls
     *     const book_tbl = await prisma.book_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends book_tblCreateManyArgs>(
      args?: SelectSubset<T, book_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Book_tbl.
     * @param {book_tblDeleteArgs} args - Arguments to delete one Book_tbl.
     * @example
     * // Delete one Book_tbl
     * const Book_tbl = await prisma.book_tbl.delete({
     *   where: {
     *     // ... filter to delete one Book_tbl
     *   }
     * })
     * 
    **/
    delete<T extends book_tblDeleteArgs>(
      args: SelectSubset<T, book_tblDeleteArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Update one Book_tbl.
     * @param {book_tblUpdateArgs} args - Arguments to update one Book_tbl.
     * @example
     * // Update one Book_tbl
     * const book_tbl = await prisma.book_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends book_tblUpdateArgs>(
      args: SelectSubset<T, book_tblUpdateArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Delete zero or more Book_tbls.
     * @param {book_tblDeleteManyArgs} args - Arguments to filter Book_tbls to delete.
     * @example
     * // Delete a few Book_tbls
     * const { count } = await prisma.book_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends book_tblDeleteManyArgs>(
      args?: SelectSubset<T, book_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_tbls
     * const book_tbl = await prisma.book_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends book_tblUpdateManyArgs>(
      args: SelectSubset<T, book_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_tbl.
     * @param {book_tblUpsertArgs} args - Arguments to update or create a Book_tbl.
     * @example
     * // Update or create a Book_tbl
     * const book_tbl = await prisma.book_tbl.upsert({
     *   create: {
     *     // ... data to create a Book_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends book_tblUpsertArgs>(
      args: SelectSubset<T, book_tblUpsertArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Find one Book_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {book_tblFindUniqueOrThrowArgs} args - Arguments to find a Book_tbl
     * @example
     * // Get one Book_tbl
     * const book_tbl = await prisma.book_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends book_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, book_tblFindUniqueOrThrowArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Find the first Book_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tblFindFirstOrThrowArgs} args - Arguments to find a Book_tbl
     * @example
     * // Get one Book_tbl
     * const book_tbl = await prisma.book_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends book_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, book_tblFindFirstOrThrowArgs>
    ): Prisma__book_tblClient<book_tblGetPayload<T>>

    /**
     * Count the number of Book_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tblCountArgs} args - Arguments to filter Book_tbls to count.
     * @example
     * // Count the number of Book_tbls
     * const count = await prisma.book_tbl.count({
     *   where: {
     *     // ... the filter for the Book_tbls we want to count
     *   }
     * })
    **/
    count<T extends book_tblCountArgs>(
      args?: Subset<T, book_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_tblAggregateArgs>(args: Subset<T, Book_tblAggregateArgs>): PrismaPromise<GetBook_tblAggregateType<T>>

    /**
     * Group by Book_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Book_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Book_tblGroupByArgs['orderBy'] }
        : { orderBy?: Book_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Book_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for book_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__book_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    language_tbl_relation<T extends language_tblArgs= {}>(args?: Subset<T, language_tblArgs>): Prisma__language_tblClient<language_tblGetPayload<T> | Null>;

    genre<T extends genre_details_tblArgs= {}>(args?: Subset<T, genre_details_tblArgs>): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T> | Null>;

    amazonBookId<T extends amazon_booksArgs= {}>(args?: Subset<T, amazon_booksArgs>): Prisma__amazon_booksClient<amazon_booksGetPayload<T> | Null>;

    scribdBookId<T extends scribd_booksArgs= {}>(args?: Subset<T, scribd_booksArgs>): Prisma__scribd_booksClient<scribd_booksGetPayload<T> | Null>;

    googleBookId<T extends google_booksArgs= {}>(args?: Subset<T, google_booksArgs>): Prisma__google_booksClient<google_booksGetPayload<T> | Null>;

    storytelBookId<T extends storytel_booksArgs= {}>(args?: Subset<T, storytel_booksArgs>): Prisma__storytel_booksClient<storytel_booksGetPayload<T> | Null>;

    overdriveBookId<T extends overdrive_booksArgs= {}>(args?: Subset<T, overdrive_booksArgs>): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T> | Null>;

    audibleBookId<T extends audible_booksArgs= {}>(args?: Subset<T, audible_booksArgs>): Prisma__audible_booksClient<audible_booksGetPayload<T> | Null>;

    giftBooks<T extends author_gift_booksFindManyArgs= {}>(args?: Subset<T, author_gift_booksFindManyArgs>): PrismaPromise<Array<author_gift_booksGetPayload<T>>| Null>;

    amazon_transactions<T extends amazon_transactionsArgs= {}>(args?: Subset<T, amazon_transactionsArgs>): Prisma__amazon_transactionsClient<amazon_transactionsGetPayload<T> | Null>;

    audible_transactions<T extends audible_transactionsArgs= {}>(args?: Subset<T, audible_transactionsArgs>): Prisma__audible_transactionsClient<audible_transactionsGetPayload<T> | Null>;

    author_transaction<T extends author_transactionArgs= {}>(args?: Subset<T, author_transactionArgs>): Prisma__author_transactionClient<author_transactionGetPayload<T> | Null>;

    google_transactions<T extends google_transactionsArgs= {}>(args?: Subset<T, google_transactionsArgs>): Prisma__google_transactionsClient<google_transactionsGetPayload<T> | Null>;

    kobo_transaction<T extends kobo_transactionArgs= {}>(args?: Subset<T, kobo_transactionArgs>): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T> | Null>;

    overdrive_transactions<T extends overdrive_transactionsArgs= {}>(args?: Subset<T, overdrive_transactionsArgs>): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T> | Null>;

    scribd_transaction<T extends scribd_transactionArgs= {}>(args?: Subset<T, scribd_transactionArgs>): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T> | Null>;

    storytel_transactions<T extends storytel_transactionsArgs= {}>(args?: Subset<T, storytel_transactionsArgs>): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * book_tbl base type for findUnique actions
   */
  export type book_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * Filter, which book_tbl to fetch.
     * 
    **/
    where: book_tblWhereUniqueInput
  }

  /**
   * book_tbl: findUnique
   */
  export interface book_tblFindUniqueArgs extends book_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * book_tbl base type for findFirst actions
   */
  export type book_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * Filter, which book_tbl to fetch.
     * 
    **/
    where?: book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_tbls.
     * 
    **/
    cursor?: book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_tbls.
     * 
    **/
    distinct?: Enumerable<Book_tblScalarFieldEnum>
  }

  /**
   * book_tbl: findFirst
   */
  export interface book_tblFindFirstArgs extends book_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * book_tbl findMany
   */
  export type book_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * Filter, which book_tbls to fetch.
     * 
    **/
    where?: book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_tbls.
     * 
    **/
    cursor?: book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Book_tblScalarFieldEnum>
  }


  /**
   * book_tbl create
   */
  export type book_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * The data needed to create a book_tbl.
     * 
    **/
    data: XOR<book_tblCreateInput, book_tblUncheckedCreateInput>
  }


  /**
   * book_tbl createMany
   */
  export type book_tblCreateManyArgs = {
    /**
     * The data used to create many book_tbls.
     * 
    **/
    data: Enumerable<book_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * book_tbl update
   */
  export type book_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * The data needed to update a book_tbl.
     * 
    **/
    data: XOR<book_tblUpdateInput, book_tblUncheckedUpdateInput>
    /**
     * Choose, which book_tbl to update.
     * 
    **/
    where: book_tblWhereUniqueInput
  }


  /**
   * book_tbl updateMany
   */
  export type book_tblUpdateManyArgs = {
    /**
     * The data used to update book_tbls.
     * 
    **/
    data: XOR<book_tblUpdateManyMutationInput, book_tblUncheckedUpdateManyInput>
    /**
     * Filter which book_tbls to update
     * 
    **/
    where?: book_tblWhereInput
  }


  /**
   * book_tbl upsert
   */
  export type book_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * The filter to search for the book_tbl to update in case it exists.
     * 
    **/
    where: book_tblWhereUniqueInput
    /**
     * In case the book_tbl found by the `where` argument doesn't exist, create a new book_tbl with this data.
     * 
    **/
    create: XOR<book_tblCreateInput, book_tblUncheckedCreateInput>
    /**
     * In case the book_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<book_tblUpdateInput, book_tblUncheckedUpdateInput>
  }


  /**
   * book_tbl delete
   */
  export type book_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
    /**
     * Filter which book_tbl to delete.
     * 
    **/
    where: book_tblWhereUniqueInput
  }


  /**
   * book_tbl deleteMany
   */
  export type book_tblDeleteManyArgs = {
    /**
     * Filter which book_tbls to delete
     * 
    **/
    where?: book_tblWhereInput
  }


  /**
   * book_tbl: findUniqueOrThrow
   */
  export type book_tblFindUniqueOrThrowArgs = book_tblFindUniqueArgsBase
      

  /**
   * book_tbl: findFirstOrThrow
   */
  export type book_tblFindFirstOrThrowArgs = book_tblFindFirstArgsBase
      

  /**
   * book_tbl without action
   */
  export type book_tblArgs = {
    /**
     * Select specific fields to fetch from the book_tbl
     * 
    **/
    select?: book_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: book_tblInclude | null
  }



  /**
   * Model book_types
   */


  export type AggregateBook_types = {
    _count: Book_typesCountAggregateOutputType | null
    _avg: Book_typesAvgAggregateOutputType | null
    _sum: Book_typesSumAggregateOutputType | null
    _min: Book_typesMinAggregateOutputType | null
    _max: Book_typesMaxAggregateOutputType | null
  }

  export type Book_typesAvgAggregateOutputType = {
    book_type_id: number | null
    status: number | null
  }

  export type Book_typesSumAggregateOutputType = {
    book_type_id: number | null
    status: number | null
  }

  export type Book_typesMinAggregateOutputType = {
    book_type_id: number | null
    type_name: string | null
    url_name: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type Book_typesMaxAggregateOutputType = {
    book_type_id: number | null
    type_name: string | null
    url_name: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type Book_typesCountAggregateOutputType = {
    book_type_id: number
    type_name: number
    url_name: number
    status: number
    created_at: number
    updated_at: number
    image_url: number
    _all: number
  }


  export type Book_typesAvgAggregateInputType = {
    book_type_id?: true
    status?: true
  }

  export type Book_typesSumAggregateInputType = {
    book_type_id?: true
    status?: true
  }

  export type Book_typesMinAggregateInputType = {
    book_type_id?: true
    type_name?: true
    url_name?: true
    status?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type Book_typesMaxAggregateInputType = {
    book_type_id?: true
    type_name?: true
    url_name?: true
    status?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type Book_typesCountAggregateInputType = {
    book_type_id?: true
    type_name?: true
    url_name?: true
    status?: true
    created_at?: true
    updated_at?: true
    image_url?: true
    _all?: true
  }

  export type Book_typesAggregateArgs = {
    /**
     * Filter which book_types to aggregate.
     * 
    **/
    where?: book_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_types to fetch.
     * 
    **/
    orderBy?: Enumerable<book_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: book_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_types
    **/
    _count?: true | Book_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Book_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Book_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_typesMaxAggregateInputType
  }

  export type GetBook_typesAggregateType<T extends Book_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_types[P]>
      : GetScalarType<T[P], AggregateBook_types[P]>
  }




  export type Book_typesGroupByArgs = {
    where?: book_typesWhereInput
    orderBy?: Enumerable<book_typesOrderByWithAggregationInput>
    by: Array<Book_typesScalarFieldEnum>
    having?: book_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_typesCountAggregateInputType | true
    _avg?: Book_typesAvgAggregateInputType
    _sum?: Book_typesSumAggregateInputType
    _min?: Book_typesMinAggregateInputType
    _max?: Book_typesMaxAggregateInputType
  }


  export type Book_typesGroupByOutputType = {
    book_type_id: number
    type_name: string
    url_name: string
    status: number
    created_at: Date
    updated_at: Date
    image_url: string | null
    _count: Book_typesCountAggregateOutputType | null
    _avg: Book_typesAvgAggregateOutputType | null
    _sum: Book_typesSumAggregateOutputType | null
    _min: Book_typesMinAggregateOutputType | null
    _max: Book_typesMaxAggregateOutputType | null
  }

  type GetBook_typesGroupByPayload<T extends Book_typesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Book_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Book_typesGroupByOutputType[P]>
        }
      >
    >


  export type book_typesSelect = {
    book_type_id?: boolean
    type_name?: boolean
    url_name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
  }


  export type book_typesGetPayload<S extends boolean | null | undefined | book_typesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? book_types :
    S extends undefined ? never :
    S extends { include: any } & (book_typesArgs | book_typesFindManyArgs)
    ? book_types 
    : S extends { select: any } & (book_typesArgs | book_typesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof book_types ? book_types[P] : never
  } 
      : book_types


  type book_typesCountArgs = Merge<
    Omit<book_typesFindManyArgs, 'select' | 'include'> & {
      select?: Book_typesCountAggregateInputType | true
    }
  >

  export interface book_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Book_types that matches the filter.
     * @param {book_typesFindUniqueArgs} args - Arguments to find a Book_types
     * @example
     * // Get one Book_types
     * const book_types = await prisma.book_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends book_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, book_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'book_types'> extends True ? Prisma__book_typesClient<book_typesGetPayload<T>> : Prisma__book_typesClient<book_typesGetPayload<T> | null, null>

    /**
     * Find the first Book_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_typesFindFirstArgs} args - Arguments to find a Book_types
     * @example
     * // Get one Book_types
     * const book_types = await prisma.book_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends book_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, book_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'book_types'> extends True ? Prisma__book_typesClient<book_typesGetPayload<T>> : Prisma__book_typesClient<book_typesGetPayload<T> | null, null>

    /**
     * Find zero or more Book_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_types
     * const book_types = await prisma.book_types.findMany()
     * 
     * // Get first 10 Book_types
     * const book_types = await prisma.book_types.findMany({ take: 10 })
     * 
     * // Only select the `book_type_id`
     * const book_typesWithBook_type_idOnly = await prisma.book_types.findMany({ select: { book_type_id: true } })
     * 
    **/
    findMany<T extends book_typesFindManyArgs>(
      args?: SelectSubset<T, book_typesFindManyArgs>
    ): PrismaPromise<Array<book_typesGetPayload<T>>>

    /**
     * Create a Book_types.
     * @param {book_typesCreateArgs} args - Arguments to create a Book_types.
     * @example
     * // Create one Book_types
     * const Book_types = await prisma.book_types.create({
     *   data: {
     *     // ... data to create a Book_types
     *   }
     * })
     * 
    **/
    create<T extends book_typesCreateArgs>(
      args: SelectSubset<T, book_typesCreateArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Create many Book_types.
     *     @param {book_typesCreateManyArgs} args - Arguments to create many Book_types.
     *     @example
     *     // Create many Book_types
     *     const book_types = await prisma.book_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends book_typesCreateManyArgs>(
      args?: SelectSubset<T, book_typesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Book_types.
     * @param {book_typesDeleteArgs} args - Arguments to delete one Book_types.
     * @example
     * // Delete one Book_types
     * const Book_types = await prisma.book_types.delete({
     *   where: {
     *     // ... filter to delete one Book_types
     *   }
     * })
     * 
    **/
    delete<T extends book_typesDeleteArgs>(
      args: SelectSubset<T, book_typesDeleteArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Update one Book_types.
     * @param {book_typesUpdateArgs} args - Arguments to update one Book_types.
     * @example
     * // Update one Book_types
     * const book_types = await prisma.book_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends book_typesUpdateArgs>(
      args: SelectSubset<T, book_typesUpdateArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Delete zero or more Book_types.
     * @param {book_typesDeleteManyArgs} args - Arguments to filter Book_types to delete.
     * @example
     * // Delete a few Book_types
     * const { count } = await prisma.book_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends book_typesDeleteManyArgs>(
      args?: SelectSubset<T, book_typesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_types
     * const book_types = await prisma.book_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends book_typesUpdateManyArgs>(
      args: SelectSubset<T, book_typesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_types.
     * @param {book_typesUpsertArgs} args - Arguments to update or create a Book_types.
     * @example
     * // Update or create a Book_types
     * const book_types = await prisma.book_types.upsert({
     *   create: {
     *     // ... data to create a Book_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_types we want to update
     *   }
     * })
    **/
    upsert<T extends book_typesUpsertArgs>(
      args: SelectSubset<T, book_typesUpsertArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Find one Book_types that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {book_typesFindUniqueOrThrowArgs} args - Arguments to find a Book_types
     * @example
     * // Get one Book_types
     * const book_types = await prisma.book_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends book_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, book_typesFindUniqueOrThrowArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Find the first Book_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_typesFindFirstOrThrowArgs} args - Arguments to find a Book_types
     * @example
     * // Get one Book_types
     * const book_types = await prisma.book_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends book_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, book_typesFindFirstOrThrowArgs>
    ): Prisma__book_typesClient<book_typesGetPayload<T>>

    /**
     * Count the number of Book_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_typesCountArgs} args - Arguments to filter Book_types to count.
     * @example
     * // Count the number of Book_types
     * const count = await prisma.book_types.count({
     *   where: {
     *     // ... the filter for the Book_types we want to count
     *   }
     * })
    **/
    count<T extends book_typesCountArgs>(
      args?: Subset<T, book_typesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_typesAggregateArgs>(args: Subset<T, Book_typesAggregateArgs>): PrismaPromise<GetBook_typesAggregateType<T>>

    /**
     * Group by Book_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Book_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Book_typesGroupByArgs['orderBy'] }
        : { orderBy?: Book_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Book_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_typesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for book_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__book_typesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * book_types base type for findUnique actions
   */
  export type book_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * Filter, which book_types to fetch.
     * 
    **/
    where: book_typesWhereUniqueInput
  }

  /**
   * book_types: findUnique
   */
  export interface book_typesFindUniqueArgs extends book_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * book_types base type for findFirst actions
   */
  export type book_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * Filter, which book_types to fetch.
     * 
    **/
    where?: book_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_types to fetch.
     * 
    **/
    orderBy?: Enumerable<book_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_types.
     * 
    **/
    cursor?: book_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_types.
     * 
    **/
    distinct?: Enumerable<Book_typesScalarFieldEnum>
  }

  /**
   * book_types: findFirst
   */
  export interface book_typesFindFirstArgs extends book_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * book_types findMany
   */
  export type book_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * Filter, which book_types to fetch.
     * 
    **/
    where?: book_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_types to fetch.
     * 
    **/
    orderBy?: Enumerable<book_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_types.
     * 
    **/
    cursor?: book_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_types.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Book_typesScalarFieldEnum>
  }


  /**
   * book_types create
   */
  export type book_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * The data needed to create a book_types.
     * 
    **/
    data: XOR<book_typesCreateInput, book_typesUncheckedCreateInput>
  }


  /**
   * book_types createMany
   */
  export type book_typesCreateManyArgs = {
    /**
     * The data used to create many book_types.
     * 
    **/
    data: Enumerable<book_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * book_types update
   */
  export type book_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * The data needed to update a book_types.
     * 
    **/
    data: XOR<book_typesUpdateInput, book_typesUncheckedUpdateInput>
    /**
     * Choose, which book_types to update.
     * 
    **/
    where: book_typesWhereUniqueInput
  }


  /**
   * book_types updateMany
   */
  export type book_typesUpdateManyArgs = {
    /**
     * The data used to update book_types.
     * 
    **/
    data: XOR<book_typesUpdateManyMutationInput, book_typesUncheckedUpdateManyInput>
    /**
     * Filter which book_types to update
     * 
    **/
    where?: book_typesWhereInput
  }


  /**
   * book_types upsert
   */
  export type book_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * The filter to search for the book_types to update in case it exists.
     * 
    **/
    where: book_typesWhereUniqueInput
    /**
     * In case the book_types found by the `where` argument doesn't exist, create a new book_types with this data.
     * 
    **/
    create: XOR<book_typesCreateInput, book_typesUncheckedCreateInput>
    /**
     * In case the book_types was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<book_typesUpdateInput, book_typesUncheckedUpdateInput>
  }


  /**
   * book_types delete
   */
  export type book_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
    /**
     * Filter which book_types to delete.
     * 
    **/
    where: book_typesWhereUniqueInput
  }


  /**
   * book_types deleteMany
   */
  export type book_typesDeleteManyArgs = {
    /**
     * Filter which book_types to delete
     * 
    **/
    where?: book_typesWhereInput
  }


  /**
   * book_types: findUniqueOrThrow
   */
  export type book_typesFindUniqueOrThrowArgs = book_typesFindUniqueArgsBase
      

  /**
   * book_types: findFirstOrThrow
   */
  export type book_typesFindFirstOrThrowArgs = book_typesFindFirstArgsBase
      

  /**
   * book_types without action
   */
  export type book_typesArgs = {
    /**
     * Select specific fields to fetch from the book_types
     * 
    **/
    select?: book_typesSelect | null
  }



  /**
   * Model books_metadata
   */


  export type AggregateBooks_metadata = {
    _count: Books_metadataCountAggregateOutputType | null
    _avg: Books_metadataAvgAggregateOutputType | null
    _sum: Books_metadataSumAggregateOutputType | null
    _min: Books_metadataMinAggregateOutputType | null
    _max: Books_metadataMaxAggregateOutputType | null
  }

  export type Books_metadataAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    type_of_book: number | null
    final_page_number: number | null
    settled_page_number: number | null
    payment_status: number | null
    assigned_by: number | null
    assigned_to: number | null
    price_per_page: number | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    general_cover_status: number | null
    general_epub_status: number | null
    pustaka_epub_status: number | null
    amazon_epub_status: number | null
    pustaka_flippdf_status: number | null
    pustaka_word_status: number | null
    current_state: number | null
  }

  export type Books_metadataSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    type_of_book: number | null
    final_page_number: number | null
    settled_page_number: number | null
    payment_status: number | null
    assigned_by: number | null
    assigned_to: number | null
    price_per_page: number | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    general_cover_status: number | null
    general_epub_status: number | null
    pustaka_epub_status: number | null
    amazon_epub_status: number | null
    pustaka_flippdf_status: number | null
    pustaka_word_status: number | null
    current_state: number | null
  }

  export type Books_metadataMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    description: boolean | null
    type_of_book: number | null
    content_type: string | null
    hard_copy_type: string | null
    soft_copy_type: string | null
    final_page_number: number | null
    allocated_date: Date | null
    start_date: Date | null
    completion_date: Date | null
    payment_date: Date | null
    settled_page_number: number | null
    payment_status: number | null
    assigned_by: number | null
    assigned_to: number | null
    price_per_page: number | null
    initial_page_number: number | null
    general_file_path: string | null
    url_title: string | null
    unique_key: string | null
    pustaka_cover_status: number | null
    general_cover_status: number | null
    general_epub_status: number | null
    pustaka_epub_status: number | null
    amazon_epub_status: number | null
    pustaka_flippdf_status: number | null
    pustaka_word_status: number | null
    priority: string | null
    current_state: number | null
    remarks: string | null
  }

  export type Books_metadataMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    description: boolean | null
    type_of_book: number | null
    content_type: string | null
    hard_copy_type: string | null
    soft_copy_type: string | null
    final_page_number: number | null
    allocated_date: Date | null
    start_date: Date | null
    completion_date: Date | null
    payment_date: Date | null
    settled_page_number: number | null
    payment_status: number | null
    assigned_by: number | null
    assigned_to: number | null
    price_per_page: number | null
    initial_page_number: number | null
    general_file_path: string | null
    url_title: string | null
    unique_key: string | null
    pustaka_cover_status: number | null
    general_cover_status: number | null
    general_epub_status: number | null
    pustaka_epub_status: number | null
    amazon_epub_status: number | null
    pustaka_flippdf_status: number | null
    pustaka_word_status: number | null
    priority: string | null
    current_state: number | null
    remarks: string | null
  }

  export type Books_metadataCountAggregateOutputType = {
    id: number
    book_id: number
    description: number
    type_of_book: number
    content_type: number
    hard_copy_type: number
    soft_copy_type: number
    final_page_number: number
    allocated_date: number
    start_date: number
    completion_date: number
    payment_date: number
    settled_page_number: number
    payment_status: number
    assigned_by: number
    assigned_to: number
    price_per_page: number
    initial_page_number: number
    general_file_path: number
    url_title: number
    unique_key: number
    pustaka_cover_status: number
    general_cover_status: number
    general_epub_status: number
    pustaka_epub_status: number
    amazon_epub_status: number
    pustaka_flippdf_status: number
    pustaka_word_status: number
    priority: number
    current_state: number
    remarks: number
    _all: number
  }


  export type Books_metadataAvgAggregateInputType = {
    id?: true
    book_id?: true
    type_of_book?: true
    final_page_number?: true
    settled_page_number?: true
    payment_status?: true
    assigned_by?: true
    assigned_to?: true
    price_per_page?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    general_cover_status?: true
    general_epub_status?: true
    pustaka_epub_status?: true
    amazon_epub_status?: true
    pustaka_flippdf_status?: true
    pustaka_word_status?: true
    current_state?: true
  }

  export type Books_metadataSumAggregateInputType = {
    id?: true
    book_id?: true
    type_of_book?: true
    final_page_number?: true
    settled_page_number?: true
    payment_status?: true
    assigned_by?: true
    assigned_to?: true
    price_per_page?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    general_cover_status?: true
    general_epub_status?: true
    pustaka_epub_status?: true
    amazon_epub_status?: true
    pustaka_flippdf_status?: true
    pustaka_word_status?: true
    current_state?: true
  }

  export type Books_metadataMinAggregateInputType = {
    id?: true
    book_id?: true
    description?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    final_page_number?: true
    allocated_date?: true
    start_date?: true
    completion_date?: true
    payment_date?: true
    settled_page_number?: true
    payment_status?: true
    assigned_by?: true
    assigned_to?: true
    price_per_page?: true
    initial_page_number?: true
    general_file_path?: true
    url_title?: true
    unique_key?: true
    pustaka_cover_status?: true
    general_cover_status?: true
    general_epub_status?: true
    pustaka_epub_status?: true
    amazon_epub_status?: true
    pustaka_flippdf_status?: true
    pustaka_word_status?: true
    priority?: true
    current_state?: true
    remarks?: true
  }

  export type Books_metadataMaxAggregateInputType = {
    id?: true
    book_id?: true
    description?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    final_page_number?: true
    allocated_date?: true
    start_date?: true
    completion_date?: true
    payment_date?: true
    settled_page_number?: true
    payment_status?: true
    assigned_by?: true
    assigned_to?: true
    price_per_page?: true
    initial_page_number?: true
    general_file_path?: true
    url_title?: true
    unique_key?: true
    pustaka_cover_status?: true
    general_cover_status?: true
    general_epub_status?: true
    pustaka_epub_status?: true
    amazon_epub_status?: true
    pustaka_flippdf_status?: true
    pustaka_word_status?: true
    priority?: true
    current_state?: true
    remarks?: true
  }

  export type Books_metadataCountAggregateInputType = {
    id?: true
    book_id?: true
    description?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    final_page_number?: true
    allocated_date?: true
    start_date?: true
    completion_date?: true
    payment_date?: true
    settled_page_number?: true
    payment_status?: true
    assigned_by?: true
    assigned_to?: true
    price_per_page?: true
    initial_page_number?: true
    general_file_path?: true
    url_title?: true
    unique_key?: true
    pustaka_cover_status?: true
    general_cover_status?: true
    general_epub_status?: true
    pustaka_epub_status?: true
    amazon_epub_status?: true
    pustaka_flippdf_status?: true
    pustaka_word_status?: true
    priority?: true
    current_state?: true
    remarks?: true
    _all?: true
  }

  export type Books_metadataAggregateArgs = {
    /**
     * Filter which books_metadata to aggregate.
     * 
    **/
    where?: books_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<books_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: books_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned books_metadata
    **/
    _count?: true | Books_metadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Books_metadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Books_metadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Books_metadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Books_metadataMaxAggregateInputType
  }

  export type GetBooks_metadataAggregateType<T extends Books_metadataAggregateArgs> = {
        [P in keyof T & keyof AggregateBooks_metadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooks_metadata[P]>
      : GetScalarType<T[P], AggregateBooks_metadata[P]>
  }




  export type Books_metadataGroupByArgs = {
    where?: books_metadataWhereInput
    orderBy?: Enumerable<books_metadataOrderByWithAggregationInput>
    by: Array<Books_metadataScalarFieldEnum>
    having?: books_metadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Books_metadataCountAggregateInputType | true
    _avg?: Books_metadataAvgAggregateInputType
    _sum?: Books_metadataSumAggregateInputType
    _min?: Books_metadataMinAggregateInputType
    _max?: Books_metadataMaxAggregateInputType
  }


  export type Books_metadataGroupByOutputType = {
    id: number
    book_id: number
    description: boolean
    type_of_book: number
    content_type: string
    hard_copy_type: string
    soft_copy_type: string
    final_page_number: number
    allocated_date: Date | null
    start_date: Date | null
    completion_date: Date | null
    payment_date: Date
    settled_page_number: number
    payment_status: number
    assigned_by: number
    assigned_to: number
    price_per_page: number
    initial_page_number: number | null
    general_file_path: string
    url_title: string
    unique_key: string
    pustaka_cover_status: number
    general_cover_status: number
    general_epub_status: number
    pustaka_epub_status: number
    amazon_epub_status: number
    pustaka_flippdf_status: number
    pustaka_word_status: number
    priority: string
    current_state: number | null
    remarks: string | null
    _count: Books_metadataCountAggregateOutputType | null
    _avg: Books_metadataAvgAggregateOutputType | null
    _sum: Books_metadataSumAggregateOutputType | null
    _min: Books_metadataMinAggregateOutputType | null
    _max: Books_metadataMaxAggregateOutputType | null
  }

  type GetBooks_metadataGroupByPayload<T extends Books_metadataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Books_metadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Books_metadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Books_metadataGroupByOutputType[P]>
            : GetScalarType<T[P], Books_metadataGroupByOutputType[P]>
        }
      >
    >


  export type books_metadataSelect = {
    id?: boolean
    book_id?: boolean
    description?: boolean
    type_of_book?: boolean
    content_type?: boolean
    hard_copy_type?: boolean
    soft_copy_type?: boolean
    final_page_number?: boolean
    allocated_date?: boolean
    start_date?: boolean
    completion_date?: boolean
    payment_date?: boolean
    settled_page_number?: boolean
    payment_status?: boolean
    assigned_by?: boolean
    assigned_to?: boolean
    price_per_page?: boolean
    initial_page_number?: boolean
    general_file_path?: boolean
    url_title?: boolean
    unique_key?: boolean
    pustaka_cover_status?: boolean
    general_cover_status?: boolean
    general_epub_status?: boolean
    pustaka_epub_status?: boolean
    amazon_epub_status?: boolean
    pustaka_flippdf_status?: boolean
    pustaka_word_status?: boolean
    priority?: boolean
    current_state?: boolean
    remarks?: boolean
  }


  export type books_metadataGetPayload<S extends boolean | null | undefined | books_metadataArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? books_metadata :
    S extends undefined ? never :
    S extends { include: any } & (books_metadataArgs | books_metadataFindManyArgs)
    ? books_metadata 
    : S extends { select: any } & (books_metadataArgs | books_metadataFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof books_metadata ? books_metadata[P] : never
  } 
      : books_metadata


  type books_metadataCountArgs = Merge<
    Omit<books_metadataFindManyArgs, 'select' | 'include'> & {
      select?: Books_metadataCountAggregateInputType | true
    }
  >

  export interface books_metadataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Books_metadata that matches the filter.
     * @param {books_metadataFindUniqueArgs} args - Arguments to find a Books_metadata
     * @example
     * // Get one Books_metadata
     * const books_metadata = await prisma.books_metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends books_metadataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, books_metadataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'books_metadata'> extends True ? Prisma__books_metadataClient<books_metadataGetPayload<T>> : Prisma__books_metadataClient<books_metadataGetPayload<T> | null, null>

    /**
     * Find the first Books_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_metadataFindFirstArgs} args - Arguments to find a Books_metadata
     * @example
     * // Get one Books_metadata
     * const books_metadata = await prisma.books_metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends books_metadataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, books_metadataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'books_metadata'> extends True ? Prisma__books_metadataClient<books_metadataGetPayload<T>> : Prisma__books_metadataClient<books_metadataGetPayload<T> | null, null>

    /**
     * Find zero or more Books_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_metadataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books_metadata
     * const books_metadata = await prisma.books_metadata.findMany()
     * 
     * // Get first 10 Books_metadata
     * const books_metadata = await prisma.books_metadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const books_metadataWithIdOnly = await prisma.books_metadata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends books_metadataFindManyArgs>(
      args?: SelectSubset<T, books_metadataFindManyArgs>
    ): PrismaPromise<Array<books_metadataGetPayload<T>>>

    /**
     * Create a Books_metadata.
     * @param {books_metadataCreateArgs} args - Arguments to create a Books_metadata.
     * @example
     * // Create one Books_metadata
     * const Books_metadata = await prisma.books_metadata.create({
     *   data: {
     *     // ... data to create a Books_metadata
     *   }
     * })
     * 
    **/
    create<T extends books_metadataCreateArgs>(
      args: SelectSubset<T, books_metadataCreateArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Create many Books_metadata.
     *     @param {books_metadataCreateManyArgs} args - Arguments to create many Books_metadata.
     *     @example
     *     // Create many Books_metadata
     *     const books_metadata = await prisma.books_metadata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends books_metadataCreateManyArgs>(
      args?: SelectSubset<T, books_metadataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Books_metadata.
     * @param {books_metadataDeleteArgs} args - Arguments to delete one Books_metadata.
     * @example
     * // Delete one Books_metadata
     * const Books_metadata = await prisma.books_metadata.delete({
     *   where: {
     *     // ... filter to delete one Books_metadata
     *   }
     * })
     * 
    **/
    delete<T extends books_metadataDeleteArgs>(
      args: SelectSubset<T, books_metadataDeleteArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Update one Books_metadata.
     * @param {books_metadataUpdateArgs} args - Arguments to update one Books_metadata.
     * @example
     * // Update one Books_metadata
     * const books_metadata = await prisma.books_metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends books_metadataUpdateArgs>(
      args: SelectSubset<T, books_metadataUpdateArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Delete zero or more Books_metadata.
     * @param {books_metadataDeleteManyArgs} args - Arguments to filter Books_metadata to delete.
     * @example
     * // Delete a few Books_metadata
     * const { count } = await prisma.books_metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends books_metadataDeleteManyArgs>(
      args?: SelectSubset<T, books_metadataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_metadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books_metadata
     * const books_metadata = await prisma.books_metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends books_metadataUpdateManyArgs>(
      args: SelectSubset<T, books_metadataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Books_metadata.
     * @param {books_metadataUpsertArgs} args - Arguments to update or create a Books_metadata.
     * @example
     * // Update or create a Books_metadata
     * const books_metadata = await prisma.books_metadata.upsert({
     *   create: {
     *     // ... data to create a Books_metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Books_metadata we want to update
     *   }
     * })
    **/
    upsert<T extends books_metadataUpsertArgs>(
      args: SelectSubset<T, books_metadataUpsertArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Find one Books_metadata that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {books_metadataFindUniqueOrThrowArgs} args - Arguments to find a Books_metadata
     * @example
     * // Get one Books_metadata
     * const books_metadata = await prisma.books_metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends books_metadataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, books_metadataFindUniqueOrThrowArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Find the first Books_metadata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_metadataFindFirstOrThrowArgs} args - Arguments to find a Books_metadata
     * @example
     * // Get one Books_metadata
     * const books_metadata = await prisma.books_metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends books_metadataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, books_metadataFindFirstOrThrowArgs>
    ): Prisma__books_metadataClient<books_metadataGetPayload<T>>

    /**
     * Count the number of Books_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_metadataCountArgs} args - Arguments to filter Books_metadata to count.
     * @example
     * // Count the number of Books_metadata
     * const count = await prisma.books_metadata.count({
     *   where: {
     *     // ... the filter for the Books_metadata we want to count
     *   }
     * })
    **/
    count<T extends books_metadataCountArgs>(
      args?: Subset<T, books_metadataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Books_metadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Books_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_metadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Books_metadataAggregateArgs>(args: Subset<T, Books_metadataAggregateArgs>): PrismaPromise<GetBooks_metadataAggregateType<T>>

    /**
     * Group by Books_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_metadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Books_metadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Books_metadataGroupByArgs['orderBy'] }
        : { orderBy?: Books_metadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Books_metadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooks_metadataGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for books_metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__books_metadataClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * books_metadata base type for findUnique actions
   */
  export type books_metadataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * Filter, which books_metadata to fetch.
     * 
    **/
    where: books_metadataWhereUniqueInput
  }

  /**
   * books_metadata: findUnique
   */
  export interface books_metadataFindUniqueArgs extends books_metadataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_metadata base type for findFirst actions
   */
  export type books_metadataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * Filter, which books_metadata to fetch.
     * 
    **/
    where?: books_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<books_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books_metadata.
     * 
    **/
    cursor?: books_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books_metadata.
     * 
    **/
    distinct?: Enumerable<Books_metadataScalarFieldEnum>
  }

  /**
   * books_metadata: findFirst
   */
  export interface books_metadataFindFirstArgs extends books_metadataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_metadata findMany
   */
  export type books_metadataFindManyArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * Filter, which books_metadata to fetch.
     * 
    **/
    where?: books_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<books_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing books_metadata.
     * 
    **/
    cursor?: books_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_metadata.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Books_metadataScalarFieldEnum>
  }


  /**
   * books_metadata create
   */
  export type books_metadataCreateArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * The data needed to create a books_metadata.
     * 
    **/
    data: XOR<books_metadataCreateInput, books_metadataUncheckedCreateInput>
  }


  /**
   * books_metadata createMany
   */
  export type books_metadataCreateManyArgs = {
    /**
     * The data used to create many books_metadata.
     * 
    **/
    data: Enumerable<books_metadataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * books_metadata update
   */
  export type books_metadataUpdateArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * The data needed to update a books_metadata.
     * 
    **/
    data: XOR<books_metadataUpdateInput, books_metadataUncheckedUpdateInput>
    /**
     * Choose, which books_metadata to update.
     * 
    **/
    where: books_metadataWhereUniqueInput
  }


  /**
   * books_metadata updateMany
   */
  export type books_metadataUpdateManyArgs = {
    /**
     * The data used to update books_metadata.
     * 
    **/
    data: XOR<books_metadataUpdateManyMutationInput, books_metadataUncheckedUpdateManyInput>
    /**
     * Filter which books_metadata to update
     * 
    **/
    where?: books_metadataWhereInput
  }


  /**
   * books_metadata upsert
   */
  export type books_metadataUpsertArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * The filter to search for the books_metadata to update in case it exists.
     * 
    **/
    where: books_metadataWhereUniqueInput
    /**
     * In case the books_metadata found by the `where` argument doesn't exist, create a new books_metadata with this data.
     * 
    **/
    create: XOR<books_metadataCreateInput, books_metadataUncheckedCreateInput>
    /**
     * In case the books_metadata was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<books_metadataUpdateInput, books_metadataUncheckedUpdateInput>
  }


  /**
   * books_metadata delete
   */
  export type books_metadataDeleteArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
    /**
     * Filter which books_metadata to delete.
     * 
    **/
    where: books_metadataWhereUniqueInput
  }


  /**
   * books_metadata deleteMany
   */
  export type books_metadataDeleteManyArgs = {
    /**
     * Filter which books_metadata to delete
     * 
    **/
    where?: books_metadataWhereInput
  }


  /**
   * books_metadata: findUniqueOrThrow
   */
  export type books_metadataFindUniqueOrThrowArgs = books_metadataFindUniqueArgsBase
      

  /**
   * books_metadata: findFirstOrThrow
   */
  export type books_metadataFindFirstOrThrowArgs = books_metadataFindFirstArgsBase
      

  /**
   * books_metadata without action
   */
  export type books_metadataArgs = {
    /**
     * Select specific fields to fetch from the books_metadata
     * 
    **/
    select?: books_metadataSelect | null
  }



  /**
   * Model books_processing
   */


  export type AggregateBooks_processing = {
    _count: Books_processingCountAggregateOutputType | null
    _avg: Books_processingAvgAggregateOutputType | null
    _sum: Books_processingSumAggregateOutputType | null
    _min: Books_processingMinAggregateOutputType | null
    _max: Books_processingMaxAggregateOutputType | null
  }

  export type Books_processingAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    pustaka_epub_status: number | null
    pustaka_flippdf_status: number | null
    completed: number | null
    rework: number | null
  }

  export type Books_processingSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    pustaka_epub_status: number | null
    pustaka_flippdf_status: number | null
    completed: number | null
    rework: number | null
  }

  export type Books_processingMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    type_of_book: string | null
    content_type: string | null
    hard_copy_type: string | null
    soft_copy_type: string | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    pustaka_epub_status: number | null
    pustaka_flippdf_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
  }

  export type Books_processingMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    type_of_book: string | null
    content_type: string | null
    hard_copy_type: string | null
    soft_copy_type: string | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    pustaka_epub_status: number | null
    pustaka_flippdf_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
  }

  export type Books_processingCountAggregateOutputType = {
    id: number
    book_id: number
    stage_id: number
    type_of_book: number
    content_type: number
    hard_copy_type: number
    soft_copy_type: number
    initial_page_number: number
    pustaka_cover_status: number
    pustaka_epub_status: number
    pustaka_flippdf_status: number
    priority: number
    date_created: number
    completed: number
    rework: number
    _all: number
  }


  export type Books_processingAvgAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    pustaka_epub_status?: true
    pustaka_flippdf_status?: true
    completed?: true
    rework?: true
  }

  export type Books_processingSumAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    pustaka_epub_status?: true
    pustaka_flippdf_status?: true
    completed?: true
    rework?: true
  }

  export type Books_processingMinAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    pustaka_epub_status?: true
    pustaka_flippdf_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
  }

  export type Books_processingMaxAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    pustaka_epub_status?: true
    pustaka_flippdf_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
  }

  export type Books_processingCountAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    type_of_book?: true
    content_type?: true
    hard_copy_type?: true
    soft_copy_type?: true
    initial_page_number?: true
    pustaka_cover_status?: true
    pustaka_epub_status?: true
    pustaka_flippdf_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
    _all?: true
  }

  export type Books_processingAggregateArgs = {
    /**
     * Filter which books_processing to aggregate.
     * 
    **/
    where?: books_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<books_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: books_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_processings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned books_processings
    **/
    _count?: true | Books_processingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Books_processingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Books_processingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Books_processingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Books_processingMaxAggregateInputType
  }

  export type GetBooks_processingAggregateType<T extends Books_processingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooks_processing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooks_processing[P]>
      : GetScalarType<T[P], AggregateBooks_processing[P]>
  }




  export type Books_processingGroupByArgs = {
    where?: books_processingWhereInput
    orderBy?: Enumerable<books_processingOrderByWithAggregationInput>
    by: Array<Books_processingScalarFieldEnum>
    having?: books_processingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Books_processingCountAggregateInputType | true
    _avg?: Books_processingAvgAggregateInputType
    _sum?: Books_processingSumAggregateInputType
    _min?: Books_processingMinAggregateInputType
    _max?: Books_processingMaxAggregateInputType
  }


  export type Books_processingGroupByOutputType = {
    id: number
    book_id: number | null
    stage_id: number | null
    type_of_book: string | null
    content_type: string | null
    hard_copy_type: string | null
    soft_copy_type: string | null
    initial_page_number: number | null
    pustaka_cover_status: number | null
    pustaka_epub_status: number | null
    pustaka_flippdf_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
    _count: Books_processingCountAggregateOutputType | null
    _avg: Books_processingAvgAggregateOutputType | null
    _sum: Books_processingSumAggregateOutputType | null
    _min: Books_processingMinAggregateOutputType | null
    _max: Books_processingMaxAggregateOutputType | null
  }

  type GetBooks_processingGroupByPayload<T extends Books_processingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Books_processingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Books_processingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Books_processingGroupByOutputType[P]>
            : GetScalarType<T[P], Books_processingGroupByOutputType[P]>
        }
      >
    >


  export type books_processingSelect = {
    id?: boolean
    book_id?: boolean
    stage_id?: boolean
    type_of_book?: boolean
    content_type?: boolean
    hard_copy_type?: boolean
    soft_copy_type?: boolean
    initial_page_number?: boolean
    pustaka_cover_status?: boolean
    pustaka_epub_status?: boolean
    pustaka_flippdf_status?: boolean
    priority?: boolean
    date_created?: boolean
    completed?: boolean
    rework?: boolean
  }


  export type books_processingGetPayload<S extends boolean | null | undefined | books_processingArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? books_processing :
    S extends undefined ? never :
    S extends { include: any } & (books_processingArgs | books_processingFindManyArgs)
    ? books_processing 
    : S extends { select: any } & (books_processingArgs | books_processingFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof books_processing ? books_processing[P] : never
  } 
      : books_processing


  type books_processingCountArgs = Merge<
    Omit<books_processingFindManyArgs, 'select' | 'include'> & {
      select?: Books_processingCountAggregateInputType | true
    }
  >

  export interface books_processingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Books_processing that matches the filter.
     * @param {books_processingFindUniqueArgs} args - Arguments to find a Books_processing
     * @example
     * // Get one Books_processing
     * const books_processing = await prisma.books_processing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends books_processingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, books_processingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'books_processing'> extends True ? Prisma__books_processingClient<books_processingGetPayload<T>> : Prisma__books_processingClient<books_processingGetPayload<T> | null, null>

    /**
     * Find the first Books_processing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_processingFindFirstArgs} args - Arguments to find a Books_processing
     * @example
     * // Get one Books_processing
     * const books_processing = await prisma.books_processing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends books_processingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, books_processingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'books_processing'> extends True ? Prisma__books_processingClient<books_processingGetPayload<T>> : Prisma__books_processingClient<books_processingGetPayload<T> | null, null>

    /**
     * Find zero or more Books_processings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_processingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books_processings
     * const books_processings = await prisma.books_processing.findMany()
     * 
     * // Get first 10 Books_processings
     * const books_processings = await prisma.books_processing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const books_processingWithIdOnly = await prisma.books_processing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends books_processingFindManyArgs>(
      args?: SelectSubset<T, books_processingFindManyArgs>
    ): PrismaPromise<Array<books_processingGetPayload<T>>>

    /**
     * Create a Books_processing.
     * @param {books_processingCreateArgs} args - Arguments to create a Books_processing.
     * @example
     * // Create one Books_processing
     * const Books_processing = await prisma.books_processing.create({
     *   data: {
     *     // ... data to create a Books_processing
     *   }
     * })
     * 
    **/
    create<T extends books_processingCreateArgs>(
      args: SelectSubset<T, books_processingCreateArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Create many Books_processings.
     *     @param {books_processingCreateManyArgs} args - Arguments to create many Books_processings.
     *     @example
     *     // Create many Books_processings
     *     const books_processing = await prisma.books_processing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends books_processingCreateManyArgs>(
      args?: SelectSubset<T, books_processingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Books_processing.
     * @param {books_processingDeleteArgs} args - Arguments to delete one Books_processing.
     * @example
     * // Delete one Books_processing
     * const Books_processing = await prisma.books_processing.delete({
     *   where: {
     *     // ... filter to delete one Books_processing
     *   }
     * })
     * 
    **/
    delete<T extends books_processingDeleteArgs>(
      args: SelectSubset<T, books_processingDeleteArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Update one Books_processing.
     * @param {books_processingUpdateArgs} args - Arguments to update one Books_processing.
     * @example
     * // Update one Books_processing
     * const books_processing = await prisma.books_processing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends books_processingUpdateArgs>(
      args: SelectSubset<T, books_processingUpdateArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Delete zero or more Books_processings.
     * @param {books_processingDeleteManyArgs} args - Arguments to filter Books_processings to delete.
     * @example
     * // Delete a few Books_processings
     * const { count } = await prisma.books_processing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends books_processingDeleteManyArgs>(
      args?: SelectSubset<T, books_processingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books_processings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_processingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books_processings
     * const books_processing = await prisma.books_processing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends books_processingUpdateManyArgs>(
      args: SelectSubset<T, books_processingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Books_processing.
     * @param {books_processingUpsertArgs} args - Arguments to update or create a Books_processing.
     * @example
     * // Update or create a Books_processing
     * const books_processing = await prisma.books_processing.upsert({
     *   create: {
     *     // ... data to create a Books_processing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Books_processing we want to update
     *   }
     * })
    **/
    upsert<T extends books_processingUpsertArgs>(
      args: SelectSubset<T, books_processingUpsertArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Find one Books_processing that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {books_processingFindUniqueOrThrowArgs} args - Arguments to find a Books_processing
     * @example
     * // Get one Books_processing
     * const books_processing = await prisma.books_processing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends books_processingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, books_processingFindUniqueOrThrowArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Find the first Books_processing that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_processingFindFirstOrThrowArgs} args - Arguments to find a Books_processing
     * @example
     * // Get one Books_processing
     * const books_processing = await prisma.books_processing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends books_processingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, books_processingFindFirstOrThrowArgs>
    ): Prisma__books_processingClient<books_processingGetPayload<T>>

    /**
     * Count the number of Books_processings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_processingCountArgs} args - Arguments to filter Books_processings to count.
     * @example
     * // Count the number of Books_processings
     * const count = await prisma.books_processing.count({
     *   where: {
     *     // ... the filter for the Books_processings we want to count
     *   }
     * })
    **/
    count<T extends books_processingCountArgs>(
      args?: Subset<T, books_processingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Books_processingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Books_processing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_processingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Books_processingAggregateArgs>(args: Subset<T, Books_processingAggregateArgs>): PrismaPromise<GetBooks_processingAggregateType<T>>

    /**
     * Group by Books_processing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_processingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Books_processingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Books_processingGroupByArgs['orderBy'] }
        : { orderBy?: Books_processingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Books_processingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooks_processingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for books_processing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__books_processingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * books_processing base type for findUnique actions
   */
  export type books_processingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * Filter, which books_processing to fetch.
     * 
    **/
    where: books_processingWhereUniqueInput
  }

  /**
   * books_processing: findUnique
   */
  export interface books_processingFindUniqueArgs extends books_processingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_processing base type for findFirst actions
   */
  export type books_processingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * Filter, which books_processing to fetch.
     * 
    **/
    where?: books_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<books_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books_processings.
     * 
    **/
    cursor?: books_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_processings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books_processings.
     * 
    **/
    distinct?: Enumerable<Books_processingScalarFieldEnum>
  }

  /**
   * books_processing: findFirst
   */
  export interface books_processingFindFirstArgs extends books_processingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_processing findMany
   */
  export type books_processingFindManyArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * Filter, which books_processings to fetch.
     * 
    **/
    where?: books_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<books_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing books_processings.
     * 
    **/
    cursor?: books_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_processings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Books_processingScalarFieldEnum>
  }


  /**
   * books_processing create
   */
  export type books_processingCreateArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * The data needed to create a books_processing.
     * 
    **/
    data: XOR<books_processingCreateInput, books_processingUncheckedCreateInput>
  }


  /**
   * books_processing createMany
   */
  export type books_processingCreateManyArgs = {
    /**
     * The data used to create many books_processings.
     * 
    **/
    data: Enumerable<books_processingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * books_processing update
   */
  export type books_processingUpdateArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * The data needed to update a books_processing.
     * 
    **/
    data: XOR<books_processingUpdateInput, books_processingUncheckedUpdateInput>
    /**
     * Choose, which books_processing to update.
     * 
    **/
    where: books_processingWhereUniqueInput
  }


  /**
   * books_processing updateMany
   */
  export type books_processingUpdateManyArgs = {
    /**
     * The data used to update books_processings.
     * 
    **/
    data: XOR<books_processingUpdateManyMutationInput, books_processingUncheckedUpdateManyInput>
    /**
     * Filter which books_processings to update
     * 
    **/
    where?: books_processingWhereInput
  }


  /**
   * books_processing upsert
   */
  export type books_processingUpsertArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * The filter to search for the books_processing to update in case it exists.
     * 
    **/
    where: books_processingWhereUniqueInput
    /**
     * In case the books_processing found by the `where` argument doesn't exist, create a new books_processing with this data.
     * 
    **/
    create: XOR<books_processingCreateInput, books_processingUncheckedCreateInput>
    /**
     * In case the books_processing was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<books_processingUpdateInput, books_processingUncheckedUpdateInput>
  }


  /**
   * books_processing delete
   */
  export type books_processingDeleteArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
    /**
     * Filter which books_processing to delete.
     * 
    **/
    where: books_processingWhereUniqueInput
  }


  /**
   * books_processing deleteMany
   */
  export type books_processingDeleteManyArgs = {
    /**
     * Filter which books_processings to delete
     * 
    **/
    where?: books_processingWhereInput
  }


  /**
   * books_processing: findUniqueOrThrow
   */
  export type books_processingFindUniqueOrThrowArgs = books_processingFindUniqueArgsBase
      

  /**
   * books_processing: findFirstOrThrow
   */
  export type books_processingFindFirstOrThrowArgs = books_processingFindFirstArgsBase
      

  /**
   * books_processing without action
   */
  export type books_processingArgs = {
    /**
     * Select specific fields to fetch from the books_processing
     * 
    **/
    select?: books_processingSelect | null
  }



  /**
   * Model books_progress
   */


  export type AggregateBooks_progress = {
    _count: Books_progressCountAggregateOutputType | null
    _avg: Books_progressAvgAggregateOutputType | null
    _sum: Books_progressSumAggregateOutputType | null
    _min: Books_progressMinAggregateOutputType | null
    _max: Books_progressMaxAggregateOutputType | null
  }

  export type Books_progressAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
  }

  export type Books_progressSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
  }

  export type Books_progressMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
  }

  export type Books_progressMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
  }

  export type Books_progressCountAggregateOutputType = {
    id: number
    book_id: number
    status: number
    stage: number
    startdate: number
    enddate: number
    on_hold_startdate: number
    on_hold_enddate: number
    remarks: number
    _all: number
  }


  export type Books_progressAvgAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
  }

  export type Books_progressSumAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
  }

  export type Books_progressMinAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
  }

  export type Books_progressMaxAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
  }

  export type Books_progressCountAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
    _all?: true
  }

  export type Books_progressAggregateArgs = {
    /**
     * Filter which books_progress to aggregate.
     * 
    **/
    where?: books_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<books_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: books_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_progresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned books_progresses
    **/
    _count?: true | Books_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Books_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Books_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Books_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Books_progressMaxAggregateInputType
  }

  export type GetBooks_progressAggregateType<T extends Books_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateBooks_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooks_progress[P]>
      : GetScalarType<T[P], AggregateBooks_progress[P]>
  }




  export type Books_progressGroupByArgs = {
    where?: books_progressWhereInput
    orderBy?: Enumerable<books_progressOrderByWithAggregationInput>
    by: Array<Books_progressScalarFieldEnum>
    having?: books_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Books_progressCountAggregateInputType | true
    _avg?: Books_progressAvgAggregateInputType
    _sum?: Books_progressSumAggregateInputType
    _min?: Books_progressMinAggregateInputType
    _max?: Books_progressMaxAggregateInputType
  }


  export type Books_progressGroupByOutputType = {
    id: number
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
    _count: Books_progressCountAggregateOutputType | null
    _avg: Books_progressAvgAggregateOutputType | null
    _sum: Books_progressSumAggregateOutputType | null
    _min: Books_progressMinAggregateOutputType | null
    _max: Books_progressMaxAggregateOutputType | null
  }

  type GetBooks_progressGroupByPayload<T extends Books_progressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Books_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Books_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Books_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Books_progressGroupByOutputType[P]>
        }
      >
    >


  export type books_progressSelect = {
    id?: boolean
    book_id?: boolean
    status?: boolean
    stage?: boolean
    startdate?: boolean
    enddate?: boolean
    on_hold_startdate?: boolean
    on_hold_enddate?: boolean
    remarks?: boolean
  }


  export type books_progressGetPayload<S extends boolean | null | undefined | books_progressArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? books_progress :
    S extends undefined ? never :
    S extends { include: any } & (books_progressArgs | books_progressFindManyArgs)
    ? books_progress 
    : S extends { select: any } & (books_progressArgs | books_progressFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof books_progress ? books_progress[P] : never
  } 
      : books_progress


  type books_progressCountArgs = Merge<
    Omit<books_progressFindManyArgs, 'select' | 'include'> & {
      select?: Books_progressCountAggregateInputType | true
    }
  >

  export interface books_progressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Books_progress that matches the filter.
     * @param {books_progressFindUniqueArgs} args - Arguments to find a Books_progress
     * @example
     * // Get one Books_progress
     * const books_progress = await prisma.books_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends books_progressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, books_progressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'books_progress'> extends True ? Prisma__books_progressClient<books_progressGetPayload<T>> : Prisma__books_progressClient<books_progressGetPayload<T> | null, null>

    /**
     * Find the first Books_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_progressFindFirstArgs} args - Arguments to find a Books_progress
     * @example
     * // Get one Books_progress
     * const books_progress = await prisma.books_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends books_progressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, books_progressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'books_progress'> extends True ? Prisma__books_progressClient<books_progressGetPayload<T>> : Prisma__books_progressClient<books_progressGetPayload<T> | null, null>

    /**
     * Find zero or more Books_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_progressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books_progresses
     * const books_progresses = await prisma.books_progress.findMany()
     * 
     * // Get first 10 Books_progresses
     * const books_progresses = await prisma.books_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const books_progressWithIdOnly = await prisma.books_progress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends books_progressFindManyArgs>(
      args?: SelectSubset<T, books_progressFindManyArgs>
    ): PrismaPromise<Array<books_progressGetPayload<T>>>

    /**
     * Create a Books_progress.
     * @param {books_progressCreateArgs} args - Arguments to create a Books_progress.
     * @example
     * // Create one Books_progress
     * const Books_progress = await prisma.books_progress.create({
     *   data: {
     *     // ... data to create a Books_progress
     *   }
     * })
     * 
    **/
    create<T extends books_progressCreateArgs>(
      args: SelectSubset<T, books_progressCreateArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Create many Books_progresses.
     *     @param {books_progressCreateManyArgs} args - Arguments to create many Books_progresses.
     *     @example
     *     // Create many Books_progresses
     *     const books_progress = await prisma.books_progress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends books_progressCreateManyArgs>(
      args?: SelectSubset<T, books_progressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Books_progress.
     * @param {books_progressDeleteArgs} args - Arguments to delete one Books_progress.
     * @example
     * // Delete one Books_progress
     * const Books_progress = await prisma.books_progress.delete({
     *   where: {
     *     // ... filter to delete one Books_progress
     *   }
     * })
     * 
    **/
    delete<T extends books_progressDeleteArgs>(
      args: SelectSubset<T, books_progressDeleteArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Update one Books_progress.
     * @param {books_progressUpdateArgs} args - Arguments to update one Books_progress.
     * @example
     * // Update one Books_progress
     * const books_progress = await prisma.books_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends books_progressUpdateArgs>(
      args: SelectSubset<T, books_progressUpdateArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Delete zero or more Books_progresses.
     * @param {books_progressDeleteManyArgs} args - Arguments to filter Books_progresses to delete.
     * @example
     * // Delete a few Books_progresses
     * const { count } = await prisma.books_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends books_progressDeleteManyArgs>(
      args?: SelectSubset<T, books_progressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books_progresses
     * const books_progress = await prisma.books_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends books_progressUpdateManyArgs>(
      args: SelectSubset<T, books_progressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Books_progress.
     * @param {books_progressUpsertArgs} args - Arguments to update or create a Books_progress.
     * @example
     * // Update or create a Books_progress
     * const books_progress = await prisma.books_progress.upsert({
     *   create: {
     *     // ... data to create a Books_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Books_progress we want to update
     *   }
     * })
    **/
    upsert<T extends books_progressUpsertArgs>(
      args: SelectSubset<T, books_progressUpsertArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Find one Books_progress that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {books_progressFindUniqueOrThrowArgs} args - Arguments to find a Books_progress
     * @example
     * // Get one Books_progress
     * const books_progress = await prisma.books_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends books_progressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, books_progressFindUniqueOrThrowArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Find the first Books_progress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_progressFindFirstOrThrowArgs} args - Arguments to find a Books_progress
     * @example
     * // Get one Books_progress
     * const books_progress = await prisma.books_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends books_progressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, books_progressFindFirstOrThrowArgs>
    ): Prisma__books_progressClient<books_progressGetPayload<T>>

    /**
     * Count the number of Books_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {books_progressCountArgs} args - Arguments to filter Books_progresses to count.
     * @example
     * // Count the number of Books_progresses
     * const count = await prisma.books_progress.count({
     *   where: {
     *     // ... the filter for the Books_progresses we want to count
     *   }
     * })
    **/
    count<T extends books_progressCountArgs>(
      args?: Subset<T, books_progressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Books_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Books_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Books_progressAggregateArgs>(args: Subset<T, Books_progressAggregateArgs>): PrismaPromise<GetBooks_progressAggregateType<T>>

    /**
     * Group by Books_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Books_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Books_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Books_progressGroupByArgs['orderBy'] }
        : { orderBy?: Books_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Books_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooks_progressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for books_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__books_progressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * books_progress base type for findUnique actions
   */
  export type books_progressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * Filter, which books_progress to fetch.
     * 
    **/
    where: books_progressWhereUniqueInput
  }

  /**
   * books_progress: findUnique
   */
  export interface books_progressFindUniqueArgs extends books_progressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_progress base type for findFirst actions
   */
  export type books_progressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * Filter, which books_progress to fetch.
     * 
    **/
    where?: books_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<books_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books_progresses.
     * 
    **/
    cursor?: books_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_progresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books_progresses.
     * 
    **/
    distinct?: Enumerable<Books_progressScalarFieldEnum>
  }

  /**
   * books_progress: findFirst
   */
  export interface books_progressFindFirstArgs extends books_progressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * books_progress findMany
   */
  export type books_progressFindManyArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * Filter, which books_progresses to fetch.
     * 
    **/
    where?: books_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<books_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing books_progresses.
     * 
    **/
    cursor?: books_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books_progresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Books_progressScalarFieldEnum>
  }


  /**
   * books_progress create
   */
  export type books_progressCreateArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * The data needed to create a books_progress.
     * 
    **/
    data: XOR<books_progressCreateInput, books_progressUncheckedCreateInput>
  }


  /**
   * books_progress createMany
   */
  export type books_progressCreateManyArgs = {
    /**
     * The data used to create many books_progresses.
     * 
    **/
    data: Enumerable<books_progressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * books_progress update
   */
  export type books_progressUpdateArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * The data needed to update a books_progress.
     * 
    **/
    data: XOR<books_progressUpdateInput, books_progressUncheckedUpdateInput>
    /**
     * Choose, which books_progress to update.
     * 
    **/
    where: books_progressWhereUniqueInput
  }


  /**
   * books_progress updateMany
   */
  export type books_progressUpdateManyArgs = {
    /**
     * The data used to update books_progresses.
     * 
    **/
    data: XOR<books_progressUpdateManyMutationInput, books_progressUncheckedUpdateManyInput>
    /**
     * Filter which books_progresses to update
     * 
    **/
    where?: books_progressWhereInput
  }


  /**
   * books_progress upsert
   */
  export type books_progressUpsertArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * The filter to search for the books_progress to update in case it exists.
     * 
    **/
    where: books_progressWhereUniqueInput
    /**
     * In case the books_progress found by the `where` argument doesn't exist, create a new books_progress with this data.
     * 
    **/
    create: XOR<books_progressCreateInput, books_progressUncheckedCreateInput>
    /**
     * In case the books_progress was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<books_progressUpdateInput, books_progressUncheckedUpdateInput>
  }


  /**
   * books_progress delete
   */
  export type books_progressDeleteArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
    /**
     * Filter which books_progress to delete.
     * 
    **/
    where: books_progressWhereUniqueInput
  }


  /**
   * books_progress deleteMany
   */
  export type books_progressDeleteManyArgs = {
    /**
     * Filter which books_progresses to delete
     * 
    **/
    where?: books_progressWhereInput
  }


  /**
   * books_progress: findUniqueOrThrow
   */
  export type books_progressFindUniqueOrThrowArgs = books_progressFindUniqueArgsBase
      

  /**
   * books_progress: findFirstOrThrow
   */
  export type books_progressFindFirstOrThrowArgs = books_progressFindFirstArgsBase
      

  /**
   * books_progress without action
   */
  export type books_progressArgs = {
    /**
     * Select specific fields to fetch from the books_progress
     * 
    **/
    select?: books_progressSelect | null
  }



  /**
   * Model contact_us
   */


  export type AggregateContact_us = {
    _count: Contact_usCountAggregateOutputType | null
    _avg: Contact_usAvgAggregateOutputType | null
    _sum: Contact_usSumAggregateOutputType | null
    _min: Contact_usMinAggregateOutputType | null
    _max: Contact_usMaxAggregateOutputType | null
  }

  export type Contact_usAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Contact_usSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Contact_usMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    subject: string | null
    message: string | null
    date_created: Date | null
  }

  export type Contact_usMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    subject: string | null
    message: string | null
    date_created: Date | null
  }

  export type Contact_usCountAggregateOutputType = {
    id: number
    user_id: number
    subject: number
    message: number
    date_created: number
    _all: number
  }


  export type Contact_usAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Contact_usSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Contact_usMinAggregateInputType = {
    id?: true
    user_id?: true
    subject?: true
    message?: true
    date_created?: true
  }

  export type Contact_usMaxAggregateInputType = {
    id?: true
    user_id?: true
    subject?: true
    message?: true
    date_created?: true
  }

  export type Contact_usCountAggregateInputType = {
    id?: true
    user_id?: true
    subject?: true
    message?: true
    date_created?: true
    _all?: true
  }

  export type Contact_usAggregateArgs = {
    /**
     * Filter which contact_us to aggregate.
     * 
    **/
    where?: contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_uses to fetch.
     * 
    **/
    orderBy?: Enumerable<contact_usOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_uses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_uses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contact_uses
    **/
    _count?: true | Contact_usCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_usAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_usSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_usMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_usMaxAggregateInputType
  }

  export type GetContact_usAggregateType<T extends Contact_usAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_us]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_us[P]>
      : GetScalarType<T[P], AggregateContact_us[P]>
  }




  export type Contact_usGroupByArgs = {
    where?: contact_usWhereInput
    orderBy?: Enumerable<contact_usOrderByWithAggregationInput>
    by: Array<Contact_usScalarFieldEnum>
    having?: contact_usScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_usCountAggregateInputType | true
    _avg?: Contact_usAvgAggregateInputType
    _sum?: Contact_usSumAggregateInputType
    _min?: Contact_usMinAggregateInputType
    _max?: Contact_usMaxAggregateInputType
  }


  export type Contact_usGroupByOutputType = {
    id: number
    user_id: number | null
    subject: string | null
    message: string | null
    date_created: Date | null
    _count: Contact_usCountAggregateOutputType | null
    _avg: Contact_usAvgAggregateOutputType | null
    _sum: Contact_usSumAggregateOutputType | null
    _min: Contact_usMinAggregateOutputType | null
    _max: Contact_usMaxAggregateOutputType | null
  }

  type GetContact_usGroupByPayload<T extends Contact_usGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Contact_usGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_usGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_usGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_usGroupByOutputType[P]>
        }
      >
    >


  export type contact_usSelect = {
    id?: boolean
    user_id?: boolean
    subject?: boolean
    message?: boolean
    date_created?: boolean
  }


  export type contact_usGetPayload<S extends boolean | null | undefined | contact_usArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? contact_us :
    S extends undefined ? never :
    S extends { include: any } & (contact_usArgs | contact_usFindManyArgs)
    ? contact_us 
    : S extends { select: any } & (contact_usArgs | contact_usFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof contact_us ? contact_us[P] : never
  } 
      : contact_us


  type contact_usCountArgs = Merge<
    Omit<contact_usFindManyArgs, 'select' | 'include'> & {
      select?: Contact_usCountAggregateInputType | true
    }
  >

  export interface contact_usDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Contact_us that matches the filter.
     * @param {contact_usFindUniqueArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contact_usFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, contact_usFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'contact_us'> extends True ? Prisma__contact_usClient<contact_usGetPayload<T>> : Prisma__contact_usClient<contact_usGetPayload<T> | null, null>

    /**
     * Find the first Contact_us that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_usFindFirstArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contact_usFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, contact_usFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'contact_us'> extends True ? Prisma__contact_usClient<contact_usGetPayload<T>> : Prisma__contact_usClient<contact_usGetPayload<T> | null, null>

    /**
     * Find zero or more Contact_uses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_usFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_uses
     * const contact_uses = await prisma.contact_us.findMany()
     * 
     * // Get first 10 Contact_uses
     * const contact_uses = await prisma.contact_us.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_usWithIdOnly = await prisma.contact_us.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contact_usFindManyArgs>(
      args?: SelectSubset<T, contact_usFindManyArgs>
    ): PrismaPromise<Array<contact_usGetPayload<T>>>

    /**
     * Create a Contact_us.
     * @param {contact_usCreateArgs} args - Arguments to create a Contact_us.
     * @example
     * // Create one Contact_us
     * const Contact_us = await prisma.contact_us.create({
     *   data: {
     *     // ... data to create a Contact_us
     *   }
     * })
     * 
    **/
    create<T extends contact_usCreateArgs>(
      args: SelectSubset<T, contact_usCreateArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Create many Contact_uses.
     *     @param {contact_usCreateManyArgs} args - Arguments to create many Contact_uses.
     *     @example
     *     // Create many Contact_uses
     *     const contact_us = await prisma.contact_us.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contact_usCreateManyArgs>(
      args?: SelectSubset<T, contact_usCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Contact_us.
     * @param {contact_usDeleteArgs} args - Arguments to delete one Contact_us.
     * @example
     * // Delete one Contact_us
     * const Contact_us = await prisma.contact_us.delete({
     *   where: {
     *     // ... filter to delete one Contact_us
     *   }
     * })
     * 
    **/
    delete<T extends contact_usDeleteArgs>(
      args: SelectSubset<T, contact_usDeleteArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Update one Contact_us.
     * @param {contact_usUpdateArgs} args - Arguments to update one Contact_us.
     * @example
     * // Update one Contact_us
     * const contact_us = await prisma.contact_us.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contact_usUpdateArgs>(
      args: SelectSubset<T, contact_usUpdateArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Delete zero or more Contact_uses.
     * @param {contact_usDeleteManyArgs} args - Arguments to filter Contact_uses to delete.
     * @example
     * // Delete a few Contact_uses
     * const { count } = await prisma.contact_us.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contact_usDeleteManyArgs>(
      args?: SelectSubset<T, contact_usDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_uses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_usUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_uses
     * const contact_us = await prisma.contact_us.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contact_usUpdateManyArgs>(
      args: SelectSubset<T, contact_usUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_us.
     * @param {contact_usUpsertArgs} args - Arguments to update or create a Contact_us.
     * @example
     * // Update or create a Contact_us
     * const contact_us = await prisma.contact_us.upsert({
     *   create: {
     *     // ... data to create a Contact_us
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_us we want to update
     *   }
     * })
    **/
    upsert<T extends contact_usUpsertArgs>(
      args: SelectSubset<T, contact_usUpsertArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Find one Contact_us that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {contact_usFindUniqueOrThrowArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contact_usFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, contact_usFindUniqueOrThrowArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Find the first Contact_us that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_usFindFirstOrThrowArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contact_usFindFirstOrThrowArgs>(
      args?: SelectSubset<T, contact_usFindFirstOrThrowArgs>
    ): Prisma__contact_usClient<contact_usGetPayload<T>>

    /**
     * Count the number of Contact_uses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_usCountArgs} args - Arguments to filter Contact_uses to count.
     * @example
     * // Count the number of Contact_uses
     * const count = await prisma.contact_us.count({
     *   where: {
     *     // ... the filter for the Contact_uses we want to count
     *   }
     * })
    **/
    count<T extends contact_usCountArgs>(
      args?: Subset<T, contact_usCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_usCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_us.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_usAggregateArgs>(args: Subset<T, Contact_usAggregateArgs>): PrismaPromise<GetContact_usAggregateType<T>>

    /**
     * Group by Contact_us.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_usGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_usGroupByArgs['orderBy'] }
        : { orderBy?: Contact_usGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_usGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_usGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for contact_us.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contact_usClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * contact_us base type for findUnique actions
   */
  export type contact_usFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * Filter, which contact_us to fetch.
     * 
    **/
    where: contact_usWhereUniqueInput
  }

  /**
   * contact_us: findUnique
   */
  export interface contact_usFindUniqueArgs extends contact_usFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contact_us base type for findFirst actions
   */
  export type contact_usFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * Filter, which contact_us to fetch.
     * 
    **/
    where?: contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_uses to fetch.
     * 
    **/
    orderBy?: Enumerable<contact_usOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_uses.
     * 
    **/
    cursor?: contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_uses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_uses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_uses.
     * 
    **/
    distinct?: Enumerable<Contact_usScalarFieldEnum>
  }

  /**
   * contact_us: findFirst
   */
  export interface contact_usFindFirstArgs extends contact_usFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contact_us findMany
   */
  export type contact_usFindManyArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * Filter, which contact_uses to fetch.
     * 
    **/
    where?: contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_uses to fetch.
     * 
    **/
    orderBy?: Enumerable<contact_usOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contact_uses.
     * 
    **/
    cursor?: contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_uses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_uses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Contact_usScalarFieldEnum>
  }


  /**
   * contact_us create
   */
  export type contact_usCreateArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * The data needed to create a contact_us.
     * 
    **/
    data: XOR<contact_usCreateInput, contact_usUncheckedCreateInput>
  }


  /**
   * contact_us createMany
   */
  export type contact_usCreateManyArgs = {
    /**
     * The data used to create many contact_uses.
     * 
    **/
    data: Enumerable<contact_usCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * contact_us update
   */
  export type contact_usUpdateArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * The data needed to update a contact_us.
     * 
    **/
    data: XOR<contact_usUpdateInput, contact_usUncheckedUpdateInput>
    /**
     * Choose, which contact_us to update.
     * 
    **/
    where: contact_usWhereUniqueInput
  }


  /**
   * contact_us updateMany
   */
  export type contact_usUpdateManyArgs = {
    /**
     * The data used to update contact_uses.
     * 
    **/
    data: XOR<contact_usUpdateManyMutationInput, contact_usUncheckedUpdateManyInput>
    /**
     * Filter which contact_uses to update
     * 
    **/
    where?: contact_usWhereInput
  }


  /**
   * contact_us upsert
   */
  export type contact_usUpsertArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * The filter to search for the contact_us to update in case it exists.
     * 
    **/
    where: contact_usWhereUniqueInput
    /**
     * In case the contact_us found by the `where` argument doesn't exist, create a new contact_us with this data.
     * 
    **/
    create: XOR<contact_usCreateInput, contact_usUncheckedCreateInput>
    /**
     * In case the contact_us was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<contact_usUpdateInput, contact_usUncheckedUpdateInput>
  }


  /**
   * contact_us delete
   */
  export type contact_usDeleteArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
    /**
     * Filter which contact_us to delete.
     * 
    **/
    where: contact_usWhereUniqueInput
  }


  /**
   * contact_us deleteMany
   */
  export type contact_usDeleteManyArgs = {
    /**
     * Filter which contact_uses to delete
     * 
    **/
    where?: contact_usWhereInput
  }


  /**
   * contact_us: findUniqueOrThrow
   */
  export type contact_usFindUniqueOrThrowArgs = contact_usFindUniqueArgsBase
      

  /**
   * contact_us: findFirstOrThrow
   */
  export type contact_usFindFirstOrThrowArgs = contact_usFindFirstArgsBase
      

  /**
   * contact_us without action
   */
  export type contact_usArgs = {
    /**
     * Select specific fields to fetch from the contact_us
     * 
    **/
    select?: contact_usSelect | null
  }



  /**
   * Model copyright_mapping
   */


  export type AggregateCopyright_mapping = {
    _count: Copyright_mappingCountAggregateOutputType | null
    _avg: Copyright_mappingAvgAggregateOutputType | null
    _sum: Copyright_mappingSumAggregateOutputType | null
    _min: Copyright_mappingMinAggregateOutputType | null
    _max: Copyright_mappingMaxAggregateOutputType | null
  }

  export type Copyright_mappingAvgAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
  }

  export type Copyright_mappingSumAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
  }

  export type Copyright_mappingMinAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    date_created: Date | null
  }

  export type Copyright_mappingMaxAggregateOutputType = {
    id: number | null
    copyright_owner: number | null
    author_id: number | null
    date_created: Date | null
  }

  export type Copyright_mappingCountAggregateOutputType = {
    id: number
    copyright_owner: number
    author_id: number
    date_created: number
    _all: number
  }


  export type Copyright_mappingAvgAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
  }

  export type Copyright_mappingSumAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
  }

  export type Copyright_mappingMinAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    date_created?: true
  }

  export type Copyright_mappingMaxAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    date_created?: true
  }

  export type Copyright_mappingCountAggregateInputType = {
    id?: true
    copyright_owner?: true
    author_id?: true
    date_created?: true
    _all?: true
  }

  export type Copyright_mappingAggregateArgs = {
    /**
     * Filter which copyright_mapping to aggregate.
     * 
    **/
    where?: copyright_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of copyright_mappings to fetch.
     * 
    **/
    orderBy?: Enumerable<copyright_mappingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: copyright_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` copyright_mappings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` copyright_mappings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned copyright_mappings
    **/
    _count?: true | Copyright_mappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Copyright_mappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Copyright_mappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Copyright_mappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Copyright_mappingMaxAggregateInputType
  }

  export type GetCopyright_mappingAggregateType<T extends Copyright_mappingAggregateArgs> = {
        [P in keyof T & keyof AggregateCopyright_mapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCopyright_mapping[P]>
      : GetScalarType<T[P], AggregateCopyright_mapping[P]>
  }




  export type Copyright_mappingGroupByArgs = {
    where?: copyright_mappingWhereInput
    orderBy?: Enumerable<copyright_mappingOrderByWithAggregationInput>
    by: Array<Copyright_mappingScalarFieldEnum>
    having?: copyright_mappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Copyright_mappingCountAggregateInputType | true
    _avg?: Copyright_mappingAvgAggregateInputType
    _sum?: Copyright_mappingSumAggregateInputType
    _min?: Copyright_mappingMinAggregateInputType
    _max?: Copyright_mappingMaxAggregateInputType
  }


  export type Copyright_mappingGroupByOutputType = {
    id: number
    copyright_owner: number | null
    author_id: number | null
    date_created: Date | null
    _count: Copyright_mappingCountAggregateOutputType | null
    _avg: Copyright_mappingAvgAggregateOutputType | null
    _sum: Copyright_mappingSumAggregateOutputType | null
    _min: Copyright_mappingMinAggregateOutputType | null
    _max: Copyright_mappingMaxAggregateOutputType | null
  }

  type GetCopyright_mappingGroupByPayload<T extends Copyright_mappingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Copyright_mappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Copyright_mappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Copyright_mappingGroupByOutputType[P]>
            : GetScalarType<T[P], Copyright_mappingGroupByOutputType[P]>
        }
      >
    >


  export type copyright_mappingSelect = {
    id?: boolean
    copyright_owner?: boolean
    author_id?: boolean
    date_created?: boolean
  }


  export type copyright_mappingGetPayload<S extends boolean | null | undefined | copyright_mappingArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? copyright_mapping :
    S extends undefined ? never :
    S extends { include: any } & (copyright_mappingArgs | copyright_mappingFindManyArgs)
    ? copyright_mapping 
    : S extends { select: any } & (copyright_mappingArgs | copyright_mappingFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof copyright_mapping ? copyright_mapping[P] : never
  } 
      : copyright_mapping


  type copyright_mappingCountArgs = Merge<
    Omit<copyright_mappingFindManyArgs, 'select' | 'include'> & {
      select?: Copyright_mappingCountAggregateInputType | true
    }
  >

  export interface copyright_mappingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Copyright_mapping that matches the filter.
     * @param {copyright_mappingFindUniqueArgs} args - Arguments to find a Copyright_mapping
     * @example
     * // Get one Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends copyright_mappingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, copyright_mappingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'copyright_mapping'> extends True ? Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>> : Prisma__copyright_mappingClient<copyright_mappingGetPayload<T> | null, null>

    /**
     * Find the first Copyright_mapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {copyright_mappingFindFirstArgs} args - Arguments to find a Copyright_mapping
     * @example
     * // Get one Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends copyright_mappingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, copyright_mappingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'copyright_mapping'> extends True ? Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>> : Prisma__copyright_mappingClient<copyright_mappingGetPayload<T> | null, null>

    /**
     * Find zero or more Copyright_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {copyright_mappingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Copyright_mappings
     * const copyright_mappings = await prisma.copyright_mapping.findMany()
     * 
     * // Get first 10 Copyright_mappings
     * const copyright_mappings = await prisma.copyright_mapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const copyright_mappingWithIdOnly = await prisma.copyright_mapping.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends copyright_mappingFindManyArgs>(
      args?: SelectSubset<T, copyright_mappingFindManyArgs>
    ): PrismaPromise<Array<copyright_mappingGetPayload<T>>>

    /**
     * Create a Copyright_mapping.
     * @param {copyright_mappingCreateArgs} args - Arguments to create a Copyright_mapping.
     * @example
     * // Create one Copyright_mapping
     * const Copyright_mapping = await prisma.copyright_mapping.create({
     *   data: {
     *     // ... data to create a Copyright_mapping
     *   }
     * })
     * 
    **/
    create<T extends copyright_mappingCreateArgs>(
      args: SelectSubset<T, copyright_mappingCreateArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Create many Copyright_mappings.
     *     @param {copyright_mappingCreateManyArgs} args - Arguments to create many Copyright_mappings.
     *     @example
     *     // Create many Copyright_mappings
     *     const copyright_mapping = await prisma.copyright_mapping.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends copyright_mappingCreateManyArgs>(
      args?: SelectSubset<T, copyright_mappingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Copyright_mapping.
     * @param {copyright_mappingDeleteArgs} args - Arguments to delete one Copyright_mapping.
     * @example
     * // Delete one Copyright_mapping
     * const Copyright_mapping = await prisma.copyright_mapping.delete({
     *   where: {
     *     // ... filter to delete one Copyright_mapping
     *   }
     * })
     * 
    **/
    delete<T extends copyright_mappingDeleteArgs>(
      args: SelectSubset<T, copyright_mappingDeleteArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Update one Copyright_mapping.
     * @param {copyright_mappingUpdateArgs} args - Arguments to update one Copyright_mapping.
     * @example
     * // Update one Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends copyright_mappingUpdateArgs>(
      args: SelectSubset<T, copyright_mappingUpdateArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Delete zero or more Copyright_mappings.
     * @param {copyright_mappingDeleteManyArgs} args - Arguments to filter Copyright_mappings to delete.
     * @example
     * // Delete a few Copyright_mappings
     * const { count } = await prisma.copyright_mapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends copyright_mappingDeleteManyArgs>(
      args?: SelectSubset<T, copyright_mappingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Copyright_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {copyright_mappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Copyright_mappings
     * const copyright_mapping = await prisma.copyright_mapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends copyright_mappingUpdateManyArgs>(
      args: SelectSubset<T, copyright_mappingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Copyright_mapping.
     * @param {copyright_mappingUpsertArgs} args - Arguments to update or create a Copyright_mapping.
     * @example
     * // Update or create a Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.upsert({
     *   create: {
     *     // ... data to create a Copyright_mapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Copyright_mapping we want to update
     *   }
     * })
    **/
    upsert<T extends copyright_mappingUpsertArgs>(
      args: SelectSubset<T, copyright_mappingUpsertArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Find one Copyright_mapping that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {copyright_mappingFindUniqueOrThrowArgs} args - Arguments to find a Copyright_mapping
     * @example
     * // Get one Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends copyright_mappingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, copyright_mappingFindUniqueOrThrowArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Find the first Copyright_mapping that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {copyright_mappingFindFirstOrThrowArgs} args - Arguments to find a Copyright_mapping
     * @example
     * // Get one Copyright_mapping
     * const copyright_mapping = await prisma.copyright_mapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends copyright_mappingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, copyright_mappingFindFirstOrThrowArgs>
    ): Prisma__copyright_mappingClient<copyright_mappingGetPayload<T>>

    /**
     * Count the number of Copyright_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {copyright_mappingCountArgs} args - Arguments to filter Copyright_mappings to count.
     * @example
     * // Count the number of Copyright_mappings
     * const count = await prisma.copyright_mapping.count({
     *   where: {
     *     // ... the filter for the Copyright_mappings we want to count
     *   }
     * })
    **/
    count<T extends copyright_mappingCountArgs>(
      args?: Subset<T, copyright_mappingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Copyright_mappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Copyright_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Copyright_mappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Copyright_mappingAggregateArgs>(args: Subset<T, Copyright_mappingAggregateArgs>): PrismaPromise<GetCopyright_mappingAggregateType<T>>

    /**
     * Group by Copyright_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Copyright_mappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Copyright_mappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Copyright_mappingGroupByArgs['orderBy'] }
        : { orderBy?: Copyright_mappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Copyright_mappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCopyright_mappingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for copyright_mapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__copyright_mappingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * copyright_mapping base type for findUnique actions
   */
  export type copyright_mappingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * Filter, which copyright_mapping to fetch.
     * 
    **/
    where: copyright_mappingWhereUniqueInput
  }

  /**
   * copyright_mapping: findUnique
   */
  export interface copyright_mappingFindUniqueArgs extends copyright_mappingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * copyright_mapping base type for findFirst actions
   */
  export type copyright_mappingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * Filter, which copyright_mapping to fetch.
     * 
    **/
    where?: copyright_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of copyright_mappings to fetch.
     * 
    **/
    orderBy?: Enumerable<copyright_mappingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for copyright_mappings.
     * 
    **/
    cursor?: copyright_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` copyright_mappings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` copyright_mappings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of copyright_mappings.
     * 
    **/
    distinct?: Enumerable<Copyright_mappingScalarFieldEnum>
  }

  /**
   * copyright_mapping: findFirst
   */
  export interface copyright_mappingFindFirstArgs extends copyright_mappingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * copyright_mapping findMany
   */
  export type copyright_mappingFindManyArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * Filter, which copyright_mappings to fetch.
     * 
    **/
    where?: copyright_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of copyright_mappings to fetch.
     * 
    **/
    orderBy?: Enumerable<copyright_mappingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing copyright_mappings.
     * 
    **/
    cursor?: copyright_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` copyright_mappings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` copyright_mappings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Copyright_mappingScalarFieldEnum>
  }


  /**
   * copyright_mapping create
   */
  export type copyright_mappingCreateArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * The data needed to create a copyright_mapping.
     * 
    **/
    data: XOR<copyright_mappingCreateInput, copyright_mappingUncheckedCreateInput>
  }


  /**
   * copyright_mapping createMany
   */
  export type copyright_mappingCreateManyArgs = {
    /**
     * The data used to create many copyright_mappings.
     * 
    **/
    data: Enumerable<copyright_mappingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * copyright_mapping update
   */
  export type copyright_mappingUpdateArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * The data needed to update a copyright_mapping.
     * 
    **/
    data: XOR<copyright_mappingUpdateInput, copyright_mappingUncheckedUpdateInput>
    /**
     * Choose, which copyright_mapping to update.
     * 
    **/
    where: copyright_mappingWhereUniqueInput
  }


  /**
   * copyright_mapping updateMany
   */
  export type copyright_mappingUpdateManyArgs = {
    /**
     * The data used to update copyright_mappings.
     * 
    **/
    data: XOR<copyright_mappingUpdateManyMutationInput, copyright_mappingUncheckedUpdateManyInput>
    /**
     * Filter which copyright_mappings to update
     * 
    **/
    where?: copyright_mappingWhereInput
  }


  /**
   * copyright_mapping upsert
   */
  export type copyright_mappingUpsertArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * The filter to search for the copyright_mapping to update in case it exists.
     * 
    **/
    where: copyright_mappingWhereUniqueInput
    /**
     * In case the copyright_mapping found by the `where` argument doesn't exist, create a new copyright_mapping with this data.
     * 
    **/
    create: XOR<copyright_mappingCreateInput, copyright_mappingUncheckedCreateInput>
    /**
     * In case the copyright_mapping was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<copyright_mappingUpdateInput, copyright_mappingUncheckedUpdateInput>
  }


  /**
   * copyright_mapping delete
   */
  export type copyright_mappingDeleteArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
    /**
     * Filter which copyright_mapping to delete.
     * 
    **/
    where: copyright_mappingWhereUniqueInput
  }


  /**
   * copyright_mapping deleteMany
   */
  export type copyright_mappingDeleteManyArgs = {
    /**
     * Filter which copyright_mappings to delete
     * 
    **/
    where?: copyright_mappingWhereInput
  }


  /**
   * copyright_mapping: findUniqueOrThrow
   */
  export type copyright_mappingFindUniqueOrThrowArgs = copyright_mappingFindUniqueArgsBase
      

  /**
   * copyright_mapping: findFirstOrThrow
   */
  export type copyright_mappingFindFirstOrThrowArgs = copyright_mappingFindFirstArgsBase
      

  /**
   * copyright_mapping without action
   */
  export type copyright_mappingArgs = {
    /**
     * Select specific fields to fetch from the copyright_mapping
     * 
    **/
    select?: copyright_mappingSelect | null
  }



  /**
   * Model episode_book_details
   */


  export type AggregateEpisode_book_details = {
    _count: Episode_book_detailsCountAggregateOutputType | null
    _avg: Episode_book_detailsAvgAggregateOutputType | null
    _sum: Episode_book_detailsSumAggregateOutputType | null
    _min: Episode_book_detailsMinAggregateOutputType | null
    _max: Episode_book_detailsMaxAggregateOutputType | null
  }

  export type Episode_book_detailsAvgAggregateOutputType = {
    id: number | null
    episode_book_id: number | null
    chapter_num_pages: number | null
    chapter_status: number | null
  }

  export type Episode_book_detailsSumAggregateOutputType = {
    id: number | null
    episode_book_id: number | null
    chapter_num_pages: number | null
    chapter_status: number | null
  }

  export type Episode_book_detailsMinAggregateOutputType = {
    id: number | null
    episode_book_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_epub_url: string | null
    chapter_num_pages: number | null
    chapter_status: number | null
    chapter_activated_at: Date | null
  }

  export type Episode_book_detailsMaxAggregateOutputType = {
    id: number | null
    episode_book_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_epub_url: string | null
    chapter_num_pages: number | null
    chapter_status: number | null
    chapter_activated_at: Date | null
  }

  export type Episode_book_detailsCountAggregateOutputType = {
    id: number
    episode_book_id: number
    chapter_name: number
    chapter_name_english: number
    chapter_epub_url: number
    chapter_num_pages: number
    chapter_status: number
    chapter_activated_at: number
    _all: number
  }


  export type Episode_book_detailsAvgAggregateInputType = {
    id?: true
    episode_book_id?: true
    chapter_num_pages?: true
    chapter_status?: true
  }

  export type Episode_book_detailsSumAggregateInputType = {
    id?: true
    episode_book_id?: true
    chapter_num_pages?: true
    chapter_status?: true
  }

  export type Episode_book_detailsMinAggregateInputType = {
    id?: true
    episode_book_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_epub_url?: true
    chapter_num_pages?: true
    chapter_status?: true
    chapter_activated_at?: true
  }

  export type Episode_book_detailsMaxAggregateInputType = {
    id?: true
    episode_book_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_epub_url?: true
    chapter_num_pages?: true
    chapter_status?: true
    chapter_activated_at?: true
  }

  export type Episode_book_detailsCountAggregateInputType = {
    id?: true
    episode_book_id?: true
    chapter_name?: true
    chapter_name_english?: true
    chapter_epub_url?: true
    chapter_num_pages?: true
    chapter_status?: true
    chapter_activated_at?: true
    _all?: true
  }

  export type Episode_book_detailsAggregateArgs = {
    /**
     * Filter which episode_book_details to aggregate.
     * 
    **/
    where?: episode_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: episode_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned episode_book_details
    **/
    _count?: true | Episode_book_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Episode_book_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Episode_book_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Episode_book_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Episode_book_detailsMaxAggregateInputType
  }

  export type GetEpisode_book_detailsAggregateType<T extends Episode_book_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode_book_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode_book_details[P]>
      : GetScalarType<T[P], AggregateEpisode_book_details[P]>
  }




  export type Episode_book_detailsGroupByArgs = {
    where?: episode_book_detailsWhereInput
    orderBy?: Enumerable<episode_book_detailsOrderByWithAggregationInput>
    by: Array<Episode_book_detailsScalarFieldEnum>
    having?: episode_book_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Episode_book_detailsCountAggregateInputType | true
    _avg?: Episode_book_detailsAvgAggregateInputType
    _sum?: Episode_book_detailsSumAggregateInputType
    _min?: Episode_book_detailsMinAggregateInputType
    _max?: Episode_book_detailsMaxAggregateInputType
  }


  export type Episode_book_detailsGroupByOutputType = {
    id: number
    episode_book_id: number | null
    chapter_name: string | null
    chapter_name_english: string | null
    chapter_epub_url: string | null
    chapter_num_pages: number | null
    chapter_status: number | null
    chapter_activated_at: Date | null
    _count: Episode_book_detailsCountAggregateOutputType | null
    _avg: Episode_book_detailsAvgAggregateOutputType | null
    _sum: Episode_book_detailsSumAggregateOutputType | null
    _min: Episode_book_detailsMinAggregateOutputType | null
    _max: Episode_book_detailsMaxAggregateOutputType | null
  }

  type GetEpisode_book_detailsGroupByPayload<T extends Episode_book_detailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Episode_book_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Episode_book_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Episode_book_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Episode_book_detailsGroupByOutputType[P]>
        }
      >
    >


  export type episode_book_detailsSelect = {
    id?: boolean
    episode_book_id?: boolean
    chapter_name?: boolean
    chapter_name_english?: boolean
    chapter_epub_url?: boolean
    chapter_num_pages?: boolean
    chapter_status?: boolean
    chapter_activated_at?: boolean
  }


  export type episode_book_detailsGetPayload<S extends boolean | null | undefined | episode_book_detailsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? episode_book_details :
    S extends undefined ? never :
    S extends { include: any } & (episode_book_detailsArgs | episode_book_detailsFindManyArgs)
    ? episode_book_details 
    : S extends { select: any } & (episode_book_detailsArgs | episode_book_detailsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof episode_book_details ? episode_book_details[P] : never
  } 
      : episode_book_details


  type episode_book_detailsCountArgs = Merge<
    Omit<episode_book_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Episode_book_detailsCountAggregateInputType | true
    }
  >

  export interface episode_book_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Episode_book_details that matches the filter.
     * @param {episode_book_detailsFindUniqueArgs} args - Arguments to find a Episode_book_details
     * @example
     * // Get one Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends episode_book_detailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, episode_book_detailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'episode_book_details'> extends True ? Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>> : Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T> | null, null>

    /**
     * Find the first Episode_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_detailsFindFirstArgs} args - Arguments to find a Episode_book_details
     * @example
     * // Get one Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends episode_book_detailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, episode_book_detailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'episode_book_details'> extends True ? Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>> : Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T> | null, null>

    /**
     * Find zero or more Episode_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findMany()
     * 
     * // Get first 10 Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const episode_book_detailsWithIdOnly = await prisma.episode_book_details.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends episode_book_detailsFindManyArgs>(
      args?: SelectSubset<T, episode_book_detailsFindManyArgs>
    ): PrismaPromise<Array<episode_book_detailsGetPayload<T>>>

    /**
     * Create a Episode_book_details.
     * @param {episode_book_detailsCreateArgs} args - Arguments to create a Episode_book_details.
     * @example
     * // Create one Episode_book_details
     * const Episode_book_details = await prisma.episode_book_details.create({
     *   data: {
     *     // ... data to create a Episode_book_details
     *   }
     * })
     * 
    **/
    create<T extends episode_book_detailsCreateArgs>(
      args: SelectSubset<T, episode_book_detailsCreateArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Create many Episode_book_details.
     *     @param {episode_book_detailsCreateManyArgs} args - Arguments to create many Episode_book_details.
     *     @example
     *     // Create many Episode_book_details
     *     const episode_book_details = await prisma.episode_book_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends episode_book_detailsCreateManyArgs>(
      args?: SelectSubset<T, episode_book_detailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Episode_book_details.
     * @param {episode_book_detailsDeleteArgs} args - Arguments to delete one Episode_book_details.
     * @example
     * // Delete one Episode_book_details
     * const Episode_book_details = await prisma.episode_book_details.delete({
     *   where: {
     *     // ... filter to delete one Episode_book_details
     *   }
     * })
     * 
    **/
    delete<T extends episode_book_detailsDeleteArgs>(
      args: SelectSubset<T, episode_book_detailsDeleteArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Update one Episode_book_details.
     * @param {episode_book_detailsUpdateArgs} args - Arguments to update one Episode_book_details.
     * @example
     * // Update one Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends episode_book_detailsUpdateArgs>(
      args: SelectSubset<T, episode_book_detailsUpdateArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Delete zero or more Episode_book_details.
     * @param {episode_book_detailsDeleteManyArgs} args - Arguments to filter Episode_book_details to delete.
     * @example
     * // Delete a few Episode_book_details
     * const { count } = await prisma.episode_book_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends episode_book_detailsDeleteManyArgs>(
      args?: SelectSubset<T, episode_book_detailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episode_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends episode_book_detailsUpdateManyArgs>(
      args: SelectSubset<T, episode_book_detailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Episode_book_details.
     * @param {episode_book_detailsUpsertArgs} args - Arguments to update or create a Episode_book_details.
     * @example
     * // Update or create a Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.upsert({
     *   create: {
     *     // ... data to create a Episode_book_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode_book_details we want to update
     *   }
     * })
    **/
    upsert<T extends episode_book_detailsUpsertArgs>(
      args: SelectSubset<T, episode_book_detailsUpsertArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Find one Episode_book_details that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {episode_book_detailsFindUniqueOrThrowArgs} args - Arguments to find a Episode_book_details
     * @example
     * // Get one Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends episode_book_detailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, episode_book_detailsFindUniqueOrThrowArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Find the first Episode_book_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_detailsFindFirstOrThrowArgs} args - Arguments to find a Episode_book_details
     * @example
     * // Get one Episode_book_details
     * const episode_book_details = await prisma.episode_book_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends episode_book_detailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, episode_book_detailsFindFirstOrThrowArgs>
    ): Prisma__episode_book_detailsClient<episode_book_detailsGetPayload<T>>

    /**
     * Count the number of Episode_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_detailsCountArgs} args - Arguments to filter Episode_book_details to count.
     * @example
     * // Count the number of Episode_book_details
     * const count = await prisma.episode_book_details.count({
     *   where: {
     *     // ... the filter for the Episode_book_details we want to count
     *   }
     * })
    **/
    count<T extends episode_book_detailsCountArgs>(
      args?: Subset<T, episode_book_detailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Episode_book_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_book_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Episode_book_detailsAggregateArgs>(args: Subset<T, Episode_book_detailsAggregateArgs>): PrismaPromise<GetEpisode_book_detailsAggregateType<T>>

    /**
     * Group by Episode_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_book_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Episode_book_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Episode_book_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Episode_book_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Episode_book_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisode_book_detailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for episode_book_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__episode_book_detailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * episode_book_details base type for findUnique actions
   */
  export type episode_book_detailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * Filter, which episode_book_details to fetch.
     * 
    **/
    where: episode_book_detailsWhereUniqueInput
  }

  /**
   * episode_book_details: findUnique
   */
  export interface episode_book_detailsFindUniqueArgs extends episode_book_detailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_book_details base type for findFirst actions
   */
  export type episode_book_detailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * Filter, which episode_book_details to fetch.
     * 
    **/
    where?: episode_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episode_book_details.
     * 
    **/
    cursor?: episode_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episode_book_details.
     * 
    **/
    distinct?: Enumerable<Episode_book_detailsScalarFieldEnum>
  }

  /**
   * episode_book_details: findFirst
   */
  export interface episode_book_detailsFindFirstArgs extends episode_book_detailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_book_details findMany
   */
  export type episode_book_detailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * Filter, which episode_book_details to fetch.
     * 
    **/
    where?: episode_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing episode_book_details.
     * 
    **/
    cursor?: episode_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_details.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Episode_book_detailsScalarFieldEnum>
  }


  /**
   * episode_book_details create
   */
  export type episode_book_detailsCreateArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * The data needed to create a episode_book_details.
     * 
    **/
    data: XOR<episode_book_detailsCreateInput, episode_book_detailsUncheckedCreateInput>
  }


  /**
   * episode_book_details createMany
   */
  export type episode_book_detailsCreateManyArgs = {
    /**
     * The data used to create many episode_book_details.
     * 
    **/
    data: Enumerable<episode_book_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * episode_book_details update
   */
  export type episode_book_detailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * The data needed to update a episode_book_details.
     * 
    **/
    data: XOR<episode_book_detailsUpdateInput, episode_book_detailsUncheckedUpdateInput>
    /**
     * Choose, which episode_book_details to update.
     * 
    **/
    where: episode_book_detailsWhereUniqueInput
  }


  /**
   * episode_book_details updateMany
   */
  export type episode_book_detailsUpdateManyArgs = {
    /**
     * The data used to update episode_book_details.
     * 
    **/
    data: XOR<episode_book_detailsUpdateManyMutationInput, episode_book_detailsUncheckedUpdateManyInput>
    /**
     * Filter which episode_book_details to update
     * 
    **/
    where?: episode_book_detailsWhereInput
  }


  /**
   * episode_book_details upsert
   */
  export type episode_book_detailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * The filter to search for the episode_book_details to update in case it exists.
     * 
    **/
    where: episode_book_detailsWhereUniqueInput
    /**
     * In case the episode_book_details found by the `where` argument doesn't exist, create a new episode_book_details with this data.
     * 
    **/
    create: XOR<episode_book_detailsCreateInput, episode_book_detailsUncheckedCreateInput>
    /**
     * In case the episode_book_details was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<episode_book_detailsUpdateInput, episode_book_detailsUncheckedUpdateInput>
  }


  /**
   * episode_book_details delete
   */
  export type episode_book_detailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
    /**
     * Filter which episode_book_details to delete.
     * 
    **/
    where: episode_book_detailsWhereUniqueInput
  }


  /**
   * episode_book_details deleteMany
   */
  export type episode_book_detailsDeleteManyArgs = {
    /**
     * Filter which episode_book_details to delete
     * 
    **/
    where?: episode_book_detailsWhereInput
  }


  /**
   * episode_book_details: findUniqueOrThrow
   */
  export type episode_book_detailsFindUniqueOrThrowArgs = episode_book_detailsFindUniqueArgsBase
      

  /**
   * episode_book_details: findFirstOrThrow
   */
  export type episode_book_detailsFindFirstOrThrowArgs = episode_book_detailsFindFirstArgsBase
      

  /**
   * episode_book_details without action
   */
  export type episode_book_detailsArgs = {
    /**
     * Select specific fields to fetch from the episode_book_details
     * 
    **/
    select?: episode_book_detailsSelect | null
  }



  /**
   * Model episode_book_tbl
   */


  export type AggregateEpisode_book_tbl = {
    _count: Episode_book_tblCountAggregateOutputType | null
    _avg: Episode_book_tblAvgAggregateOutputType | null
    _sum: Episode_book_tblSumAggregateOutputType | null
    _min: Episode_book_tblMinAggregateOutputType | null
    _max: Episode_book_tblMaxAggregateOutputType | null
  }

  export type Episode_book_tblAvgAggregateOutputType = {
    episode_book_id: number | null
    author_id: number | null
    language: number | null
    type_of_book: number | null
    genre_id: number | null
    status: number | null
  }

  export type Episode_book_tblSumAggregateOutputType = {
    episode_book_id: number | null
    author_id: number | null
    language: number | null
    type_of_book: number | null
    genre_id: number | null
    status: number | null
  }

  export type Episode_book_tblMinAggregateOutputType = {
    episode_book_id: number | null
    book_title: string | null
    author_id: number | null
    url_name: string | null
    cover_image: string | null
    regional_book_title: string | null
    language: number | null
    type_of_book: number | null
    genre_id: number | null
    book_category: string | null
    description: string | null
    status: number | null
    day_of_chapter: string | null
    activated_at: Date | null
  }

  export type Episode_book_tblMaxAggregateOutputType = {
    episode_book_id: number | null
    book_title: string | null
    author_id: number | null
    url_name: string | null
    cover_image: string | null
    regional_book_title: string | null
    language: number | null
    type_of_book: number | null
    genre_id: number | null
    book_category: string | null
    description: string | null
    status: number | null
    day_of_chapter: string | null
    activated_at: Date | null
  }

  export type Episode_book_tblCountAggregateOutputType = {
    episode_book_id: number
    book_title: number
    author_id: number
    url_name: number
    cover_image: number
    regional_book_title: number
    language: number
    type_of_book: number
    genre_id: number
    book_category: number
    description: number
    status: number
    day_of_chapter: number
    activated_at: number
    _all: number
  }


  export type Episode_book_tblAvgAggregateInputType = {
    episode_book_id?: true
    author_id?: true
    language?: true
    type_of_book?: true
    genre_id?: true
    status?: true
  }

  export type Episode_book_tblSumAggregateInputType = {
    episode_book_id?: true
    author_id?: true
    language?: true
    type_of_book?: true
    genre_id?: true
    status?: true
  }

  export type Episode_book_tblMinAggregateInputType = {
    episode_book_id?: true
    book_title?: true
    author_id?: true
    url_name?: true
    cover_image?: true
    regional_book_title?: true
    language?: true
    type_of_book?: true
    genre_id?: true
    book_category?: true
    description?: true
    status?: true
    day_of_chapter?: true
    activated_at?: true
  }

  export type Episode_book_tblMaxAggregateInputType = {
    episode_book_id?: true
    book_title?: true
    author_id?: true
    url_name?: true
    cover_image?: true
    regional_book_title?: true
    language?: true
    type_of_book?: true
    genre_id?: true
    book_category?: true
    description?: true
    status?: true
    day_of_chapter?: true
    activated_at?: true
  }

  export type Episode_book_tblCountAggregateInputType = {
    episode_book_id?: true
    book_title?: true
    author_id?: true
    url_name?: true
    cover_image?: true
    regional_book_title?: true
    language?: true
    type_of_book?: true
    genre_id?: true
    book_category?: true
    description?: true
    status?: true
    day_of_chapter?: true
    activated_at?: true
    _all?: true
  }

  export type Episode_book_tblAggregateArgs = {
    /**
     * Filter which episode_book_tbl to aggregate.
     * 
    **/
    where?: episode_book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: episode_book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned episode_book_tbls
    **/
    _count?: true | Episode_book_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Episode_book_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Episode_book_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Episode_book_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Episode_book_tblMaxAggregateInputType
  }

  export type GetEpisode_book_tblAggregateType<T extends Episode_book_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode_book_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode_book_tbl[P]>
      : GetScalarType<T[P], AggregateEpisode_book_tbl[P]>
  }




  export type Episode_book_tblGroupByArgs = {
    where?: episode_book_tblWhereInput
    orderBy?: Enumerable<episode_book_tblOrderByWithAggregationInput>
    by: Array<Episode_book_tblScalarFieldEnum>
    having?: episode_book_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Episode_book_tblCountAggregateInputType | true
    _avg?: Episode_book_tblAvgAggregateInputType
    _sum?: Episode_book_tblSumAggregateInputType
    _min?: Episode_book_tblMinAggregateInputType
    _max?: Episode_book_tblMaxAggregateInputType
  }


  export type Episode_book_tblGroupByOutputType = {
    episode_book_id: number
    book_title: string | null
    author_id: number | null
    url_name: string | null
    cover_image: string | null
    regional_book_title: string | null
    language: number | null
    type_of_book: number | null
    genre_id: number | null
    book_category: string | null
    description: string | null
    status: number | null
    day_of_chapter: string | null
    activated_at: Date | null
    _count: Episode_book_tblCountAggregateOutputType | null
    _avg: Episode_book_tblAvgAggregateOutputType | null
    _sum: Episode_book_tblSumAggregateOutputType | null
    _min: Episode_book_tblMinAggregateOutputType | null
    _max: Episode_book_tblMaxAggregateOutputType | null
  }

  type GetEpisode_book_tblGroupByPayload<T extends Episode_book_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Episode_book_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Episode_book_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Episode_book_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Episode_book_tblGroupByOutputType[P]>
        }
      >
    >


  export type episode_book_tblSelect = {
    episode_book_id?: boolean
    book_title?: boolean
    author_id?: boolean
    url_name?: boolean
    cover_image?: boolean
    regional_book_title?: boolean
    language?: boolean
    type_of_book?: boolean
    genre_id?: boolean
    book_category?: boolean
    description?: boolean
    status?: boolean
    day_of_chapter?: boolean
    activated_at?: boolean
  }


  export type episode_book_tblGetPayload<S extends boolean | null | undefined | episode_book_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? episode_book_tbl :
    S extends undefined ? never :
    S extends { include: any } & (episode_book_tblArgs | episode_book_tblFindManyArgs)
    ? episode_book_tbl 
    : S extends { select: any } & (episode_book_tblArgs | episode_book_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof episode_book_tbl ? episode_book_tbl[P] : never
  } 
      : episode_book_tbl


  type episode_book_tblCountArgs = Merge<
    Omit<episode_book_tblFindManyArgs, 'select' | 'include'> & {
      select?: Episode_book_tblCountAggregateInputType | true
    }
  >

  export interface episode_book_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Episode_book_tbl that matches the filter.
     * @param {episode_book_tblFindUniqueArgs} args - Arguments to find a Episode_book_tbl
     * @example
     * // Get one Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends episode_book_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, episode_book_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'episode_book_tbl'> extends True ? Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>> : Prisma__episode_book_tblClient<episode_book_tblGetPayload<T> | null, null>

    /**
     * Find the first Episode_book_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_tblFindFirstArgs} args - Arguments to find a Episode_book_tbl
     * @example
     * // Get one Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends episode_book_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, episode_book_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'episode_book_tbl'> extends True ? Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>> : Prisma__episode_book_tblClient<episode_book_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Episode_book_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episode_book_tbls
     * const episode_book_tbls = await prisma.episode_book_tbl.findMany()
     * 
     * // Get first 10 Episode_book_tbls
     * const episode_book_tbls = await prisma.episode_book_tbl.findMany({ take: 10 })
     * 
     * // Only select the `episode_book_id`
     * const episode_book_tblWithEpisode_book_idOnly = await prisma.episode_book_tbl.findMany({ select: { episode_book_id: true } })
     * 
    **/
    findMany<T extends episode_book_tblFindManyArgs>(
      args?: SelectSubset<T, episode_book_tblFindManyArgs>
    ): PrismaPromise<Array<episode_book_tblGetPayload<T>>>

    /**
     * Create a Episode_book_tbl.
     * @param {episode_book_tblCreateArgs} args - Arguments to create a Episode_book_tbl.
     * @example
     * // Create one Episode_book_tbl
     * const Episode_book_tbl = await prisma.episode_book_tbl.create({
     *   data: {
     *     // ... data to create a Episode_book_tbl
     *   }
     * })
     * 
    **/
    create<T extends episode_book_tblCreateArgs>(
      args: SelectSubset<T, episode_book_tblCreateArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Create many Episode_book_tbls.
     *     @param {episode_book_tblCreateManyArgs} args - Arguments to create many Episode_book_tbls.
     *     @example
     *     // Create many Episode_book_tbls
     *     const episode_book_tbl = await prisma.episode_book_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends episode_book_tblCreateManyArgs>(
      args?: SelectSubset<T, episode_book_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Episode_book_tbl.
     * @param {episode_book_tblDeleteArgs} args - Arguments to delete one Episode_book_tbl.
     * @example
     * // Delete one Episode_book_tbl
     * const Episode_book_tbl = await prisma.episode_book_tbl.delete({
     *   where: {
     *     // ... filter to delete one Episode_book_tbl
     *   }
     * })
     * 
    **/
    delete<T extends episode_book_tblDeleteArgs>(
      args: SelectSubset<T, episode_book_tblDeleteArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Update one Episode_book_tbl.
     * @param {episode_book_tblUpdateArgs} args - Arguments to update one Episode_book_tbl.
     * @example
     * // Update one Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends episode_book_tblUpdateArgs>(
      args: SelectSubset<T, episode_book_tblUpdateArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Delete zero or more Episode_book_tbls.
     * @param {episode_book_tblDeleteManyArgs} args - Arguments to filter Episode_book_tbls to delete.
     * @example
     * // Delete a few Episode_book_tbls
     * const { count } = await prisma.episode_book_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends episode_book_tblDeleteManyArgs>(
      args?: SelectSubset<T, episode_book_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episode_book_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episode_book_tbls
     * const episode_book_tbl = await prisma.episode_book_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends episode_book_tblUpdateManyArgs>(
      args: SelectSubset<T, episode_book_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Episode_book_tbl.
     * @param {episode_book_tblUpsertArgs} args - Arguments to update or create a Episode_book_tbl.
     * @example
     * // Update or create a Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.upsert({
     *   create: {
     *     // ... data to create a Episode_book_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode_book_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends episode_book_tblUpsertArgs>(
      args: SelectSubset<T, episode_book_tblUpsertArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Find one Episode_book_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {episode_book_tblFindUniqueOrThrowArgs} args - Arguments to find a Episode_book_tbl
     * @example
     * // Get one Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends episode_book_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, episode_book_tblFindUniqueOrThrowArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Find the first Episode_book_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_tblFindFirstOrThrowArgs} args - Arguments to find a Episode_book_tbl
     * @example
     * // Get one Episode_book_tbl
     * const episode_book_tbl = await prisma.episode_book_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends episode_book_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, episode_book_tblFindFirstOrThrowArgs>
    ): Prisma__episode_book_tblClient<episode_book_tblGetPayload<T>>

    /**
     * Count the number of Episode_book_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_book_tblCountArgs} args - Arguments to filter Episode_book_tbls to count.
     * @example
     * // Count the number of Episode_book_tbls
     * const count = await prisma.episode_book_tbl.count({
     *   where: {
     *     // ... the filter for the Episode_book_tbls we want to count
     *   }
     * })
    **/
    count<T extends episode_book_tblCountArgs>(
      args?: Subset<T, episode_book_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Episode_book_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode_book_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_book_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Episode_book_tblAggregateArgs>(args: Subset<T, Episode_book_tblAggregateArgs>): PrismaPromise<GetEpisode_book_tblAggregateType<T>>

    /**
     * Group by Episode_book_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_book_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Episode_book_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Episode_book_tblGroupByArgs['orderBy'] }
        : { orderBy?: Episode_book_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Episode_book_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisode_book_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for episode_book_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__episode_book_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * episode_book_tbl base type for findUnique actions
   */
  export type episode_book_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * Filter, which episode_book_tbl to fetch.
     * 
    **/
    where: episode_book_tblWhereUniqueInput
  }

  /**
   * episode_book_tbl: findUnique
   */
  export interface episode_book_tblFindUniqueArgs extends episode_book_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_book_tbl base type for findFirst actions
   */
  export type episode_book_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * Filter, which episode_book_tbl to fetch.
     * 
    **/
    where?: episode_book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episode_book_tbls.
     * 
    **/
    cursor?: episode_book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episode_book_tbls.
     * 
    **/
    distinct?: Enumerable<Episode_book_tblScalarFieldEnum>
  }

  /**
   * episode_book_tbl: findFirst
   */
  export interface episode_book_tblFindFirstArgs extends episode_book_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_book_tbl findMany
   */
  export type episode_book_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * Filter, which episode_book_tbls to fetch.
     * 
    **/
    where?: episode_book_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_book_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<episode_book_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing episode_book_tbls.
     * 
    **/
    cursor?: episode_book_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_book_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_book_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Episode_book_tblScalarFieldEnum>
  }


  /**
   * episode_book_tbl create
   */
  export type episode_book_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * The data needed to create a episode_book_tbl.
     * 
    **/
    data: XOR<episode_book_tblCreateInput, episode_book_tblUncheckedCreateInput>
  }


  /**
   * episode_book_tbl createMany
   */
  export type episode_book_tblCreateManyArgs = {
    /**
     * The data used to create many episode_book_tbls.
     * 
    **/
    data: Enumerable<episode_book_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * episode_book_tbl update
   */
  export type episode_book_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * The data needed to update a episode_book_tbl.
     * 
    **/
    data: XOR<episode_book_tblUpdateInput, episode_book_tblUncheckedUpdateInput>
    /**
     * Choose, which episode_book_tbl to update.
     * 
    **/
    where: episode_book_tblWhereUniqueInput
  }


  /**
   * episode_book_tbl updateMany
   */
  export type episode_book_tblUpdateManyArgs = {
    /**
     * The data used to update episode_book_tbls.
     * 
    **/
    data: XOR<episode_book_tblUpdateManyMutationInput, episode_book_tblUncheckedUpdateManyInput>
    /**
     * Filter which episode_book_tbls to update
     * 
    **/
    where?: episode_book_tblWhereInput
  }


  /**
   * episode_book_tbl upsert
   */
  export type episode_book_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * The filter to search for the episode_book_tbl to update in case it exists.
     * 
    **/
    where: episode_book_tblWhereUniqueInput
    /**
     * In case the episode_book_tbl found by the `where` argument doesn't exist, create a new episode_book_tbl with this data.
     * 
    **/
    create: XOR<episode_book_tblCreateInput, episode_book_tblUncheckedCreateInput>
    /**
     * In case the episode_book_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<episode_book_tblUpdateInput, episode_book_tblUncheckedUpdateInput>
  }


  /**
   * episode_book_tbl delete
   */
  export type episode_book_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
    /**
     * Filter which episode_book_tbl to delete.
     * 
    **/
    where: episode_book_tblWhereUniqueInput
  }


  /**
   * episode_book_tbl deleteMany
   */
  export type episode_book_tblDeleteManyArgs = {
    /**
     * Filter which episode_book_tbls to delete
     * 
    **/
    where?: episode_book_tblWhereInput
  }


  /**
   * episode_book_tbl: findUniqueOrThrow
   */
  export type episode_book_tblFindUniqueOrThrowArgs = episode_book_tblFindUniqueArgsBase
      

  /**
   * episode_book_tbl: findFirstOrThrow
   */
  export type episode_book_tblFindFirstOrThrowArgs = episode_book_tblFindFirstArgsBase
      

  /**
   * episode_book_tbl without action
   */
  export type episode_book_tblArgs = {
    /**
     * Select specific fields to fetch from the episode_book_tbl
     * 
    **/
    select?: episode_book_tblSelect | null
  }



  /**
   * Model fixed_royalty
   */


  export type AggregateFixed_royalty = {
    _count: Fixed_royaltyCountAggregateOutputType | null
    _avg: Fixed_royaltyAvgAggregateOutputType | null
    _sum: Fixed_royaltySumAggregateOutputType | null
    _min: Fixed_royaltyMinAggregateOutputType | null
    _max: Fixed_royaltyMaxAggregateOutputType | null
  }

  export type Fixed_royaltyAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    copyright_owner: number | null
    fixed_royalty_value: number | null
    author_id: number | null
    status: number | null
  }

  export type Fixed_royaltySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    copyright_owner: number | null
    fixed_royalty_value: number | null
    author_id: number | null
    status: number | null
  }

  export type Fixed_royaltyMinAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    user_id: number | null
    copyright_owner: number | null
    fixed_royalty_value: number | null
    author_id: number | null
    status: number | null
  }

  export type Fixed_royaltyMaxAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    user_id: number | null
    copyright_owner: number | null
    fixed_royalty_value: number | null
    author_id: number | null
    status: number | null
  }

  export type Fixed_royaltyCountAggregateOutputType = {
    id: number
    transaction_date: number
    user_id: number
    copyright_owner: number
    fixed_royalty_value: number
    author_id: number
    status: number
    _all: number
  }


  export type Fixed_royaltyAvgAggregateInputType = {
    id?: true
    user_id?: true
    copyright_owner?: true
    fixed_royalty_value?: true
    author_id?: true
    status?: true
  }

  export type Fixed_royaltySumAggregateInputType = {
    id?: true
    user_id?: true
    copyright_owner?: true
    fixed_royalty_value?: true
    author_id?: true
    status?: true
  }

  export type Fixed_royaltyMinAggregateInputType = {
    id?: true
    transaction_date?: true
    user_id?: true
    copyright_owner?: true
    fixed_royalty_value?: true
    author_id?: true
    status?: true
  }

  export type Fixed_royaltyMaxAggregateInputType = {
    id?: true
    transaction_date?: true
    user_id?: true
    copyright_owner?: true
    fixed_royalty_value?: true
    author_id?: true
    status?: true
  }

  export type Fixed_royaltyCountAggregateInputType = {
    id?: true
    transaction_date?: true
    user_id?: true
    copyright_owner?: true
    fixed_royalty_value?: true
    author_id?: true
    status?: true
    _all?: true
  }

  export type Fixed_royaltyAggregateArgs = {
    /**
     * Filter which fixed_royalty to aggregate.
     * 
    **/
    where?: fixed_royaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_royalties to fetch.
     * 
    **/
    orderBy?: Enumerable<fixed_royaltyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fixed_royaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_royalties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_royalties.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fixed_royalties
    **/
    _count?: true | Fixed_royaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fixed_royaltyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fixed_royaltySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fixed_royaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fixed_royaltyMaxAggregateInputType
  }

  export type GetFixed_royaltyAggregateType<T extends Fixed_royaltyAggregateArgs> = {
        [P in keyof T & keyof AggregateFixed_royalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixed_royalty[P]>
      : GetScalarType<T[P], AggregateFixed_royalty[P]>
  }




  export type Fixed_royaltyGroupByArgs = {
    where?: fixed_royaltyWhereInput
    orderBy?: Enumerable<fixed_royaltyOrderByWithAggregationInput>
    by: Array<Fixed_royaltyScalarFieldEnum>
    having?: fixed_royaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fixed_royaltyCountAggregateInputType | true
    _avg?: Fixed_royaltyAvgAggregateInputType
    _sum?: Fixed_royaltySumAggregateInputType
    _min?: Fixed_royaltyMinAggregateInputType
    _max?: Fixed_royaltyMaxAggregateInputType
  }


  export type Fixed_royaltyGroupByOutputType = {
    id: number
    transaction_date: Date | null
    user_id: number | null
    copyright_owner: number | null
    fixed_royalty_value: number | null
    author_id: number | null
    status: number | null
    _count: Fixed_royaltyCountAggregateOutputType | null
    _avg: Fixed_royaltyAvgAggregateOutputType | null
    _sum: Fixed_royaltySumAggregateOutputType | null
    _min: Fixed_royaltyMinAggregateOutputType | null
    _max: Fixed_royaltyMaxAggregateOutputType | null
  }

  type GetFixed_royaltyGroupByPayload<T extends Fixed_royaltyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fixed_royaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fixed_royaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fixed_royaltyGroupByOutputType[P]>
            : GetScalarType<T[P], Fixed_royaltyGroupByOutputType[P]>
        }
      >
    >


  export type fixed_royaltySelect = {
    id?: boolean
    transaction_date?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    fixed_royalty_value?: boolean
    author_id?: boolean
    status?: boolean
  }


  export type fixed_royaltyGetPayload<S extends boolean | null | undefined | fixed_royaltyArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fixed_royalty :
    S extends undefined ? never :
    S extends { include: any } & (fixed_royaltyArgs | fixed_royaltyFindManyArgs)
    ? fixed_royalty 
    : S extends { select: any } & (fixed_royaltyArgs | fixed_royaltyFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof fixed_royalty ? fixed_royalty[P] : never
  } 
      : fixed_royalty


  type fixed_royaltyCountArgs = Merge<
    Omit<fixed_royaltyFindManyArgs, 'select' | 'include'> & {
      select?: Fixed_royaltyCountAggregateInputType | true
    }
  >

  export interface fixed_royaltyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fixed_royalty that matches the filter.
     * @param {fixed_royaltyFindUniqueArgs} args - Arguments to find a Fixed_royalty
     * @example
     * // Get one Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fixed_royaltyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fixed_royaltyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fixed_royalty'> extends True ? Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>> : Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T> | null, null>

    /**
     * Find the first Fixed_royalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_royaltyFindFirstArgs} args - Arguments to find a Fixed_royalty
     * @example
     * // Get one Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fixed_royaltyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fixed_royaltyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fixed_royalty'> extends True ? Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>> : Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T> | null, null>

    /**
     * Find zero or more Fixed_royalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_royaltyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fixed_royalties
     * const fixed_royalties = await prisma.fixed_royalty.findMany()
     * 
     * // Get first 10 Fixed_royalties
     * const fixed_royalties = await prisma.fixed_royalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixed_royaltyWithIdOnly = await prisma.fixed_royalty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fixed_royaltyFindManyArgs>(
      args?: SelectSubset<T, fixed_royaltyFindManyArgs>
    ): PrismaPromise<Array<fixed_royaltyGetPayload<T>>>

    /**
     * Create a Fixed_royalty.
     * @param {fixed_royaltyCreateArgs} args - Arguments to create a Fixed_royalty.
     * @example
     * // Create one Fixed_royalty
     * const Fixed_royalty = await prisma.fixed_royalty.create({
     *   data: {
     *     // ... data to create a Fixed_royalty
     *   }
     * })
     * 
    **/
    create<T extends fixed_royaltyCreateArgs>(
      args: SelectSubset<T, fixed_royaltyCreateArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Create many Fixed_royalties.
     *     @param {fixed_royaltyCreateManyArgs} args - Arguments to create many Fixed_royalties.
     *     @example
     *     // Create many Fixed_royalties
     *     const fixed_royalty = await prisma.fixed_royalty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fixed_royaltyCreateManyArgs>(
      args?: SelectSubset<T, fixed_royaltyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fixed_royalty.
     * @param {fixed_royaltyDeleteArgs} args - Arguments to delete one Fixed_royalty.
     * @example
     * // Delete one Fixed_royalty
     * const Fixed_royalty = await prisma.fixed_royalty.delete({
     *   where: {
     *     // ... filter to delete one Fixed_royalty
     *   }
     * })
     * 
    **/
    delete<T extends fixed_royaltyDeleteArgs>(
      args: SelectSubset<T, fixed_royaltyDeleteArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Update one Fixed_royalty.
     * @param {fixed_royaltyUpdateArgs} args - Arguments to update one Fixed_royalty.
     * @example
     * // Update one Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fixed_royaltyUpdateArgs>(
      args: SelectSubset<T, fixed_royaltyUpdateArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Delete zero or more Fixed_royalties.
     * @param {fixed_royaltyDeleteManyArgs} args - Arguments to filter Fixed_royalties to delete.
     * @example
     * // Delete a few Fixed_royalties
     * const { count } = await prisma.fixed_royalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fixed_royaltyDeleteManyArgs>(
      args?: SelectSubset<T, fixed_royaltyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fixed_royalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_royaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fixed_royalties
     * const fixed_royalty = await prisma.fixed_royalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fixed_royaltyUpdateManyArgs>(
      args: SelectSubset<T, fixed_royaltyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fixed_royalty.
     * @param {fixed_royaltyUpsertArgs} args - Arguments to update or create a Fixed_royalty.
     * @example
     * // Update or create a Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.upsert({
     *   create: {
     *     // ... data to create a Fixed_royalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fixed_royalty we want to update
     *   }
     * })
    **/
    upsert<T extends fixed_royaltyUpsertArgs>(
      args: SelectSubset<T, fixed_royaltyUpsertArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Find one Fixed_royalty that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fixed_royaltyFindUniqueOrThrowArgs} args - Arguments to find a Fixed_royalty
     * @example
     * // Get one Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fixed_royaltyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fixed_royaltyFindUniqueOrThrowArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Find the first Fixed_royalty that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_royaltyFindFirstOrThrowArgs} args - Arguments to find a Fixed_royalty
     * @example
     * // Get one Fixed_royalty
     * const fixed_royalty = await prisma.fixed_royalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fixed_royaltyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fixed_royaltyFindFirstOrThrowArgs>
    ): Prisma__fixed_royaltyClient<fixed_royaltyGetPayload<T>>

    /**
     * Count the number of Fixed_royalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_royaltyCountArgs} args - Arguments to filter Fixed_royalties to count.
     * @example
     * // Count the number of Fixed_royalties
     * const count = await prisma.fixed_royalty.count({
     *   where: {
     *     // ... the filter for the Fixed_royalties we want to count
     *   }
     * })
    **/
    count<T extends fixed_royaltyCountArgs>(
      args?: Subset<T, fixed_royaltyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fixed_royaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fixed_royalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fixed_royaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fixed_royaltyAggregateArgs>(args: Subset<T, Fixed_royaltyAggregateArgs>): PrismaPromise<GetFixed_royaltyAggregateType<T>>

    /**
     * Group by Fixed_royalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fixed_royaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fixed_royaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fixed_royaltyGroupByArgs['orderBy'] }
        : { orderBy?: Fixed_royaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fixed_royaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixed_royaltyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fixed_royalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fixed_royaltyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fixed_royalty base type for findUnique actions
   */
  export type fixed_royaltyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * Filter, which fixed_royalty to fetch.
     * 
    **/
    where: fixed_royaltyWhereUniqueInput
  }

  /**
   * fixed_royalty: findUnique
   */
  export interface fixed_royaltyFindUniqueArgs extends fixed_royaltyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fixed_royalty base type for findFirst actions
   */
  export type fixed_royaltyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * Filter, which fixed_royalty to fetch.
     * 
    **/
    where?: fixed_royaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_royalties to fetch.
     * 
    **/
    orderBy?: Enumerable<fixed_royaltyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fixed_royalties.
     * 
    **/
    cursor?: fixed_royaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_royalties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_royalties.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fixed_royalties.
     * 
    **/
    distinct?: Enumerable<Fixed_royaltyScalarFieldEnum>
  }

  /**
   * fixed_royalty: findFirst
   */
  export interface fixed_royaltyFindFirstArgs extends fixed_royaltyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fixed_royalty findMany
   */
  export type fixed_royaltyFindManyArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * Filter, which fixed_royalties to fetch.
     * 
    **/
    where?: fixed_royaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_royalties to fetch.
     * 
    **/
    orderBy?: Enumerable<fixed_royaltyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fixed_royalties.
     * 
    **/
    cursor?: fixed_royaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_royalties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_royalties.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fixed_royaltyScalarFieldEnum>
  }


  /**
   * fixed_royalty create
   */
  export type fixed_royaltyCreateArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * The data needed to create a fixed_royalty.
     * 
    **/
    data: XOR<fixed_royaltyCreateInput, fixed_royaltyUncheckedCreateInput>
  }


  /**
   * fixed_royalty createMany
   */
  export type fixed_royaltyCreateManyArgs = {
    /**
     * The data used to create many fixed_royalties.
     * 
    **/
    data: Enumerable<fixed_royaltyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fixed_royalty update
   */
  export type fixed_royaltyUpdateArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * The data needed to update a fixed_royalty.
     * 
    **/
    data: XOR<fixed_royaltyUpdateInput, fixed_royaltyUncheckedUpdateInput>
    /**
     * Choose, which fixed_royalty to update.
     * 
    **/
    where: fixed_royaltyWhereUniqueInput
  }


  /**
   * fixed_royalty updateMany
   */
  export type fixed_royaltyUpdateManyArgs = {
    /**
     * The data used to update fixed_royalties.
     * 
    **/
    data: XOR<fixed_royaltyUpdateManyMutationInput, fixed_royaltyUncheckedUpdateManyInput>
    /**
     * Filter which fixed_royalties to update
     * 
    **/
    where?: fixed_royaltyWhereInput
  }


  /**
   * fixed_royalty upsert
   */
  export type fixed_royaltyUpsertArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * The filter to search for the fixed_royalty to update in case it exists.
     * 
    **/
    where: fixed_royaltyWhereUniqueInput
    /**
     * In case the fixed_royalty found by the `where` argument doesn't exist, create a new fixed_royalty with this data.
     * 
    **/
    create: XOR<fixed_royaltyCreateInput, fixed_royaltyUncheckedCreateInput>
    /**
     * In case the fixed_royalty was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fixed_royaltyUpdateInput, fixed_royaltyUncheckedUpdateInput>
  }


  /**
   * fixed_royalty delete
   */
  export type fixed_royaltyDeleteArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
    /**
     * Filter which fixed_royalty to delete.
     * 
    **/
    where: fixed_royaltyWhereUniqueInput
  }


  /**
   * fixed_royalty deleteMany
   */
  export type fixed_royaltyDeleteManyArgs = {
    /**
     * Filter which fixed_royalties to delete
     * 
    **/
    where?: fixed_royaltyWhereInput
  }


  /**
   * fixed_royalty: findUniqueOrThrow
   */
  export type fixed_royaltyFindUniqueOrThrowArgs = fixed_royaltyFindUniqueArgsBase
      

  /**
   * fixed_royalty: findFirstOrThrow
   */
  export type fixed_royaltyFindFirstOrThrowArgs = fixed_royaltyFindFirstArgsBase
      

  /**
   * fixed_royalty without action
   */
  export type fixed_royaltyArgs = {
    /**
     * Select specific fields to fetch from the fixed_royalty
     * 
    **/
    select?: fixed_royaltySelect | null
  }



  /**
   * Model free_book_subscription
   */


  export type AggregateFree_book_subscription = {
    _count: Free_book_subscriptionCountAggregateOutputType | null
    _avg: Free_book_subscriptionAvgAggregateOutputType | null
    _sum: Free_book_subscriptionSumAggregateOutputType | null
    _min: Free_book_subscriptionMinAggregateOutputType | null
    _max: Free_book_subscriptionMaxAggregateOutputType | null
  }

  export type Free_book_subscriptionAvgAggregateOutputType = {
    seq_id: number | null
    user_id: number | null
    book_id: number | null
  }

  export type Free_book_subscriptionSumAggregateOutputType = {
    seq_id: number | null
    user_id: bigint | null
    book_id: bigint | null
  }

  export type Free_book_subscriptionMinAggregateOutputType = {
    seq_id: number | null
    user_id: bigint | null
    book_id: bigint | null
    date_subscribed: Date | null
    comments: string | null
  }

  export type Free_book_subscriptionMaxAggregateOutputType = {
    seq_id: number | null
    user_id: bigint | null
    book_id: bigint | null
    date_subscribed: Date | null
    comments: string | null
  }

  export type Free_book_subscriptionCountAggregateOutputType = {
    seq_id: number
    user_id: number
    book_id: number
    date_subscribed: number
    comments: number
    _all: number
  }


  export type Free_book_subscriptionAvgAggregateInputType = {
    seq_id?: true
    user_id?: true
    book_id?: true
  }

  export type Free_book_subscriptionSumAggregateInputType = {
    seq_id?: true
    user_id?: true
    book_id?: true
  }

  export type Free_book_subscriptionMinAggregateInputType = {
    seq_id?: true
    user_id?: true
    book_id?: true
    date_subscribed?: true
    comments?: true
  }

  export type Free_book_subscriptionMaxAggregateInputType = {
    seq_id?: true
    user_id?: true
    book_id?: true
    date_subscribed?: true
    comments?: true
  }

  export type Free_book_subscriptionCountAggregateInputType = {
    seq_id?: true
    user_id?: true
    book_id?: true
    date_subscribed?: true
    comments?: true
    _all?: true
  }

  export type Free_book_subscriptionAggregateArgs = {
    /**
     * Filter which free_book_subscription to aggregate.
     * 
    **/
    where?: free_book_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_book_subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<free_book_subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: free_book_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_book_subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_book_subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned free_book_subscriptions
    **/
    _count?: true | Free_book_subscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Free_book_subscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Free_book_subscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Free_book_subscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Free_book_subscriptionMaxAggregateInputType
  }

  export type GetFree_book_subscriptionAggregateType<T extends Free_book_subscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateFree_book_subscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFree_book_subscription[P]>
      : GetScalarType<T[P], AggregateFree_book_subscription[P]>
  }




  export type Free_book_subscriptionGroupByArgs = {
    where?: free_book_subscriptionWhereInput
    orderBy?: Enumerable<free_book_subscriptionOrderByWithAggregationInput>
    by: Array<Free_book_subscriptionScalarFieldEnum>
    having?: free_book_subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Free_book_subscriptionCountAggregateInputType | true
    _avg?: Free_book_subscriptionAvgAggregateInputType
    _sum?: Free_book_subscriptionSumAggregateInputType
    _min?: Free_book_subscriptionMinAggregateInputType
    _max?: Free_book_subscriptionMaxAggregateInputType
  }


  export type Free_book_subscriptionGroupByOutputType = {
    seq_id: number
    user_id: bigint
    book_id: bigint
    date_subscribed: Date
    comments: string
    _count: Free_book_subscriptionCountAggregateOutputType | null
    _avg: Free_book_subscriptionAvgAggregateOutputType | null
    _sum: Free_book_subscriptionSumAggregateOutputType | null
    _min: Free_book_subscriptionMinAggregateOutputType | null
    _max: Free_book_subscriptionMaxAggregateOutputType | null
  }

  type GetFree_book_subscriptionGroupByPayload<T extends Free_book_subscriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Free_book_subscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Free_book_subscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Free_book_subscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], Free_book_subscriptionGroupByOutputType[P]>
        }
      >
    >


  export type free_book_subscriptionSelect = {
    seq_id?: boolean
    user_id?: boolean
    book_id?: boolean
    date_subscribed?: boolean
    comments?: boolean
  }


  export type free_book_subscriptionGetPayload<S extends boolean | null | undefined | free_book_subscriptionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? free_book_subscription :
    S extends undefined ? never :
    S extends { include: any } & (free_book_subscriptionArgs | free_book_subscriptionFindManyArgs)
    ? free_book_subscription 
    : S extends { select: any } & (free_book_subscriptionArgs | free_book_subscriptionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof free_book_subscription ? free_book_subscription[P] : never
  } 
      : free_book_subscription


  type free_book_subscriptionCountArgs = Merge<
    Omit<free_book_subscriptionFindManyArgs, 'select' | 'include'> & {
      select?: Free_book_subscriptionCountAggregateInputType | true
    }
  >

  export interface free_book_subscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Free_book_subscription that matches the filter.
     * @param {free_book_subscriptionFindUniqueArgs} args - Arguments to find a Free_book_subscription
     * @example
     * // Get one Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends free_book_subscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, free_book_subscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'free_book_subscription'> extends True ? Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>> : Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T> | null, null>

    /**
     * Find the first Free_book_subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_book_subscriptionFindFirstArgs} args - Arguments to find a Free_book_subscription
     * @example
     * // Get one Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends free_book_subscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, free_book_subscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'free_book_subscription'> extends True ? Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>> : Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T> | null, null>

    /**
     * Find zero or more Free_book_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_book_subscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Free_book_subscriptions
     * const free_book_subscriptions = await prisma.free_book_subscription.findMany()
     * 
     * // Get first 10 Free_book_subscriptions
     * const free_book_subscriptions = await prisma.free_book_subscription.findMany({ take: 10 })
     * 
     * // Only select the `seq_id`
     * const free_book_subscriptionWithSeq_idOnly = await prisma.free_book_subscription.findMany({ select: { seq_id: true } })
     * 
    **/
    findMany<T extends free_book_subscriptionFindManyArgs>(
      args?: SelectSubset<T, free_book_subscriptionFindManyArgs>
    ): PrismaPromise<Array<free_book_subscriptionGetPayload<T>>>

    /**
     * Create a Free_book_subscription.
     * @param {free_book_subscriptionCreateArgs} args - Arguments to create a Free_book_subscription.
     * @example
     * // Create one Free_book_subscription
     * const Free_book_subscription = await prisma.free_book_subscription.create({
     *   data: {
     *     // ... data to create a Free_book_subscription
     *   }
     * })
     * 
    **/
    create<T extends free_book_subscriptionCreateArgs>(
      args: SelectSubset<T, free_book_subscriptionCreateArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Create many Free_book_subscriptions.
     *     @param {free_book_subscriptionCreateManyArgs} args - Arguments to create many Free_book_subscriptions.
     *     @example
     *     // Create many Free_book_subscriptions
     *     const free_book_subscription = await prisma.free_book_subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends free_book_subscriptionCreateManyArgs>(
      args?: SelectSubset<T, free_book_subscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Free_book_subscription.
     * @param {free_book_subscriptionDeleteArgs} args - Arguments to delete one Free_book_subscription.
     * @example
     * // Delete one Free_book_subscription
     * const Free_book_subscription = await prisma.free_book_subscription.delete({
     *   where: {
     *     // ... filter to delete one Free_book_subscription
     *   }
     * })
     * 
    **/
    delete<T extends free_book_subscriptionDeleteArgs>(
      args: SelectSubset<T, free_book_subscriptionDeleteArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Update one Free_book_subscription.
     * @param {free_book_subscriptionUpdateArgs} args - Arguments to update one Free_book_subscription.
     * @example
     * // Update one Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends free_book_subscriptionUpdateArgs>(
      args: SelectSubset<T, free_book_subscriptionUpdateArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Delete zero or more Free_book_subscriptions.
     * @param {free_book_subscriptionDeleteManyArgs} args - Arguments to filter Free_book_subscriptions to delete.
     * @example
     * // Delete a few Free_book_subscriptions
     * const { count } = await prisma.free_book_subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends free_book_subscriptionDeleteManyArgs>(
      args?: SelectSubset<T, free_book_subscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Free_book_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_book_subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Free_book_subscriptions
     * const free_book_subscription = await prisma.free_book_subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends free_book_subscriptionUpdateManyArgs>(
      args: SelectSubset<T, free_book_subscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Free_book_subscription.
     * @param {free_book_subscriptionUpsertArgs} args - Arguments to update or create a Free_book_subscription.
     * @example
     * // Update or create a Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.upsert({
     *   create: {
     *     // ... data to create a Free_book_subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Free_book_subscription we want to update
     *   }
     * })
    **/
    upsert<T extends free_book_subscriptionUpsertArgs>(
      args: SelectSubset<T, free_book_subscriptionUpsertArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Find one Free_book_subscription that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {free_book_subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Free_book_subscription
     * @example
     * // Get one Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends free_book_subscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, free_book_subscriptionFindUniqueOrThrowArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Find the first Free_book_subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_book_subscriptionFindFirstOrThrowArgs} args - Arguments to find a Free_book_subscription
     * @example
     * // Get one Free_book_subscription
     * const free_book_subscription = await prisma.free_book_subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends free_book_subscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, free_book_subscriptionFindFirstOrThrowArgs>
    ): Prisma__free_book_subscriptionClient<free_book_subscriptionGetPayload<T>>

    /**
     * Count the number of Free_book_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_book_subscriptionCountArgs} args - Arguments to filter Free_book_subscriptions to count.
     * @example
     * // Count the number of Free_book_subscriptions
     * const count = await prisma.free_book_subscription.count({
     *   where: {
     *     // ... the filter for the Free_book_subscriptions we want to count
     *   }
     * })
    **/
    count<T extends free_book_subscriptionCountArgs>(
      args?: Subset<T, free_book_subscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Free_book_subscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Free_book_subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Free_book_subscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Free_book_subscriptionAggregateArgs>(args: Subset<T, Free_book_subscriptionAggregateArgs>): PrismaPromise<GetFree_book_subscriptionAggregateType<T>>

    /**
     * Group by Free_book_subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Free_book_subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Free_book_subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Free_book_subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: Free_book_subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Free_book_subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFree_book_subscriptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for free_book_subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__free_book_subscriptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * free_book_subscription base type for findUnique actions
   */
  export type free_book_subscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * Filter, which free_book_subscription to fetch.
     * 
    **/
    where: free_book_subscriptionWhereUniqueInput
  }

  /**
   * free_book_subscription: findUnique
   */
  export interface free_book_subscriptionFindUniqueArgs extends free_book_subscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * free_book_subscription base type for findFirst actions
   */
  export type free_book_subscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * Filter, which free_book_subscription to fetch.
     * 
    **/
    where?: free_book_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_book_subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<free_book_subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for free_book_subscriptions.
     * 
    **/
    cursor?: free_book_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_book_subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_book_subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of free_book_subscriptions.
     * 
    **/
    distinct?: Enumerable<Free_book_subscriptionScalarFieldEnum>
  }

  /**
   * free_book_subscription: findFirst
   */
  export interface free_book_subscriptionFindFirstArgs extends free_book_subscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * free_book_subscription findMany
   */
  export type free_book_subscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * Filter, which free_book_subscriptions to fetch.
     * 
    **/
    where?: free_book_subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_book_subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<free_book_subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing free_book_subscriptions.
     * 
    **/
    cursor?: free_book_subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_book_subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_book_subscriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Free_book_subscriptionScalarFieldEnum>
  }


  /**
   * free_book_subscription create
   */
  export type free_book_subscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * The data needed to create a free_book_subscription.
     * 
    **/
    data: XOR<free_book_subscriptionCreateInput, free_book_subscriptionUncheckedCreateInput>
  }


  /**
   * free_book_subscription createMany
   */
  export type free_book_subscriptionCreateManyArgs = {
    /**
     * The data used to create many free_book_subscriptions.
     * 
    **/
    data: Enumerable<free_book_subscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * free_book_subscription update
   */
  export type free_book_subscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * The data needed to update a free_book_subscription.
     * 
    **/
    data: XOR<free_book_subscriptionUpdateInput, free_book_subscriptionUncheckedUpdateInput>
    /**
     * Choose, which free_book_subscription to update.
     * 
    **/
    where: free_book_subscriptionWhereUniqueInput
  }


  /**
   * free_book_subscription updateMany
   */
  export type free_book_subscriptionUpdateManyArgs = {
    /**
     * The data used to update free_book_subscriptions.
     * 
    **/
    data: XOR<free_book_subscriptionUpdateManyMutationInput, free_book_subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which free_book_subscriptions to update
     * 
    **/
    where?: free_book_subscriptionWhereInput
  }


  /**
   * free_book_subscription upsert
   */
  export type free_book_subscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * The filter to search for the free_book_subscription to update in case it exists.
     * 
    **/
    where: free_book_subscriptionWhereUniqueInput
    /**
     * In case the free_book_subscription found by the `where` argument doesn't exist, create a new free_book_subscription with this data.
     * 
    **/
    create: XOR<free_book_subscriptionCreateInput, free_book_subscriptionUncheckedCreateInput>
    /**
     * In case the free_book_subscription was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<free_book_subscriptionUpdateInput, free_book_subscriptionUncheckedUpdateInput>
  }


  /**
   * free_book_subscription delete
   */
  export type free_book_subscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
    /**
     * Filter which free_book_subscription to delete.
     * 
    **/
    where: free_book_subscriptionWhereUniqueInput
  }


  /**
   * free_book_subscription deleteMany
   */
  export type free_book_subscriptionDeleteManyArgs = {
    /**
     * Filter which free_book_subscriptions to delete
     * 
    **/
    where?: free_book_subscriptionWhereInput
  }


  /**
   * free_book_subscription: findUniqueOrThrow
   */
  export type free_book_subscriptionFindUniqueOrThrowArgs = free_book_subscriptionFindUniqueArgsBase
      

  /**
   * free_book_subscription: findFirstOrThrow
   */
  export type free_book_subscriptionFindFirstOrThrowArgs = free_book_subscriptionFindFirstArgsBase
      

  /**
   * free_book_subscription without action
   */
  export type free_book_subscriptionArgs = {
    /**
     * Select specific fields to fetch from the free_book_subscription
     * 
    **/
    select?: free_book_subscriptionSelect | null
  }



  /**
   * Model genre_details_tbl
   */


  export type AggregateGenre_details_tbl = {
    _count: Genre_details_tblCountAggregateOutputType | null
    _avg: Genre_details_tblAvgAggregateOutputType | null
    _sum: Genre_details_tblSumAggregateOutputType | null
    _min: Genre_details_tblMinAggregateOutputType | null
    _max: Genre_details_tblMaxAggregateOutputType | null
  }

  export type Genre_details_tblAvgAggregateOutputType = {
    genre_id: number | null
    admin_id: number | null
    status: number | null
  }

  export type Genre_details_tblSumAggregateOutputType = {
    genre_id: number | null
    admin_id: number | null
    status: number | null
  }

  export type Genre_details_tblMinAggregateOutputType = {
    genre_id: number | null
    admin_id: number | null
    genre_name: string | null
    url_name: string | null
    lang_0: string | null
    lang_1: string | null
    lang_2: string | null
    lang_3: string | null
    lang_4: string | null
    lang_5: string | null
    status: number | null
    bisac_code: string | null
    image_url: string | null
  }

  export type Genre_details_tblMaxAggregateOutputType = {
    genre_id: number | null
    admin_id: number | null
    genre_name: string | null
    url_name: string | null
    lang_0: string | null
    lang_1: string | null
    lang_2: string | null
    lang_3: string | null
    lang_4: string | null
    lang_5: string | null
    status: number | null
    bisac_code: string | null
    image_url: string | null
  }

  export type Genre_details_tblCountAggregateOutputType = {
    genre_id: number
    admin_id: number
    genre_name: number
    url_name: number
    lang_0: number
    lang_1: number
    lang_2: number
    lang_3: number
    lang_4: number
    lang_5: number
    status: number
    bisac_code: number
    image_url: number
    _all: number
  }


  export type Genre_details_tblAvgAggregateInputType = {
    genre_id?: true
    admin_id?: true
    status?: true
  }

  export type Genre_details_tblSumAggregateInputType = {
    genre_id?: true
    admin_id?: true
    status?: true
  }

  export type Genre_details_tblMinAggregateInputType = {
    genre_id?: true
    admin_id?: true
    genre_name?: true
    url_name?: true
    lang_0?: true
    lang_1?: true
    lang_2?: true
    lang_3?: true
    lang_4?: true
    lang_5?: true
    status?: true
    bisac_code?: true
    image_url?: true
  }

  export type Genre_details_tblMaxAggregateInputType = {
    genre_id?: true
    admin_id?: true
    genre_name?: true
    url_name?: true
    lang_0?: true
    lang_1?: true
    lang_2?: true
    lang_3?: true
    lang_4?: true
    lang_5?: true
    status?: true
    bisac_code?: true
    image_url?: true
  }

  export type Genre_details_tblCountAggregateInputType = {
    genre_id?: true
    admin_id?: true
    genre_name?: true
    url_name?: true
    lang_0?: true
    lang_1?: true
    lang_2?: true
    lang_3?: true
    lang_4?: true
    lang_5?: true
    status?: true
    bisac_code?: true
    image_url?: true
    _all?: true
  }

  export type Genre_details_tblAggregateArgs = {
    /**
     * Filter which genre_details_tbl to aggregate.
     * 
    **/
    where?: genre_details_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genre_details_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<genre_details_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: genre_details_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genre_details_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genre_details_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genre_details_tbls
    **/
    _count?: true | Genre_details_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Genre_details_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Genre_details_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Genre_details_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Genre_details_tblMaxAggregateInputType
  }

  export type GetGenre_details_tblAggregateType<T extends Genre_details_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre_details_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre_details_tbl[P]>
      : GetScalarType<T[P], AggregateGenre_details_tbl[P]>
  }




  export type Genre_details_tblGroupByArgs = {
    where?: genre_details_tblWhereInput
    orderBy?: Enumerable<genre_details_tblOrderByWithAggregationInput>
    by: Array<Genre_details_tblScalarFieldEnum>
    having?: genre_details_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Genre_details_tblCountAggregateInputType | true
    _avg?: Genre_details_tblAvgAggregateInputType
    _sum?: Genre_details_tblSumAggregateInputType
    _min?: Genre_details_tblMinAggregateInputType
    _max?: Genre_details_tblMaxAggregateInputType
  }


  export type Genre_details_tblGroupByOutputType = {
    genre_id: number
    admin_id: number
    genre_name: string
    url_name: string
    lang_0: string | null
    lang_1: string
    lang_2: string
    lang_3: string
    lang_4: string
    lang_5: string | null
    status: number
    bisac_code: string | null
    image_url: string | null
    _count: Genre_details_tblCountAggregateOutputType | null
    _avg: Genre_details_tblAvgAggregateOutputType | null
    _sum: Genre_details_tblSumAggregateOutputType | null
    _min: Genre_details_tblMinAggregateOutputType | null
    _max: Genre_details_tblMaxAggregateOutputType | null
  }

  type GetGenre_details_tblGroupByPayload<T extends Genre_details_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Genre_details_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Genre_details_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Genre_details_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Genre_details_tblGroupByOutputType[P]>
        }
      >
    >


  export type genre_details_tblSelect = {
    genre_id?: boolean
    admin_id?: boolean
    genre_name?: boolean
    url_name?: boolean
    lang_0?: boolean
    lang_1?: boolean
    lang_2?: boolean
    lang_3?: boolean
    lang_4?: boolean
    lang_5?: boolean
    status?: boolean
    bisac_code?: boolean
    image_url?: boolean
    books?: boolean | book_tblFindManyArgs
    _count?: boolean | Genre_details_tblCountOutputTypeArgs
  }


  export type genre_details_tblInclude = {
    books?: boolean | book_tblFindManyArgs
    _count?: boolean | Genre_details_tblCountOutputTypeArgs
  } 

  export type genre_details_tblGetPayload<S extends boolean | null | undefined | genre_details_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? genre_details_tbl :
    S extends undefined ? never :
    S extends { include: any } & (genre_details_tblArgs | genre_details_tblFindManyArgs)
    ? genre_details_tbl  & {
    [P in TrueKeys<S['include']>]:
        P extends 'books' ? Array < book_tblGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Genre_details_tblCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (genre_details_tblArgs | genre_details_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'books' ? Array < book_tblGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Genre_details_tblCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof genre_details_tbl ? genre_details_tbl[P] : never
  } 
      : genre_details_tbl


  type genre_details_tblCountArgs = Merge<
    Omit<genre_details_tblFindManyArgs, 'select' | 'include'> & {
      select?: Genre_details_tblCountAggregateInputType | true
    }
  >

  export interface genre_details_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Genre_details_tbl that matches the filter.
     * @param {genre_details_tblFindUniqueArgs} args - Arguments to find a Genre_details_tbl
     * @example
     * // Get one Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends genre_details_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, genre_details_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'genre_details_tbl'> extends True ? Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>> : Prisma__genre_details_tblClient<genre_details_tblGetPayload<T> | null, null>

    /**
     * Find the first Genre_details_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genre_details_tblFindFirstArgs} args - Arguments to find a Genre_details_tbl
     * @example
     * // Get one Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends genre_details_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, genre_details_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'genre_details_tbl'> extends True ? Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>> : Prisma__genre_details_tblClient<genre_details_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Genre_details_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genre_details_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genre_details_tbls
     * const genre_details_tbls = await prisma.genre_details_tbl.findMany()
     * 
     * // Get first 10 Genre_details_tbls
     * const genre_details_tbls = await prisma.genre_details_tbl.findMany({ take: 10 })
     * 
     * // Only select the `genre_id`
     * const genre_details_tblWithGenre_idOnly = await prisma.genre_details_tbl.findMany({ select: { genre_id: true } })
     * 
    **/
    findMany<T extends genre_details_tblFindManyArgs>(
      args?: SelectSubset<T, genre_details_tblFindManyArgs>
    ): PrismaPromise<Array<genre_details_tblGetPayload<T>>>

    /**
     * Create a Genre_details_tbl.
     * @param {genre_details_tblCreateArgs} args - Arguments to create a Genre_details_tbl.
     * @example
     * // Create one Genre_details_tbl
     * const Genre_details_tbl = await prisma.genre_details_tbl.create({
     *   data: {
     *     // ... data to create a Genre_details_tbl
     *   }
     * })
     * 
    **/
    create<T extends genre_details_tblCreateArgs>(
      args: SelectSubset<T, genre_details_tblCreateArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Create many Genre_details_tbls.
     *     @param {genre_details_tblCreateManyArgs} args - Arguments to create many Genre_details_tbls.
     *     @example
     *     // Create many Genre_details_tbls
     *     const genre_details_tbl = await prisma.genre_details_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends genre_details_tblCreateManyArgs>(
      args?: SelectSubset<T, genre_details_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Genre_details_tbl.
     * @param {genre_details_tblDeleteArgs} args - Arguments to delete one Genre_details_tbl.
     * @example
     * // Delete one Genre_details_tbl
     * const Genre_details_tbl = await prisma.genre_details_tbl.delete({
     *   where: {
     *     // ... filter to delete one Genre_details_tbl
     *   }
     * })
     * 
    **/
    delete<T extends genre_details_tblDeleteArgs>(
      args: SelectSubset<T, genre_details_tblDeleteArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Update one Genre_details_tbl.
     * @param {genre_details_tblUpdateArgs} args - Arguments to update one Genre_details_tbl.
     * @example
     * // Update one Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends genre_details_tblUpdateArgs>(
      args: SelectSubset<T, genre_details_tblUpdateArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Delete zero or more Genre_details_tbls.
     * @param {genre_details_tblDeleteManyArgs} args - Arguments to filter Genre_details_tbls to delete.
     * @example
     * // Delete a few Genre_details_tbls
     * const { count } = await prisma.genre_details_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends genre_details_tblDeleteManyArgs>(
      args?: SelectSubset<T, genre_details_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genre_details_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genre_details_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genre_details_tbls
     * const genre_details_tbl = await prisma.genre_details_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends genre_details_tblUpdateManyArgs>(
      args: SelectSubset<T, genre_details_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Genre_details_tbl.
     * @param {genre_details_tblUpsertArgs} args - Arguments to update or create a Genre_details_tbl.
     * @example
     * // Update or create a Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.upsert({
     *   create: {
     *     // ... data to create a Genre_details_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre_details_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends genre_details_tblUpsertArgs>(
      args: SelectSubset<T, genre_details_tblUpsertArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Find one Genre_details_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {genre_details_tblFindUniqueOrThrowArgs} args - Arguments to find a Genre_details_tbl
     * @example
     * // Get one Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends genre_details_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, genre_details_tblFindUniqueOrThrowArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Find the first Genre_details_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genre_details_tblFindFirstOrThrowArgs} args - Arguments to find a Genre_details_tbl
     * @example
     * // Get one Genre_details_tbl
     * const genre_details_tbl = await prisma.genre_details_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends genre_details_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, genre_details_tblFindFirstOrThrowArgs>
    ): Prisma__genre_details_tblClient<genre_details_tblGetPayload<T>>

    /**
     * Count the number of Genre_details_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genre_details_tblCountArgs} args - Arguments to filter Genre_details_tbls to count.
     * @example
     * // Count the number of Genre_details_tbls
     * const count = await prisma.genre_details_tbl.count({
     *   where: {
     *     // ... the filter for the Genre_details_tbls we want to count
     *   }
     * })
    **/
    count<T extends genre_details_tblCountArgs>(
      args?: Subset<T, genre_details_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Genre_details_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre_details_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Genre_details_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Genre_details_tblAggregateArgs>(args: Subset<T, Genre_details_tblAggregateArgs>): PrismaPromise<GetGenre_details_tblAggregateType<T>>

    /**
     * Group by Genre_details_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Genre_details_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Genre_details_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Genre_details_tblGroupByArgs['orderBy'] }
        : { orderBy?: Genre_details_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Genre_details_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenre_details_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for genre_details_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__genre_details_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    books<T extends book_tblFindManyArgs= {}>(args?: Subset<T, book_tblFindManyArgs>): PrismaPromise<Array<book_tblGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * genre_details_tbl base type for findUnique actions
   */
  export type genre_details_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * Filter, which genre_details_tbl to fetch.
     * 
    **/
    where: genre_details_tblWhereUniqueInput
  }

  /**
   * genre_details_tbl: findUnique
   */
  export interface genre_details_tblFindUniqueArgs extends genre_details_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * genre_details_tbl base type for findFirst actions
   */
  export type genre_details_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * Filter, which genre_details_tbl to fetch.
     * 
    **/
    where?: genre_details_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genre_details_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<genre_details_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genre_details_tbls.
     * 
    **/
    cursor?: genre_details_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genre_details_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genre_details_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genre_details_tbls.
     * 
    **/
    distinct?: Enumerable<Genre_details_tblScalarFieldEnum>
  }

  /**
   * genre_details_tbl: findFirst
   */
  export interface genre_details_tblFindFirstArgs extends genre_details_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * genre_details_tbl findMany
   */
  export type genre_details_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * Filter, which genre_details_tbls to fetch.
     * 
    **/
    where?: genre_details_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genre_details_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<genre_details_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genre_details_tbls.
     * 
    **/
    cursor?: genre_details_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genre_details_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genre_details_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Genre_details_tblScalarFieldEnum>
  }


  /**
   * genre_details_tbl create
   */
  export type genre_details_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * The data needed to create a genre_details_tbl.
     * 
    **/
    data: XOR<genre_details_tblCreateInput, genre_details_tblUncheckedCreateInput>
  }


  /**
   * genre_details_tbl createMany
   */
  export type genre_details_tblCreateManyArgs = {
    /**
     * The data used to create many genre_details_tbls.
     * 
    **/
    data: Enumerable<genre_details_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * genre_details_tbl update
   */
  export type genre_details_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * The data needed to update a genre_details_tbl.
     * 
    **/
    data: XOR<genre_details_tblUpdateInput, genre_details_tblUncheckedUpdateInput>
    /**
     * Choose, which genre_details_tbl to update.
     * 
    **/
    where: genre_details_tblWhereUniqueInput
  }


  /**
   * genre_details_tbl updateMany
   */
  export type genre_details_tblUpdateManyArgs = {
    /**
     * The data used to update genre_details_tbls.
     * 
    **/
    data: XOR<genre_details_tblUpdateManyMutationInput, genre_details_tblUncheckedUpdateManyInput>
    /**
     * Filter which genre_details_tbls to update
     * 
    **/
    where?: genre_details_tblWhereInput
  }


  /**
   * genre_details_tbl upsert
   */
  export type genre_details_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * The filter to search for the genre_details_tbl to update in case it exists.
     * 
    **/
    where: genre_details_tblWhereUniqueInput
    /**
     * In case the genre_details_tbl found by the `where` argument doesn't exist, create a new genre_details_tbl with this data.
     * 
    **/
    create: XOR<genre_details_tblCreateInput, genre_details_tblUncheckedCreateInput>
    /**
     * In case the genre_details_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<genre_details_tblUpdateInput, genre_details_tblUncheckedUpdateInput>
  }


  /**
   * genre_details_tbl delete
   */
  export type genre_details_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
    /**
     * Filter which genre_details_tbl to delete.
     * 
    **/
    where: genre_details_tblWhereUniqueInput
  }


  /**
   * genre_details_tbl deleteMany
   */
  export type genre_details_tblDeleteManyArgs = {
    /**
     * Filter which genre_details_tbls to delete
     * 
    **/
    where?: genre_details_tblWhereInput
  }


  /**
   * genre_details_tbl: findUniqueOrThrow
   */
  export type genre_details_tblFindUniqueOrThrowArgs = genre_details_tblFindUniqueArgsBase
      

  /**
   * genre_details_tbl: findFirstOrThrow
   */
  export type genre_details_tblFindFirstOrThrowArgs = genre_details_tblFindFirstArgsBase
      

  /**
   * genre_details_tbl without action
   */
  export type genre_details_tblArgs = {
    /**
     * Select specific fields to fetch from the genre_details_tbl
     * 
    **/
    select?: genre_details_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: genre_details_tblInclude | null
  }



  /**
   * Model google_books
   */


  export type AggregateGoogle_books = {
    _count: Google_booksCountAggregateOutputType | null
    _avg: Google_booksAvgAggregateOutputType | null
    _sum: Google_booksSumAggregateOutputType | null
    _min: Google_booksMinAggregateOutputType | null
    _max: Google_booksMaxAggregateOutputType | null
  }

  export type Google_booksAvgAggregateOutputType = {
    id: number | null
    page_count: number | null
    volume_in_series: number | null
    school_list_price_60: number | null
    school_list_price_180: number | null
    school_list_price_360: number | null
    preview_length_minutes: number | null
    preview_length_percentage: number | null
    inr_price_including_tax: number | null
    usd_price_including_tax: number | null
    inr_price_excluding_tax: number | null
    usd_price_excluding_tax: number | null
    eur_price_including_tax: number | null
    eur_price_excluding_tax: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
  }

  export type Google_booksSumAggregateOutputType = {
    id: number | null
    page_count: number | null
    volume_in_series: number | null
    school_list_price_60: number | null
    school_list_price_180: number | null
    school_list_price_360: number | null
    preview_length_minutes: number | null
    preview_length_percentage: number | null
    inr_price_including_tax: number | null
    usd_price_including_tax: number | null
    inr_price_excluding_tax: number | null
    usd_price_excluding_tax: number | null
    eur_price_including_tax: number | null
    eur_price_excluding_tax: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
  }

  export type Google_booksMinAggregateOutputType = {
    id: number | null
    identifier: string | null
    status: string | null
    label: string | null
    play_store_link: string | null
    enable_for_sale: boolean | null
    title: string | null
    subtitle: string | null
    book_format: string | null
    related_identifier: string | null
    contributor: string | null
    biographical_note: string | null
    language: string | null
    subject_code: string | null
    age_group: string | null
    description: string | null
    publication_date: string | null
    page_count: number | null
    series_name: string | null
    volume_in_series: number | null
    preview_type: string | null
    preview_territories: string | null
    buy_link_text: string | null
    buy_link: string | null
    publisher_name: string | null
    publisher_website: string | null
    show_photos_preview: boolean | null
    pdf_download: boolean | null
    on_sale_date: string | null
    drm_enabled: boolean | null
    show_photos_ebook: boolean | null
    include_scanned_pages: boolean | null
    mature_audiences: boolean | null
    copy_paste_percentage: string | null
    enable_school_use: boolean | null
    school_list_price_60: number | null
    school_list_price_180: number | null
    school_list_price_360: number | null
    school_use_countries: string | null
    duration: Date | null
    preview_length_minutes: number | null
    preview_length_percentage: number | null
    abridged_version: string | null
    inr_price_including_tax: number | null
    inr_countries_including_tax: string | null
    usd_price_including_tax: number | null
    usd_countries_including_tax: string | null
    inr_price_excluding_tax: number | null
    inr_countries_excluding_tax: string | null
    usd_price_excluding_tax: number | null
    usd_countries_excluding_tax: string | null
    eur_price_including_tax: number | null
    eur_price_excluding_tax: number | null
    eur_countries_including_tax: string | null
    eur_countries_excluding_tax: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    publish_date: Date | null
  }

  export type Google_booksMaxAggregateOutputType = {
    id: number | null
    identifier: string | null
    status: string | null
    label: string | null
    play_store_link: string | null
    enable_for_sale: boolean | null
    title: string | null
    subtitle: string | null
    book_format: string | null
    related_identifier: string | null
    contributor: string | null
    biographical_note: string | null
    language: string | null
    subject_code: string | null
    age_group: string | null
    description: string | null
    publication_date: string | null
    page_count: number | null
    series_name: string | null
    volume_in_series: number | null
    preview_type: string | null
    preview_territories: string | null
    buy_link_text: string | null
    buy_link: string | null
    publisher_name: string | null
    publisher_website: string | null
    show_photos_preview: boolean | null
    pdf_download: boolean | null
    on_sale_date: string | null
    drm_enabled: boolean | null
    show_photos_ebook: boolean | null
    include_scanned_pages: boolean | null
    mature_audiences: boolean | null
    copy_paste_percentage: string | null
    enable_school_use: boolean | null
    school_list_price_60: number | null
    school_list_price_180: number | null
    school_list_price_360: number | null
    school_use_countries: string | null
    duration: Date | null
    preview_length_minutes: number | null
    preview_length_percentage: number | null
    abridged_version: string | null
    inr_price_including_tax: number | null
    inr_countries_including_tax: string | null
    usd_price_including_tax: number | null
    usd_countries_including_tax: string | null
    inr_price_excluding_tax: number | null
    inr_countries_excluding_tax: string | null
    usd_price_excluding_tax: number | null
    usd_countries_excluding_tax: string | null
    eur_price_including_tax: number | null
    eur_price_excluding_tax: number | null
    eur_countries_including_tax: string | null
    eur_countries_excluding_tax: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    publish_date: Date | null
  }

  export type Google_booksCountAggregateOutputType = {
    id: number
    identifier: number
    status: number
    label: number
    play_store_link: number
    enable_for_sale: number
    title: number
    subtitle: number
    book_format: number
    related_identifier: number
    contributor: number
    biographical_note: number
    language: number
    subject_code: number
    age_group: number
    description: number
    publication_date: number
    page_count: number
    series_name: number
    volume_in_series: number
    preview_type: number
    preview_territories: number
    buy_link_text: number
    buy_link: number
    publisher_name: number
    publisher_website: number
    show_photos_preview: number
    pdf_download: number
    on_sale_date: number
    drm_enabled: number
    show_photos_ebook: number
    include_scanned_pages: number
    mature_audiences: number
    copy_paste_percentage: number
    enable_school_use: number
    school_list_price_60: number
    school_list_price_180: number
    school_list_price_360: number
    school_use_countries: number
    duration: number
    preview_length_minutes: number
    preview_length_percentage: number
    abridged_version: number
    inr_price_including_tax: number
    inr_countries_including_tax: number
    usd_price_including_tax: number
    usd_countries_including_tax: number
    inr_price_excluding_tax: number
    inr_countries_excluding_tax: number
    usd_price_excluding_tax: number
    usd_countries_excluding_tax: number
    eur_price_including_tax: number
    eur_price_excluding_tax: number
    eur_countries_including_tax: number
    eur_countries_excluding_tax: number
    book_id: number
    author_id: number
    copyright_owner: number
    language_id: number
    publish_date: number
    _all: number
  }


  export type Google_booksAvgAggregateInputType = {
    id?: true
    page_count?: true
    volume_in_series?: true
    school_list_price_60?: true
    school_list_price_180?: true
    school_list_price_360?: true
    preview_length_minutes?: true
    preview_length_percentage?: true
    inr_price_including_tax?: true
    usd_price_including_tax?: true
    inr_price_excluding_tax?: true
    usd_price_excluding_tax?: true
    eur_price_including_tax?: true
    eur_price_excluding_tax?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
  }

  export type Google_booksSumAggregateInputType = {
    id?: true
    page_count?: true
    volume_in_series?: true
    school_list_price_60?: true
    school_list_price_180?: true
    school_list_price_360?: true
    preview_length_minutes?: true
    preview_length_percentage?: true
    inr_price_including_tax?: true
    usd_price_including_tax?: true
    inr_price_excluding_tax?: true
    usd_price_excluding_tax?: true
    eur_price_including_tax?: true
    eur_price_excluding_tax?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
  }

  export type Google_booksMinAggregateInputType = {
    id?: true
    identifier?: true
    status?: true
    label?: true
    play_store_link?: true
    enable_for_sale?: true
    title?: true
    subtitle?: true
    book_format?: true
    related_identifier?: true
    contributor?: true
    biographical_note?: true
    language?: true
    subject_code?: true
    age_group?: true
    description?: true
    publication_date?: true
    page_count?: true
    series_name?: true
    volume_in_series?: true
    preview_type?: true
    preview_territories?: true
    buy_link_text?: true
    buy_link?: true
    publisher_name?: true
    publisher_website?: true
    show_photos_preview?: true
    pdf_download?: true
    on_sale_date?: true
    drm_enabled?: true
    show_photos_ebook?: true
    include_scanned_pages?: true
    mature_audiences?: true
    copy_paste_percentage?: true
    enable_school_use?: true
    school_list_price_60?: true
    school_list_price_180?: true
    school_list_price_360?: true
    school_use_countries?: true
    duration?: true
    preview_length_minutes?: true
    preview_length_percentage?: true
    abridged_version?: true
    inr_price_including_tax?: true
    inr_countries_including_tax?: true
    usd_price_including_tax?: true
    usd_countries_including_tax?: true
    inr_price_excluding_tax?: true
    inr_countries_excluding_tax?: true
    usd_price_excluding_tax?: true
    usd_countries_excluding_tax?: true
    eur_price_including_tax?: true
    eur_price_excluding_tax?: true
    eur_countries_including_tax?: true
    eur_countries_excluding_tax?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    publish_date?: true
  }

  export type Google_booksMaxAggregateInputType = {
    id?: true
    identifier?: true
    status?: true
    label?: true
    play_store_link?: true
    enable_for_sale?: true
    title?: true
    subtitle?: true
    book_format?: true
    related_identifier?: true
    contributor?: true
    biographical_note?: true
    language?: true
    subject_code?: true
    age_group?: true
    description?: true
    publication_date?: true
    page_count?: true
    series_name?: true
    volume_in_series?: true
    preview_type?: true
    preview_territories?: true
    buy_link_text?: true
    buy_link?: true
    publisher_name?: true
    publisher_website?: true
    show_photos_preview?: true
    pdf_download?: true
    on_sale_date?: true
    drm_enabled?: true
    show_photos_ebook?: true
    include_scanned_pages?: true
    mature_audiences?: true
    copy_paste_percentage?: true
    enable_school_use?: true
    school_list_price_60?: true
    school_list_price_180?: true
    school_list_price_360?: true
    school_use_countries?: true
    duration?: true
    preview_length_minutes?: true
    preview_length_percentage?: true
    abridged_version?: true
    inr_price_including_tax?: true
    inr_countries_including_tax?: true
    usd_price_including_tax?: true
    usd_countries_including_tax?: true
    inr_price_excluding_tax?: true
    inr_countries_excluding_tax?: true
    usd_price_excluding_tax?: true
    usd_countries_excluding_tax?: true
    eur_price_including_tax?: true
    eur_price_excluding_tax?: true
    eur_countries_including_tax?: true
    eur_countries_excluding_tax?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    publish_date?: true
  }

  export type Google_booksCountAggregateInputType = {
    id?: true
    identifier?: true
    status?: true
    label?: true
    play_store_link?: true
    enable_for_sale?: true
    title?: true
    subtitle?: true
    book_format?: true
    related_identifier?: true
    contributor?: true
    biographical_note?: true
    language?: true
    subject_code?: true
    age_group?: true
    description?: true
    publication_date?: true
    page_count?: true
    series_name?: true
    volume_in_series?: true
    preview_type?: true
    preview_territories?: true
    buy_link_text?: true
    buy_link?: true
    publisher_name?: true
    publisher_website?: true
    show_photos_preview?: true
    pdf_download?: true
    on_sale_date?: true
    drm_enabled?: true
    show_photos_ebook?: true
    include_scanned_pages?: true
    mature_audiences?: true
    copy_paste_percentage?: true
    enable_school_use?: true
    school_list_price_60?: true
    school_list_price_180?: true
    school_list_price_360?: true
    school_use_countries?: true
    duration?: true
    preview_length_minutes?: true
    preview_length_percentage?: true
    abridged_version?: true
    inr_price_including_tax?: true
    inr_countries_including_tax?: true
    usd_price_including_tax?: true
    usd_countries_including_tax?: true
    inr_price_excluding_tax?: true
    inr_countries_excluding_tax?: true
    usd_price_excluding_tax?: true
    usd_countries_excluding_tax?: true
    eur_price_including_tax?: true
    eur_price_excluding_tax?: true
    eur_countries_including_tax?: true
    eur_countries_excluding_tax?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    publish_date?: true
    _all?: true
  }

  export type Google_booksAggregateArgs = {
    /**
     * Filter which google_books to aggregate.
     * 
    **/
    where?: google_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_books to fetch.
     * 
    **/
    orderBy?: Enumerable<google_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: google_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned google_books
    **/
    _count?: true | Google_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Google_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Google_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Google_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Google_booksMaxAggregateInputType
  }

  export type GetGoogle_booksAggregateType<T extends Google_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogle_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogle_books[P]>
      : GetScalarType<T[P], AggregateGoogle_books[P]>
  }




  export type Google_booksGroupByArgs = {
    where?: google_booksWhereInput
    orderBy?: Enumerable<google_booksOrderByWithAggregationInput>
    by: Array<Google_booksScalarFieldEnum>
    having?: google_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Google_booksCountAggregateInputType | true
    _avg?: Google_booksAvgAggregateInputType
    _sum?: Google_booksSumAggregateInputType
    _min?: Google_booksMinAggregateInputType
    _max?: Google_booksMaxAggregateInputType
  }


  export type Google_booksGroupByOutputType = {
    id: number
    identifier: string | null
    status: string | null
    label: string | null
    play_store_link: string | null
    enable_for_sale: boolean | null
    title: string | null
    subtitle: string | null
    book_format: string | null
    related_identifier: string | null
    contributor: string | null
    biographical_note: string | null
    language: string | null
    subject_code: string | null
    age_group: string | null
    description: string | null
    publication_date: string | null
    page_count: number | null
    series_name: string | null
    volume_in_series: number | null
    preview_type: string | null
    preview_territories: string | null
    buy_link_text: string | null
    buy_link: string | null
    publisher_name: string | null
    publisher_website: string | null
    show_photos_preview: boolean | null
    pdf_download: boolean | null
    on_sale_date: string | null
    drm_enabled: boolean | null
    show_photos_ebook: boolean | null
    include_scanned_pages: boolean | null
    mature_audiences: boolean | null
    copy_paste_percentage: string | null
    enable_school_use: boolean | null
    school_list_price_60: number | null
    school_list_price_180: number | null
    school_list_price_360: number | null
    school_use_countries: string | null
    duration: Date | null
    preview_length_minutes: number | null
    preview_length_percentage: number | null
    abridged_version: string | null
    inr_price_including_tax: number | null
    inr_countries_including_tax: string | null
    usd_price_including_tax: number | null
    usd_countries_including_tax: string | null
    inr_price_excluding_tax: number | null
    inr_countries_excluding_tax: string | null
    usd_price_excluding_tax: number | null
    usd_countries_excluding_tax: string | null
    eur_price_including_tax: number | null
    eur_price_excluding_tax: number | null
    eur_countries_including_tax: string | null
    eur_countries_excluding_tax: string | null
    book_id: number
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    publish_date: Date | null
    _count: Google_booksCountAggregateOutputType | null
    _avg: Google_booksAvgAggregateOutputType | null
    _sum: Google_booksSumAggregateOutputType | null
    _min: Google_booksMinAggregateOutputType | null
    _max: Google_booksMaxAggregateOutputType | null
  }

  type GetGoogle_booksGroupByPayload<T extends Google_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Google_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Google_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Google_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Google_booksGroupByOutputType[P]>
        }
      >
    >


  export type google_booksSelect = {
    id?: boolean
    identifier?: boolean
    status?: boolean
    label?: boolean
    play_store_link?: boolean
    enable_for_sale?: boolean
    title?: boolean
    subtitle?: boolean
    book_format?: boolean
    related_identifier?: boolean
    contributor?: boolean
    biographical_note?: boolean
    language?: boolean
    subject_code?: boolean
    age_group?: boolean
    description?: boolean
    publication_date?: boolean
    page_count?: boolean
    series_name?: boolean
    volume_in_series?: boolean
    preview_type?: boolean
    preview_territories?: boolean
    buy_link_text?: boolean
    buy_link?: boolean
    publisher_name?: boolean
    publisher_website?: boolean
    show_photos_preview?: boolean
    pdf_download?: boolean
    on_sale_date?: boolean
    drm_enabled?: boolean
    show_photos_ebook?: boolean
    include_scanned_pages?: boolean
    mature_audiences?: boolean
    copy_paste_percentage?: boolean
    enable_school_use?: boolean
    school_list_price_60?: boolean
    school_list_price_180?: boolean
    school_list_price_360?: boolean
    school_use_countries?: boolean
    duration?: boolean
    preview_length_minutes?: boolean
    preview_length_percentage?: boolean
    abridged_version?: boolean
    inr_price_including_tax?: boolean
    inr_countries_including_tax?: boolean
    usd_price_including_tax?: boolean
    usd_countries_including_tax?: boolean
    inr_price_excluding_tax?: boolean
    inr_countries_excluding_tax?: boolean
    usd_price_excluding_tax?: boolean
    usd_countries_excluding_tax?: boolean
    eur_price_including_tax?: boolean
    eur_price_excluding_tax?: boolean
    eur_countries_including_tax?: boolean
    eur_countries_excluding_tax?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    publish_date?: boolean
  }


  export type google_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type google_booksGetPayload<S extends boolean | null | undefined | google_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? google_books :
    S extends undefined ? never :
    S extends { include: any } & (google_booksArgs | google_booksFindManyArgs)
    ? google_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (google_booksArgs | google_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof google_books ? google_books[P] : never
  } 
      : google_books


  type google_booksCountArgs = Merge<
    Omit<google_booksFindManyArgs, 'select' | 'include'> & {
      select?: Google_booksCountAggregateInputType | true
    }
  >

  export interface google_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Google_books that matches the filter.
     * @param {google_booksFindUniqueArgs} args - Arguments to find a Google_books
     * @example
     * // Get one Google_books
     * const google_books = await prisma.google_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends google_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, google_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'google_books'> extends True ? Prisma__google_booksClient<google_booksGetPayload<T>> : Prisma__google_booksClient<google_booksGetPayload<T> | null, null>

    /**
     * Find the first Google_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_booksFindFirstArgs} args - Arguments to find a Google_books
     * @example
     * // Get one Google_books
     * const google_books = await prisma.google_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends google_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, google_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'google_books'> extends True ? Prisma__google_booksClient<google_booksGetPayload<T>> : Prisma__google_booksClient<google_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Google_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Google_books
     * const google_books = await prisma.google_books.findMany()
     * 
     * // Get first 10 Google_books
     * const google_books = await prisma.google_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const google_booksWithIdOnly = await prisma.google_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends google_booksFindManyArgs>(
      args?: SelectSubset<T, google_booksFindManyArgs>
    ): PrismaPromise<Array<google_booksGetPayload<T>>>

    /**
     * Create a Google_books.
     * @param {google_booksCreateArgs} args - Arguments to create a Google_books.
     * @example
     * // Create one Google_books
     * const Google_books = await prisma.google_books.create({
     *   data: {
     *     // ... data to create a Google_books
     *   }
     * })
     * 
    **/
    create<T extends google_booksCreateArgs>(
      args: SelectSubset<T, google_booksCreateArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Create many Google_books.
     *     @param {google_booksCreateManyArgs} args - Arguments to create many Google_books.
     *     @example
     *     // Create many Google_books
     *     const google_books = await prisma.google_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends google_booksCreateManyArgs>(
      args?: SelectSubset<T, google_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Google_books.
     * @param {google_booksDeleteArgs} args - Arguments to delete one Google_books.
     * @example
     * // Delete one Google_books
     * const Google_books = await prisma.google_books.delete({
     *   where: {
     *     // ... filter to delete one Google_books
     *   }
     * })
     * 
    **/
    delete<T extends google_booksDeleteArgs>(
      args: SelectSubset<T, google_booksDeleteArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Update one Google_books.
     * @param {google_booksUpdateArgs} args - Arguments to update one Google_books.
     * @example
     * // Update one Google_books
     * const google_books = await prisma.google_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends google_booksUpdateArgs>(
      args: SelectSubset<T, google_booksUpdateArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Delete zero or more Google_books.
     * @param {google_booksDeleteManyArgs} args - Arguments to filter Google_books to delete.
     * @example
     * // Delete a few Google_books
     * const { count } = await prisma.google_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends google_booksDeleteManyArgs>(
      args?: SelectSubset<T, google_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Google_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Google_books
     * const google_books = await prisma.google_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends google_booksUpdateManyArgs>(
      args: SelectSubset<T, google_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Google_books.
     * @param {google_booksUpsertArgs} args - Arguments to update or create a Google_books.
     * @example
     * // Update or create a Google_books
     * const google_books = await prisma.google_books.upsert({
     *   create: {
     *     // ... data to create a Google_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Google_books we want to update
     *   }
     * })
    **/
    upsert<T extends google_booksUpsertArgs>(
      args: SelectSubset<T, google_booksUpsertArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Find one Google_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {google_booksFindUniqueOrThrowArgs} args - Arguments to find a Google_books
     * @example
     * // Get one Google_books
     * const google_books = await prisma.google_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends google_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, google_booksFindUniqueOrThrowArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Find the first Google_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_booksFindFirstOrThrowArgs} args - Arguments to find a Google_books
     * @example
     * // Get one Google_books
     * const google_books = await prisma.google_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends google_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, google_booksFindFirstOrThrowArgs>
    ): Prisma__google_booksClient<google_booksGetPayload<T>>

    /**
     * Count the number of Google_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_booksCountArgs} args - Arguments to filter Google_books to count.
     * @example
     * // Count the number of Google_books
     * const count = await prisma.google_books.count({
     *   where: {
     *     // ... the filter for the Google_books we want to count
     *   }
     * })
    **/
    count<T extends google_booksCountArgs>(
      args?: Subset<T, google_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Google_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Google_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Google_booksAggregateArgs>(args: Subset<T, Google_booksAggregateArgs>): PrismaPromise<GetGoogle_booksAggregateType<T>>

    /**
     * Group by Google_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Google_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Google_booksGroupByArgs['orderBy'] }
        : { orderBy?: Google_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Google_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogle_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for google_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__google_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * google_books base type for findUnique actions
   */
  export type google_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * Filter, which google_books to fetch.
     * 
    **/
    where: google_booksWhereUniqueInput
  }

  /**
   * google_books: findUnique
   */
  export interface google_booksFindUniqueArgs extends google_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * google_books base type for findFirst actions
   */
  export type google_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * Filter, which google_books to fetch.
     * 
    **/
    where?: google_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_books to fetch.
     * 
    **/
    orderBy?: Enumerable<google_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_books.
     * 
    **/
    cursor?: google_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_books.
     * 
    **/
    distinct?: Enumerable<Google_booksScalarFieldEnum>
  }

  /**
   * google_books: findFirst
   */
  export interface google_booksFindFirstArgs extends google_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * google_books findMany
   */
  export type google_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * Filter, which google_books to fetch.
     * 
    **/
    where?: google_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_books to fetch.
     * 
    **/
    orderBy?: Enumerable<google_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing google_books.
     * 
    **/
    cursor?: google_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Google_booksScalarFieldEnum>
  }


  /**
   * google_books create
   */
  export type google_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * The data needed to create a google_books.
     * 
    **/
    data: XOR<google_booksCreateInput, google_booksUncheckedCreateInput>
  }


  /**
   * google_books createMany
   */
  export type google_booksCreateManyArgs = {
    /**
     * The data used to create many google_books.
     * 
    **/
    data: Enumerable<google_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * google_books update
   */
  export type google_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * The data needed to update a google_books.
     * 
    **/
    data: XOR<google_booksUpdateInput, google_booksUncheckedUpdateInput>
    /**
     * Choose, which google_books to update.
     * 
    **/
    where: google_booksWhereUniqueInput
  }


  /**
   * google_books updateMany
   */
  export type google_booksUpdateManyArgs = {
    /**
     * The data used to update google_books.
     * 
    **/
    data: XOR<google_booksUpdateManyMutationInput, google_booksUncheckedUpdateManyInput>
    /**
     * Filter which google_books to update
     * 
    **/
    where?: google_booksWhereInput
  }


  /**
   * google_books upsert
   */
  export type google_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * The filter to search for the google_books to update in case it exists.
     * 
    **/
    where: google_booksWhereUniqueInput
    /**
     * In case the google_books found by the `where` argument doesn't exist, create a new google_books with this data.
     * 
    **/
    create: XOR<google_booksCreateInput, google_booksUncheckedCreateInput>
    /**
     * In case the google_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<google_booksUpdateInput, google_booksUncheckedUpdateInput>
  }


  /**
   * google_books delete
   */
  export type google_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
    /**
     * Filter which google_books to delete.
     * 
    **/
    where: google_booksWhereUniqueInput
  }


  /**
   * google_books deleteMany
   */
  export type google_booksDeleteManyArgs = {
    /**
     * Filter which google_books to delete
     * 
    **/
    where?: google_booksWhereInput
  }


  /**
   * google_books: findUniqueOrThrow
   */
  export type google_booksFindUniqueOrThrowArgs = google_booksFindUniqueArgsBase
      

  /**
   * google_books: findFirstOrThrow
   */
  export type google_booksFindFirstOrThrowArgs = google_booksFindFirstArgsBase
      

  /**
   * google_books without action
   */
  export type google_booksArgs = {
    /**
     * Select specific fields to fetch from the google_books
     * 
    **/
    select?: google_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_booksInclude | null
  }



  /**
   * Model google_transactions
   */


  export type AggregateGoogle_transactions = {
    _count: Google_transactionsCountAggregateOutputType | null
    _avg: Google_transactionsAvgAggregateOutputType | null
    _sum: Google_transactionsSumAggregateOutputType | null
    _min: Google_transactionsMinAggregateOutputType | null
    _max: Google_transactionsMaxAggregateOutputType | null
  }

  export type Google_transactionsAvgAggregateOutputType = {
    id: number | null
    qty: number | null
    original_list_price: number | null
    list_price_tax_inclusive: number | null
    list_price_tax_exclusive: number | null
    publisher_revenue: number | null
    earnings_amount: number | null
    currency_conversion_rate: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Google_transactionsSumAggregateOutputType = {
    id: number | null
    qty: number | null
    original_list_price: number | null
    list_price_tax_inclusive: number | null
    list_price_tax_exclusive: number | null
    publisher_revenue: number | null
    earnings_amount: number | null
    currency_conversion_rate: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Google_transactionsMinAggregateOutputType = {
    id: number | null
    earnings_date: Date | null
    transaction_date: Date | null
    unique_id: string | null
    product: string | null
    type: string | null
    preorder: string | null
    qty: number | null
    primary_isbn: string | null
    imprint_name: string | null
    title: string | null
    author: string | null
    original_list_price_currency: string | null
    original_list_price: number | null
    list_price_currency: string | null
    list_price_tax_inclusive: number | null
    list_price_tax_exclusive: number | null
    country_of_sale: string | null
    publisher_revenue_percentage: string | null
    publisher_revenue: number | null
    earnings_currency: string | null
    earnings_amount: number | null
    currency_conversion_rate: number | null
    line_of_business: string | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Google_transactionsMaxAggregateOutputType = {
    id: number | null
    earnings_date: Date | null
    transaction_date: Date | null
    unique_id: string | null
    product: string | null
    type: string | null
    preorder: string | null
    qty: number | null
    primary_isbn: string | null
    imprint_name: string | null
    title: string | null
    author: string | null
    original_list_price_currency: string | null
    original_list_price: number | null
    list_price_currency: string | null
    list_price_tax_inclusive: number | null
    list_price_tax_exclusive: number | null
    country_of_sale: string | null
    publisher_revenue_percentage: string | null
    publisher_revenue: number | null
    earnings_currency: string | null
    earnings_amount: number | null
    currency_conversion_rate: number | null
    line_of_business: string | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    currency_exchange: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Google_transactionsCountAggregateOutputType = {
    id: number
    earnings_date: number
    transaction_date: number
    unique_id: number
    product: number
    type: number
    preorder: number
    qty: number
    primary_isbn: number
    imprint_name: number
    title: number
    author: number
    original_list_price_currency: number
    original_list_price: number
    list_price_currency: number
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: number
    publisher_revenue_percentage: number
    publisher_revenue: number
    earnings_currency: number
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: number
    book_id: number
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner: number
    status: number
    _all: number
  }


  export type Google_transactionsAvgAggregateInputType = {
    id?: true
    qty?: true
    original_list_price?: true
    list_price_tax_inclusive?: true
    list_price_tax_exclusive?: true
    publisher_revenue?: true
    earnings_amount?: true
    currency_conversion_rate?: true
    book_id?: true
    author_id?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Google_transactionsSumAggregateInputType = {
    id?: true
    qty?: true
    original_list_price?: true
    list_price_tax_inclusive?: true
    list_price_tax_exclusive?: true
    publisher_revenue?: true
    earnings_amount?: true
    currency_conversion_rate?: true
    book_id?: true
    author_id?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Google_transactionsMinAggregateInputType = {
    id?: true
    earnings_date?: true
    transaction_date?: true
    unique_id?: true
    product?: true
    type?: true
    preorder?: true
    qty?: true
    primary_isbn?: true
    imprint_name?: true
    title?: true
    author?: true
    original_list_price_currency?: true
    original_list_price?: true
    list_price_currency?: true
    list_price_tax_inclusive?: true
    list_price_tax_exclusive?: true
    country_of_sale?: true
    publisher_revenue_percentage?: true
    publisher_revenue?: true
    earnings_currency?: true
    earnings_amount?: true
    currency_conversion_rate?: true
    line_of_business?: true
    book_id?: true
    author_id?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Google_transactionsMaxAggregateInputType = {
    id?: true
    earnings_date?: true
    transaction_date?: true
    unique_id?: true
    product?: true
    type?: true
    preorder?: true
    qty?: true
    primary_isbn?: true
    imprint_name?: true
    title?: true
    author?: true
    original_list_price_currency?: true
    original_list_price?: true
    list_price_currency?: true
    list_price_tax_inclusive?: true
    list_price_tax_exclusive?: true
    country_of_sale?: true
    publisher_revenue_percentage?: true
    publisher_revenue?: true
    earnings_currency?: true
    earnings_amount?: true
    currency_conversion_rate?: true
    line_of_business?: true
    book_id?: true
    author_id?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Google_transactionsCountAggregateInputType = {
    id?: true
    earnings_date?: true
    transaction_date?: true
    unique_id?: true
    product?: true
    type?: true
    preorder?: true
    qty?: true
    primary_isbn?: true
    imprint_name?: true
    title?: true
    author?: true
    original_list_price_currency?: true
    original_list_price?: true
    list_price_currency?: true
    list_price_tax_inclusive?: true
    list_price_tax_exclusive?: true
    country_of_sale?: true
    publisher_revenue_percentage?: true
    publisher_revenue?: true
    earnings_currency?: true
    earnings_amount?: true
    currency_conversion_rate?: true
    line_of_business?: true
    book_id?: true
    author_id?: true
    language_id?: true
    currency_exchange?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    _all?: true
  }

  export type Google_transactionsAggregateArgs = {
    /**
     * Filter which google_transactions to aggregate.
     * 
    **/
    where?: google_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<google_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: google_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned google_transactions
    **/
    _count?: true | Google_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Google_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Google_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Google_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Google_transactionsMaxAggregateInputType
  }

  export type GetGoogle_transactionsAggregateType<T extends Google_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogle_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogle_transactions[P]>
      : GetScalarType<T[P], AggregateGoogle_transactions[P]>
  }




  export type Google_transactionsGroupByArgs = {
    where?: google_transactionsWhereInput
    orderBy?: Enumerable<google_transactionsOrderByWithAggregationInput>
    by: Array<Google_transactionsScalarFieldEnum>
    having?: google_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Google_transactionsCountAggregateInputType | true
    _avg?: Google_transactionsAvgAggregateInputType
    _sum?: Google_transactionsSumAggregateInputType
    _min?: Google_transactionsMinAggregateInputType
    _max?: Google_transactionsMaxAggregateInputType
  }


  export type Google_transactionsGroupByOutputType = {
    id: number
    earnings_date: Date
    transaction_date: Date
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    book_id: number
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner: number | null
    status: string | null
    _count: Google_transactionsCountAggregateOutputType | null
    _avg: Google_transactionsAvgAggregateOutputType | null
    _sum: Google_transactionsSumAggregateOutputType | null
    _min: Google_transactionsMinAggregateOutputType | null
    _max: Google_transactionsMaxAggregateOutputType | null
  }

  type GetGoogle_transactionsGroupByPayload<T extends Google_transactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Google_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Google_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Google_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Google_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type google_transactionsSelect = {
    id?: boolean
    earnings_date?: boolean
    transaction_date?: boolean
    unique_id?: boolean
    product?: boolean
    type?: boolean
    preorder?: boolean
    qty?: boolean
    primary_isbn?: boolean
    imprint_name?: boolean
    title?: boolean
    author?: boolean
    original_list_price_currency?: boolean
    original_list_price?: boolean
    list_price_currency?: boolean
    list_price_tax_inclusive?: boolean
    list_price_tax_exclusive?: boolean
    country_of_sale?: boolean
    publisher_revenue_percentage?: boolean
    publisher_revenue?: boolean
    earnings_currency?: boolean
    earnings_amount?: boolean
    currency_conversion_rate?: boolean
    line_of_business?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    language_id?: boolean
    currency_exchange?: boolean
    inr_value?: boolean
    final_royalty_value?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    status?: boolean
  }


  export type google_transactionsInclude = {
    book?: boolean | book_tblArgs
  } 

  export type google_transactionsGetPayload<S extends boolean | null | undefined | google_transactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? google_transactions :
    S extends undefined ? never :
    S extends { include: any } & (google_transactionsArgs | google_transactionsFindManyArgs)
    ? google_transactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (google_transactionsArgs | google_transactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof google_transactions ? google_transactions[P] : never
  } 
      : google_transactions


  type google_transactionsCountArgs = Merge<
    Omit<google_transactionsFindManyArgs, 'select' | 'include'> & {
      select?: Google_transactionsCountAggregateInputType | true
    }
  >

  export interface google_transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Google_transactions that matches the filter.
     * @param {google_transactionsFindUniqueArgs} args - Arguments to find a Google_transactions
     * @example
     * // Get one Google_transactions
     * const google_transactions = await prisma.google_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends google_transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, google_transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'google_transactions'> extends True ? Prisma__google_transactionsClient<google_transactionsGetPayload<T>> : Prisma__google_transactionsClient<google_transactionsGetPayload<T> | null, null>

    /**
     * Find the first Google_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_transactionsFindFirstArgs} args - Arguments to find a Google_transactions
     * @example
     * // Get one Google_transactions
     * const google_transactions = await prisma.google_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends google_transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, google_transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'google_transactions'> extends True ? Prisma__google_transactionsClient<google_transactionsGetPayload<T>> : Prisma__google_transactionsClient<google_transactionsGetPayload<T> | null, null>

    /**
     * Find zero or more Google_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Google_transactions
     * const google_transactions = await prisma.google_transactions.findMany()
     * 
     * // Get first 10 Google_transactions
     * const google_transactions = await prisma.google_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const google_transactionsWithIdOnly = await prisma.google_transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends google_transactionsFindManyArgs>(
      args?: SelectSubset<T, google_transactionsFindManyArgs>
    ): PrismaPromise<Array<google_transactionsGetPayload<T>>>

    /**
     * Create a Google_transactions.
     * @param {google_transactionsCreateArgs} args - Arguments to create a Google_transactions.
     * @example
     * // Create one Google_transactions
     * const Google_transactions = await prisma.google_transactions.create({
     *   data: {
     *     // ... data to create a Google_transactions
     *   }
     * })
     * 
    **/
    create<T extends google_transactionsCreateArgs>(
      args: SelectSubset<T, google_transactionsCreateArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Create many Google_transactions.
     *     @param {google_transactionsCreateManyArgs} args - Arguments to create many Google_transactions.
     *     @example
     *     // Create many Google_transactions
     *     const google_transactions = await prisma.google_transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends google_transactionsCreateManyArgs>(
      args?: SelectSubset<T, google_transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Google_transactions.
     * @param {google_transactionsDeleteArgs} args - Arguments to delete one Google_transactions.
     * @example
     * // Delete one Google_transactions
     * const Google_transactions = await prisma.google_transactions.delete({
     *   where: {
     *     // ... filter to delete one Google_transactions
     *   }
     * })
     * 
    **/
    delete<T extends google_transactionsDeleteArgs>(
      args: SelectSubset<T, google_transactionsDeleteArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Update one Google_transactions.
     * @param {google_transactionsUpdateArgs} args - Arguments to update one Google_transactions.
     * @example
     * // Update one Google_transactions
     * const google_transactions = await prisma.google_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends google_transactionsUpdateArgs>(
      args: SelectSubset<T, google_transactionsUpdateArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Delete zero or more Google_transactions.
     * @param {google_transactionsDeleteManyArgs} args - Arguments to filter Google_transactions to delete.
     * @example
     * // Delete a few Google_transactions
     * const { count } = await prisma.google_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends google_transactionsDeleteManyArgs>(
      args?: SelectSubset<T, google_transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Google_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Google_transactions
     * const google_transactions = await prisma.google_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends google_transactionsUpdateManyArgs>(
      args: SelectSubset<T, google_transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Google_transactions.
     * @param {google_transactionsUpsertArgs} args - Arguments to update or create a Google_transactions.
     * @example
     * // Update or create a Google_transactions
     * const google_transactions = await prisma.google_transactions.upsert({
     *   create: {
     *     // ... data to create a Google_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Google_transactions we want to update
     *   }
     * })
    **/
    upsert<T extends google_transactionsUpsertArgs>(
      args: SelectSubset<T, google_transactionsUpsertArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Find one Google_transactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {google_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Google_transactions
     * @example
     * // Get one Google_transactions
     * const google_transactions = await prisma.google_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends google_transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, google_transactionsFindUniqueOrThrowArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Find the first Google_transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_transactionsFindFirstOrThrowArgs} args - Arguments to find a Google_transactions
     * @example
     * // Get one Google_transactions
     * const google_transactions = await prisma.google_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends google_transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, google_transactionsFindFirstOrThrowArgs>
    ): Prisma__google_transactionsClient<google_transactionsGetPayload<T>>

    /**
     * Count the number of Google_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_transactionsCountArgs} args - Arguments to filter Google_transactions to count.
     * @example
     * // Count the number of Google_transactions
     * const count = await prisma.google_transactions.count({
     *   where: {
     *     // ... the filter for the Google_transactions we want to count
     *   }
     * })
    **/
    count<T extends google_transactionsCountArgs>(
      args?: Subset<T, google_transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Google_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Google_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Google_transactionsAggregateArgs>(args: Subset<T, Google_transactionsAggregateArgs>): PrismaPromise<GetGoogle_transactionsAggregateType<T>>

    /**
     * Group by Google_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Google_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Google_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: Google_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Google_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogle_transactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for google_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__google_transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * google_transactions base type for findUnique actions
   */
  export type google_transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * Filter, which google_transactions to fetch.
     * 
    **/
    where: google_transactionsWhereUniqueInput
  }

  /**
   * google_transactions: findUnique
   */
  export interface google_transactionsFindUniqueArgs extends google_transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * google_transactions base type for findFirst actions
   */
  export type google_transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * Filter, which google_transactions to fetch.
     * 
    **/
    where?: google_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<google_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_transactions.
     * 
    **/
    cursor?: google_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_transactions.
     * 
    **/
    distinct?: Enumerable<Google_transactionsScalarFieldEnum>
  }

  /**
   * google_transactions: findFirst
   */
  export interface google_transactionsFindFirstArgs extends google_transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * google_transactions findMany
   */
  export type google_transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * Filter, which google_transactions to fetch.
     * 
    **/
    where?: google_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<google_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing google_transactions.
     * 
    **/
    cursor?: google_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Google_transactionsScalarFieldEnum>
  }


  /**
   * google_transactions create
   */
  export type google_transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * The data needed to create a google_transactions.
     * 
    **/
    data: XOR<google_transactionsCreateInput, google_transactionsUncheckedCreateInput>
  }


  /**
   * google_transactions createMany
   */
  export type google_transactionsCreateManyArgs = {
    /**
     * The data used to create many google_transactions.
     * 
    **/
    data: Enumerable<google_transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * google_transactions update
   */
  export type google_transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * The data needed to update a google_transactions.
     * 
    **/
    data: XOR<google_transactionsUpdateInput, google_transactionsUncheckedUpdateInput>
    /**
     * Choose, which google_transactions to update.
     * 
    **/
    where: google_transactionsWhereUniqueInput
  }


  /**
   * google_transactions updateMany
   */
  export type google_transactionsUpdateManyArgs = {
    /**
     * The data used to update google_transactions.
     * 
    **/
    data: XOR<google_transactionsUpdateManyMutationInput, google_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which google_transactions to update
     * 
    **/
    where?: google_transactionsWhereInput
  }


  /**
   * google_transactions upsert
   */
  export type google_transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * The filter to search for the google_transactions to update in case it exists.
     * 
    **/
    where: google_transactionsWhereUniqueInput
    /**
     * In case the google_transactions found by the `where` argument doesn't exist, create a new google_transactions with this data.
     * 
    **/
    create: XOR<google_transactionsCreateInput, google_transactionsUncheckedCreateInput>
    /**
     * In case the google_transactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<google_transactionsUpdateInput, google_transactionsUncheckedUpdateInput>
  }


  /**
   * google_transactions delete
   */
  export type google_transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
    /**
     * Filter which google_transactions to delete.
     * 
    **/
    where: google_transactionsWhereUniqueInput
  }


  /**
   * google_transactions deleteMany
   */
  export type google_transactionsDeleteManyArgs = {
    /**
     * Filter which google_transactions to delete
     * 
    **/
    where?: google_transactionsWhereInput
  }


  /**
   * google_transactions: findUniqueOrThrow
   */
  export type google_transactionsFindUniqueOrThrowArgs = google_transactionsFindUniqueArgsBase
      

  /**
   * google_transactions: findFirstOrThrow
   */
  export type google_transactionsFindFirstOrThrowArgs = google_transactionsFindFirstArgsBase
      

  /**
   * google_transactions without action
   */
  export type google_transactionsArgs = {
    /**
     * Select specific fields to fetch from the google_transactions
     * 
    **/
    select?: google_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: google_transactionsInclude | null
  }



  /**
   * Model kobo_transaction
   */


  export type AggregateKobo_transaction = {
    _count: Kobo_transactionCountAggregateOutputType | null
    _avg: Kobo_transactionAvgAggregateOutputType | null
    _sum: Kobo_transactionSumAggregateOutputType | null
    _min: Kobo_transactionMinAggregateOutputType | null
    _max: Kobo_transactionMaxAggregateOutputType | null
  }

  export type Kobo_transactionAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    list_price: number | null
    tax_excluded: number | null
    COGS_percentage: number | null
    COGS_amount: number | null
    foreign_exchange: number | null
    COGS_payable: number | null
    COGS_based_lp: number | null
    COGS_based_lp_excluded_tax: number | null
    COGS_based_lp_currency: number | null
    COGS_adjustment: number | null
    net_due: number | null
    total_tax: number | null
    book_id: number | null
    author_id: number | null
    paid_inr: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Kobo_transactionSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    list_price: number | null
    tax_excluded: number | null
    COGS_percentage: number | null
    COGS_amount: number | null
    foreign_exchange: number | null
    COGS_payable: number | null
    COGS_based_lp: number | null
    COGS_based_lp_excluded_tax: number | null
    COGS_based_lp_currency: number | null
    COGS_adjustment: number | null
    net_due: number | null
    total_tax: number | null
    book_id: number | null
    author_id: number | null
    paid_inr: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Kobo_transactionMinAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    country: string | null
    state: string | null
    zipcode: string | null
    content_type: string | null
    quantity: number | null
    refund_reason: string | null
    dealID: string | null
    publisher_name: string | null
    imprint: string | null
    eISBN: string | null
    author_name: string | null
    book_title: string | null
    list_price: number | null
    tax_excluded: number | null
    COGS_percentage: number | null
    COGS_amount: number | null
    list_price_currency: string | null
    foreign_exchange: number | null
    COGS_payable: number | null
    COGS_based_lp: number | null
    COGS_based_lp_excluded_tax: number | null
    COGS_based_lp_currency: number | null
    COGS_adjustment: number | null
    net_due: number | null
    payable_currency: string | null
    total_tax: number | null
    book_id: number | null
    author_id: number | null
    paid_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Kobo_transactionMaxAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    country: string | null
    state: string | null
    zipcode: string | null
    content_type: string | null
    quantity: number | null
    refund_reason: string | null
    dealID: string | null
    publisher_name: string | null
    imprint: string | null
    eISBN: string | null
    author_name: string | null
    book_title: string | null
    list_price: number | null
    tax_excluded: number | null
    COGS_percentage: number | null
    COGS_amount: number | null
    list_price_currency: string | null
    foreign_exchange: number | null
    COGS_payable: number | null
    COGS_based_lp: number | null
    COGS_based_lp_excluded_tax: number | null
    COGS_based_lp_currency: number | null
    COGS_adjustment: number | null
    net_due: number | null
    payable_currency: string | null
    total_tax: number | null
    book_id: number | null
    author_id: number | null
    paid_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Kobo_transactionCountAggregateOutputType = {
    id: number
    transaction_date: number
    country: number
    state: number
    zipcode: number
    content_type: number
    quantity: number
    refund_reason: number
    dealID: number
    publisher_name: number
    imprint: number
    eISBN: number
    author_name: number
    book_title: number
    list_price: number
    tax_excluded: number
    COGS_percentage: number
    COGS_amount: number
    list_price_currency: number
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp: number
    COGS_based_lp_excluded_tax: number
    COGS_based_lp_currency: number
    COGS_adjustment: number
    net_due: number
    payable_currency: number
    total_tax: number
    book_id: number
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner: number
    status: number
    _all: number
  }


  export type Kobo_transactionAvgAggregateInputType = {
    id?: true
    quantity?: true
    list_price?: true
    tax_excluded?: true
    COGS_percentage?: true
    COGS_amount?: true
    foreign_exchange?: true
    COGS_payable?: true
    COGS_based_lp?: true
    COGS_based_lp_excluded_tax?: true
    COGS_based_lp_currency?: true
    COGS_adjustment?: true
    net_due?: true
    total_tax?: true
    book_id?: true
    author_id?: true
    paid_inr?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Kobo_transactionSumAggregateInputType = {
    id?: true
    quantity?: true
    list_price?: true
    tax_excluded?: true
    COGS_percentage?: true
    COGS_amount?: true
    foreign_exchange?: true
    COGS_payable?: true
    COGS_based_lp?: true
    COGS_based_lp_excluded_tax?: true
    COGS_based_lp_currency?: true
    COGS_adjustment?: true
    net_due?: true
    total_tax?: true
    book_id?: true
    author_id?: true
    paid_inr?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Kobo_transactionMinAggregateInputType = {
    id?: true
    transaction_date?: true
    country?: true
    state?: true
    zipcode?: true
    content_type?: true
    quantity?: true
    refund_reason?: true
    dealID?: true
    publisher_name?: true
    imprint?: true
    eISBN?: true
    author_name?: true
    book_title?: true
    list_price?: true
    tax_excluded?: true
    COGS_percentage?: true
    COGS_amount?: true
    list_price_currency?: true
    foreign_exchange?: true
    COGS_payable?: true
    COGS_based_lp?: true
    COGS_based_lp_excluded_tax?: true
    COGS_based_lp_currency?: true
    COGS_adjustment?: true
    net_due?: true
    payable_currency?: true
    total_tax?: true
    book_id?: true
    author_id?: true
    paid_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Kobo_transactionMaxAggregateInputType = {
    id?: true
    transaction_date?: true
    country?: true
    state?: true
    zipcode?: true
    content_type?: true
    quantity?: true
    refund_reason?: true
    dealID?: true
    publisher_name?: true
    imprint?: true
    eISBN?: true
    author_name?: true
    book_title?: true
    list_price?: true
    tax_excluded?: true
    COGS_percentage?: true
    COGS_amount?: true
    list_price_currency?: true
    foreign_exchange?: true
    COGS_payable?: true
    COGS_based_lp?: true
    COGS_based_lp_excluded_tax?: true
    COGS_based_lp_currency?: true
    COGS_adjustment?: true
    net_due?: true
    payable_currency?: true
    total_tax?: true
    book_id?: true
    author_id?: true
    paid_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Kobo_transactionCountAggregateInputType = {
    id?: true
    transaction_date?: true
    country?: true
    state?: true
    zipcode?: true
    content_type?: true
    quantity?: true
    refund_reason?: true
    dealID?: true
    publisher_name?: true
    imprint?: true
    eISBN?: true
    author_name?: true
    book_title?: true
    list_price?: true
    tax_excluded?: true
    COGS_percentage?: true
    COGS_amount?: true
    list_price_currency?: true
    foreign_exchange?: true
    COGS_payable?: true
    COGS_based_lp?: true
    COGS_based_lp_excluded_tax?: true
    COGS_based_lp_currency?: true
    COGS_adjustment?: true
    net_due?: true
    payable_currency?: true
    total_tax?: true
    book_id?: true
    author_id?: true
    paid_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    _all?: true
  }

  export type Kobo_transactionAggregateArgs = {
    /**
     * Filter which kobo_transaction to aggregate.
     * 
    **/
    where?: kobo_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kobo_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<kobo_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: kobo_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kobo_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kobo_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kobo_transactions
    **/
    _count?: true | Kobo_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kobo_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kobo_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kobo_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kobo_transactionMaxAggregateInputType
  }

  export type GetKobo_transactionAggregateType<T extends Kobo_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateKobo_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKobo_transaction[P]>
      : GetScalarType<T[P], AggregateKobo_transaction[P]>
  }




  export type Kobo_transactionGroupByArgs = {
    where?: kobo_transactionWhereInput
    orderBy?: Enumerable<kobo_transactionOrderByWithAggregationInput>
    by: Array<Kobo_transactionScalarFieldEnum>
    having?: kobo_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kobo_transactionCountAggregateInputType | true
    _avg?: Kobo_transactionAvgAggregateInputType
    _sum?: Kobo_transactionSumAggregateInputType
    _min?: Kobo_transactionMinAggregateInputType
    _max?: Kobo_transactionMaxAggregateInputType
  }


  export type Kobo_transactionGroupByOutputType = {
    id: number
    transaction_date: Date
    country: string
    state: string | null
    zipcode: string | null
    content_type: string | null
    quantity: number | null
    refund_reason: string | null
    dealID: string | null
    publisher_name: string | null
    imprint: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded: number | null
    COGS_percentage: number
    COGS_amount: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp: number | null
    COGS_based_lp_excluded_tax: number | null
    COGS_based_lp_currency: number | null
    COGS_adjustment: number | null
    net_due: number
    payable_currency: string
    total_tax: number | null
    book_id: number
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner: number | null
    status: string
    _count: Kobo_transactionCountAggregateOutputType | null
    _avg: Kobo_transactionAvgAggregateOutputType | null
    _sum: Kobo_transactionSumAggregateOutputType | null
    _min: Kobo_transactionMinAggregateOutputType | null
    _max: Kobo_transactionMaxAggregateOutputType | null
  }

  type GetKobo_transactionGroupByPayload<T extends Kobo_transactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Kobo_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kobo_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kobo_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Kobo_transactionGroupByOutputType[P]>
        }
      >
    >


  export type kobo_transactionSelect = {
    id?: boolean
    transaction_date?: boolean
    country?: boolean
    state?: boolean
    zipcode?: boolean
    content_type?: boolean
    quantity?: boolean
    refund_reason?: boolean
    dealID?: boolean
    publisher_name?: boolean
    imprint?: boolean
    eISBN?: boolean
    author_name?: boolean
    book_title?: boolean
    list_price?: boolean
    tax_excluded?: boolean
    COGS_percentage?: boolean
    COGS_amount?: boolean
    list_price_currency?: boolean
    foreign_exchange?: boolean
    COGS_payable?: boolean
    COGS_based_lp?: boolean
    COGS_based_lp_excluded_tax?: boolean
    COGS_based_lp_currency?: boolean
    COGS_adjustment?: boolean
    net_due?: boolean
    payable_currency?: boolean
    total_tax?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    paid_inr?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    status?: boolean
  }


  export type kobo_transactionInclude = {
    book?: boolean | book_tblArgs
  } 

  export type kobo_transactionGetPayload<S extends boolean | null | undefined | kobo_transactionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? kobo_transaction :
    S extends undefined ? never :
    S extends { include: any } & (kobo_transactionArgs | kobo_transactionFindManyArgs)
    ? kobo_transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (kobo_transactionArgs | kobo_transactionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof kobo_transaction ? kobo_transaction[P] : never
  } 
      : kobo_transaction


  type kobo_transactionCountArgs = Merge<
    Omit<kobo_transactionFindManyArgs, 'select' | 'include'> & {
      select?: Kobo_transactionCountAggregateInputType | true
    }
  >

  export interface kobo_transactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Kobo_transaction that matches the filter.
     * @param {kobo_transactionFindUniqueArgs} args - Arguments to find a Kobo_transaction
     * @example
     * // Get one Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kobo_transactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, kobo_transactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'kobo_transaction'> extends True ? Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>> : Prisma__kobo_transactionClient<kobo_transactionGetPayload<T> | null, null>

    /**
     * Find the first Kobo_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kobo_transactionFindFirstArgs} args - Arguments to find a Kobo_transaction
     * @example
     * // Get one Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kobo_transactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, kobo_transactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'kobo_transaction'> extends True ? Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>> : Prisma__kobo_transactionClient<kobo_transactionGetPayload<T> | null, null>

    /**
     * Find zero or more Kobo_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kobo_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kobo_transactions
     * const kobo_transactions = await prisma.kobo_transaction.findMany()
     * 
     * // Get first 10 Kobo_transactions
     * const kobo_transactions = await prisma.kobo_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kobo_transactionWithIdOnly = await prisma.kobo_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kobo_transactionFindManyArgs>(
      args?: SelectSubset<T, kobo_transactionFindManyArgs>
    ): PrismaPromise<Array<kobo_transactionGetPayload<T>>>

    /**
     * Create a Kobo_transaction.
     * @param {kobo_transactionCreateArgs} args - Arguments to create a Kobo_transaction.
     * @example
     * // Create one Kobo_transaction
     * const Kobo_transaction = await prisma.kobo_transaction.create({
     *   data: {
     *     // ... data to create a Kobo_transaction
     *   }
     * })
     * 
    **/
    create<T extends kobo_transactionCreateArgs>(
      args: SelectSubset<T, kobo_transactionCreateArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Create many Kobo_transactions.
     *     @param {kobo_transactionCreateManyArgs} args - Arguments to create many Kobo_transactions.
     *     @example
     *     // Create many Kobo_transactions
     *     const kobo_transaction = await prisma.kobo_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kobo_transactionCreateManyArgs>(
      args?: SelectSubset<T, kobo_transactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Kobo_transaction.
     * @param {kobo_transactionDeleteArgs} args - Arguments to delete one Kobo_transaction.
     * @example
     * // Delete one Kobo_transaction
     * const Kobo_transaction = await prisma.kobo_transaction.delete({
     *   where: {
     *     // ... filter to delete one Kobo_transaction
     *   }
     * })
     * 
    **/
    delete<T extends kobo_transactionDeleteArgs>(
      args: SelectSubset<T, kobo_transactionDeleteArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Update one Kobo_transaction.
     * @param {kobo_transactionUpdateArgs} args - Arguments to update one Kobo_transaction.
     * @example
     * // Update one Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kobo_transactionUpdateArgs>(
      args: SelectSubset<T, kobo_transactionUpdateArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Delete zero or more Kobo_transactions.
     * @param {kobo_transactionDeleteManyArgs} args - Arguments to filter Kobo_transactions to delete.
     * @example
     * // Delete a few Kobo_transactions
     * const { count } = await prisma.kobo_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kobo_transactionDeleteManyArgs>(
      args?: SelectSubset<T, kobo_transactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kobo_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kobo_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kobo_transactions
     * const kobo_transaction = await prisma.kobo_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kobo_transactionUpdateManyArgs>(
      args: SelectSubset<T, kobo_transactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Kobo_transaction.
     * @param {kobo_transactionUpsertArgs} args - Arguments to update or create a Kobo_transaction.
     * @example
     * // Update or create a Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.upsert({
     *   create: {
     *     // ... data to create a Kobo_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kobo_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends kobo_transactionUpsertArgs>(
      args: SelectSubset<T, kobo_transactionUpsertArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Find one Kobo_transaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {kobo_transactionFindUniqueOrThrowArgs} args - Arguments to find a Kobo_transaction
     * @example
     * // Get one Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kobo_transactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, kobo_transactionFindUniqueOrThrowArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Find the first Kobo_transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kobo_transactionFindFirstOrThrowArgs} args - Arguments to find a Kobo_transaction
     * @example
     * // Get one Kobo_transaction
     * const kobo_transaction = await prisma.kobo_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kobo_transactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, kobo_transactionFindFirstOrThrowArgs>
    ): Prisma__kobo_transactionClient<kobo_transactionGetPayload<T>>

    /**
     * Count the number of Kobo_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kobo_transactionCountArgs} args - Arguments to filter Kobo_transactions to count.
     * @example
     * // Count the number of Kobo_transactions
     * const count = await prisma.kobo_transaction.count({
     *   where: {
     *     // ... the filter for the Kobo_transactions we want to count
     *   }
     * })
    **/
    count<T extends kobo_transactionCountArgs>(
      args?: Subset<T, kobo_transactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kobo_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kobo_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kobo_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kobo_transactionAggregateArgs>(args: Subset<T, Kobo_transactionAggregateArgs>): PrismaPromise<GetKobo_transactionAggregateType<T>>

    /**
     * Group by Kobo_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kobo_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Kobo_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Kobo_transactionGroupByArgs['orderBy'] }
        : { orderBy?: Kobo_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Kobo_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKobo_transactionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for kobo_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__kobo_transactionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * kobo_transaction base type for findUnique actions
   */
  export type kobo_transactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * Filter, which kobo_transaction to fetch.
     * 
    **/
    where: kobo_transactionWhereUniqueInput
  }

  /**
   * kobo_transaction: findUnique
   */
  export interface kobo_transactionFindUniqueArgs extends kobo_transactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * kobo_transaction base type for findFirst actions
   */
  export type kobo_transactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * Filter, which kobo_transaction to fetch.
     * 
    **/
    where?: kobo_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kobo_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<kobo_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kobo_transactions.
     * 
    **/
    cursor?: kobo_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kobo_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kobo_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kobo_transactions.
     * 
    **/
    distinct?: Enumerable<Kobo_transactionScalarFieldEnum>
  }

  /**
   * kobo_transaction: findFirst
   */
  export interface kobo_transactionFindFirstArgs extends kobo_transactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * kobo_transaction findMany
   */
  export type kobo_transactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * Filter, which kobo_transactions to fetch.
     * 
    **/
    where?: kobo_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kobo_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<kobo_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kobo_transactions.
     * 
    **/
    cursor?: kobo_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kobo_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kobo_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Kobo_transactionScalarFieldEnum>
  }


  /**
   * kobo_transaction create
   */
  export type kobo_transactionCreateArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * The data needed to create a kobo_transaction.
     * 
    **/
    data: XOR<kobo_transactionCreateInput, kobo_transactionUncheckedCreateInput>
  }


  /**
   * kobo_transaction createMany
   */
  export type kobo_transactionCreateManyArgs = {
    /**
     * The data used to create many kobo_transactions.
     * 
    **/
    data: Enumerable<kobo_transactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * kobo_transaction update
   */
  export type kobo_transactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * The data needed to update a kobo_transaction.
     * 
    **/
    data: XOR<kobo_transactionUpdateInput, kobo_transactionUncheckedUpdateInput>
    /**
     * Choose, which kobo_transaction to update.
     * 
    **/
    where: kobo_transactionWhereUniqueInput
  }


  /**
   * kobo_transaction updateMany
   */
  export type kobo_transactionUpdateManyArgs = {
    /**
     * The data used to update kobo_transactions.
     * 
    **/
    data: XOR<kobo_transactionUpdateManyMutationInput, kobo_transactionUncheckedUpdateManyInput>
    /**
     * Filter which kobo_transactions to update
     * 
    **/
    where?: kobo_transactionWhereInput
  }


  /**
   * kobo_transaction upsert
   */
  export type kobo_transactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * The filter to search for the kobo_transaction to update in case it exists.
     * 
    **/
    where: kobo_transactionWhereUniqueInput
    /**
     * In case the kobo_transaction found by the `where` argument doesn't exist, create a new kobo_transaction with this data.
     * 
    **/
    create: XOR<kobo_transactionCreateInput, kobo_transactionUncheckedCreateInput>
    /**
     * In case the kobo_transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<kobo_transactionUpdateInput, kobo_transactionUncheckedUpdateInput>
  }


  /**
   * kobo_transaction delete
   */
  export type kobo_transactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
    /**
     * Filter which kobo_transaction to delete.
     * 
    **/
    where: kobo_transactionWhereUniqueInput
  }


  /**
   * kobo_transaction deleteMany
   */
  export type kobo_transactionDeleteManyArgs = {
    /**
     * Filter which kobo_transactions to delete
     * 
    **/
    where?: kobo_transactionWhereInput
  }


  /**
   * kobo_transaction: findUniqueOrThrow
   */
  export type kobo_transactionFindUniqueOrThrowArgs = kobo_transactionFindUniqueArgsBase
      

  /**
   * kobo_transaction: findFirstOrThrow
   */
  export type kobo_transactionFindFirstOrThrowArgs = kobo_transactionFindFirstArgsBase
      

  /**
   * kobo_transaction without action
   */
  export type kobo_transactionArgs = {
    /**
     * Select specific fields to fetch from the kobo_transaction
     * 
    **/
    select?: kobo_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: kobo_transactionInclude | null
  }



  /**
   * Model language_tbl
   */


  export type AggregateLanguage_tbl = {
    _count: Language_tblCountAggregateOutputType | null
    _avg: Language_tblAvgAggregateOutputType | null
    _sum: Language_tblSumAggregateOutputType | null
    _min: Language_tblMinAggregateOutputType | null
    _max: Language_tblMaxAggregateOutputType | null
  }

  export type Language_tblAvgAggregateOutputType = {
    language_id: number | null
    admin_id: number | null
    status: number | null
  }

  export type Language_tblSumAggregateOutputType = {
    language_id: number | null
    admin_id: number | null
    status: number | null
  }

  export type Language_tblMinAggregateOutputType = {
    language_id: number | null
    admin_id: number | null
    language_name: string | null
    regional_language_name: string | null
    url_name: string | null
    image_url: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Language_tblMaxAggregateOutputType = {
    language_id: number | null
    admin_id: number | null
    language_name: string | null
    regional_language_name: string | null
    url_name: string | null
    image_url: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Language_tblCountAggregateOutputType = {
    language_id: number
    admin_id: number
    language_name: number
    regional_language_name: number
    url_name: number
    image_url: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Language_tblAvgAggregateInputType = {
    language_id?: true
    admin_id?: true
    status?: true
  }

  export type Language_tblSumAggregateInputType = {
    language_id?: true
    admin_id?: true
    status?: true
  }

  export type Language_tblMinAggregateInputType = {
    language_id?: true
    admin_id?: true
    language_name?: true
    regional_language_name?: true
    url_name?: true
    image_url?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Language_tblMaxAggregateInputType = {
    language_id?: true
    admin_id?: true
    language_name?: true
    regional_language_name?: true
    url_name?: true
    image_url?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Language_tblCountAggregateInputType = {
    language_id?: true
    admin_id?: true
    language_name?: true
    regional_language_name?: true
    url_name?: true
    image_url?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Language_tblAggregateArgs = {
    /**
     * Filter which language_tbl to aggregate.
     * 
    **/
    where?: language_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of language_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<language_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: language_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` language_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` language_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned language_tbls
    **/
    _count?: true | Language_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Language_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Language_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Language_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Language_tblMaxAggregateInputType
  }

  export type GetLanguage_tblAggregateType<T extends Language_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage_tbl[P]>
      : GetScalarType<T[P], AggregateLanguage_tbl[P]>
  }




  export type Language_tblGroupByArgs = {
    where?: language_tblWhereInput
    orderBy?: Enumerable<language_tblOrderByWithAggregationInput>
    by: Array<Language_tblScalarFieldEnum>
    having?: language_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Language_tblCountAggregateInputType | true
    _avg?: Language_tblAvgAggregateInputType
    _sum?: Language_tblSumAggregateInputType
    _min?: Language_tblMinAggregateInputType
    _max?: Language_tblMaxAggregateInputType
  }


  export type Language_tblGroupByOutputType = {
    language_id: number
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name: string | null
    image_url: string | null
    status: number
    created_at: Date
    updated_at: Date
    _count: Language_tblCountAggregateOutputType | null
    _avg: Language_tblAvgAggregateOutputType | null
    _sum: Language_tblSumAggregateOutputType | null
    _min: Language_tblMinAggregateOutputType | null
    _max: Language_tblMaxAggregateOutputType | null
  }

  type GetLanguage_tblGroupByPayload<T extends Language_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Language_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Language_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Language_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Language_tblGroupByOutputType[P]>
        }
      >
    >


  export type language_tblSelect = {
    language_id?: boolean
    admin_id?: boolean
    language_name?: boolean
    regional_language_name?: boolean
    url_name?: boolean
    image_url?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    books?: boolean | book_tblFindManyArgs
    authorLanguages?: boolean | author_languageFindManyArgs
    _count?: boolean | Language_tblCountOutputTypeArgs
  }


  export type language_tblInclude = {
    books?: boolean | book_tblFindManyArgs
    authorLanguages?: boolean | author_languageFindManyArgs
    _count?: boolean | Language_tblCountOutputTypeArgs
  } 

  export type language_tblGetPayload<S extends boolean | null | undefined | language_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? language_tbl :
    S extends undefined ? never :
    S extends { include: any } & (language_tblArgs | language_tblFindManyArgs)
    ? language_tbl  & {
    [P in TrueKeys<S['include']>]:
        P extends 'books' ? Array < book_tblGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'authorLanguages' ? Array < author_languageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Language_tblCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (language_tblArgs | language_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'books' ? Array < book_tblGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'authorLanguages' ? Array < author_languageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Language_tblCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof language_tbl ? language_tbl[P] : never
  } 
      : language_tbl


  type language_tblCountArgs = Merge<
    Omit<language_tblFindManyArgs, 'select' | 'include'> & {
      select?: Language_tblCountAggregateInputType | true
    }
  >

  export interface language_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Language_tbl that matches the filter.
     * @param {language_tblFindUniqueArgs} args - Arguments to find a Language_tbl
     * @example
     * // Get one Language_tbl
     * const language_tbl = await prisma.language_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends language_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, language_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'language_tbl'> extends True ? Prisma__language_tblClient<language_tblGetPayload<T>> : Prisma__language_tblClient<language_tblGetPayload<T> | null, null>

    /**
     * Find the first Language_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {language_tblFindFirstArgs} args - Arguments to find a Language_tbl
     * @example
     * // Get one Language_tbl
     * const language_tbl = await prisma.language_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends language_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, language_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'language_tbl'> extends True ? Prisma__language_tblClient<language_tblGetPayload<T>> : Prisma__language_tblClient<language_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Language_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {language_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Language_tbls
     * const language_tbls = await prisma.language_tbl.findMany()
     * 
     * // Get first 10 Language_tbls
     * const language_tbls = await prisma.language_tbl.findMany({ take: 10 })
     * 
     * // Only select the `language_id`
     * const language_tblWithLanguage_idOnly = await prisma.language_tbl.findMany({ select: { language_id: true } })
     * 
    **/
    findMany<T extends language_tblFindManyArgs>(
      args?: SelectSubset<T, language_tblFindManyArgs>
    ): PrismaPromise<Array<language_tblGetPayload<T>>>

    /**
     * Create a Language_tbl.
     * @param {language_tblCreateArgs} args - Arguments to create a Language_tbl.
     * @example
     * // Create one Language_tbl
     * const Language_tbl = await prisma.language_tbl.create({
     *   data: {
     *     // ... data to create a Language_tbl
     *   }
     * })
     * 
    **/
    create<T extends language_tblCreateArgs>(
      args: SelectSubset<T, language_tblCreateArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Create many Language_tbls.
     *     @param {language_tblCreateManyArgs} args - Arguments to create many Language_tbls.
     *     @example
     *     // Create many Language_tbls
     *     const language_tbl = await prisma.language_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends language_tblCreateManyArgs>(
      args?: SelectSubset<T, language_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Language_tbl.
     * @param {language_tblDeleteArgs} args - Arguments to delete one Language_tbl.
     * @example
     * // Delete one Language_tbl
     * const Language_tbl = await prisma.language_tbl.delete({
     *   where: {
     *     // ... filter to delete one Language_tbl
     *   }
     * })
     * 
    **/
    delete<T extends language_tblDeleteArgs>(
      args: SelectSubset<T, language_tblDeleteArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Update one Language_tbl.
     * @param {language_tblUpdateArgs} args - Arguments to update one Language_tbl.
     * @example
     * // Update one Language_tbl
     * const language_tbl = await prisma.language_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends language_tblUpdateArgs>(
      args: SelectSubset<T, language_tblUpdateArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Delete zero or more Language_tbls.
     * @param {language_tblDeleteManyArgs} args - Arguments to filter Language_tbls to delete.
     * @example
     * // Delete a few Language_tbls
     * const { count } = await prisma.language_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends language_tblDeleteManyArgs>(
      args?: SelectSubset<T, language_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Language_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {language_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Language_tbls
     * const language_tbl = await prisma.language_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends language_tblUpdateManyArgs>(
      args: SelectSubset<T, language_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Language_tbl.
     * @param {language_tblUpsertArgs} args - Arguments to update or create a Language_tbl.
     * @example
     * // Update or create a Language_tbl
     * const language_tbl = await prisma.language_tbl.upsert({
     *   create: {
     *     // ... data to create a Language_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends language_tblUpsertArgs>(
      args: SelectSubset<T, language_tblUpsertArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Find one Language_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {language_tblFindUniqueOrThrowArgs} args - Arguments to find a Language_tbl
     * @example
     * // Get one Language_tbl
     * const language_tbl = await prisma.language_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends language_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, language_tblFindUniqueOrThrowArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Find the first Language_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {language_tblFindFirstOrThrowArgs} args - Arguments to find a Language_tbl
     * @example
     * // Get one Language_tbl
     * const language_tbl = await prisma.language_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends language_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, language_tblFindFirstOrThrowArgs>
    ): Prisma__language_tblClient<language_tblGetPayload<T>>

    /**
     * Count the number of Language_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {language_tblCountArgs} args - Arguments to filter Language_tbls to count.
     * @example
     * // Count the number of Language_tbls
     * const count = await prisma.language_tbl.count({
     *   where: {
     *     // ... the filter for the Language_tbls we want to count
     *   }
     * })
    **/
    count<T extends language_tblCountArgs>(
      args?: Subset<T, language_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Language_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Language_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Language_tblAggregateArgs>(args: Subset<T, Language_tblAggregateArgs>): PrismaPromise<GetLanguage_tblAggregateType<T>>

    /**
     * Group by Language_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Language_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Language_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Language_tblGroupByArgs['orderBy'] }
        : { orderBy?: Language_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Language_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguage_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for language_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__language_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    books<T extends book_tblFindManyArgs= {}>(args?: Subset<T, book_tblFindManyArgs>): PrismaPromise<Array<book_tblGetPayload<T>>| Null>;

    authorLanguages<T extends author_languageFindManyArgs= {}>(args?: Subset<T, author_languageFindManyArgs>): PrismaPromise<Array<author_languageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * language_tbl base type for findUnique actions
   */
  export type language_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * Filter, which language_tbl to fetch.
     * 
    **/
    where: language_tblWhereUniqueInput
  }

  /**
   * language_tbl: findUnique
   */
  export interface language_tblFindUniqueArgs extends language_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * language_tbl base type for findFirst actions
   */
  export type language_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * Filter, which language_tbl to fetch.
     * 
    **/
    where?: language_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of language_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<language_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for language_tbls.
     * 
    **/
    cursor?: language_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` language_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` language_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of language_tbls.
     * 
    **/
    distinct?: Enumerable<Language_tblScalarFieldEnum>
  }

  /**
   * language_tbl: findFirst
   */
  export interface language_tblFindFirstArgs extends language_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * language_tbl findMany
   */
  export type language_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * Filter, which language_tbls to fetch.
     * 
    **/
    where?: language_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of language_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<language_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing language_tbls.
     * 
    **/
    cursor?: language_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` language_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` language_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Language_tblScalarFieldEnum>
  }


  /**
   * language_tbl create
   */
  export type language_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * The data needed to create a language_tbl.
     * 
    **/
    data: XOR<language_tblCreateInput, language_tblUncheckedCreateInput>
  }


  /**
   * language_tbl createMany
   */
  export type language_tblCreateManyArgs = {
    /**
     * The data used to create many language_tbls.
     * 
    **/
    data: Enumerable<language_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * language_tbl update
   */
  export type language_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * The data needed to update a language_tbl.
     * 
    **/
    data: XOR<language_tblUpdateInput, language_tblUncheckedUpdateInput>
    /**
     * Choose, which language_tbl to update.
     * 
    **/
    where: language_tblWhereUniqueInput
  }


  /**
   * language_tbl updateMany
   */
  export type language_tblUpdateManyArgs = {
    /**
     * The data used to update language_tbls.
     * 
    **/
    data: XOR<language_tblUpdateManyMutationInput, language_tblUncheckedUpdateManyInput>
    /**
     * Filter which language_tbls to update
     * 
    **/
    where?: language_tblWhereInput
  }


  /**
   * language_tbl upsert
   */
  export type language_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * The filter to search for the language_tbl to update in case it exists.
     * 
    **/
    where: language_tblWhereUniqueInput
    /**
     * In case the language_tbl found by the `where` argument doesn't exist, create a new language_tbl with this data.
     * 
    **/
    create: XOR<language_tblCreateInput, language_tblUncheckedCreateInput>
    /**
     * In case the language_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<language_tblUpdateInput, language_tblUncheckedUpdateInput>
  }


  /**
   * language_tbl delete
   */
  export type language_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
    /**
     * Filter which language_tbl to delete.
     * 
    **/
    where: language_tblWhereUniqueInput
  }


  /**
   * language_tbl deleteMany
   */
  export type language_tblDeleteManyArgs = {
    /**
     * Filter which language_tbls to delete
     * 
    **/
    where?: language_tblWhereInput
  }


  /**
   * language_tbl: findUniqueOrThrow
   */
  export type language_tblFindUniqueOrThrowArgs = language_tblFindUniqueArgsBase
      

  /**
   * language_tbl: findFirstOrThrow
   */
  export type language_tblFindFirstOrThrowArgs = language_tblFindFirstArgsBase
      

  /**
   * language_tbl without action
   */
  export type language_tblArgs = {
    /**
     * Select specific fields to fetch from the language_tbl
     * 
    **/
    select?: language_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: language_tblInclude | null
  }



  /**
   * Model ledger_head_tbl
   */


  export type AggregateLedger_head_tbl = {
    _count: Ledger_head_tblCountAggregateOutputType | null
    _avg: Ledger_head_tblAvgAggregateOutputType | null
    _sum: Ledger_head_tblSumAggregateOutputType | null
    _min: Ledger_head_tblMinAggregateOutputType | null
    _max: Ledger_head_tblMaxAggregateOutputType | null
  }

  export type Ledger_head_tblAvgAggregateOutputType = {
    id: number | null
  }

  export type Ledger_head_tblSumAggregateOutputType = {
    id: number | null
  }

  export type Ledger_head_tblMinAggregateOutputType = {
    id: number | null
    ledger_head_name: string | null
    date_created: Date | null
  }

  export type Ledger_head_tblMaxAggregateOutputType = {
    id: number | null
    ledger_head_name: string | null
    date_created: Date | null
  }

  export type Ledger_head_tblCountAggregateOutputType = {
    id: number
    ledger_head_name: number
    date_created: number
    _all: number
  }


  export type Ledger_head_tblAvgAggregateInputType = {
    id?: true
  }

  export type Ledger_head_tblSumAggregateInputType = {
    id?: true
  }

  export type Ledger_head_tblMinAggregateInputType = {
    id?: true
    ledger_head_name?: true
    date_created?: true
  }

  export type Ledger_head_tblMaxAggregateInputType = {
    id?: true
    ledger_head_name?: true
    date_created?: true
  }

  export type Ledger_head_tblCountAggregateInputType = {
    id?: true
    ledger_head_name?: true
    date_created?: true
    _all?: true
  }

  export type Ledger_head_tblAggregateArgs = {
    /**
     * Filter which ledger_head_tbl to aggregate.
     * 
    **/
    where?: ledger_head_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_head_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<ledger_head_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ledger_head_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_head_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_head_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ledger_head_tbls
    **/
    _count?: true | Ledger_head_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ledger_head_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ledger_head_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ledger_head_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ledger_head_tblMaxAggregateInputType
  }

  export type GetLedger_head_tblAggregateType<T extends Ledger_head_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateLedger_head_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedger_head_tbl[P]>
      : GetScalarType<T[P], AggregateLedger_head_tbl[P]>
  }




  export type Ledger_head_tblGroupByArgs = {
    where?: ledger_head_tblWhereInput
    orderBy?: Enumerable<ledger_head_tblOrderByWithAggregationInput>
    by: Array<Ledger_head_tblScalarFieldEnum>
    having?: ledger_head_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ledger_head_tblCountAggregateInputType | true
    _avg?: Ledger_head_tblAvgAggregateInputType
    _sum?: Ledger_head_tblSumAggregateInputType
    _min?: Ledger_head_tblMinAggregateInputType
    _max?: Ledger_head_tblMaxAggregateInputType
  }


  export type Ledger_head_tblGroupByOutputType = {
    id: number
    ledger_head_name: string
    date_created: Date
    _count: Ledger_head_tblCountAggregateOutputType | null
    _avg: Ledger_head_tblAvgAggregateOutputType | null
    _sum: Ledger_head_tblSumAggregateOutputType | null
    _min: Ledger_head_tblMinAggregateOutputType | null
    _max: Ledger_head_tblMaxAggregateOutputType | null
  }

  type GetLedger_head_tblGroupByPayload<T extends Ledger_head_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Ledger_head_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ledger_head_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ledger_head_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Ledger_head_tblGroupByOutputType[P]>
        }
      >
    >


  export type ledger_head_tblSelect = {
    id?: boolean
    ledger_head_name?: boolean
    date_created?: boolean
  }


  export type ledger_head_tblGetPayload<S extends boolean | null | undefined | ledger_head_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ledger_head_tbl :
    S extends undefined ? never :
    S extends { include: any } & (ledger_head_tblArgs | ledger_head_tblFindManyArgs)
    ? ledger_head_tbl 
    : S extends { select: any } & (ledger_head_tblArgs | ledger_head_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ledger_head_tbl ? ledger_head_tbl[P] : never
  } 
      : ledger_head_tbl


  type ledger_head_tblCountArgs = Merge<
    Omit<ledger_head_tblFindManyArgs, 'select' | 'include'> & {
      select?: Ledger_head_tblCountAggregateInputType | true
    }
  >

  export interface ledger_head_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ledger_head_tbl that matches the filter.
     * @param {ledger_head_tblFindUniqueArgs} args - Arguments to find a Ledger_head_tbl
     * @example
     * // Get one Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ledger_head_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ledger_head_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ledger_head_tbl'> extends True ? Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>> : Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T> | null, null>

    /**
     * Find the first Ledger_head_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_head_tblFindFirstArgs} args - Arguments to find a Ledger_head_tbl
     * @example
     * // Get one Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ledger_head_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ledger_head_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ledger_head_tbl'> extends True ? Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>> : Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Ledger_head_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_head_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ledger_head_tbls
     * const ledger_head_tbls = await prisma.ledger_head_tbl.findMany()
     * 
     * // Get first 10 Ledger_head_tbls
     * const ledger_head_tbls = await prisma.ledger_head_tbl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledger_head_tblWithIdOnly = await prisma.ledger_head_tbl.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ledger_head_tblFindManyArgs>(
      args?: SelectSubset<T, ledger_head_tblFindManyArgs>
    ): PrismaPromise<Array<ledger_head_tblGetPayload<T>>>

    /**
     * Create a Ledger_head_tbl.
     * @param {ledger_head_tblCreateArgs} args - Arguments to create a Ledger_head_tbl.
     * @example
     * // Create one Ledger_head_tbl
     * const Ledger_head_tbl = await prisma.ledger_head_tbl.create({
     *   data: {
     *     // ... data to create a Ledger_head_tbl
     *   }
     * })
     * 
    **/
    create<T extends ledger_head_tblCreateArgs>(
      args: SelectSubset<T, ledger_head_tblCreateArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Create many Ledger_head_tbls.
     *     @param {ledger_head_tblCreateManyArgs} args - Arguments to create many Ledger_head_tbls.
     *     @example
     *     // Create many Ledger_head_tbls
     *     const ledger_head_tbl = await prisma.ledger_head_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ledger_head_tblCreateManyArgs>(
      args?: SelectSubset<T, ledger_head_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ledger_head_tbl.
     * @param {ledger_head_tblDeleteArgs} args - Arguments to delete one Ledger_head_tbl.
     * @example
     * // Delete one Ledger_head_tbl
     * const Ledger_head_tbl = await prisma.ledger_head_tbl.delete({
     *   where: {
     *     // ... filter to delete one Ledger_head_tbl
     *   }
     * })
     * 
    **/
    delete<T extends ledger_head_tblDeleteArgs>(
      args: SelectSubset<T, ledger_head_tblDeleteArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Update one Ledger_head_tbl.
     * @param {ledger_head_tblUpdateArgs} args - Arguments to update one Ledger_head_tbl.
     * @example
     * // Update one Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ledger_head_tblUpdateArgs>(
      args: SelectSubset<T, ledger_head_tblUpdateArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Delete zero or more Ledger_head_tbls.
     * @param {ledger_head_tblDeleteManyArgs} args - Arguments to filter Ledger_head_tbls to delete.
     * @example
     * // Delete a few Ledger_head_tbls
     * const { count } = await prisma.ledger_head_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ledger_head_tblDeleteManyArgs>(
      args?: SelectSubset<T, ledger_head_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledger_head_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_head_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ledger_head_tbls
     * const ledger_head_tbl = await prisma.ledger_head_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ledger_head_tblUpdateManyArgs>(
      args: SelectSubset<T, ledger_head_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ledger_head_tbl.
     * @param {ledger_head_tblUpsertArgs} args - Arguments to update or create a Ledger_head_tbl.
     * @example
     * // Update or create a Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.upsert({
     *   create: {
     *     // ... data to create a Ledger_head_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ledger_head_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends ledger_head_tblUpsertArgs>(
      args: SelectSubset<T, ledger_head_tblUpsertArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Find one Ledger_head_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ledger_head_tblFindUniqueOrThrowArgs} args - Arguments to find a Ledger_head_tbl
     * @example
     * // Get one Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ledger_head_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ledger_head_tblFindUniqueOrThrowArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Find the first Ledger_head_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_head_tblFindFirstOrThrowArgs} args - Arguments to find a Ledger_head_tbl
     * @example
     * // Get one Ledger_head_tbl
     * const ledger_head_tbl = await prisma.ledger_head_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ledger_head_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ledger_head_tblFindFirstOrThrowArgs>
    ): Prisma__ledger_head_tblClient<ledger_head_tblGetPayload<T>>

    /**
     * Count the number of Ledger_head_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_head_tblCountArgs} args - Arguments to filter Ledger_head_tbls to count.
     * @example
     * // Count the number of Ledger_head_tbls
     * const count = await prisma.ledger_head_tbl.count({
     *   where: {
     *     // ... the filter for the Ledger_head_tbls we want to count
     *   }
     * })
    **/
    count<T extends ledger_head_tblCountArgs>(
      args?: Subset<T, ledger_head_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ledger_head_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ledger_head_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ledger_head_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ledger_head_tblAggregateArgs>(args: Subset<T, Ledger_head_tblAggregateArgs>): PrismaPromise<GetLedger_head_tblAggregateType<T>>

    /**
     * Group by Ledger_head_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ledger_head_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ledger_head_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ledger_head_tblGroupByArgs['orderBy'] }
        : { orderBy?: Ledger_head_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ledger_head_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedger_head_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ledger_head_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ledger_head_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ledger_head_tbl base type for findUnique actions
   */
  export type ledger_head_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * Filter, which ledger_head_tbl to fetch.
     * 
    **/
    where: ledger_head_tblWhereUniqueInput
  }

  /**
   * ledger_head_tbl: findUnique
   */
  export interface ledger_head_tblFindUniqueArgs extends ledger_head_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ledger_head_tbl base type for findFirst actions
   */
  export type ledger_head_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * Filter, which ledger_head_tbl to fetch.
     * 
    **/
    where?: ledger_head_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_head_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<ledger_head_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ledger_head_tbls.
     * 
    **/
    cursor?: ledger_head_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_head_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_head_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ledger_head_tbls.
     * 
    **/
    distinct?: Enumerable<Ledger_head_tblScalarFieldEnum>
  }

  /**
   * ledger_head_tbl: findFirst
   */
  export interface ledger_head_tblFindFirstArgs extends ledger_head_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ledger_head_tbl findMany
   */
  export type ledger_head_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * Filter, which ledger_head_tbls to fetch.
     * 
    **/
    where?: ledger_head_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_head_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<ledger_head_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ledger_head_tbls.
     * 
    **/
    cursor?: ledger_head_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_head_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_head_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ledger_head_tblScalarFieldEnum>
  }


  /**
   * ledger_head_tbl create
   */
  export type ledger_head_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * The data needed to create a ledger_head_tbl.
     * 
    **/
    data: XOR<ledger_head_tblCreateInput, ledger_head_tblUncheckedCreateInput>
  }


  /**
   * ledger_head_tbl createMany
   */
  export type ledger_head_tblCreateManyArgs = {
    /**
     * The data used to create many ledger_head_tbls.
     * 
    **/
    data: Enumerable<ledger_head_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ledger_head_tbl update
   */
  export type ledger_head_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * The data needed to update a ledger_head_tbl.
     * 
    **/
    data: XOR<ledger_head_tblUpdateInput, ledger_head_tblUncheckedUpdateInput>
    /**
     * Choose, which ledger_head_tbl to update.
     * 
    **/
    where: ledger_head_tblWhereUniqueInput
  }


  /**
   * ledger_head_tbl updateMany
   */
  export type ledger_head_tblUpdateManyArgs = {
    /**
     * The data used to update ledger_head_tbls.
     * 
    **/
    data: XOR<ledger_head_tblUpdateManyMutationInput, ledger_head_tblUncheckedUpdateManyInput>
    /**
     * Filter which ledger_head_tbls to update
     * 
    **/
    where?: ledger_head_tblWhereInput
  }


  /**
   * ledger_head_tbl upsert
   */
  export type ledger_head_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * The filter to search for the ledger_head_tbl to update in case it exists.
     * 
    **/
    where: ledger_head_tblWhereUniqueInput
    /**
     * In case the ledger_head_tbl found by the `where` argument doesn't exist, create a new ledger_head_tbl with this data.
     * 
    **/
    create: XOR<ledger_head_tblCreateInput, ledger_head_tblUncheckedCreateInput>
    /**
     * In case the ledger_head_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ledger_head_tblUpdateInput, ledger_head_tblUncheckedUpdateInput>
  }


  /**
   * ledger_head_tbl delete
   */
  export type ledger_head_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
    /**
     * Filter which ledger_head_tbl to delete.
     * 
    **/
    where: ledger_head_tblWhereUniqueInput
  }


  /**
   * ledger_head_tbl deleteMany
   */
  export type ledger_head_tblDeleteManyArgs = {
    /**
     * Filter which ledger_head_tbls to delete
     * 
    **/
    where?: ledger_head_tblWhereInput
  }


  /**
   * ledger_head_tbl: findUniqueOrThrow
   */
  export type ledger_head_tblFindUniqueOrThrowArgs = ledger_head_tblFindUniqueArgsBase
      

  /**
   * ledger_head_tbl: findFirstOrThrow
   */
  export type ledger_head_tblFindFirstOrThrowArgs = ledger_head_tblFindFirstArgsBase
      

  /**
   * ledger_head_tbl without action
   */
  export type ledger_head_tblArgs = {
    /**
     * Select specific fields to fetch from the ledger_head_tbl
     * 
    **/
    select?: ledger_head_tblSelect | null
  }



  /**
   * Model narrator_tbl
   */


  export type AggregateNarrator_tbl = {
    _count: Narrator_tblCountAggregateOutputType | null
    _avg: Narrator_tblAvgAggregateOutputType | null
    _sum: Narrator_tblSumAggregateOutputType | null
    _min: Narrator_tblMinAggregateOutputType | null
    _max: Narrator_tblMaxAggregateOutputType | null
  }

  export type Narrator_tblAvgAggregateOutputType = {
    narrator_id: number | null
    status: number | null
    user_id: number | null
  }

  export type Narrator_tblSumAggregateOutputType = {
    narrator_id: number | null
    status: number | null
    user_id: number | null
  }

  export type Narrator_tblMinAggregateOutputType = {
    narrator_id: number | null
    narrator_name: string | null
    narrator_url: string | null
    narrator_image: string | null
    mobile: string | null
    email: string | null
    description: string | null
    status: number | null
    user_id: number | null
    image_alt_text: string | null
    image_title_text: string | null
    created_at: Date | null
  }

  export type Narrator_tblMaxAggregateOutputType = {
    narrator_id: number | null
    narrator_name: string | null
    narrator_url: string | null
    narrator_image: string | null
    mobile: string | null
    email: string | null
    description: string | null
    status: number | null
    user_id: number | null
    image_alt_text: string | null
    image_title_text: string | null
    created_at: Date | null
  }

  export type Narrator_tblCountAggregateOutputType = {
    narrator_id: number
    narrator_name: number
    narrator_url: number
    narrator_image: number
    mobile: number
    email: number
    description: number
    status: number
    user_id: number
    image_alt_text: number
    image_title_text: number
    created_at: number
    _all: number
  }


  export type Narrator_tblAvgAggregateInputType = {
    narrator_id?: true
    status?: true
    user_id?: true
  }

  export type Narrator_tblSumAggregateInputType = {
    narrator_id?: true
    status?: true
    user_id?: true
  }

  export type Narrator_tblMinAggregateInputType = {
    narrator_id?: true
    narrator_name?: true
    narrator_url?: true
    narrator_image?: true
    mobile?: true
    email?: true
    description?: true
    status?: true
    user_id?: true
    image_alt_text?: true
    image_title_text?: true
    created_at?: true
  }

  export type Narrator_tblMaxAggregateInputType = {
    narrator_id?: true
    narrator_name?: true
    narrator_url?: true
    narrator_image?: true
    mobile?: true
    email?: true
    description?: true
    status?: true
    user_id?: true
    image_alt_text?: true
    image_title_text?: true
    created_at?: true
  }

  export type Narrator_tblCountAggregateInputType = {
    narrator_id?: true
    narrator_name?: true
    narrator_url?: true
    narrator_image?: true
    mobile?: true
    email?: true
    description?: true
    status?: true
    user_id?: true
    image_alt_text?: true
    image_title_text?: true
    created_at?: true
    _all?: true
  }

  export type Narrator_tblAggregateArgs = {
    /**
     * Filter which narrator_tbl to aggregate.
     * 
    **/
    where?: narrator_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of narrator_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<narrator_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: narrator_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` narrator_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` narrator_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned narrator_tbls
    **/
    _count?: true | Narrator_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Narrator_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Narrator_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Narrator_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Narrator_tblMaxAggregateInputType
  }

  export type GetNarrator_tblAggregateType<T extends Narrator_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrator_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrator_tbl[P]>
      : GetScalarType<T[P], AggregateNarrator_tbl[P]>
  }




  export type Narrator_tblGroupByArgs = {
    where?: narrator_tblWhereInput
    orderBy?: Enumerable<narrator_tblOrderByWithAggregationInput>
    by: Array<Narrator_tblScalarFieldEnum>
    having?: narrator_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Narrator_tblCountAggregateInputType | true
    _avg?: Narrator_tblAvgAggregateInputType
    _sum?: Narrator_tblSumAggregateInputType
    _min?: Narrator_tblMinAggregateInputType
    _max?: Narrator_tblMaxAggregateInputType
  }


  export type Narrator_tblGroupByOutputType = {
    narrator_id: number
    narrator_name: string | null
    narrator_url: string | null
    narrator_image: string | null
    mobile: string | null
    email: string | null
    description: string | null
    status: number | null
    user_id: number | null
    image_alt_text: string | null
    image_title_text: string | null
    created_at: Date | null
    _count: Narrator_tblCountAggregateOutputType | null
    _avg: Narrator_tblAvgAggregateOutputType | null
    _sum: Narrator_tblSumAggregateOutputType | null
    _min: Narrator_tblMinAggregateOutputType | null
    _max: Narrator_tblMaxAggregateOutputType | null
  }

  type GetNarrator_tblGroupByPayload<T extends Narrator_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Narrator_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Narrator_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Narrator_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Narrator_tblGroupByOutputType[P]>
        }
      >
    >


  export type narrator_tblSelect = {
    narrator_id?: boolean
    narrator_name?: boolean
    narrator_url?: boolean
    narrator_image?: boolean
    mobile?: boolean
    email?: boolean
    description?: boolean
    status?: boolean
    user_id?: boolean
    image_alt_text?: boolean
    image_title_text?: boolean
    created_at?: boolean
  }


  export type narrator_tblGetPayload<S extends boolean | null | undefined | narrator_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? narrator_tbl :
    S extends undefined ? never :
    S extends { include: any } & (narrator_tblArgs | narrator_tblFindManyArgs)
    ? narrator_tbl 
    : S extends { select: any } & (narrator_tblArgs | narrator_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof narrator_tbl ? narrator_tbl[P] : never
  } 
      : narrator_tbl


  type narrator_tblCountArgs = Merge<
    Omit<narrator_tblFindManyArgs, 'select' | 'include'> & {
      select?: Narrator_tblCountAggregateInputType | true
    }
  >

  export interface narrator_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Narrator_tbl that matches the filter.
     * @param {narrator_tblFindUniqueArgs} args - Arguments to find a Narrator_tbl
     * @example
     * // Get one Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends narrator_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, narrator_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'narrator_tbl'> extends True ? Prisma__narrator_tblClient<narrator_tblGetPayload<T>> : Prisma__narrator_tblClient<narrator_tblGetPayload<T> | null, null>

    /**
     * Find the first Narrator_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {narrator_tblFindFirstArgs} args - Arguments to find a Narrator_tbl
     * @example
     * // Get one Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends narrator_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, narrator_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'narrator_tbl'> extends True ? Prisma__narrator_tblClient<narrator_tblGetPayload<T>> : Prisma__narrator_tblClient<narrator_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Narrator_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {narrator_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Narrator_tbls
     * const narrator_tbls = await prisma.narrator_tbl.findMany()
     * 
     * // Get first 10 Narrator_tbls
     * const narrator_tbls = await prisma.narrator_tbl.findMany({ take: 10 })
     * 
     * // Only select the `narrator_id`
     * const narrator_tblWithNarrator_idOnly = await prisma.narrator_tbl.findMany({ select: { narrator_id: true } })
     * 
    **/
    findMany<T extends narrator_tblFindManyArgs>(
      args?: SelectSubset<T, narrator_tblFindManyArgs>
    ): PrismaPromise<Array<narrator_tblGetPayload<T>>>

    /**
     * Create a Narrator_tbl.
     * @param {narrator_tblCreateArgs} args - Arguments to create a Narrator_tbl.
     * @example
     * // Create one Narrator_tbl
     * const Narrator_tbl = await prisma.narrator_tbl.create({
     *   data: {
     *     // ... data to create a Narrator_tbl
     *   }
     * })
     * 
    **/
    create<T extends narrator_tblCreateArgs>(
      args: SelectSubset<T, narrator_tblCreateArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Create many Narrator_tbls.
     *     @param {narrator_tblCreateManyArgs} args - Arguments to create many Narrator_tbls.
     *     @example
     *     // Create many Narrator_tbls
     *     const narrator_tbl = await prisma.narrator_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends narrator_tblCreateManyArgs>(
      args?: SelectSubset<T, narrator_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Narrator_tbl.
     * @param {narrator_tblDeleteArgs} args - Arguments to delete one Narrator_tbl.
     * @example
     * // Delete one Narrator_tbl
     * const Narrator_tbl = await prisma.narrator_tbl.delete({
     *   where: {
     *     // ... filter to delete one Narrator_tbl
     *   }
     * })
     * 
    **/
    delete<T extends narrator_tblDeleteArgs>(
      args: SelectSubset<T, narrator_tblDeleteArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Update one Narrator_tbl.
     * @param {narrator_tblUpdateArgs} args - Arguments to update one Narrator_tbl.
     * @example
     * // Update one Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends narrator_tblUpdateArgs>(
      args: SelectSubset<T, narrator_tblUpdateArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Delete zero or more Narrator_tbls.
     * @param {narrator_tblDeleteManyArgs} args - Arguments to filter Narrator_tbls to delete.
     * @example
     * // Delete a few Narrator_tbls
     * const { count } = await prisma.narrator_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends narrator_tblDeleteManyArgs>(
      args?: SelectSubset<T, narrator_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Narrator_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {narrator_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Narrator_tbls
     * const narrator_tbl = await prisma.narrator_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends narrator_tblUpdateManyArgs>(
      args: SelectSubset<T, narrator_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Narrator_tbl.
     * @param {narrator_tblUpsertArgs} args - Arguments to update or create a Narrator_tbl.
     * @example
     * // Update or create a Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.upsert({
     *   create: {
     *     // ... data to create a Narrator_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Narrator_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends narrator_tblUpsertArgs>(
      args: SelectSubset<T, narrator_tblUpsertArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Find one Narrator_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {narrator_tblFindUniqueOrThrowArgs} args - Arguments to find a Narrator_tbl
     * @example
     * // Get one Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends narrator_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, narrator_tblFindUniqueOrThrowArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Find the first Narrator_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {narrator_tblFindFirstOrThrowArgs} args - Arguments to find a Narrator_tbl
     * @example
     * // Get one Narrator_tbl
     * const narrator_tbl = await prisma.narrator_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends narrator_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, narrator_tblFindFirstOrThrowArgs>
    ): Prisma__narrator_tblClient<narrator_tblGetPayload<T>>

    /**
     * Count the number of Narrator_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {narrator_tblCountArgs} args - Arguments to filter Narrator_tbls to count.
     * @example
     * // Count the number of Narrator_tbls
     * const count = await prisma.narrator_tbl.count({
     *   where: {
     *     // ... the filter for the Narrator_tbls we want to count
     *   }
     * })
    **/
    count<T extends narrator_tblCountArgs>(
      args?: Subset<T, narrator_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Narrator_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Narrator_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Narrator_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Narrator_tblAggregateArgs>(args: Subset<T, Narrator_tblAggregateArgs>): PrismaPromise<GetNarrator_tblAggregateType<T>>

    /**
     * Group by Narrator_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Narrator_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Narrator_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Narrator_tblGroupByArgs['orderBy'] }
        : { orderBy?: Narrator_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Narrator_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrator_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for narrator_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__narrator_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * narrator_tbl base type for findUnique actions
   */
  export type narrator_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * Filter, which narrator_tbl to fetch.
     * 
    **/
    where: narrator_tblWhereUniqueInput
  }

  /**
   * narrator_tbl: findUnique
   */
  export interface narrator_tblFindUniqueArgs extends narrator_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * narrator_tbl base type for findFirst actions
   */
  export type narrator_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * Filter, which narrator_tbl to fetch.
     * 
    **/
    where?: narrator_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of narrator_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<narrator_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for narrator_tbls.
     * 
    **/
    cursor?: narrator_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` narrator_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` narrator_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of narrator_tbls.
     * 
    **/
    distinct?: Enumerable<Narrator_tblScalarFieldEnum>
  }

  /**
   * narrator_tbl: findFirst
   */
  export interface narrator_tblFindFirstArgs extends narrator_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * narrator_tbl findMany
   */
  export type narrator_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * Filter, which narrator_tbls to fetch.
     * 
    **/
    where?: narrator_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of narrator_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<narrator_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing narrator_tbls.
     * 
    **/
    cursor?: narrator_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` narrator_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` narrator_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Narrator_tblScalarFieldEnum>
  }


  /**
   * narrator_tbl create
   */
  export type narrator_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * The data needed to create a narrator_tbl.
     * 
    **/
    data: XOR<narrator_tblCreateInput, narrator_tblUncheckedCreateInput>
  }


  /**
   * narrator_tbl createMany
   */
  export type narrator_tblCreateManyArgs = {
    /**
     * The data used to create many narrator_tbls.
     * 
    **/
    data: Enumerable<narrator_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * narrator_tbl update
   */
  export type narrator_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * The data needed to update a narrator_tbl.
     * 
    **/
    data: XOR<narrator_tblUpdateInput, narrator_tblUncheckedUpdateInput>
    /**
     * Choose, which narrator_tbl to update.
     * 
    **/
    where: narrator_tblWhereUniqueInput
  }


  /**
   * narrator_tbl updateMany
   */
  export type narrator_tblUpdateManyArgs = {
    /**
     * The data used to update narrator_tbls.
     * 
    **/
    data: XOR<narrator_tblUpdateManyMutationInput, narrator_tblUncheckedUpdateManyInput>
    /**
     * Filter which narrator_tbls to update
     * 
    **/
    where?: narrator_tblWhereInput
  }


  /**
   * narrator_tbl upsert
   */
  export type narrator_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * The filter to search for the narrator_tbl to update in case it exists.
     * 
    **/
    where: narrator_tblWhereUniqueInput
    /**
     * In case the narrator_tbl found by the `where` argument doesn't exist, create a new narrator_tbl with this data.
     * 
    **/
    create: XOR<narrator_tblCreateInput, narrator_tblUncheckedCreateInput>
    /**
     * In case the narrator_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<narrator_tblUpdateInput, narrator_tblUncheckedUpdateInput>
  }


  /**
   * narrator_tbl delete
   */
  export type narrator_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
    /**
     * Filter which narrator_tbl to delete.
     * 
    **/
    where: narrator_tblWhereUniqueInput
  }


  /**
   * narrator_tbl deleteMany
   */
  export type narrator_tblDeleteManyArgs = {
    /**
     * Filter which narrator_tbls to delete
     * 
    **/
    where?: narrator_tblWhereInput
  }


  /**
   * narrator_tbl: findUniqueOrThrow
   */
  export type narrator_tblFindUniqueOrThrowArgs = narrator_tblFindUniqueArgsBase
      

  /**
   * narrator_tbl: findFirstOrThrow
   */
  export type narrator_tblFindFirstOrThrowArgs = narrator_tblFindFirstArgsBase
      

  /**
   * narrator_tbl without action
   */
  export type narrator_tblArgs = {
    /**
     * Select specific fields to fetch from the narrator_tbl
     * 
    **/
    select?: narrator_tblSelect | null
  }



  /**
   * Model offline_payment
   */


  export type AggregateOffline_payment = {
    _count: Offline_paymentCountAggregateOutputType | null
    _avg: Offline_paymentAvgAggregateOutputType | null
    _sum: Offline_paymentSumAggregateOutputType | null
    _min: Offline_paymentMinAggregateOutputType | null
    _max: Offline_paymentMaxAggregateOutputType | null
  }

  export type Offline_paymentAvgAggregateOutputType = {
    id: number | null
    cart_type: number | null
    user_id: number | null
    amount: number | null
    status: number | null
  }

  export type Offline_paymentSumAggregateOutputType = {
    id: number | null
    cart_type: number | null
    user_id: number | null
    amount: number | null
    status: number | null
  }

  export type Offline_paymentMinAggregateOutputType = {
    id: number | null
    cart_type: number | null
    cart_items: string | null
    user_id: number | null
    amount: number | null
    currency: string | null
    date_created: Date | null
    status: number | null
  }

  export type Offline_paymentMaxAggregateOutputType = {
    id: number | null
    cart_type: number | null
    cart_items: string | null
    user_id: number | null
    amount: number | null
    currency: string | null
    date_created: Date | null
    status: number | null
  }

  export type Offline_paymentCountAggregateOutputType = {
    id: number
    cart_type: number
    cart_items: number
    user_id: number
    amount: number
    currency: number
    date_created: number
    status: number
    _all: number
  }


  export type Offline_paymentAvgAggregateInputType = {
    id?: true
    cart_type?: true
    user_id?: true
    amount?: true
    status?: true
  }

  export type Offline_paymentSumAggregateInputType = {
    id?: true
    cart_type?: true
    user_id?: true
    amount?: true
    status?: true
  }

  export type Offline_paymentMinAggregateInputType = {
    id?: true
    cart_type?: true
    cart_items?: true
    user_id?: true
    amount?: true
    currency?: true
    date_created?: true
    status?: true
  }

  export type Offline_paymentMaxAggregateInputType = {
    id?: true
    cart_type?: true
    cart_items?: true
    user_id?: true
    amount?: true
    currency?: true
    date_created?: true
    status?: true
  }

  export type Offline_paymentCountAggregateInputType = {
    id?: true
    cart_type?: true
    cart_items?: true
    user_id?: true
    amount?: true
    currency?: true
    date_created?: true
    status?: true
    _all?: true
  }

  export type Offline_paymentAggregateArgs = {
    /**
     * Filter which offline_payment to aggregate.
     * 
    **/
    where?: offline_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offline_payments to fetch.
     * 
    **/
    orderBy?: Enumerable<offline_paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: offline_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offline_payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offline_payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offline_payments
    **/
    _count?: true | Offline_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Offline_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Offline_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Offline_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Offline_paymentMaxAggregateInputType
  }

  export type GetOffline_paymentAggregateType<T extends Offline_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateOffline_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffline_payment[P]>
      : GetScalarType<T[P], AggregateOffline_payment[P]>
  }




  export type Offline_paymentGroupByArgs = {
    where?: offline_paymentWhereInput
    orderBy?: Enumerable<offline_paymentOrderByWithAggregationInput>
    by: Array<Offline_paymentScalarFieldEnum>
    having?: offline_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Offline_paymentCountAggregateInputType | true
    _avg?: Offline_paymentAvgAggregateInputType
    _sum?: Offline_paymentSumAggregateInputType
    _min?: Offline_paymentMinAggregateInputType
    _max?: Offline_paymentMaxAggregateInputType
  }


  export type Offline_paymentGroupByOutputType = {
    id: number
    cart_type: number
    cart_items: string
    user_id: number
    amount: number
    currency: string
    date_created: Date
    status: number
    _count: Offline_paymentCountAggregateOutputType | null
    _avg: Offline_paymentAvgAggregateOutputType | null
    _sum: Offline_paymentSumAggregateOutputType | null
    _min: Offline_paymentMinAggregateOutputType | null
    _max: Offline_paymentMaxAggregateOutputType | null
  }

  type GetOffline_paymentGroupByPayload<T extends Offline_paymentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Offline_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Offline_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Offline_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Offline_paymentGroupByOutputType[P]>
        }
      >
    >


  export type offline_paymentSelect = {
    id?: boolean
    cart_type?: boolean
    cart_items?: boolean
    user_id?: boolean
    amount?: boolean
    currency?: boolean
    date_created?: boolean
    status?: boolean
  }


  export type offline_paymentGetPayload<S extends boolean | null | undefined | offline_paymentArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? offline_payment :
    S extends undefined ? never :
    S extends { include: any } & (offline_paymentArgs | offline_paymentFindManyArgs)
    ? offline_payment 
    : S extends { select: any } & (offline_paymentArgs | offline_paymentFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof offline_payment ? offline_payment[P] : never
  } 
      : offline_payment


  type offline_paymentCountArgs = Merge<
    Omit<offline_paymentFindManyArgs, 'select' | 'include'> & {
      select?: Offline_paymentCountAggregateInputType | true
    }
  >

  export interface offline_paymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Offline_payment that matches the filter.
     * @param {offline_paymentFindUniqueArgs} args - Arguments to find a Offline_payment
     * @example
     * // Get one Offline_payment
     * const offline_payment = await prisma.offline_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends offline_paymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, offline_paymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'offline_payment'> extends True ? Prisma__offline_paymentClient<offline_paymentGetPayload<T>> : Prisma__offline_paymentClient<offline_paymentGetPayload<T> | null, null>

    /**
     * Find the first Offline_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offline_paymentFindFirstArgs} args - Arguments to find a Offline_payment
     * @example
     * // Get one Offline_payment
     * const offline_payment = await prisma.offline_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends offline_paymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, offline_paymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'offline_payment'> extends True ? Prisma__offline_paymentClient<offline_paymentGetPayload<T>> : Prisma__offline_paymentClient<offline_paymentGetPayload<T> | null, null>

    /**
     * Find zero or more Offline_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offline_paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offline_payments
     * const offline_payments = await prisma.offline_payment.findMany()
     * 
     * // Get first 10 Offline_payments
     * const offline_payments = await prisma.offline_payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offline_paymentWithIdOnly = await prisma.offline_payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends offline_paymentFindManyArgs>(
      args?: SelectSubset<T, offline_paymentFindManyArgs>
    ): PrismaPromise<Array<offline_paymentGetPayload<T>>>

    /**
     * Create a Offline_payment.
     * @param {offline_paymentCreateArgs} args - Arguments to create a Offline_payment.
     * @example
     * // Create one Offline_payment
     * const Offline_payment = await prisma.offline_payment.create({
     *   data: {
     *     // ... data to create a Offline_payment
     *   }
     * })
     * 
    **/
    create<T extends offline_paymentCreateArgs>(
      args: SelectSubset<T, offline_paymentCreateArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Create many Offline_payments.
     *     @param {offline_paymentCreateManyArgs} args - Arguments to create many Offline_payments.
     *     @example
     *     // Create many Offline_payments
     *     const offline_payment = await prisma.offline_payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends offline_paymentCreateManyArgs>(
      args?: SelectSubset<T, offline_paymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Offline_payment.
     * @param {offline_paymentDeleteArgs} args - Arguments to delete one Offline_payment.
     * @example
     * // Delete one Offline_payment
     * const Offline_payment = await prisma.offline_payment.delete({
     *   where: {
     *     // ... filter to delete one Offline_payment
     *   }
     * })
     * 
    **/
    delete<T extends offline_paymentDeleteArgs>(
      args: SelectSubset<T, offline_paymentDeleteArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Update one Offline_payment.
     * @param {offline_paymentUpdateArgs} args - Arguments to update one Offline_payment.
     * @example
     * // Update one Offline_payment
     * const offline_payment = await prisma.offline_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends offline_paymentUpdateArgs>(
      args: SelectSubset<T, offline_paymentUpdateArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Delete zero or more Offline_payments.
     * @param {offline_paymentDeleteManyArgs} args - Arguments to filter Offline_payments to delete.
     * @example
     * // Delete a few Offline_payments
     * const { count } = await prisma.offline_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends offline_paymentDeleteManyArgs>(
      args?: SelectSubset<T, offline_paymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offline_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offline_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offline_payments
     * const offline_payment = await prisma.offline_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends offline_paymentUpdateManyArgs>(
      args: SelectSubset<T, offline_paymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Offline_payment.
     * @param {offline_paymentUpsertArgs} args - Arguments to update or create a Offline_payment.
     * @example
     * // Update or create a Offline_payment
     * const offline_payment = await prisma.offline_payment.upsert({
     *   create: {
     *     // ... data to create a Offline_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offline_payment we want to update
     *   }
     * })
    **/
    upsert<T extends offline_paymentUpsertArgs>(
      args: SelectSubset<T, offline_paymentUpsertArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Find one Offline_payment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {offline_paymentFindUniqueOrThrowArgs} args - Arguments to find a Offline_payment
     * @example
     * // Get one Offline_payment
     * const offline_payment = await prisma.offline_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends offline_paymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, offline_paymentFindUniqueOrThrowArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Find the first Offline_payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offline_paymentFindFirstOrThrowArgs} args - Arguments to find a Offline_payment
     * @example
     * // Get one Offline_payment
     * const offline_payment = await prisma.offline_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends offline_paymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, offline_paymentFindFirstOrThrowArgs>
    ): Prisma__offline_paymentClient<offline_paymentGetPayload<T>>

    /**
     * Count the number of Offline_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offline_paymentCountArgs} args - Arguments to filter Offline_payments to count.
     * @example
     * // Count the number of Offline_payments
     * const count = await prisma.offline_payment.count({
     *   where: {
     *     // ... the filter for the Offline_payments we want to count
     *   }
     * })
    **/
    count<T extends offline_paymentCountArgs>(
      args?: Subset<T, offline_paymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Offline_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offline_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offline_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Offline_paymentAggregateArgs>(args: Subset<T, Offline_paymentAggregateArgs>): PrismaPromise<GetOffline_paymentAggregateType<T>>

    /**
     * Group by Offline_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offline_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Offline_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Offline_paymentGroupByArgs['orderBy'] }
        : { orderBy?: Offline_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Offline_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffline_paymentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for offline_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__offline_paymentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * offline_payment base type for findUnique actions
   */
  export type offline_paymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * Filter, which offline_payment to fetch.
     * 
    **/
    where: offline_paymentWhereUniqueInput
  }

  /**
   * offline_payment: findUnique
   */
  export interface offline_paymentFindUniqueArgs extends offline_paymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offline_payment base type for findFirst actions
   */
  export type offline_paymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * Filter, which offline_payment to fetch.
     * 
    **/
    where?: offline_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offline_payments to fetch.
     * 
    **/
    orderBy?: Enumerable<offline_paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offline_payments.
     * 
    **/
    cursor?: offline_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offline_payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offline_payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offline_payments.
     * 
    **/
    distinct?: Enumerable<Offline_paymentScalarFieldEnum>
  }

  /**
   * offline_payment: findFirst
   */
  export interface offline_paymentFindFirstArgs extends offline_paymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offline_payment findMany
   */
  export type offline_paymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * Filter, which offline_payments to fetch.
     * 
    **/
    where?: offline_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offline_payments to fetch.
     * 
    **/
    orderBy?: Enumerable<offline_paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offline_payments.
     * 
    **/
    cursor?: offline_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offline_payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offline_payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Offline_paymentScalarFieldEnum>
  }


  /**
   * offline_payment create
   */
  export type offline_paymentCreateArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * The data needed to create a offline_payment.
     * 
    **/
    data: XOR<offline_paymentCreateInput, offline_paymentUncheckedCreateInput>
  }


  /**
   * offline_payment createMany
   */
  export type offline_paymentCreateManyArgs = {
    /**
     * The data used to create many offline_payments.
     * 
    **/
    data: Enumerable<offline_paymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * offline_payment update
   */
  export type offline_paymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * The data needed to update a offline_payment.
     * 
    **/
    data: XOR<offline_paymentUpdateInput, offline_paymentUncheckedUpdateInput>
    /**
     * Choose, which offline_payment to update.
     * 
    **/
    where: offline_paymentWhereUniqueInput
  }


  /**
   * offline_payment updateMany
   */
  export type offline_paymentUpdateManyArgs = {
    /**
     * The data used to update offline_payments.
     * 
    **/
    data: XOR<offline_paymentUpdateManyMutationInput, offline_paymentUncheckedUpdateManyInput>
    /**
     * Filter which offline_payments to update
     * 
    **/
    where?: offline_paymentWhereInput
  }


  /**
   * offline_payment upsert
   */
  export type offline_paymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * The filter to search for the offline_payment to update in case it exists.
     * 
    **/
    where: offline_paymentWhereUniqueInput
    /**
     * In case the offline_payment found by the `where` argument doesn't exist, create a new offline_payment with this data.
     * 
    **/
    create: XOR<offline_paymentCreateInput, offline_paymentUncheckedCreateInput>
    /**
     * In case the offline_payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<offline_paymentUpdateInput, offline_paymentUncheckedUpdateInput>
  }


  /**
   * offline_payment delete
   */
  export type offline_paymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
    /**
     * Filter which offline_payment to delete.
     * 
    **/
    where: offline_paymentWhereUniqueInput
  }


  /**
   * offline_payment deleteMany
   */
  export type offline_paymentDeleteManyArgs = {
    /**
     * Filter which offline_payments to delete
     * 
    **/
    where?: offline_paymentWhereInput
  }


  /**
   * offline_payment: findUniqueOrThrow
   */
  export type offline_paymentFindUniqueOrThrowArgs = offline_paymentFindUniqueArgsBase
      

  /**
   * offline_payment: findFirstOrThrow
   */
  export type offline_paymentFindFirstOrThrowArgs = offline_paymentFindFirstArgsBase
      

  /**
   * offline_payment without action
   */
  export type offline_paymentArgs = {
    /**
     * Select specific fields to fetch from the offline_payment
     * 
    **/
    select?: offline_paymentSelect | null
  }



  /**
   * Model order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    bank_ref_no: number | null
    amount: number | null
    user_id: number | null
    subtotal: number | null
    service_tax: number | null
    net_revenue: number | null
    net_total: number | null
    coupon_discount_amt: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    bank_ref_no: number | null
    amount: number | null
    user_id: number | null
    subtotal: number | null
    service_tax: number | null
    net_revenue: number | null
    net_total: number | null
    coupon_discount_amt: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    tracking_id: string | null
    bank_ref_no: number | null
    order_status: string | null
    failure_message: string | null
    payment_mode: string | null
    card_name: string | null
    status_code: string | null
    status_message: string | null
    currency: string | null
    amount: number | null
    channel: string | null
    billing_name: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_zip: string | null
    billing_country: string | null
    billing_tel: string | null
    billing_email: string | null
    delivery_name: string | null
    delivery_address: string | null
    delivery_city: string | null
    delivery_state: string | null
    delivery_zip: string | null
    delivery_country: string | null
    delivery_tel: string | null
    user_id: number | null
    cart_type: string | null
    subtotal: number | null
    service_tax: number | null
    net_revenue: number | null
    net_total: number | null
    date_created: Date | null
    coupon_id: string | null
    coupon_discount_amt: Decimal | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    tracking_id: string | null
    bank_ref_no: number | null
    order_status: string | null
    failure_message: string | null
    payment_mode: string | null
    card_name: string | null
    status_code: string | null
    status_message: string | null
    currency: string | null
    amount: number | null
    channel: string | null
    billing_name: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_zip: string | null
    billing_country: string | null
    billing_tel: string | null
    billing_email: string | null
    delivery_name: string | null
    delivery_address: string | null
    delivery_city: string | null
    delivery_state: string | null
    delivery_zip: string | null
    delivery_country: string | null
    delivery_tel: string | null
    user_id: number | null
    cart_type: string | null
    subtotal: number | null
    service_tax: number | null
    net_revenue: number | null
    net_total: number | null
    date_created: Date | null
    coupon_id: string | null
    coupon_discount_amt: Decimal | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    order_id: number
    tracking_id: number
    bank_ref_no: number
    order_status: number
    failure_message: number
    payment_mode: number
    card_name: number
    status_code: number
    status_message: number
    currency: number
    amount: number
    channel: number
    billing_name: number
    billing_address: number
    billing_city: number
    billing_state: number
    billing_zip: number
    billing_country: number
    billing_tel: number
    billing_email: number
    delivery_name: number
    delivery_address: number
    delivery_city: number
    delivery_state: number
    delivery_zip: number
    delivery_country: number
    delivery_tel: number
    user_id: number
    cart_type: number
    subtotal: number
    service_tax: number
    net_revenue: number
    net_total: number
    date_created: number
    coupon_id: number
    coupon_discount_amt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    order_id?: true
    bank_ref_no?: true
    amount?: true
    user_id?: true
    subtotal?: true
    service_tax?: true
    net_revenue?: true
    net_total?: true
    coupon_discount_amt?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    order_id?: true
    bank_ref_no?: true
    amount?: true
    user_id?: true
    subtotal?: true
    service_tax?: true
    net_revenue?: true
    net_total?: true
    coupon_discount_amt?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    order_id?: true
    tracking_id?: true
    bank_ref_no?: true
    order_status?: true
    failure_message?: true
    payment_mode?: true
    card_name?: true
    status_code?: true
    status_message?: true
    currency?: true
    amount?: true
    channel?: true
    billing_name?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    billing_tel?: true
    billing_email?: true
    delivery_name?: true
    delivery_address?: true
    delivery_city?: true
    delivery_state?: true
    delivery_zip?: true
    delivery_country?: true
    delivery_tel?: true
    user_id?: true
    cart_type?: true
    subtotal?: true
    service_tax?: true
    net_revenue?: true
    net_total?: true
    date_created?: true
    coupon_id?: true
    coupon_discount_amt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    order_id?: true
    tracking_id?: true
    bank_ref_no?: true
    order_status?: true
    failure_message?: true
    payment_mode?: true
    card_name?: true
    status_code?: true
    status_message?: true
    currency?: true
    amount?: true
    channel?: true
    billing_name?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    billing_tel?: true
    billing_email?: true
    delivery_name?: true
    delivery_address?: true
    delivery_city?: true
    delivery_state?: true
    delivery_zip?: true
    delivery_country?: true
    delivery_tel?: true
    user_id?: true
    cart_type?: true
    subtotal?: true
    service_tax?: true
    net_revenue?: true
    net_total?: true
    date_created?: true
    coupon_id?: true
    coupon_discount_amt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    order_id?: true
    tracking_id?: true
    bank_ref_no?: true
    order_status?: true
    failure_message?: true
    payment_mode?: true
    card_name?: true
    status_code?: true
    status_message?: true
    currency?: true
    amount?: true
    channel?: true
    billing_name?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    billing_tel?: true
    billing_email?: true
    delivery_name?: true
    delivery_address?: true
    delivery_city?: true
    delivery_state?: true
    delivery_zip?: true
    delivery_country?: true
    delivery_tel?: true
    user_id?: true
    cart_type?: true
    subtotal?: true
    service_tax?: true
    net_revenue?: true
    net_total?: true
    date_created?: true
    coupon_id?: true
    coupon_discount_amt?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which order to aggregate.
     * 
    **/
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     * 
    **/
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: orderWhereInput
    orderBy?: Enumerable<orderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    order_id: bigint
    tracking_id: string
    bank_ref_no: number
    order_status: string
    failure_message: string | null
    payment_mode: string | null
    card_name: string | null
    status_code: string | null
    status_message: string | null
    currency: string
    amount: number
    channel: string | null
    billing_name: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_zip: string | null
    billing_country: string | null
    billing_tel: string | null
    billing_email: string | null
    delivery_name: string | null
    delivery_address: string | null
    delivery_city: string | null
    delivery_state: string | null
    delivery_zip: string | null
    delivery_country: string | null
    delivery_tel: string | null
    user_id: number
    cart_type: string
    subtotal: number
    service_tax: number
    net_revenue: number | null
    net_total: number
    date_created: Date
    coupon_id: string | null
    coupon_discount_amt: Decimal | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect = {
    id?: boolean
    order_id?: boolean
    tracking_id?: boolean
    bank_ref_no?: boolean
    order_status?: boolean
    failure_message?: boolean
    payment_mode?: boolean
    card_name?: boolean
    status_code?: boolean
    status_message?: boolean
    currency?: boolean
    amount?: boolean
    channel?: boolean
    billing_name?: boolean
    billing_address?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_zip?: boolean
    billing_country?: boolean
    billing_tel?: boolean
    billing_email?: boolean
    delivery_name?: boolean
    delivery_address?: boolean
    delivery_city?: boolean
    delivery_state?: boolean
    delivery_zip?: boolean
    delivery_country?: boolean
    delivery_tel?: boolean
    user_id?: boolean
    cart_type?: boolean
    subtotal?: boolean
    service_tax?: boolean
    net_revenue?: boolean
    net_total?: boolean
    date_created?: boolean
    coupon_id?: boolean
    coupon_discount_amt?: boolean
  }


  export type orderGetPayload<S extends boolean | null | undefined | orderArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? order :
    S extends undefined ? never :
    S extends { include: any } & (orderArgs | orderFindManyArgs)
    ? order 
    : S extends { select: any } & (orderArgs | orderFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof order ? order[P] : never
  } 
      : order


  type orderCountArgs = Merge<
    Omit<orderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface orderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, orderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'order'> extends True ? Prisma__orderClient<orderGetPayload<T>> : Prisma__orderClient<orderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, orderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'order'> extends True ? Prisma__orderClient<orderGetPayload<T>> : Prisma__orderClient<orderGetPayload<T> | null, null>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs>(
      args?: SelectSubset<T, orderFindManyArgs>
    ): PrismaPromise<Array<orderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs>(
      args: SelectSubset<T, orderCreateArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {orderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderCreateManyArgs>(
      args?: SelectSubset<T, orderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs>(
      args: SelectSubset<T, orderDeleteArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs>(
      args: SelectSubset<T, orderUpdateArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs>(
      args?: SelectSubset<T, orderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs>(
      args: SelectSubset<T, orderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs>(
      args: SelectSubset<T, orderUpsertArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Find one Order that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * order base type for findUnique actions
   */
  export type orderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * Filter, which order to fetch.
     * 
    **/
    where: orderWhereUniqueInput
  }

  /**
   * order: findUnique
   */
  export interface orderFindUniqueArgs extends orderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order base type for findFirst actions
   */
  export type orderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * Filter, which order to fetch.
     * 
    **/
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     * 
    **/
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     * 
    **/
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * order: findFirst
   */
  export interface orderFindFirstArgs extends orderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order findMany
   */
  export type orderFindManyArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * Filter, which orders to fetch.
     * 
    **/
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     * 
    **/
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     * 
    **/
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * order create
   */
  export type orderCreateArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * The data needed to create a order.
     * 
    **/
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }


  /**
   * order createMany
   */
  export type orderCreateManyArgs = {
    /**
     * The data used to create many orders.
     * 
    **/
    data: Enumerable<orderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * order update
   */
  export type orderUpdateArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * The data needed to update a order.
     * 
    **/
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     * 
    **/
    where: orderWhereUniqueInput
  }


  /**
   * order updateMany
   */
  export type orderUpdateManyArgs = {
    /**
     * The data used to update orders.
     * 
    **/
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     * 
    **/
    where?: orderWhereInput
  }


  /**
   * order upsert
   */
  export type orderUpsertArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * The filter to search for the order to update in case it exists.
     * 
    **/
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     * 
    **/
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }


  /**
   * order delete
   */
  export type orderDeleteArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
    /**
     * Filter which order to delete.
     * 
    **/
    where: orderWhereUniqueInput
  }


  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs = {
    /**
     * Filter which orders to delete
     * 
    **/
    where?: orderWhereInput
  }


  /**
   * order: findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs = orderFindUniqueArgsBase
      

  /**
   * order: findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs = orderFindFirstArgsBase
      

  /**
   * order without action
   */
  export type orderArgs = {
    /**
     * Select specific fields to fetch from the order
     * 
    **/
    select?: orderSelect | null
  }



  /**
   * Model order_book_details
   */


  export type AggregateOrder_book_details = {
    _count: Order_book_detailsCountAggregateOutputType | null
    _avg: Order_book_detailsAvgAggregateOutputType | null
    _sum: Order_book_detailsSumAggregateOutputType | null
    _min: Order_book_detailsMinAggregateOutputType | null
    _max: Order_book_detailsMaxAggregateOutputType | null
  }

  export type Order_book_detailsAvgAggregateOutputType = {
    book_order_id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    book_cost: number | null
    order_type: number | null
    rent_plan: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    status: number | null
  }

  export type Order_book_detailsSumAggregateOutputType = {
    book_order_id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    book_cost: number | null
    order_type: number | null
    rent_plan: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    status: number | null
  }

  export type Order_book_detailsMinAggregateOutputType = {
    book_order_id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    book_cost: number | null
    order_type: number | null
    start_date: Date | null
    end_date: Date | null
    order_date: string | null
    rent_plan: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    channel: string | null
    status: number | null
    date_created: Date | null
    user_ip: string | null
  }

  export type Order_book_detailsMaxAggregateOutputType = {
    book_order_id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    book_cost: number | null
    order_type: number | null
    start_date: Date | null
    end_date: Date | null
    order_date: string | null
    rent_plan: number | null
    author_id: number | null
    language_id: number | null
    copyright_owner: number | null
    channel: string | null
    status: number | null
    date_created: Date | null
    user_ip: string | null
  }

  export type Order_book_detailsCountAggregateOutputType = {
    book_order_id: number
    order_id: number
    user_id: number
    book_id: number
    book_cost: number
    order_type: number
    start_date: number
    end_date: number
    order_date: number
    rent_plan: number
    author_id: number
    language_id: number
    copyright_owner: number
    channel: number
    status: number
    date_created: number
    user_ip: number
    _all: number
  }


  export type Order_book_detailsAvgAggregateInputType = {
    book_order_id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    book_cost?: true
    order_type?: true
    rent_plan?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Order_book_detailsSumAggregateInputType = {
    book_order_id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    book_cost?: true
    order_type?: true
    rent_plan?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Order_book_detailsMinAggregateInputType = {
    book_order_id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    book_cost?: true
    order_type?: true
    start_date?: true
    end_date?: true
    order_date?: true
    rent_plan?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    channel?: true
    status?: true
    date_created?: true
    user_ip?: true
  }

  export type Order_book_detailsMaxAggregateInputType = {
    book_order_id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    book_cost?: true
    order_type?: true
    start_date?: true
    end_date?: true
    order_date?: true
    rent_plan?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    channel?: true
    status?: true
    date_created?: true
    user_ip?: true
  }

  export type Order_book_detailsCountAggregateInputType = {
    book_order_id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    book_cost?: true
    order_type?: true
    start_date?: true
    end_date?: true
    order_date?: true
    rent_plan?: true
    author_id?: true
    language_id?: true
    copyright_owner?: true
    channel?: true
    status?: true
    date_created?: true
    user_ip?: true
    _all?: true
  }

  export type Order_book_detailsAggregateArgs = {
    /**
     * Filter which order_book_details to aggregate.
     * 
    **/
    where?: order_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<order_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: order_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_book_details
    **/
    _count?: true | Order_book_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_book_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_book_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_book_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_book_detailsMaxAggregateInputType
  }

  export type GetOrder_book_detailsAggregateType<T extends Order_book_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_book_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_book_details[P]>
      : GetScalarType<T[P], AggregateOrder_book_details[P]>
  }




  export type Order_book_detailsGroupByArgs = {
    where?: order_book_detailsWhereInput
    orderBy?: Enumerable<order_book_detailsOrderByWithAggregationInput>
    by: Array<Order_book_detailsScalarFieldEnum>
    having?: order_book_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_book_detailsCountAggregateInputType | true
    _avg?: Order_book_detailsAvgAggregateInputType
    _sum?: Order_book_detailsSumAggregateInputType
    _min?: Order_book_detailsMinAggregateInputType
    _max?: Order_book_detailsMaxAggregateInputType
  }


  export type Order_book_detailsGroupByOutputType = {
    book_order_id: number
    order_id: number
    user_id: number
    book_id: number
    book_cost: number | null
    order_type: number
    start_date: Date | null
    end_date: Date | null
    order_date: string
    rent_plan: number
    author_id: number
    language_id: number | null
    copyright_owner: number | null
    channel: string | null
    status: number
    date_created: Date
    user_ip: string | null
    _count: Order_book_detailsCountAggregateOutputType | null
    _avg: Order_book_detailsAvgAggregateOutputType | null
    _sum: Order_book_detailsSumAggregateOutputType | null
    _min: Order_book_detailsMinAggregateOutputType | null
    _max: Order_book_detailsMaxAggregateOutputType | null
  }

  type GetOrder_book_detailsGroupByPayload<T extends Order_book_detailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Order_book_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_book_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_book_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Order_book_detailsGroupByOutputType[P]>
        }
      >
    >


  export type order_book_detailsSelect = {
    book_order_id?: boolean
    order_id?: boolean
    user_id?: boolean
    book_id?: boolean
    book_cost?: boolean
    order_type?: boolean
    start_date?: boolean
    end_date?: boolean
    order_date?: boolean
    rent_plan?: boolean
    author_id?: boolean
    language_id?: boolean
    copyright_owner?: boolean
    channel?: boolean
    status?: boolean
    date_created?: boolean
    user_ip?: boolean
  }


  export type order_book_detailsGetPayload<S extends boolean | null | undefined | order_book_detailsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? order_book_details :
    S extends undefined ? never :
    S extends { include: any } & (order_book_detailsArgs | order_book_detailsFindManyArgs)
    ? order_book_details 
    : S extends { select: any } & (order_book_detailsArgs | order_book_detailsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof order_book_details ? order_book_details[P] : never
  } 
      : order_book_details


  type order_book_detailsCountArgs = Merge<
    Omit<order_book_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Order_book_detailsCountAggregateInputType | true
    }
  >

  export interface order_book_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order_book_details that matches the filter.
     * @param {order_book_detailsFindUniqueArgs} args - Arguments to find a Order_book_details
     * @example
     * // Get one Order_book_details
     * const order_book_details = await prisma.order_book_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends order_book_detailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, order_book_detailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'order_book_details'> extends True ? Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>> : Prisma__order_book_detailsClient<order_book_detailsGetPayload<T> | null, null>

    /**
     * Find the first Order_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_book_detailsFindFirstArgs} args - Arguments to find a Order_book_details
     * @example
     * // Get one Order_book_details
     * const order_book_details = await prisma.order_book_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends order_book_detailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, order_book_detailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'order_book_details'> extends True ? Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>> : Prisma__order_book_detailsClient<order_book_detailsGetPayload<T> | null, null>

    /**
     * Find zero or more Order_book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_book_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_book_details
     * const order_book_details = await prisma.order_book_details.findMany()
     * 
     * // Get first 10 Order_book_details
     * const order_book_details = await prisma.order_book_details.findMany({ take: 10 })
     * 
     * // Only select the `book_order_id`
     * const order_book_detailsWithBook_order_idOnly = await prisma.order_book_details.findMany({ select: { book_order_id: true } })
     * 
    **/
    findMany<T extends order_book_detailsFindManyArgs>(
      args?: SelectSubset<T, order_book_detailsFindManyArgs>
    ): PrismaPromise<Array<order_book_detailsGetPayload<T>>>

    /**
     * Create a Order_book_details.
     * @param {order_book_detailsCreateArgs} args - Arguments to create a Order_book_details.
     * @example
     * // Create one Order_book_details
     * const Order_book_details = await prisma.order_book_details.create({
     *   data: {
     *     // ... data to create a Order_book_details
     *   }
     * })
     * 
    **/
    create<T extends order_book_detailsCreateArgs>(
      args: SelectSubset<T, order_book_detailsCreateArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Create many Order_book_details.
     *     @param {order_book_detailsCreateManyArgs} args - Arguments to create many Order_book_details.
     *     @example
     *     // Create many Order_book_details
     *     const order_book_details = await prisma.order_book_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends order_book_detailsCreateManyArgs>(
      args?: SelectSubset<T, order_book_detailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order_book_details.
     * @param {order_book_detailsDeleteArgs} args - Arguments to delete one Order_book_details.
     * @example
     * // Delete one Order_book_details
     * const Order_book_details = await prisma.order_book_details.delete({
     *   where: {
     *     // ... filter to delete one Order_book_details
     *   }
     * })
     * 
    **/
    delete<T extends order_book_detailsDeleteArgs>(
      args: SelectSubset<T, order_book_detailsDeleteArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Update one Order_book_details.
     * @param {order_book_detailsUpdateArgs} args - Arguments to update one Order_book_details.
     * @example
     * // Update one Order_book_details
     * const order_book_details = await prisma.order_book_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends order_book_detailsUpdateArgs>(
      args: SelectSubset<T, order_book_detailsUpdateArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Delete zero or more Order_book_details.
     * @param {order_book_detailsDeleteManyArgs} args - Arguments to filter Order_book_details to delete.
     * @example
     * // Delete a few Order_book_details
     * const { count } = await prisma.order_book_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends order_book_detailsDeleteManyArgs>(
      args?: SelectSubset<T, order_book_detailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_book_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_book_details
     * const order_book_details = await prisma.order_book_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends order_book_detailsUpdateManyArgs>(
      args: SelectSubset<T, order_book_detailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_book_details.
     * @param {order_book_detailsUpsertArgs} args - Arguments to update or create a Order_book_details.
     * @example
     * // Update or create a Order_book_details
     * const order_book_details = await prisma.order_book_details.upsert({
     *   create: {
     *     // ... data to create a Order_book_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_book_details we want to update
     *   }
     * })
    **/
    upsert<T extends order_book_detailsUpsertArgs>(
      args: SelectSubset<T, order_book_detailsUpsertArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Find one Order_book_details that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {order_book_detailsFindUniqueOrThrowArgs} args - Arguments to find a Order_book_details
     * @example
     * // Get one Order_book_details
     * const order_book_details = await prisma.order_book_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends order_book_detailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, order_book_detailsFindUniqueOrThrowArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Find the first Order_book_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_book_detailsFindFirstOrThrowArgs} args - Arguments to find a Order_book_details
     * @example
     * // Get one Order_book_details
     * const order_book_details = await prisma.order_book_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends order_book_detailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, order_book_detailsFindFirstOrThrowArgs>
    ): Prisma__order_book_detailsClient<order_book_detailsGetPayload<T>>

    /**
     * Count the number of Order_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_book_detailsCountArgs} args - Arguments to filter Order_book_details to count.
     * @example
     * // Count the number of Order_book_details
     * const count = await prisma.order_book_details.count({
     *   where: {
     *     // ... the filter for the Order_book_details we want to count
     *   }
     * })
    **/
    count<T extends order_book_detailsCountArgs>(
      args?: Subset<T, order_book_detailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_book_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_book_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_book_detailsAggregateArgs>(args: Subset<T, Order_book_detailsAggregateArgs>): PrismaPromise<GetOrder_book_detailsAggregateType<T>>

    /**
     * Group by Order_book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_book_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Order_book_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Order_book_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Order_book_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Order_book_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_book_detailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for order_book_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__order_book_detailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * order_book_details base type for findUnique actions
   */
  export type order_book_detailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * Filter, which order_book_details to fetch.
     * 
    **/
    where: order_book_detailsWhereUniqueInput
  }

  /**
   * order_book_details: findUnique
   */
  export interface order_book_detailsFindUniqueArgs extends order_book_detailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order_book_details base type for findFirst actions
   */
  export type order_book_detailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * Filter, which order_book_details to fetch.
     * 
    **/
    where?: order_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<order_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_book_details.
     * 
    **/
    cursor?: order_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_book_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_book_details.
     * 
    **/
    distinct?: Enumerable<Order_book_detailsScalarFieldEnum>
  }

  /**
   * order_book_details: findFirst
   */
  export interface order_book_detailsFindFirstArgs extends order_book_detailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order_book_details findMany
   */
  export type order_book_detailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * Filter, which order_book_details to fetch.
     * 
    **/
    where?: order_book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_book_details to fetch.
     * 
    **/
    orderBy?: Enumerable<order_book_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_book_details.
     * 
    **/
    cursor?: order_book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_book_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_book_details.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Order_book_detailsScalarFieldEnum>
  }


  /**
   * order_book_details create
   */
  export type order_book_detailsCreateArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * The data needed to create a order_book_details.
     * 
    **/
    data: XOR<order_book_detailsCreateInput, order_book_detailsUncheckedCreateInput>
  }


  /**
   * order_book_details createMany
   */
  export type order_book_detailsCreateManyArgs = {
    /**
     * The data used to create many order_book_details.
     * 
    **/
    data: Enumerable<order_book_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * order_book_details update
   */
  export type order_book_detailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * The data needed to update a order_book_details.
     * 
    **/
    data: XOR<order_book_detailsUpdateInput, order_book_detailsUncheckedUpdateInput>
    /**
     * Choose, which order_book_details to update.
     * 
    **/
    where: order_book_detailsWhereUniqueInput
  }


  /**
   * order_book_details updateMany
   */
  export type order_book_detailsUpdateManyArgs = {
    /**
     * The data used to update order_book_details.
     * 
    **/
    data: XOR<order_book_detailsUpdateManyMutationInput, order_book_detailsUncheckedUpdateManyInput>
    /**
     * Filter which order_book_details to update
     * 
    **/
    where?: order_book_detailsWhereInput
  }


  /**
   * order_book_details upsert
   */
  export type order_book_detailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * The filter to search for the order_book_details to update in case it exists.
     * 
    **/
    where: order_book_detailsWhereUniqueInput
    /**
     * In case the order_book_details found by the `where` argument doesn't exist, create a new order_book_details with this data.
     * 
    **/
    create: XOR<order_book_detailsCreateInput, order_book_detailsUncheckedCreateInput>
    /**
     * In case the order_book_details was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<order_book_detailsUpdateInput, order_book_detailsUncheckedUpdateInput>
  }


  /**
   * order_book_details delete
   */
  export type order_book_detailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
    /**
     * Filter which order_book_details to delete.
     * 
    **/
    where: order_book_detailsWhereUniqueInput
  }


  /**
   * order_book_details deleteMany
   */
  export type order_book_detailsDeleteManyArgs = {
    /**
     * Filter which order_book_details to delete
     * 
    **/
    where?: order_book_detailsWhereInput
  }


  /**
   * order_book_details: findUniqueOrThrow
   */
  export type order_book_detailsFindUniqueOrThrowArgs = order_book_detailsFindUniqueArgsBase
      

  /**
   * order_book_details: findFirstOrThrow
   */
  export type order_book_detailsFindFirstOrThrowArgs = order_book_detailsFindFirstArgsBase
      

  /**
   * order_book_details without action
   */
  export type order_book_detailsArgs = {
    /**
     * Select specific fields to fetch from the order_book_details
     * 
    **/
    select?: order_book_detailsSelect | null
  }



  /**
   * Model overdrive_books
   */


  export type AggregateOverdrive_books = {
    _count: Overdrive_booksCountAggregateOutputType | null
    _avg: Overdrive_booksAvgAggregateOutputType | null
    _sum: Overdrive_booksSumAggregateOutputType | null
    _min: Overdrive_booksMinAggregateOutputType | null
    _max: Overdrive_booksMaxAggregateOutputType | null
  }

  export type Overdrive_booksAvgAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    catalogue_id: number | null
    isbn: number | null
    edition: number | null
    series: number | null
    filesize: number | null
    whs_usd: number | null
    whs_usddiscount: number | null
    lib_usd: number | null
    lib_usddiscount: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    type_of_book: number | null
  }

  export type Overdrive_booksSumAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    catalogue_id: bigint | null
    isbn: bigint | null
    edition: number | null
    series: number | null
    filesize: number | null
    whs_usd: number | null
    whs_usddiscount: number | null
    lib_usd: number | null
    lib_usddiscount: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    type_of_book: number | null
  }

  export type Overdrive_booksMinAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    catalogue_id: bigint | null
    isbn: bigint | null
    physical_isbn: string | null
    title: string | null
    subtitle: string | null
    edition: number | null
    series: number | null
    publisher: string | null
    imprint: string | null
    creators: string | null
    subject: string | null
    format: string | null
    filesize: number | null
    whs_usd: number | null
    whs_usddiscount: number | null
    lib_usd: number | null
    lib_usddiscount: number | null
    onsale_date: Date | null
    pub_date: Date | null
    status: string | null
    sample_link: string | null
    readbox_enabled: string | null
    special_features: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    type_of_book: number | null
  }

  export type Overdrive_booksMaxAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    catalogue_id: bigint | null
    isbn: bigint | null
    physical_isbn: string | null
    title: string | null
    subtitle: string | null
    edition: number | null
    series: number | null
    publisher: string | null
    imprint: string | null
    creators: string | null
    subject: string | null
    format: string | null
    filesize: number | null
    whs_usd: number | null
    whs_usddiscount: number | null
    lib_usd: number | null
    lib_usddiscount: number | null
    onsale_date: Date | null
    pub_date: Date | null
    status: string | null
    sample_link: string | null
    readbox_enabled: string | null
    special_features: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    type_of_book: number | null
  }

  export type Overdrive_booksCountAggregateOutputType = {
    id: number
    overdrive_id: number
    catalogue_id: number
    isbn: number
    physical_isbn: number
    title: number
    subtitle: number
    edition: number
    series: number
    publisher: number
    imprint: number
    creators: number
    subject: number
    format: number
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: number
    pub_date: number
    status: number
    sample_link: number
    readbox_enabled: number
    special_features: number
    book_id: number
    author_id: number
    copyright_owner: number
    language_id: number
    type_of_book: number
    _all: number
  }


  export type Overdrive_booksAvgAggregateInputType = {
    id?: true
    overdrive_id?: true
    catalogue_id?: true
    isbn?: true
    edition?: true
    series?: true
    filesize?: true
    whs_usd?: true
    whs_usddiscount?: true
    lib_usd?: true
    lib_usddiscount?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    type_of_book?: true
  }

  export type Overdrive_booksSumAggregateInputType = {
    id?: true
    overdrive_id?: true
    catalogue_id?: true
    isbn?: true
    edition?: true
    series?: true
    filesize?: true
    whs_usd?: true
    whs_usddiscount?: true
    lib_usd?: true
    lib_usddiscount?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    type_of_book?: true
  }

  export type Overdrive_booksMinAggregateInputType = {
    id?: true
    overdrive_id?: true
    catalogue_id?: true
    isbn?: true
    physical_isbn?: true
    title?: true
    subtitle?: true
    edition?: true
    series?: true
    publisher?: true
    imprint?: true
    creators?: true
    subject?: true
    format?: true
    filesize?: true
    whs_usd?: true
    whs_usddiscount?: true
    lib_usd?: true
    lib_usddiscount?: true
    onsale_date?: true
    pub_date?: true
    status?: true
    sample_link?: true
    readbox_enabled?: true
    special_features?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    type_of_book?: true
  }

  export type Overdrive_booksMaxAggregateInputType = {
    id?: true
    overdrive_id?: true
    catalogue_id?: true
    isbn?: true
    physical_isbn?: true
    title?: true
    subtitle?: true
    edition?: true
    series?: true
    publisher?: true
    imprint?: true
    creators?: true
    subject?: true
    format?: true
    filesize?: true
    whs_usd?: true
    whs_usddiscount?: true
    lib_usd?: true
    lib_usddiscount?: true
    onsale_date?: true
    pub_date?: true
    status?: true
    sample_link?: true
    readbox_enabled?: true
    special_features?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    type_of_book?: true
  }

  export type Overdrive_booksCountAggregateInputType = {
    id?: true
    overdrive_id?: true
    catalogue_id?: true
    isbn?: true
    physical_isbn?: true
    title?: true
    subtitle?: true
    edition?: true
    series?: true
    publisher?: true
    imprint?: true
    creators?: true
    subject?: true
    format?: true
    filesize?: true
    whs_usd?: true
    whs_usddiscount?: true
    lib_usd?: true
    lib_usddiscount?: true
    onsale_date?: true
    pub_date?: true
    status?: true
    sample_link?: true
    readbox_enabled?: true
    special_features?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    type_of_book?: true
    _all?: true
  }

  export type Overdrive_booksAggregateArgs = {
    /**
     * Filter which overdrive_books to aggregate.
     * 
    **/
    where?: overdrive_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_books to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: overdrive_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned overdrive_books
    **/
    _count?: true | Overdrive_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Overdrive_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Overdrive_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Overdrive_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Overdrive_booksMaxAggregateInputType
  }

  export type GetOverdrive_booksAggregateType<T extends Overdrive_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateOverdrive_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOverdrive_books[P]>
      : GetScalarType<T[P], AggregateOverdrive_books[P]>
  }




  export type Overdrive_booksGroupByArgs = {
    where?: overdrive_booksWhereInput
    orderBy?: Enumerable<overdrive_booksOrderByWithAggregationInput>
    by: Array<Overdrive_booksScalarFieldEnum>
    having?: overdrive_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Overdrive_booksCountAggregateInputType | true
    _avg?: Overdrive_booksAvgAggregateInputType
    _sum?: Overdrive_booksSumAggregateInputType
    _min?: Overdrive_booksMinAggregateInputType
    _max?: Overdrive_booksMaxAggregateInputType
  }


  export type Overdrive_booksGroupByOutputType = {
    id: number
    overdrive_id: number
    catalogue_id: bigint
    isbn: bigint
    physical_isbn: string | null
    title: string
    subtitle: string | null
    edition: number | null
    series: number | null
    publisher: string
    imprint: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date
    pub_date: Date | null
    status: string
    sample_link: string
    readbox_enabled: string | null
    special_features: string | null
    book_id: number
    author_id: number
    copyright_owner: number | null
    language_id: number
    type_of_book: number | null
    _count: Overdrive_booksCountAggregateOutputType | null
    _avg: Overdrive_booksAvgAggregateOutputType | null
    _sum: Overdrive_booksSumAggregateOutputType | null
    _min: Overdrive_booksMinAggregateOutputType | null
    _max: Overdrive_booksMaxAggregateOutputType | null
  }

  type GetOverdrive_booksGroupByPayload<T extends Overdrive_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Overdrive_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Overdrive_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Overdrive_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Overdrive_booksGroupByOutputType[P]>
        }
      >
    >


  export type overdrive_booksSelect = {
    id?: boolean
    overdrive_id?: boolean
    catalogue_id?: boolean
    isbn?: boolean
    physical_isbn?: boolean
    title?: boolean
    subtitle?: boolean
    edition?: boolean
    series?: boolean
    publisher?: boolean
    imprint?: boolean
    creators?: boolean
    subject?: boolean
    format?: boolean
    filesize?: boolean
    whs_usd?: boolean
    whs_usddiscount?: boolean
    lib_usd?: boolean
    lib_usddiscount?: boolean
    onsale_date?: boolean
    pub_date?: boolean
    status?: boolean
    sample_link?: boolean
    readbox_enabled?: boolean
    special_features?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    type_of_book?: boolean
  }


  export type overdrive_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type overdrive_booksGetPayload<S extends boolean | null | undefined | overdrive_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? overdrive_books :
    S extends undefined ? never :
    S extends { include: any } & (overdrive_booksArgs | overdrive_booksFindManyArgs)
    ? overdrive_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (overdrive_booksArgs | overdrive_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof overdrive_books ? overdrive_books[P] : never
  } 
      : overdrive_books


  type overdrive_booksCountArgs = Merge<
    Omit<overdrive_booksFindManyArgs, 'select' | 'include'> & {
      select?: Overdrive_booksCountAggregateInputType | true
    }
  >

  export interface overdrive_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Overdrive_books that matches the filter.
     * @param {overdrive_booksFindUniqueArgs} args - Arguments to find a Overdrive_books
     * @example
     * // Get one Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends overdrive_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, overdrive_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'overdrive_books'> extends True ? Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>> : Prisma__overdrive_booksClient<overdrive_booksGetPayload<T> | null, null>

    /**
     * Find the first Overdrive_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_booksFindFirstArgs} args - Arguments to find a Overdrive_books
     * @example
     * // Get one Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends overdrive_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, overdrive_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'overdrive_books'> extends True ? Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>> : Prisma__overdrive_booksClient<overdrive_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Overdrive_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findMany()
     * 
     * // Get first 10 Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overdrive_booksWithIdOnly = await prisma.overdrive_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends overdrive_booksFindManyArgs>(
      args?: SelectSubset<T, overdrive_booksFindManyArgs>
    ): PrismaPromise<Array<overdrive_booksGetPayload<T>>>

    /**
     * Create a Overdrive_books.
     * @param {overdrive_booksCreateArgs} args - Arguments to create a Overdrive_books.
     * @example
     * // Create one Overdrive_books
     * const Overdrive_books = await prisma.overdrive_books.create({
     *   data: {
     *     // ... data to create a Overdrive_books
     *   }
     * })
     * 
    **/
    create<T extends overdrive_booksCreateArgs>(
      args: SelectSubset<T, overdrive_booksCreateArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Create many Overdrive_books.
     *     @param {overdrive_booksCreateManyArgs} args - Arguments to create many Overdrive_books.
     *     @example
     *     // Create many Overdrive_books
     *     const overdrive_books = await prisma.overdrive_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends overdrive_booksCreateManyArgs>(
      args?: SelectSubset<T, overdrive_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Overdrive_books.
     * @param {overdrive_booksDeleteArgs} args - Arguments to delete one Overdrive_books.
     * @example
     * // Delete one Overdrive_books
     * const Overdrive_books = await prisma.overdrive_books.delete({
     *   where: {
     *     // ... filter to delete one Overdrive_books
     *   }
     * })
     * 
    **/
    delete<T extends overdrive_booksDeleteArgs>(
      args: SelectSubset<T, overdrive_booksDeleteArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Update one Overdrive_books.
     * @param {overdrive_booksUpdateArgs} args - Arguments to update one Overdrive_books.
     * @example
     * // Update one Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends overdrive_booksUpdateArgs>(
      args: SelectSubset<T, overdrive_booksUpdateArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Delete zero or more Overdrive_books.
     * @param {overdrive_booksDeleteManyArgs} args - Arguments to filter Overdrive_books to delete.
     * @example
     * // Delete a few Overdrive_books
     * const { count } = await prisma.overdrive_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends overdrive_booksDeleteManyArgs>(
      args?: SelectSubset<T, overdrive_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overdrive_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends overdrive_booksUpdateManyArgs>(
      args: SelectSubset<T, overdrive_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Overdrive_books.
     * @param {overdrive_booksUpsertArgs} args - Arguments to update or create a Overdrive_books.
     * @example
     * // Update or create a Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.upsert({
     *   create: {
     *     // ... data to create a Overdrive_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overdrive_books we want to update
     *   }
     * })
    **/
    upsert<T extends overdrive_booksUpsertArgs>(
      args: SelectSubset<T, overdrive_booksUpsertArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Find one Overdrive_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {overdrive_booksFindUniqueOrThrowArgs} args - Arguments to find a Overdrive_books
     * @example
     * // Get one Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends overdrive_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, overdrive_booksFindUniqueOrThrowArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Find the first Overdrive_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_booksFindFirstOrThrowArgs} args - Arguments to find a Overdrive_books
     * @example
     * // Get one Overdrive_books
     * const overdrive_books = await prisma.overdrive_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends overdrive_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, overdrive_booksFindFirstOrThrowArgs>
    ): Prisma__overdrive_booksClient<overdrive_booksGetPayload<T>>

    /**
     * Count the number of Overdrive_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_booksCountArgs} args - Arguments to filter Overdrive_books to count.
     * @example
     * // Count the number of Overdrive_books
     * const count = await prisma.overdrive_books.count({
     *   where: {
     *     // ... the filter for the Overdrive_books we want to count
     *   }
     * })
    **/
    count<T extends overdrive_booksCountArgs>(
      args?: Subset<T, overdrive_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Overdrive_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overdrive_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Overdrive_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Overdrive_booksAggregateArgs>(args: Subset<T, Overdrive_booksAggregateArgs>): PrismaPromise<GetOverdrive_booksAggregateType<T>>

    /**
     * Group by Overdrive_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Overdrive_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Overdrive_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Overdrive_booksGroupByArgs['orderBy'] }
        : { orderBy?: Overdrive_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Overdrive_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOverdrive_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for overdrive_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__overdrive_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * overdrive_books base type for findUnique actions
   */
  export type overdrive_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * Filter, which overdrive_books to fetch.
     * 
    **/
    where: overdrive_booksWhereUniqueInput
  }

  /**
   * overdrive_books: findUnique
   */
  export interface overdrive_booksFindUniqueArgs extends overdrive_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * overdrive_books base type for findFirst actions
   */
  export type overdrive_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * Filter, which overdrive_books to fetch.
     * 
    **/
    where?: overdrive_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_books to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for overdrive_books.
     * 
    **/
    cursor?: overdrive_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of overdrive_books.
     * 
    **/
    distinct?: Enumerable<Overdrive_booksScalarFieldEnum>
  }

  /**
   * overdrive_books: findFirst
   */
  export interface overdrive_booksFindFirstArgs extends overdrive_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * overdrive_books findMany
   */
  export type overdrive_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * Filter, which overdrive_books to fetch.
     * 
    **/
    where?: overdrive_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_books to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing overdrive_books.
     * 
    **/
    cursor?: overdrive_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Overdrive_booksScalarFieldEnum>
  }


  /**
   * overdrive_books create
   */
  export type overdrive_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * The data needed to create a overdrive_books.
     * 
    **/
    data: XOR<overdrive_booksCreateInput, overdrive_booksUncheckedCreateInput>
  }


  /**
   * overdrive_books createMany
   */
  export type overdrive_booksCreateManyArgs = {
    /**
     * The data used to create many overdrive_books.
     * 
    **/
    data: Enumerable<overdrive_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * overdrive_books update
   */
  export type overdrive_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * The data needed to update a overdrive_books.
     * 
    **/
    data: XOR<overdrive_booksUpdateInput, overdrive_booksUncheckedUpdateInput>
    /**
     * Choose, which overdrive_books to update.
     * 
    **/
    where: overdrive_booksWhereUniqueInput
  }


  /**
   * overdrive_books updateMany
   */
  export type overdrive_booksUpdateManyArgs = {
    /**
     * The data used to update overdrive_books.
     * 
    **/
    data: XOR<overdrive_booksUpdateManyMutationInput, overdrive_booksUncheckedUpdateManyInput>
    /**
     * Filter which overdrive_books to update
     * 
    **/
    where?: overdrive_booksWhereInput
  }


  /**
   * overdrive_books upsert
   */
  export type overdrive_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * The filter to search for the overdrive_books to update in case it exists.
     * 
    **/
    where: overdrive_booksWhereUniqueInput
    /**
     * In case the overdrive_books found by the `where` argument doesn't exist, create a new overdrive_books with this data.
     * 
    **/
    create: XOR<overdrive_booksCreateInput, overdrive_booksUncheckedCreateInput>
    /**
     * In case the overdrive_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<overdrive_booksUpdateInput, overdrive_booksUncheckedUpdateInput>
  }


  /**
   * overdrive_books delete
   */
  export type overdrive_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
    /**
     * Filter which overdrive_books to delete.
     * 
    **/
    where: overdrive_booksWhereUniqueInput
  }


  /**
   * overdrive_books deleteMany
   */
  export type overdrive_booksDeleteManyArgs = {
    /**
     * Filter which overdrive_books to delete
     * 
    **/
    where?: overdrive_booksWhereInput
  }


  /**
   * overdrive_books: findUniqueOrThrow
   */
  export type overdrive_booksFindUniqueOrThrowArgs = overdrive_booksFindUniqueArgsBase
      

  /**
   * overdrive_books: findFirstOrThrow
   */
  export type overdrive_booksFindFirstOrThrowArgs = overdrive_booksFindFirstArgsBase
      

  /**
   * overdrive_books without action
   */
  export type overdrive_booksArgs = {
    /**
     * Select specific fields to fetch from the overdrive_books
     * 
    **/
    select?: overdrive_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_booksInclude | null
  }



  /**
   * Model overdrive_transactions
   */


  export type AggregateOverdrive_transactions = {
    _count: Overdrive_transactionsCountAggregateOutputType | null
    _avg: Overdrive_transactionsAvgAggregateOutputType | null
    _sum: Overdrive_transactionsSumAggregateOutputType | null
    _min: Overdrive_transactionsMinAggregateOutputType | null
    _max: Overdrive_transactionsMaxAggregateOutputType | null
  }

  export type Overdrive_transactionsAvgAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    isbn: number | null
    srp_usd: number | null
    discount: number | null
    amt_owed_usd: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    exchange_rate: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Overdrive_transactionsSumAggregateOutputType = {
    id: number | null
    overdrive_id: number | null
    isbn: number | null
    srp_usd: number | null
    discount: number | null
    amt_owed_usd: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    exchange_rate: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
  }

  export type Overdrive_transactionsMinAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    overdrive_id: number | null
    isbn: number | null
    title: string | null
    subtitle: string | null
    author: string | null
    retailer: string | null
    country_of_sale: string | null
    format: string | null
    srp_usd: number | null
    discount: number | null
    amt_owed_usd: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    exchange_rate: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Overdrive_transactionsMaxAggregateOutputType = {
    id: number | null
    transaction_date: Date | null
    overdrive_id: number | null
    isbn: number | null
    title: string | null
    subtitle: string | null
    author: string | null
    retailer: string | null
    country_of_sale: string | null
    format: string | null
    srp_usd: number | null
    discount: number | null
    amt_owed_usd: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    exchange_rate: number | null
    inr_value: number | null
    final_royalty_value: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
  }

  export type Overdrive_transactionsCountAggregateOutputType = {
    id: number
    transaction_date: number
    overdrive_id: number
    isbn: number
    title: number
    subtitle: number
    author: number
    retailer: number
    country_of_sale: number
    format: number
    srp_usd: number
    discount: number
    amt_owed_usd: number
    book_id: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner: number
    status: number
    _all: number
  }


  export type Overdrive_transactionsAvgAggregateInputType = {
    id?: true
    overdrive_id?: true
    isbn?: true
    srp_usd?: true
    discount?: true
    amt_owed_usd?: true
    book_id?: true
    author_id?: true
    language_id?: true
    exchange_rate?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Overdrive_transactionsSumAggregateInputType = {
    id?: true
    overdrive_id?: true
    isbn?: true
    srp_usd?: true
    discount?: true
    amt_owed_usd?: true
    book_id?: true
    author_id?: true
    language_id?: true
    exchange_rate?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
  }

  export type Overdrive_transactionsMinAggregateInputType = {
    id?: true
    transaction_date?: true
    overdrive_id?: true
    isbn?: true
    title?: true
    subtitle?: true
    author?: true
    retailer?: true
    country_of_sale?: true
    format?: true
    srp_usd?: true
    discount?: true
    amt_owed_usd?: true
    book_id?: true
    author_id?: true
    language_id?: true
    exchange_rate?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Overdrive_transactionsMaxAggregateInputType = {
    id?: true
    transaction_date?: true
    overdrive_id?: true
    isbn?: true
    title?: true
    subtitle?: true
    author?: true
    retailer?: true
    country_of_sale?: true
    format?: true
    srp_usd?: true
    discount?: true
    amt_owed_usd?: true
    book_id?: true
    author_id?: true
    language_id?: true
    exchange_rate?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
  }

  export type Overdrive_transactionsCountAggregateInputType = {
    id?: true
    transaction_date?: true
    overdrive_id?: true
    isbn?: true
    title?: true
    subtitle?: true
    author?: true
    retailer?: true
    country_of_sale?: true
    format?: true
    srp_usd?: true
    discount?: true
    amt_owed_usd?: true
    book_id?: true
    author_id?: true
    language_id?: true
    exchange_rate?: true
    inr_value?: true
    final_royalty_value?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    _all?: true
  }

  export type Overdrive_transactionsAggregateArgs = {
    /**
     * Filter which overdrive_transactions to aggregate.
     * 
    **/
    where?: overdrive_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: overdrive_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned overdrive_transactions
    **/
    _count?: true | Overdrive_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Overdrive_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Overdrive_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Overdrive_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Overdrive_transactionsMaxAggregateInputType
  }

  export type GetOverdrive_transactionsAggregateType<T extends Overdrive_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateOverdrive_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOverdrive_transactions[P]>
      : GetScalarType<T[P], AggregateOverdrive_transactions[P]>
  }




  export type Overdrive_transactionsGroupByArgs = {
    where?: overdrive_transactionsWhereInput
    orderBy?: Enumerable<overdrive_transactionsOrderByWithAggregationInput>
    by: Array<Overdrive_transactionsScalarFieldEnum>
    having?: overdrive_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Overdrive_transactionsCountAggregateInputType | true
    _avg?: Overdrive_transactionsAvgAggregateInputType
    _sum?: Overdrive_transactionsSumAggregateInputType
    _min?: Overdrive_transactionsMinAggregateInputType
    _max?: Overdrive_transactionsMaxAggregateInputType
  }


  export type Overdrive_transactionsGroupByOutputType = {
    id: number
    transaction_date: Date
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    book_id: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner: number | null
    status: string
    _count: Overdrive_transactionsCountAggregateOutputType | null
    _avg: Overdrive_transactionsAvgAggregateOutputType | null
    _sum: Overdrive_transactionsSumAggregateOutputType | null
    _min: Overdrive_transactionsMinAggregateOutputType | null
    _max: Overdrive_transactionsMaxAggregateOutputType | null
  }

  type GetOverdrive_transactionsGroupByPayload<T extends Overdrive_transactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Overdrive_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Overdrive_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Overdrive_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Overdrive_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type overdrive_transactionsSelect = {
    id?: boolean
    transaction_date?: boolean
    overdrive_id?: boolean
    isbn?: boolean
    title?: boolean
    subtitle?: boolean
    author?: boolean
    retailer?: boolean
    country_of_sale?: boolean
    format?: boolean
    srp_usd?: boolean
    discount?: boolean
    amt_owed_usd?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    language_id?: boolean
    exchange_rate?: boolean
    inr_value?: boolean
    final_royalty_value?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    status?: boolean
  }


  export type overdrive_transactionsInclude = {
    book?: boolean | book_tblArgs
  } 

  export type overdrive_transactionsGetPayload<S extends boolean | null | undefined | overdrive_transactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? overdrive_transactions :
    S extends undefined ? never :
    S extends { include: any } & (overdrive_transactionsArgs | overdrive_transactionsFindManyArgs)
    ? overdrive_transactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (overdrive_transactionsArgs | overdrive_transactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof overdrive_transactions ? overdrive_transactions[P] : never
  } 
      : overdrive_transactions


  type overdrive_transactionsCountArgs = Merge<
    Omit<overdrive_transactionsFindManyArgs, 'select' | 'include'> & {
      select?: Overdrive_transactionsCountAggregateInputType | true
    }
  >

  export interface overdrive_transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Overdrive_transactions that matches the filter.
     * @param {overdrive_transactionsFindUniqueArgs} args - Arguments to find a Overdrive_transactions
     * @example
     * // Get one Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends overdrive_transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, overdrive_transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'overdrive_transactions'> extends True ? Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>> : Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T> | null, null>

    /**
     * Find the first Overdrive_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_transactionsFindFirstArgs} args - Arguments to find a Overdrive_transactions
     * @example
     * // Get one Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends overdrive_transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, overdrive_transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'overdrive_transactions'> extends True ? Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>> : Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T> | null, null>

    /**
     * Find zero or more Overdrive_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findMany()
     * 
     * // Get first 10 Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overdrive_transactionsWithIdOnly = await prisma.overdrive_transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends overdrive_transactionsFindManyArgs>(
      args?: SelectSubset<T, overdrive_transactionsFindManyArgs>
    ): PrismaPromise<Array<overdrive_transactionsGetPayload<T>>>

    /**
     * Create a Overdrive_transactions.
     * @param {overdrive_transactionsCreateArgs} args - Arguments to create a Overdrive_transactions.
     * @example
     * // Create one Overdrive_transactions
     * const Overdrive_transactions = await prisma.overdrive_transactions.create({
     *   data: {
     *     // ... data to create a Overdrive_transactions
     *   }
     * })
     * 
    **/
    create<T extends overdrive_transactionsCreateArgs>(
      args: SelectSubset<T, overdrive_transactionsCreateArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Create many Overdrive_transactions.
     *     @param {overdrive_transactionsCreateManyArgs} args - Arguments to create many Overdrive_transactions.
     *     @example
     *     // Create many Overdrive_transactions
     *     const overdrive_transactions = await prisma.overdrive_transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends overdrive_transactionsCreateManyArgs>(
      args?: SelectSubset<T, overdrive_transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Overdrive_transactions.
     * @param {overdrive_transactionsDeleteArgs} args - Arguments to delete one Overdrive_transactions.
     * @example
     * // Delete one Overdrive_transactions
     * const Overdrive_transactions = await prisma.overdrive_transactions.delete({
     *   where: {
     *     // ... filter to delete one Overdrive_transactions
     *   }
     * })
     * 
    **/
    delete<T extends overdrive_transactionsDeleteArgs>(
      args: SelectSubset<T, overdrive_transactionsDeleteArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Update one Overdrive_transactions.
     * @param {overdrive_transactionsUpdateArgs} args - Arguments to update one Overdrive_transactions.
     * @example
     * // Update one Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends overdrive_transactionsUpdateArgs>(
      args: SelectSubset<T, overdrive_transactionsUpdateArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Delete zero or more Overdrive_transactions.
     * @param {overdrive_transactionsDeleteManyArgs} args - Arguments to filter Overdrive_transactions to delete.
     * @example
     * // Delete a few Overdrive_transactions
     * const { count } = await prisma.overdrive_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends overdrive_transactionsDeleteManyArgs>(
      args?: SelectSubset<T, overdrive_transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overdrive_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends overdrive_transactionsUpdateManyArgs>(
      args: SelectSubset<T, overdrive_transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Overdrive_transactions.
     * @param {overdrive_transactionsUpsertArgs} args - Arguments to update or create a Overdrive_transactions.
     * @example
     * // Update or create a Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.upsert({
     *   create: {
     *     // ... data to create a Overdrive_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overdrive_transactions we want to update
     *   }
     * })
    **/
    upsert<T extends overdrive_transactionsUpsertArgs>(
      args: SelectSubset<T, overdrive_transactionsUpsertArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Find one Overdrive_transactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {overdrive_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Overdrive_transactions
     * @example
     * // Get one Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends overdrive_transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, overdrive_transactionsFindUniqueOrThrowArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Find the first Overdrive_transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_transactionsFindFirstOrThrowArgs} args - Arguments to find a Overdrive_transactions
     * @example
     * // Get one Overdrive_transactions
     * const overdrive_transactions = await prisma.overdrive_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends overdrive_transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, overdrive_transactionsFindFirstOrThrowArgs>
    ): Prisma__overdrive_transactionsClient<overdrive_transactionsGetPayload<T>>

    /**
     * Count the number of Overdrive_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overdrive_transactionsCountArgs} args - Arguments to filter Overdrive_transactions to count.
     * @example
     * // Count the number of Overdrive_transactions
     * const count = await prisma.overdrive_transactions.count({
     *   where: {
     *     // ... the filter for the Overdrive_transactions we want to count
     *   }
     * })
    **/
    count<T extends overdrive_transactionsCountArgs>(
      args?: Subset<T, overdrive_transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Overdrive_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overdrive_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Overdrive_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Overdrive_transactionsAggregateArgs>(args: Subset<T, Overdrive_transactionsAggregateArgs>): PrismaPromise<GetOverdrive_transactionsAggregateType<T>>

    /**
     * Group by Overdrive_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Overdrive_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Overdrive_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Overdrive_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: Overdrive_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Overdrive_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOverdrive_transactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for overdrive_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__overdrive_transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * overdrive_transactions base type for findUnique actions
   */
  export type overdrive_transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * Filter, which overdrive_transactions to fetch.
     * 
    **/
    where: overdrive_transactionsWhereUniqueInput
  }

  /**
   * overdrive_transactions: findUnique
   */
  export interface overdrive_transactionsFindUniqueArgs extends overdrive_transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * overdrive_transactions base type for findFirst actions
   */
  export type overdrive_transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * Filter, which overdrive_transactions to fetch.
     * 
    **/
    where?: overdrive_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for overdrive_transactions.
     * 
    **/
    cursor?: overdrive_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of overdrive_transactions.
     * 
    **/
    distinct?: Enumerable<Overdrive_transactionsScalarFieldEnum>
  }

  /**
   * overdrive_transactions: findFirst
   */
  export interface overdrive_transactionsFindFirstArgs extends overdrive_transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * overdrive_transactions findMany
   */
  export type overdrive_transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * Filter, which overdrive_transactions to fetch.
     * 
    **/
    where?: overdrive_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overdrive_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<overdrive_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing overdrive_transactions.
     * 
    **/
    cursor?: overdrive_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overdrive_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overdrive_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Overdrive_transactionsScalarFieldEnum>
  }


  /**
   * overdrive_transactions create
   */
  export type overdrive_transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * The data needed to create a overdrive_transactions.
     * 
    **/
    data: XOR<overdrive_transactionsCreateInput, overdrive_transactionsUncheckedCreateInput>
  }


  /**
   * overdrive_transactions createMany
   */
  export type overdrive_transactionsCreateManyArgs = {
    /**
     * The data used to create many overdrive_transactions.
     * 
    **/
    data: Enumerable<overdrive_transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * overdrive_transactions update
   */
  export type overdrive_transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * The data needed to update a overdrive_transactions.
     * 
    **/
    data: XOR<overdrive_transactionsUpdateInput, overdrive_transactionsUncheckedUpdateInput>
    /**
     * Choose, which overdrive_transactions to update.
     * 
    **/
    where: overdrive_transactionsWhereUniqueInput
  }


  /**
   * overdrive_transactions updateMany
   */
  export type overdrive_transactionsUpdateManyArgs = {
    /**
     * The data used to update overdrive_transactions.
     * 
    **/
    data: XOR<overdrive_transactionsUpdateManyMutationInput, overdrive_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which overdrive_transactions to update
     * 
    **/
    where?: overdrive_transactionsWhereInput
  }


  /**
   * overdrive_transactions upsert
   */
  export type overdrive_transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * The filter to search for the overdrive_transactions to update in case it exists.
     * 
    **/
    where: overdrive_transactionsWhereUniqueInput
    /**
     * In case the overdrive_transactions found by the `where` argument doesn't exist, create a new overdrive_transactions with this data.
     * 
    **/
    create: XOR<overdrive_transactionsCreateInput, overdrive_transactionsUncheckedCreateInput>
    /**
     * In case the overdrive_transactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<overdrive_transactionsUpdateInput, overdrive_transactionsUncheckedUpdateInput>
  }


  /**
   * overdrive_transactions delete
   */
  export type overdrive_transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
    /**
     * Filter which overdrive_transactions to delete.
     * 
    **/
    where: overdrive_transactionsWhereUniqueInput
  }


  /**
   * overdrive_transactions deleteMany
   */
  export type overdrive_transactionsDeleteManyArgs = {
    /**
     * Filter which overdrive_transactions to delete
     * 
    **/
    where?: overdrive_transactionsWhereInput
  }


  /**
   * overdrive_transactions: findUniqueOrThrow
   */
  export type overdrive_transactionsFindUniqueOrThrowArgs = overdrive_transactionsFindUniqueArgsBase
      

  /**
   * overdrive_transactions: findFirstOrThrow
   */
  export type overdrive_transactionsFindFirstOrThrowArgs = overdrive_transactionsFindFirstArgsBase
      

  /**
   * overdrive_transactions without action
   */
  export type overdrive_transactionsArgs = {
    /**
     * Select specific fields to fetch from the overdrive_transactions
     * 
    **/
    select?: overdrive_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: overdrive_transactionsInclude | null
  }



  /**
   * Model payout_session
   */


  export type AggregatePayout_session = {
    _count: Payout_sessionCountAggregateOutputType | null
    _avg: Payout_sessionAvgAggregateOutputType | null
    _sum: Payout_sessionSumAggregateOutputType | null
    _min: Payout_sessionMinAggregateOutputType | null
    _max: Payout_sessionMaxAggregateOutputType | null
  }

  export type Payout_sessionAvgAggregateOutputType = {
    session_id: number | null
    user_id: number | null
    order_id: number | null
  }

  export type Payout_sessionSumAggregateOutputType = {
    session_id: number | null
    user_id: number | null
    order_id: bigint | null
  }

  export type Payout_sessionMinAggregateOutputType = {
    session_id: number | null
    session_data: string | null
    user_id: number | null
    order_id: bigint | null
  }

  export type Payout_sessionMaxAggregateOutputType = {
    session_id: number | null
    session_data: string | null
    user_id: number | null
    order_id: bigint | null
  }

  export type Payout_sessionCountAggregateOutputType = {
    session_id: number
    session_data: number
    user_id: number
    order_id: number
    _all: number
  }


  export type Payout_sessionAvgAggregateInputType = {
    session_id?: true
    user_id?: true
    order_id?: true
  }

  export type Payout_sessionSumAggregateInputType = {
    session_id?: true
    user_id?: true
    order_id?: true
  }

  export type Payout_sessionMinAggregateInputType = {
    session_id?: true
    session_data?: true
    user_id?: true
    order_id?: true
  }

  export type Payout_sessionMaxAggregateInputType = {
    session_id?: true
    session_data?: true
    user_id?: true
    order_id?: true
  }

  export type Payout_sessionCountAggregateInputType = {
    session_id?: true
    session_data?: true
    user_id?: true
    order_id?: true
    _all?: true
  }

  export type Payout_sessionAggregateArgs = {
    /**
     * Filter which payout_session to aggregate.
     * 
    **/
    where?: payout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payout_sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<payout_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: payout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payout_sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payout_sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payout_sessions
    **/
    _count?: true | Payout_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payout_sessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payout_sessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payout_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payout_sessionMaxAggregateInputType
  }

  export type GetPayout_sessionAggregateType<T extends Payout_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout_session[P]>
      : GetScalarType<T[P], AggregatePayout_session[P]>
  }




  export type Payout_sessionGroupByArgs = {
    where?: payout_sessionWhereInput
    orderBy?: Enumerable<payout_sessionOrderByWithAggregationInput>
    by: Array<Payout_sessionScalarFieldEnum>
    having?: payout_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payout_sessionCountAggregateInputType | true
    _avg?: Payout_sessionAvgAggregateInputType
    _sum?: Payout_sessionSumAggregateInputType
    _min?: Payout_sessionMinAggregateInputType
    _max?: Payout_sessionMaxAggregateInputType
  }


  export type Payout_sessionGroupByOutputType = {
    session_id: number
    session_data: string
    user_id: number
    order_id: bigint
    _count: Payout_sessionCountAggregateOutputType | null
    _avg: Payout_sessionAvgAggregateOutputType | null
    _sum: Payout_sessionSumAggregateOutputType | null
    _min: Payout_sessionMinAggregateOutputType | null
    _max: Payout_sessionMaxAggregateOutputType | null
  }

  type GetPayout_sessionGroupByPayload<T extends Payout_sessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Payout_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payout_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payout_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], Payout_sessionGroupByOutputType[P]>
        }
      >
    >


  export type payout_sessionSelect = {
    session_id?: boolean
    session_data?: boolean
    user_id?: boolean
    order_id?: boolean
  }


  export type payout_sessionGetPayload<S extends boolean | null | undefined | payout_sessionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? payout_session :
    S extends undefined ? never :
    S extends { include: any } & (payout_sessionArgs | payout_sessionFindManyArgs)
    ? payout_session 
    : S extends { select: any } & (payout_sessionArgs | payout_sessionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof payout_session ? payout_session[P] : never
  } 
      : payout_session


  type payout_sessionCountArgs = Merge<
    Omit<payout_sessionFindManyArgs, 'select' | 'include'> & {
      select?: Payout_sessionCountAggregateInputType | true
    }
  >

  export interface payout_sessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Payout_session that matches the filter.
     * @param {payout_sessionFindUniqueArgs} args - Arguments to find a Payout_session
     * @example
     * // Get one Payout_session
     * const payout_session = await prisma.payout_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends payout_sessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, payout_sessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payout_session'> extends True ? Prisma__payout_sessionClient<payout_sessionGetPayload<T>> : Prisma__payout_sessionClient<payout_sessionGetPayload<T> | null, null>

    /**
     * Find the first Payout_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payout_sessionFindFirstArgs} args - Arguments to find a Payout_session
     * @example
     * // Get one Payout_session
     * const payout_session = await prisma.payout_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends payout_sessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, payout_sessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payout_session'> extends True ? Prisma__payout_sessionClient<payout_sessionGetPayload<T>> : Prisma__payout_sessionClient<payout_sessionGetPayload<T> | null, null>

    /**
     * Find zero or more Payout_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payout_sessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payout_sessions
     * const payout_sessions = await prisma.payout_session.findMany()
     * 
     * // Get first 10 Payout_sessions
     * const payout_sessions = await prisma.payout_session.findMany({ take: 10 })
     * 
     * // Only select the `session_id`
     * const payout_sessionWithSession_idOnly = await prisma.payout_session.findMany({ select: { session_id: true } })
     * 
    **/
    findMany<T extends payout_sessionFindManyArgs>(
      args?: SelectSubset<T, payout_sessionFindManyArgs>
    ): PrismaPromise<Array<payout_sessionGetPayload<T>>>

    /**
     * Create a Payout_session.
     * @param {payout_sessionCreateArgs} args - Arguments to create a Payout_session.
     * @example
     * // Create one Payout_session
     * const Payout_session = await prisma.payout_session.create({
     *   data: {
     *     // ... data to create a Payout_session
     *   }
     * })
     * 
    **/
    create<T extends payout_sessionCreateArgs>(
      args: SelectSubset<T, payout_sessionCreateArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Create many Payout_sessions.
     *     @param {payout_sessionCreateManyArgs} args - Arguments to create many Payout_sessions.
     *     @example
     *     // Create many Payout_sessions
     *     const payout_session = await prisma.payout_session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends payout_sessionCreateManyArgs>(
      args?: SelectSubset<T, payout_sessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payout_session.
     * @param {payout_sessionDeleteArgs} args - Arguments to delete one Payout_session.
     * @example
     * // Delete one Payout_session
     * const Payout_session = await prisma.payout_session.delete({
     *   where: {
     *     // ... filter to delete one Payout_session
     *   }
     * })
     * 
    **/
    delete<T extends payout_sessionDeleteArgs>(
      args: SelectSubset<T, payout_sessionDeleteArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Update one Payout_session.
     * @param {payout_sessionUpdateArgs} args - Arguments to update one Payout_session.
     * @example
     * // Update one Payout_session
     * const payout_session = await prisma.payout_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends payout_sessionUpdateArgs>(
      args: SelectSubset<T, payout_sessionUpdateArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Delete zero or more Payout_sessions.
     * @param {payout_sessionDeleteManyArgs} args - Arguments to filter Payout_sessions to delete.
     * @example
     * // Delete a few Payout_sessions
     * const { count } = await prisma.payout_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends payout_sessionDeleteManyArgs>(
      args?: SelectSubset<T, payout_sessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payout_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payout_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payout_sessions
     * const payout_session = await prisma.payout_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends payout_sessionUpdateManyArgs>(
      args: SelectSubset<T, payout_sessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payout_session.
     * @param {payout_sessionUpsertArgs} args - Arguments to update or create a Payout_session.
     * @example
     * // Update or create a Payout_session
     * const payout_session = await prisma.payout_session.upsert({
     *   create: {
     *     // ... data to create a Payout_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout_session we want to update
     *   }
     * })
    **/
    upsert<T extends payout_sessionUpsertArgs>(
      args: SelectSubset<T, payout_sessionUpsertArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Find one Payout_session that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {payout_sessionFindUniqueOrThrowArgs} args - Arguments to find a Payout_session
     * @example
     * // Get one Payout_session
     * const payout_session = await prisma.payout_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends payout_sessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, payout_sessionFindUniqueOrThrowArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Find the first Payout_session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payout_sessionFindFirstOrThrowArgs} args - Arguments to find a Payout_session
     * @example
     * // Get one Payout_session
     * const payout_session = await prisma.payout_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends payout_sessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payout_sessionFindFirstOrThrowArgs>
    ): Prisma__payout_sessionClient<payout_sessionGetPayload<T>>

    /**
     * Count the number of Payout_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payout_sessionCountArgs} args - Arguments to filter Payout_sessions to count.
     * @example
     * // Count the number of Payout_sessions
     * const count = await prisma.payout_session.count({
     *   where: {
     *     // ... the filter for the Payout_sessions we want to count
     *   }
     * })
    **/
    count<T extends payout_sessionCountArgs>(
      args?: Subset<T, payout_sessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payout_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payout_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payout_sessionAggregateArgs>(args: Subset<T, Payout_sessionAggregateArgs>): PrismaPromise<GetPayout_sessionAggregateType<T>>

    /**
     * Group by Payout_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payout_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Payout_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Payout_sessionGroupByArgs['orderBy'] }
        : { orderBy?: Payout_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Payout_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayout_sessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payout_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__payout_sessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payout_session base type for findUnique actions
   */
  export type payout_sessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * Filter, which payout_session to fetch.
     * 
    **/
    where: payout_sessionWhereUniqueInput
  }

  /**
   * payout_session: findUnique
   */
  export interface payout_sessionFindUniqueArgs extends payout_sessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payout_session base type for findFirst actions
   */
  export type payout_sessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * Filter, which payout_session to fetch.
     * 
    **/
    where?: payout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payout_sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<payout_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payout_sessions.
     * 
    **/
    cursor?: payout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payout_sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payout_sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payout_sessions.
     * 
    **/
    distinct?: Enumerable<Payout_sessionScalarFieldEnum>
  }

  /**
   * payout_session: findFirst
   */
  export interface payout_sessionFindFirstArgs extends payout_sessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payout_session findMany
   */
  export type payout_sessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * Filter, which payout_sessions to fetch.
     * 
    **/
    where?: payout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payout_sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<payout_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payout_sessions.
     * 
    **/
    cursor?: payout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payout_sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payout_sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Payout_sessionScalarFieldEnum>
  }


  /**
   * payout_session create
   */
  export type payout_sessionCreateArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * The data needed to create a payout_session.
     * 
    **/
    data: XOR<payout_sessionCreateInput, payout_sessionUncheckedCreateInput>
  }


  /**
   * payout_session createMany
   */
  export type payout_sessionCreateManyArgs = {
    /**
     * The data used to create many payout_sessions.
     * 
    **/
    data: Enumerable<payout_sessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payout_session update
   */
  export type payout_sessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * The data needed to update a payout_session.
     * 
    **/
    data: XOR<payout_sessionUpdateInput, payout_sessionUncheckedUpdateInput>
    /**
     * Choose, which payout_session to update.
     * 
    **/
    where: payout_sessionWhereUniqueInput
  }


  /**
   * payout_session updateMany
   */
  export type payout_sessionUpdateManyArgs = {
    /**
     * The data used to update payout_sessions.
     * 
    **/
    data: XOR<payout_sessionUpdateManyMutationInput, payout_sessionUncheckedUpdateManyInput>
    /**
     * Filter which payout_sessions to update
     * 
    **/
    where?: payout_sessionWhereInput
  }


  /**
   * payout_session upsert
   */
  export type payout_sessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * The filter to search for the payout_session to update in case it exists.
     * 
    **/
    where: payout_sessionWhereUniqueInput
    /**
     * In case the payout_session found by the `where` argument doesn't exist, create a new payout_session with this data.
     * 
    **/
    create: XOR<payout_sessionCreateInput, payout_sessionUncheckedCreateInput>
    /**
     * In case the payout_session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<payout_sessionUpdateInput, payout_sessionUncheckedUpdateInput>
  }


  /**
   * payout_session delete
   */
  export type payout_sessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
    /**
     * Filter which payout_session to delete.
     * 
    **/
    where: payout_sessionWhereUniqueInput
  }


  /**
   * payout_session deleteMany
   */
  export type payout_sessionDeleteManyArgs = {
    /**
     * Filter which payout_sessions to delete
     * 
    **/
    where?: payout_sessionWhereInput
  }


  /**
   * payout_session: findUniqueOrThrow
   */
  export type payout_sessionFindUniqueOrThrowArgs = payout_sessionFindUniqueArgsBase
      

  /**
   * payout_session: findFirstOrThrow
   */
  export type payout_sessionFindFirstOrThrowArgs = payout_sessionFindFirstArgsBase
      

  /**
   * payout_session without action
   */
  export type payout_sessionArgs = {
    /**
     * Select specific fields to fetch from the payout_session
     * 
    **/
    select?: payout_sessionSelect | null
  }



  /**
   * Model plan_tbl
   */


  export type AggregatePlan_tbl = {
    _count: Plan_tblCountAggregateOutputType | null
    _avg: Plan_tblAvgAggregateOutputType | null
    _sum: Plan_tblSumAggregateOutputType | null
    _min: Plan_tblMinAggregateOutputType | null
    _max: Plan_tblMaxAggregateOutputType | null
  }

  export type Plan_tblAvgAggregateOutputType = {
    plan_id: number | null
    plan_type: number | null
    plan_cost: number | null
    plan_cost_international: number | null
    validity_days: number | null
    book_validity_days: number | null
    available_books: number | null
    discount: Decimal | null
    status: number | null
  }

  export type Plan_tblSumAggregateOutputType = {
    plan_id: number | null
    plan_type: number | null
    plan_cost: number | null
    plan_cost_international: number | null
    validity_days: number | null
    book_validity_days: number | null
    available_books: number | null
    discount: Decimal | null
    status: number | null
  }

  export type Plan_tblMinAggregateOutputType = {
    plan_id: number | null
    plan_name: string | null
    plan_display_name: string | null
    plan_url_name: string | null
    plan_type: number | null
    plan_image: string | null
    plan_cost: number | null
    plan_caption: string | null
    plan_cost_international: number | null
    validity_days: number | null
    book_validity_days: number | null
    available_books: number | null
    discount: Decimal | null
    plan_intro_date: Date | null
    status: number | null
  }

  export type Plan_tblMaxAggregateOutputType = {
    plan_id: number | null
    plan_name: string | null
    plan_display_name: string | null
    plan_url_name: string | null
    plan_type: number | null
    plan_image: string | null
    plan_cost: number | null
    plan_caption: string | null
    plan_cost_international: number | null
    validity_days: number | null
    book_validity_days: number | null
    available_books: number | null
    discount: Decimal | null
    plan_intro_date: Date | null
    status: number | null
  }

  export type Plan_tblCountAggregateOutputType = {
    plan_id: number
    plan_name: number
    plan_display_name: number
    plan_url_name: number
    plan_type: number
    plan_image: number
    plan_cost: number
    plan_caption: number
    plan_cost_international: number
    validity_days: number
    book_validity_days: number
    available_books: number
    discount: number
    plan_intro_date: number
    status: number
    _all: number
  }


  export type Plan_tblAvgAggregateInputType = {
    plan_id?: true
    plan_type?: true
    plan_cost?: true
    plan_cost_international?: true
    validity_days?: true
    book_validity_days?: true
    available_books?: true
    discount?: true
    status?: true
  }

  export type Plan_tblSumAggregateInputType = {
    plan_id?: true
    plan_type?: true
    plan_cost?: true
    plan_cost_international?: true
    validity_days?: true
    book_validity_days?: true
    available_books?: true
    discount?: true
    status?: true
  }

  export type Plan_tblMinAggregateInputType = {
    plan_id?: true
    plan_name?: true
    plan_display_name?: true
    plan_url_name?: true
    plan_type?: true
    plan_image?: true
    plan_cost?: true
    plan_caption?: true
    plan_cost_international?: true
    validity_days?: true
    book_validity_days?: true
    available_books?: true
    discount?: true
    plan_intro_date?: true
    status?: true
  }

  export type Plan_tblMaxAggregateInputType = {
    plan_id?: true
    plan_name?: true
    plan_display_name?: true
    plan_url_name?: true
    plan_type?: true
    plan_image?: true
    plan_cost?: true
    plan_caption?: true
    plan_cost_international?: true
    validity_days?: true
    book_validity_days?: true
    available_books?: true
    discount?: true
    plan_intro_date?: true
    status?: true
  }

  export type Plan_tblCountAggregateInputType = {
    plan_id?: true
    plan_name?: true
    plan_display_name?: true
    plan_url_name?: true
    plan_type?: true
    plan_image?: true
    plan_cost?: true
    plan_caption?: true
    plan_cost_international?: true
    validity_days?: true
    book_validity_days?: true
    available_books?: true
    discount?: true
    plan_intro_date?: true
    status?: true
    _all?: true
  }

  export type Plan_tblAggregateArgs = {
    /**
     * Filter which plan_tbl to aggregate.
     * 
    **/
    where?: plan_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<plan_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plan_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_tbls
    **/
    _count?: true | Plan_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_tblMaxAggregateInputType
  }

  export type GetPlan_tblAggregateType<T extends Plan_tblAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_tbl[P]>
      : GetScalarType<T[P], AggregatePlan_tbl[P]>
  }




  export type Plan_tblGroupByArgs = {
    where?: plan_tblWhereInput
    orderBy?: Enumerable<plan_tblOrderByWithAggregationInput>
    by: Array<Plan_tblScalarFieldEnum>
    having?: plan_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_tblCountAggregateInputType | true
    _avg?: Plan_tblAvgAggregateInputType
    _sum?: Plan_tblSumAggregateInputType
    _min?: Plan_tblMinAggregateInputType
    _max?: Plan_tblMaxAggregateInputType
  }


  export type Plan_tblGroupByOutputType = {
    plan_id: number
    plan_name: string
    plan_display_name: string | null
    plan_url_name: string | null
    plan_type: number | null
    plan_image: string
    plan_cost: number
    plan_caption: string | null
    plan_cost_international: number
    validity_days: number
    book_validity_days: number
    available_books: number
    discount: Decimal
    plan_intro_date: Date
    status: number
    _count: Plan_tblCountAggregateOutputType | null
    _avg: Plan_tblAvgAggregateOutputType | null
    _sum: Plan_tblSumAggregateOutputType | null
    _min: Plan_tblMinAggregateOutputType | null
    _max: Plan_tblMaxAggregateOutputType | null
  }

  type GetPlan_tblGroupByPayload<T extends Plan_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plan_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_tblGroupByOutputType[P]>
        }
      >
    >


  export type plan_tblSelect = {
    plan_id?: boolean
    plan_name?: boolean
    plan_display_name?: boolean
    plan_url_name?: boolean
    plan_type?: boolean
    plan_image?: boolean
    plan_cost?: boolean
    plan_caption?: boolean
    plan_cost_international?: boolean
    validity_days?: boolean
    book_validity_days?: boolean
    available_books?: boolean
    discount?: boolean
    plan_intro_date?: boolean
    status?: boolean
  }


  export type plan_tblGetPayload<S extends boolean | null | undefined | plan_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plan_tbl :
    S extends undefined ? never :
    S extends { include: any } & (plan_tblArgs | plan_tblFindManyArgs)
    ? plan_tbl 
    : S extends { select: any } & (plan_tblArgs | plan_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plan_tbl ? plan_tbl[P] : never
  } 
      : plan_tbl


  type plan_tblCountArgs = Merge<
    Omit<plan_tblFindManyArgs, 'select' | 'include'> & {
      select?: Plan_tblCountAggregateInputType | true
    }
  >

  export interface plan_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plan_tbl that matches the filter.
     * @param {plan_tblFindUniqueArgs} args - Arguments to find a Plan_tbl
     * @example
     * // Get one Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plan_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plan_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plan_tbl'> extends True ? Prisma__plan_tblClient<plan_tblGetPayload<T>> : Prisma__plan_tblClient<plan_tblGetPayload<T> | null, null>

    /**
     * Find the first Plan_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_tblFindFirstArgs} args - Arguments to find a Plan_tbl
     * @example
     * // Get one Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plan_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plan_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plan_tbl'> extends True ? Prisma__plan_tblClient<plan_tblGetPayload<T>> : Prisma__plan_tblClient<plan_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Plan_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_tbls
     * const plan_tbls = await prisma.plan_tbl.findMany()
     * 
     * // Get first 10 Plan_tbls
     * const plan_tbls = await prisma.plan_tbl.findMany({ take: 10 })
     * 
     * // Only select the `plan_id`
     * const plan_tblWithPlan_idOnly = await prisma.plan_tbl.findMany({ select: { plan_id: true } })
     * 
    **/
    findMany<T extends plan_tblFindManyArgs>(
      args?: SelectSubset<T, plan_tblFindManyArgs>
    ): PrismaPromise<Array<plan_tblGetPayload<T>>>

    /**
     * Create a Plan_tbl.
     * @param {plan_tblCreateArgs} args - Arguments to create a Plan_tbl.
     * @example
     * // Create one Plan_tbl
     * const Plan_tbl = await prisma.plan_tbl.create({
     *   data: {
     *     // ... data to create a Plan_tbl
     *   }
     * })
     * 
    **/
    create<T extends plan_tblCreateArgs>(
      args: SelectSubset<T, plan_tblCreateArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Create many Plan_tbls.
     *     @param {plan_tblCreateManyArgs} args - Arguments to create many Plan_tbls.
     *     @example
     *     // Create many Plan_tbls
     *     const plan_tbl = await prisma.plan_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plan_tblCreateManyArgs>(
      args?: SelectSubset<T, plan_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_tbl.
     * @param {plan_tblDeleteArgs} args - Arguments to delete one Plan_tbl.
     * @example
     * // Delete one Plan_tbl
     * const Plan_tbl = await prisma.plan_tbl.delete({
     *   where: {
     *     // ... filter to delete one Plan_tbl
     *   }
     * })
     * 
    **/
    delete<T extends plan_tblDeleteArgs>(
      args: SelectSubset<T, plan_tblDeleteArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Update one Plan_tbl.
     * @param {plan_tblUpdateArgs} args - Arguments to update one Plan_tbl.
     * @example
     * // Update one Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plan_tblUpdateArgs>(
      args: SelectSubset<T, plan_tblUpdateArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Delete zero or more Plan_tbls.
     * @param {plan_tblDeleteManyArgs} args - Arguments to filter Plan_tbls to delete.
     * @example
     * // Delete a few Plan_tbls
     * const { count } = await prisma.plan_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plan_tblDeleteManyArgs>(
      args?: SelectSubset<T, plan_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_tbls
     * const plan_tbl = await prisma.plan_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plan_tblUpdateManyArgs>(
      args: SelectSubset<T, plan_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_tbl.
     * @param {plan_tblUpsertArgs} args - Arguments to update or create a Plan_tbl.
     * @example
     * // Update or create a Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.upsert({
     *   create: {
     *     // ... data to create a Plan_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends plan_tblUpsertArgs>(
      args: SelectSubset<T, plan_tblUpsertArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Find one Plan_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plan_tblFindUniqueOrThrowArgs} args - Arguments to find a Plan_tbl
     * @example
     * // Get one Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plan_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plan_tblFindUniqueOrThrowArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Find the first Plan_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_tblFindFirstOrThrowArgs} args - Arguments to find a Plan_tbl
     * @example
     * // Get one Plan_tbl
     * const plan_tbl = await prisma.plan_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plan_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plan_tblFindFirstOrThrowArgs>
    ): Prisma__plan_tblClient<plan_tblGetPayload<T>>

    /**
     * Count the number of Plan_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_tblCountArgs} args - Arguments to filter Plan_tbls to count.
     * @example
     * // Count the number of Plan_tbls
     * const count = await prisma.plan_tbl.count({
     *   where: {
     *     // ... the filter for the Plan_tbls we want to count
     *   }
     * })
    **/
    count<T extends plan_tblCountArgs>(
      args?: Subset<T, plan_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_tblAggregateArgs>(args: Subset<T, Plan_tblAggregateArgs>): PrismaPromise<GetPlan_tblAggregateType<T>>

    /**
     * Group by Plan_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plan_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plan_tblGroupByArgs['orderBy'] }
        : { orderBy?: Plan_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plan_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plan_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plan_tbl base type for findUnique actions
   */
  export type plan_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * Filter, which plan_tbl to fetch.
     * 
    **/
    where: plan_tblWhereUniqueInput
  }

  /**
   * plan_tbl: findUnique
   */
  export interface plan_tblFindUniqueArgs extends plan_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_tbl base type for findFirst actions
   */
  export type plan_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * Filter, which plan_tbl to fetch.
     * 
    **/
    where?: plan_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<plan_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_tbls.
     * 
    **/
    cursor?: plan_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_tbls.
     * 
    **/
    distinct?: Enumerable<Plan_tblScalarFieldEnum>
  }

  /**
   * plan_tbl: findFirst
   */
  export interface plan_tblFindFirstArgs extends plan_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_tbl findMany
   */
  export type plan_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * Filter, which plan_tbls to fetch.
     * 
    **/
    where?: plan_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<plan_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_tbls.
     * 
    **/
    cursor?: plan_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plan_tblScalarFieldEnum>
  }


  /**
   * plan_tbl create
   */
  export type plan_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * The data needed to create a plan_tbl.
     * 
    **/
    data: XOR<plan_tblCreateInput, plan_tblUncheckedCreateInput>
  }


  /**
   * plan_tbl createMany
   */
  export type plan_tblCreateManyArgs = {
    /**
     * The data used to create many plan_tbls.
     * 
    **/
    data: Enumerable<plan_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plan_tbl update
   */
  export type plan_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * The data needed to update a plan_tbl.
     * 
    **/
    data: XOR<plan_tblUpdateInput, plan_tblUncheckedUpdateInput>
    /**
     * Choose, which plan_tbl to update.
     * 
    **/
    where: plan_tblWhereUniqueInput
  }


  /**
   * plan_tbl updateMany
   */
  export type plan_tblUpdateManyArgs = {
    /**
     * The data used to update plan_tbls.
     * 
    **/
    data: XOR<plan_tblUpdateManyMutationInput, plan_tblUncheckedUpdateManyInput>
    /**
     * Filter which plan_tbls to update
     * 
    **/
    where?: plan_tblWhereInput
  }


  /**
   * plan_tbl upsert
   */
  export type plan_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * The filter to search for the plan_tbl to update in case it exists.
     * 
    **/
    where: plan_tblWhereUniqueInput
    /**
     * In case the plan_tbl found by the `where` argument doesn't exist, create a new plan_tbl with this data.
     * 
    **/
    create: XOR<plan_tblCreateInput, plan_tblUncheckedCreateInput>
    /**
     * In case the plan_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plan_tblUpdateInput, plan_tblUncheckedUpdateInput>
  }


  /**
   * plan_tbl delete
   */
  export type plan_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
    /**
     * Filter which plan_tbl to delete.
     * 
    **/
    where: plan_tblWhereUniqueInput
  }


  /**
   * plan_tbl deleteMany
   */
  export type plan_tblDeleteManyArgs = {
    /**
     * Filter which plan_tbls to delete
     * 
    **/
    where?: plan_tblWhereInput
  }


  /**
   * plan_tbl: findUniqueOrThrow
   */
  export type plan_tblFindUniqueOrThrowArgs = plan_tblFindUniqueArgsBase
      

  /**
   * plan_tbl: findFirstOrThrow
   */
  export type plan_tblFindFirstOrThrowArgs = plan_tblFindFirstArgsBase
      

  /**
   * plan_tbl without action
   */
  export type plan_tblArgs = {
    /**
     * Select specific fields to fetch from the plan_tbl
     * 
    **/
    select?: plan_tblSelect | null
  }



  /**
   * Model pod_cost_notification
   */


  export type AggregatePod_cost_notification = {
    _count: Pod_cost_notificationCountAggregateOutputType | null
    _avg: Pod_cost_notificationAvgAggregateOutputType | null
    _sum: Pod_cost_notificationSumAggregateOutputType | null
    _min: Pod_cost_notificationMinAggregateOutputType | null
    _max: Pod_cost_notificationMaxAggregateOutputType | null
  }

  export type Pod_cost_notificationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    mail_status: number | null
  }

  export type Pod_cost_notificationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    mail_status: number | null
  }

  export type Pod_cost_notificationMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    date_created: Date | null
    mail_status: number | null
  }

  export type Pod_cost_notificationMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    date_created: Date | null
    mail_status: number | null
  }

  export type Pod_cost_notificationCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    date_created: number
    mail_status: number
    _all: number
  }


  export type Pod_cost_notificationAvgAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    mail_status?: true
  }

  export type Pod_cost_notificationSumAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    mail_status?: true
  }

  export type Pod_cost_notificationMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    date_created?: true
    mail_status?: true
  }

  export type Pod_cost_notificationMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    date_created?: true
    mail_status?: true
  }

  export type Pod_cost_notificationCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    date_created?: true
    mail_status?: true
    _all?: true
  }

  export type Pod_cost_notificationAggregateArgs = {
    /**
     * Filter which pod_cost_notification to aggregate.
     * 
    **/
    where?: pod_cost_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_cost_notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_cost_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pod_cost_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_cost_notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_cost_notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pod_cost_notifications
    **/
    _count?: true | Pod_cost_notificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pod_cost_notificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pod_cost_notificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pod_cost_notificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pod_cost_notificationMaxAggregateInputType
  }

  export type GetPod_cost_notificationAggregateType<T extends Pod_cost_notificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePod_cost_notification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod_cost_notification[P]>
      : GetScalarType<T[P], AggregatePod_cost_notification[P]>
  }




  export type Pod_cost_notificationGroupByArgs = {
    where?: pod_cost_notificationWhereInput
    orderBy?: Enumerable<pod_cost_notificationOrderByWithAggregationInput>
    by: Array<Pod_cost_notificationScalarFieldEnum>
    having?: pod_cost_notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pod_cost_notificationCountAggregateInputType | true
    _avg?: Pod_cost_notificationAvgAggregateInputType
    _sum?: Pod_cost_notificationSumAggregateInputType
    _min?: Pod_cost_notificationMinAggregateInputType
    _max?: Pod_cost_notificationMaxAggregateInputType
  }


  export type Pod_cost_notificationGroupByOutputType = {
    id: number
    user_id: number | null
    book_id: number | null
    date_created: Date | null
    mail_status: number | null
    _count: Pod_cost_notificationCountAggregateOutputType | null
    _avg: Pod_cost_notificationAvgAggregateOutputType | null
    _sum: Pod_cost_notificationSumAggregateOutputType | null
    _min: Pod_cost_notificationMinAggregateOutputType | null
    _max: Pod_cost_notificationMaxAggregateOutputType | null
  }

  type GetPod_cost_notificationGroupByPayload<T extends Pod_cost_notificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pod_cost_notificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pod_cost_notificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pod_cost_notificationGroupByOutputType[P]>
            : GetScalarType<T[P], Pod_cost_notificationGroupByOutputType[P]>
        }
      >
    >


  export type pod_cost_notificationSelect = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    date_created?: boolean
    mail_status?: boolean
  }


  export type pod_cost_notificationGetPayload<S extends boolean | null | undefined | pod_cost_notificationArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pod_cost_notification :
    S extends undefined ? never :
    S extends { include: any } & (pod_cost_notificationArgs | pod_cost_notificationFindManyArgs)
    ? pod_cost_notification 
    : S extends { select: any } & (pod_cost_notificationArgs | pod_cost_notificationFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof pod_cost_notification ? pod_cost_notification[P] : never
  } 
      : pod_cost_notification


  type pod_cost_notificationCountArgs = Merge<
    Omit<pod_cost_notificationFindManyArgs, 'select' | 'include'> & {
      select?: Pod_cost_notificationCountAggregateInputType | true
    }
  >

  export interface pod_cost_notificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pod_cost_notification that matches the filter.
     * @param {pod_cost_notificationFindUniqueArgs} args - Arguments to find a Pod_cost_notification
     * @example
     * // Get one Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pod_cost_notificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pod_cost_notificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pod_cost_notification'> extends True ? Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>> : Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T> | null, null>

    /**
     * Find the first Pod_cost_notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_cost_notificationFindFirstArgs} args - Arguments to find a Pod_cost_notification
     * @example
     * // Get one Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pod_cost_notificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pod_cost_notificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pod_cost_notification'> extends True ? Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>> : Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T> | null, null>

    /**
     * Find zero or more Pod_cost_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_cost_notificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pod_cost_notifications
     * const pod_cost_notifications = await prisma.pod_cost_notification.findMany()
     * 
     * // Get first 10 Pod_cost_notifications
     * const pod_cost_notifications = await prisma.pod_cost_notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pod_cost_notificationWithIdOnly = await prisma.pod_cost_notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pod_cost_notificationFindManyArgs>(
      args?: SelectSubset<T, pod_cost_notificationFindManyArgs>
    ): PrismaPromise<Array<pod_cost_notificationGetPayload<T>>>

    /**
     * Create a Pod_cost_notification.
     * @param {pod_cost_notificationCreateArgs} args - Arguments to create a Pod_cost_notification.
     * @example
     * // Create one Pod_cost_notification
     * const Pod_cost_notification = await prisma.pod_cost_notification.create({
     *   data: {
     *     // ... data to create a Pod_cost_notification
     *   }
     * })
     * 
    **/
    create<T extends pod_cost_notificationCreateArgs>(
      args: SelectSubset<T, pod_cost_notificationCreateArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Create many Pod_cost_notifications.
     *     @param {pod_cost_notificationCreateManyArgs} args - Arguments to create many Pod_cost_notifications.
     *     @example
     *     // Create many Pod_cost_notifications
     *     const pod_cost_notification = await prisma.pod_cost_notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pod_cost_notificationCreateManyArgs>(
      args?: SelectSubset<T, pod_cost_notificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pod_cost_notification.
     * @param {pod_cost_notificationDeleteArgs} args - Arguments to delete one Pod_cost_notification.
     * @example
     * // Delete one Pod_cost_notification
     * const Pod_cost_notification = await prisma.pod_cost_notification.delete({
     *   where: {
     *     // ... filter to delete one Pod_cost_notification
     *   }
     * })
     * 
    **/
    delete<T extends pod_cost_notificationDeleteArgs>(
      args: SelectSubset<T, pod_cost_notificationDeleteArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Update one Pod_cost_notification.
     * @param {pod_cost_notificationUpdateArgs} args - Arguments to update one Pod_cost_notification.
     * @example
     * // Update one Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pod_cost_notificationUpdateArgs>(
      args: SelectSubset<T, pod_cost_notificationUpdateArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Delete zero or more Pod_cost_notifications.
     * @param {pod_cost_notificationDeleteManyArgs} args - Arguments to filter Pod_cost_notifications to delete.
     * @example
     * // Delete a few Pod_cost_notifications
     * const { count } = await prisma.pod_cost_notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pod_cost_notificationDeleteManyArgs>(
      args?: SelectSubset<T, pod_cost_notificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pod_cost_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_cost_notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pod_cost_notifications
     * const pod_cost_notification = await prisma.pod_cost_notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pod_cost_notificationUpdateManyArgs>(
      args: SelectSubset<T, pod_cost_notificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pod_cost_notification.
     * @param {pod_cost_notificationUpsertArgs} args - Arguments to update or create a Pod_cost_notification.
     * @example
     * // Update or create a Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.upsert({
     *   create: {
     *     // ... data to create a Pod_cost_notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod_cost_notification we want to update
     *   }
     * })
    **/
    upsert<T extends pod_cost_notificationUpsertArgs>(
      args: SelectSubset<T, pod_cost_notificationUpsertArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Find one Pod_cost_notification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pod_cost_notificationFindUniqueOrThrowArgs} args - Arguments to find a Pod_cost_notification
     * @example
     * // Get one Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pod_cost_notificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pod_cost_notificationFindUniqueOrThrowArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Find the first Pod_cost_notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_cost_notificationFindFirstOrThrowArgs} args - Arguments to find a Pod_cost_notification
     * @example
     * // Get one Pod_cost_notification
     * const pod_cost_notification = await prisma.pod_cost_notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pod_cost_notificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pod_cost_notificationFindFirstOrThrowArgs>
    ): Prisma__pod_cost_notificationClient<pod_cost_notificationGetPayload<T>>

    /**
     * Count the number of Pod_cost_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_cost_notificationCountArgs} args - Arguments to filter Pod_cost_notifications to count.
     * @example
     * // Count the number of Pod_cost_notifications
     * const count = await prisma.pod_cost_notification.count({
     *   where: {
     *     // ... the filter for the Pod_cost_notifications we want to count
     *   }
     * })
    **/
    count<T extends pod_cost_notificationCountArgs>(
      args?: Subset<T, pod_cost_notificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pod_cost_notificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod_cost_notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_cost_notificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pod_cost_notificationAggregateArgs>(args: Subset<T, Pod_cost_notificationAggregateArgs>): PrismaPromise<GetPod_cost_notificationAggregateType<T>>

    /**
     * Group by Pod_cost_notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_cost_notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pod_cost_notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pod_cost_notificationGroupByArgs['orderBy'] }
        : { orderBy?: Pod_cost_notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pod_cost_notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPod_cost_notificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pod_cost_notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pod_cost_notificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pod_cost_notification base type for findUnique actions
   */
  export type pod_cost_notificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * Filter, which pod_cost_notification to fetch.
     * 
    **/
    where: pod_cost_notificationWhereUniqueInput
  }

  /**
   * pod_cost_notification: findUnique
   */
  export interface pod_cost_notificationFindUniqueArgs extends pod_cost_notificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_cost_notification base type for findFirst actions
   */
  export type pod_cost_notificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * Filter, which pod_cost_notification to fetch.
     * 
    **/
    where?: pod_cost_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_cost_notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_cost_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pod_cost_notifications.
     * 
    **/
    cursor?: pod_cost_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_cost_notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_cost_notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pod_cost_notifications.
     * 
    **/
    distinct?: Enumerable<Pod_cost_notificationScalarFieldEnum>
  }

  /**
   * pod_cost_notification: findFirst
   */
  export interface pod_cost_notificationFindFirstArgs extends pod_cost_notificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_cost_notification findMany
   */
  export type pod_cost_notificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * Filter, which pod_cost_notifications to fetch.
     * 
    **/
    where?: pod_cost_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_cost_notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_cost_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pod_cost_notifications.
     * 
    **/
    cursor?: pod_cost_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_cost_notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_cost_notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pod_cost_notificationScalarFieldEnum>
  }


  /**
   * pod_cost_notification create
   */
  export type pod_cost_notificationCreateArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * The data needed to create a pod_cost_notification.
     * 
    **/
    data: XOR<pod_cost_notificationCreateInput, pod_cost_notificationUncheckedCreateInput>
  }


  /**
   * pod_cost_notification createMany
   */
  export type pod_cost_notificationCreateManyArgs = {
    /**
     * The data used to create many pod_cost_notifications.
     * 
    **/
    data: Enumerable<pod_cost_notificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pod_cost_notification update
   */
  export type pod_cost_notificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * The data needed to update a pod_cost_notification.
     * 
    **/
    data: XOR<pod_cost_notificationUpdateInput, pod_cost_notificationUncheckedUpdateInput>
    /**
     * Choose, which pod_cost_notification to update.
     * 
    **/
    where: pod_cost_notificationWhereUniqueInput
  }


  /**
   * pod_cost_notification updateMany
   */
  export type pod_cost_notificationUpdateManyArgs = {
    /**
     * The data used to update pod_cost_notifications.
     * 
    **/
    data: XOR<pod_cost_notificationUpdateManyMutationInput, pod_cost_notificationUncheckedUpdateManyInput>
    /**
     * Filter which pod_cost_notifications to update
     * 
    **/
    where?: pod_cost_notificationWhereInput
  }


  /**
   * pod_cost_notification upsert
   */
  export type pod_cost_notificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * The filter to search for the pod_cost_notification to update in case it exists.
     * 
    **/
    where: pod_cost_notificationWhereUniqueInput
    /**
     * In case the pod_cost_notification found by the `where` argument doesn't exist, create a new pod_cost_notification with this data.
     * 
    **/
    create: XOR<pod_cost_notificationCreateInput, pod_cost_notificationUncheckedCreateInput>
    /**
     * In case the pod_cost_notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pod_cost_notificationUpdateInput, pod_cost_notificationUncheckedUpdateInput>
  }


  /**
   * pod_cost_notification delete
   */
  export type pod_cost_notificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
    /**
     * Filter which pod_cost_notification to delete.
     * 
    **/
    where: pod_cost_notificationWhereUniqueInput
  }


  /**
   * pod_cost_notification deleteMany
   */
  export type pod_cost_notificationDeleteManyArgs = {
    /**
     * Filter which pod_cost_notifications to delete
     * 
    **/
    where?: pod_cost_notificationWhereInput
  }


  /**
   * pod_cost_notification: findUniqueOrThrow
   */
  export type pod_cost_notificationFindUniqueOrThrowArgs = pod_cost_notificationFindUniqueArgsBase
      

  /**
   * pod_cost_notification: findFirstOrThrow
   */
  export type pod_cost_notificationFindFirstOrThrowArgs = pod_cost_notificationFindFirstArgsBase
      

  /**
   * pod_cost_notification without action
   */
  export type pod_cost_notificationArgs = {
    /**
     * Select specific fields to fetch from the pod_cost_notification
     * 
    **/
    select?: pod_cost_notificationSelect | null
  }



  /**
   * Model pod_order
   */


  export type AggregatePod_order = {
    _count: Pod_orderCountAggregateOutputType | null
    _avg: Pod_orderAvgAggregateOutputType | null
    _sum: Pod_orderSumAggregateOutputType | null
    _min: Pod_orderMinAggregateOutputType | null
    _max: Pod_orderMaxAggregateOutputType | null
  }

  export type Pod_orderAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    shipping_charges: number | null
    discount: number | null
    order_status: number | null
    split_flag: number | null
  }

  export type Pod_orderSumAggregateOutputType = {
    id: number | null
    order_id: number | null
    shipping_charges: number | null
    discount: number | null
    order_status: number | null
    split_flag: number | null
  }

  export type Pod_orderMinAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: string | null
    shipping_charges: number | null
    discount: number | null
    order_status: number | null
    split_flag: number | null
    tracking_id: string | null
    tracking_url: string | null
    order_date: Date | null
  }

  export type Pod_orderMaxAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: string | null
    shipping_charges: number | null
    discount: number | null
    order_status: number | null
    split_flag: number | null
    tracking_id: string | null
    tracking_url: string | null
    order_date: Date | null
  }

  export type Pod_orderCountAggregateOutputType = {
    id: number
    order_id: number
    user_id: number
    shipping_charges: number
    discount: number
    order_status: number
    split_flag: number
    tracking_id: number
    tracking_url: number
    order_date: number
    _all: number
  }


  export type Pod_orderAvgAggregateInputType = {
    id?: true
    order_id?: true
    shipping_charges?: true
    discount?: true
    order_status?: true
    split_flag?: true
  }

  export type Pod_orderSumAggregateInputType = {
    id?: true
    order_id?: true
    shipping_charges?: true
    discount?: true
    order_status?: true
    split_flag?: true
  }

  export type Pod_orderMinAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    shipping_charges?: true
    discount?: true
    order_status?: true
    split_flag?: true
    tracking_id?: true
    tracking_url?: true
    order_date?: true
  }

  export type Pod_orderMaxAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    shipping_charges?: true
    discount?: true
    order_status?: true
    split_flag?: true
    tracking_id?: true
    tracking_url?: true
    order_date?: true
  }

  export type Pod_orderCountAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    shipping_charges?: true
    discount?: true
    order_status?: true
    split_flag?: true
    tracking_id?: true
    tracking_url?: true
    order_date?: true
    _all?: true
  }

  export type Pod_orderAggregateArgs = {
    /**
     * Filter which pod_order to aggregate.
     * 
    **/
    where?: pod_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_orders to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pod_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pod_orders
    **/
    _count?: true | Pod_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pod_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pod_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pod_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pod_orderMaxAggregateInputType
  }

  export type GetPod_orderAggregateType<T extends Pod_orderAggregateArgs> = {
        [P in keyof T & keyof AggregatePod_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod_order[P]>
      : GetScalarType<T[P], AggregatePod_order[P]>
  }




  export type Pod_orderGroupByArgs = {
    where?: pod_orderWhereInput
    orderBy?: Enumerable<pod_orderOrderByWithAggregationInput>
    by: Array<Pod_orderScalarFieldEnum>
    having?: pod_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pod_orderCountAggregateInputType | true
    _avg?: Pod_orderAvgAggregateInputType
    _sum?: Pod_orderSumAggregateInputType
    _min?: Pod_orderMinAggregateInputType
    _max?: Pod_orderMaxAggregateInputType
  }


  export type Pod_orderGroupByOutputType = {
    id: number
    order_id: number | null
    user_id: string | null
    shipping_charges: number | null
    discount: number | null
    order_status: number | null
    split_flag: number | null
    tracking_id: string | null
    tracking_url: string | null
    order_date: Date | null
    _count: Pod_orderCountAggregateOutputType | null
    _avg: Pod_orderAvgAggregateOutputType | null
    _sum: Pod_orderSumAggregateOutputType | null
    _min: Pod_orderMinAggregateOutputType | null
    _max: Pod_orderMaxAggregateOutputType | null
  }

  type GetPod_orderGroupByPayload<T extends Pod_orderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pod_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pod_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pod_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Pod_orderGroupByOutputType[P]>
        }
      >
    >


  export type pod_orderSelect = {
    id?: boolean
    order_id?: boolean
    user_id?: boolean
    shipping_charges?: boolean
    discount?: boolean
    order_status?: boolean
    split_flag?: boolean
    tracking_id?: boolean
    tracking_url?: boolean
    order_date?: boolean
  }


  export type pod_orderGetPayload<S extends boolean | null | undefined | pod_orderArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pod_order :
    S extends undefined ? never :
    S extends { include: any } & (pod_orderArgs | pod_orderFindManyArgs)
    ? pod_order 
    : S extends { select: any } & (pod_orderArgs | pod_orderFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof pod_order ? pod_order[P] : never
  } 
      : pod_order


  type pod_orderCountArgs = Merge<
    Omit<pod_orderFindManyArgs, 'select' | 'include'> & {
      select?: Pod_orderCountAggregateInputType | true
    }
  >

  export interface pod_orderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pod_order that matches the filter.
     * @param {pod_orderFindUniqueArgs} args - Arguments to find a Pod_order
     * @example
     * // Get one Pod_order
     * const pod_order = await prisma.pod_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pod_orderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pod_orderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pod_order'> extends True ? Prisma__pod_orderClient<pod_orderGetPayload<T>> : Prisma__pod_orderClient<pod_orderGetPayload<T> | null, null>

    /**
     * Find the first Pod_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_orderFindFirstArgs} args - Arguments to find a Pod_order
     * @example
     * // Get one Pod_order
     * const pod_order = await prisma.pod_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pod_orderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pod_orderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pod_order'> extends True ? Prisma__pod_orderClient<pod_orderGetPayload<T>> : Prisma__pod_orderClient<pod_orderGetPayload<T> | null, null>

    /**
     * Find zero or more Pod_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pod_orders
     * const pod_orders = await prisma.pod_order.findMany()
     * 
     * // Get first 10 Pod_orders
     * const pod_orders = await prisma.pod_order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pod_orderWithIdOnly = await prisma.pod_order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pod_orderFindManyArgs>(
      args?: SelectSubset<T, pod_orderFindManyArgs>
    ): PrismaPromise<Array<pod_orderGetPayload<T>>>

    /**
     * Create a Pod_order.
     * @param {pod_orderCreateArgs} args - Arguments to create a Pod_order.
     * @example
     * // Create one Pod_order
     * const Pod_order = await prisma.pod_order.create({
     *   data: {
     *     // ... data to create a Pod_order
     *   }
     * })
     * 
    **/
    create<T extends pod_orderCreateArgs>(
      args: SelectSubset<T, pod_orderCreateArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Create many Pod_orders.
     *     @param {pod_orderCreateManyArgs} args - Arguments to create many Pod_orders.
     *     @example
     *     // Create many Pod_orders
     *     const pod_order = await prisma.pod_order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pod_orderCreateManyArgs>(
      args?: SelectSubset<T, pod_orderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pod_order.
     * @param {pod_orderDeleteArgs} args - Arguments to delete one Pod_order.
     * @example
     * // Delete one Pod_order
     * const Pod_order = await prisma.pod_order.delete({
     *   where: {
     *     // ... filter to delete one Pod_order
     *   }
     * })
     * 
    **/
    delete<T extends pod_orderDeleteArgs>(
      args: SelectSubset<T, pod_orderDeleteArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Update one Pod_order.
     * @param {pod_orderUpdateArgs} args - Arguments to update one Pod_order.
     * @example
     * // Update one Pod_order
     * const pod_order = await prisma.pod_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pod_orderUpdateArgs>(
      args: SelectSubset<T, pod_orderUpdateArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Delete zero or more Pod_orders.
     * @param {pod_orderDeleteManyArgs} args - Arguments to filter Pod_orders to delete.
     * @example
     * // Delete a few Pod_orders
     * const { count } = await prisma.pod_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pod_orderDeleteManyArgs>(
      args?: SelectSubset<T, pod_orderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pod_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pod_orders
     * const pod_order = await prisma.pod_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pod_orderUpdateManyArgs>(
      args: SelectSubset<T, pod_orderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pod_order.
     * @param {pod_orderUpsertArgs} args - Arguments to update or create a Pod_order.
     * @example
     * // Update or create a Pod_order
     * const pod_order = await prisma.pod_order.upsert({
     *   create: {
     *     // ... data to create a Pod_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod_order we want to update
     *   }
     * })
    **/
    upsert<T extends pod_orderUpsertArgs>(
      args: SelectSubset<T, pod_orderUpsertArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Find one Pod_order that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pod_orderFindUniqueOrThrowArgs} args - Arguments to find a Pod_order
     * @example
     * // Get one Pod_order
     * const pod_order = await prisma.pod_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pod_orderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pod_orderFindUniqueOrThrowArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Find the first Pod_order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_orderFindFirstOrThrowArgs} args - Arguments to find a Pod_order
     * @example
     * // Get one Pod_order
     * const pod_order = await prisma.pod_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pod_orderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pod_orderFindFirstOrThrowArgs>
    ): Prisma__pod_orderClient<pod_orderGetPayload<T>>

    /**
     * Count the number of Pod_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_orderCountArgs} args - Arguments to filter Pod_orders to count.
     * @example
     * // Count the number of Pod_orders
     * const count = await prisma.pod_order.count({
     *   where: {
     *     // ... the filter for the Pod_orders we want to count
     *   }
     * })
    **/
    count<T extends pod_orderCountArgs>(
      args?: Subset<T, pod_orderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pod_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pod_orderAggregateArgs>(args: Subset<T, Pod_orderAggregateArgs>): PrismaPromise<GetPod_orderAggregateType<T>>

    /**
     * Group by Pod_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pod_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pod_orderGroupByArgs['orderBy'] }
        : { orderBy?: Pod_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pod_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPod_orderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pod_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pod_orderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pod_order base type for findUnique actions
   */
  export type pod_orderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * Filter, which pod_order to fetch.
     * 
    **/
    where: pod_orderWhereUniqueInput
  }

  /**
   * pod_order: findUnique
   */
  export interface pod_orderFindUniqueArgs extends pod_orderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_order base type for findFirst actions
   */
  export type pod_orderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * Filter, which pod_order to fetch.
     * 
    **/
    where?: pod_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_orders to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pod_orders.
     * 
    **/
    cursor?: pod_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pod_orders.
     * 
    **/
    distinct?: Enumerable<Pod_orderScalarFieldEnum>
  }

  /**
   * pod_order: findFirst
   */
  export interface pod_orderFindFirstArgs extends pod_orderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_order findMany
   */
  export type pod_orderFindManyArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * Filter, which pod_orders to fetch.
     * 
    **/
    where?: pod_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_orders to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pod_orders.
     * 
    **/
    cursor?: pod_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pod_orderScalarFieldEnum>
  }


  /**
   * pod_order create
   */
  export type pod_orderCreateArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * The data needed to create a pod_order.
     * 
    **/
    data: XOR<pod_orderCreateInput, pod_orderUncheckedCreateInput>
  }


  /**
   * pod_order createMany
   */
  export type pod_orderCreateManyArgs = {
    /**
     * The data used to create many pod_orders.
     * 
    **/
    data: Enumerable<pod_orderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pod_order update
   */
  export type pod_orderUpdateArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * The data needed to update a pod_order.
     * 
    **/
    data: XOR<pod_orderUpdateInput, pod_orderUncheckedUpdateInput>
    /**
     * Choose, which pod_order to update.
     * 
    **/
    where: pod_orderWhereUniqueInput
  }


  /**
   * pod_order updateMany
   */
  export type pod_orderUpdateManyArgs = {
    /**
     * The data used to update pod_orders.
     * 
    **/
    data: XOR<pod_orderUpdateManyMutationInput, pod_orderUncheckedUpdateManyInput>
    /**
     * Filter which pod_orders to update
     * 
    **/
    where?: pod_orderWhereInput
  }


  /**
   * pod_order upsert
   */
  export type pod_orderUpsertArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * The filter to search for the pod_order to update in case it exists.
     * 
    **/
    where: pod_orderWhereUniqueInput
    /**
     * In case the pod_order found by the `where` argument doesn't exist, create a new pod_order with this data.
     * 
    **/
    create: XOR<pod_orderCreateInput, pod_orderUncheckedCreateInput>
    /**
     * In case the pod_order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pod_orderUpdateInput, pod_orderUncheckedUpdateInput>
  }


  /**
   * pod_order delete
   */
  export type pod_orderDeleteArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
    /**
     * Filter which pod_order to delete.
     * 
    **/
    where: pod_orderWhereUniqueInput
  }


  /**
   * pod_order deleteMany
   */
  export type pod_orderDeleteManyArgs = {
    /**
     * Filter which pod_orders to delete
     * 
    **/
    where?: pod_orderWhereInput
  }


  /**
   * pod_order: findUniqueOrThrow
   */
  export type pod_orderFindUniqueOrThrowArgs = pod_orderFindUniqueArgsBase
      

  /**
   * pod_order: findFirstOrThrow
   */
  export type pod_orderFindFirstOrThrowArgs = pod_orderFindFirstArgsBase
      

  /**
   * pod_order without action
   */
  export type pod_orderArgs = {
    /**
     * Select specific fields to fetch from the pod_order
     * 
    **/
    select?: pod_orderSelect | null
  }



  /**
   * Model pod_order_details
   */


  export type AggregatePod_order_details = {
    _count: Pod_order_detailsCountAggregateOutputType | null
    _avg: Pod_order_detailsAvgAggregateOutputType | null
    _sum: Pod_order_detailsSumAggregateOutputType | null
    _min: Pod_order_detailsMinAggregateOutputType | null
    _max: Pod_order_detailsMaxAggregateOutputType | null
  }

  export type Pod_order_detailsAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    quantity: number | null
    wrapper_type: number | null
    status: number | null
    price: number | null
  }

  export type Pod_order_detailsSumAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    quantity: number | null
    wrapper_type: number | null
    status: number | null
    price: number | null
  }

  export type Pod_order_detailsMinAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    quantity: number | null
    wrapper_type: number | null
    personalised_message: string | null
    tracking_id: string | null
    tracking_url: string | null
    status: number | null
    price: number | null
    order_date: Date | null
  }

  export type Pod_order_detailsMaxAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    book_id: number | null
    quantity: number | null
    wrapper_type: number | null
    personalised_message: string | null
    tracking_id: string | null
    tracking_url: string | null
    status: number | null
    price: number | null
    order_date: Date | null
  }

  export type Pod_order_detailsCountAggregateOutputType = {
    id: number
    order_id: number
    user_id: number
    book_id: number
    quantity: number
    wrapper_type: number
    personalised_message: number
    tracking_id: number
    tracking_url: number
    status: number
    price: number
    order_date: number
    _all: number
  }


  export type Pod_order_detailsAvgAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    quantity?: true
    wrapper_type?: true
    status?: true
    price?: true
  }

  export type Pod_order_detailsSumAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    quantity?: true
    wrapper_type?: true
    status?: true
    price?: true
  }

  export type Pod_order_detailsMinAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    quantity?: true
    wrapper_type?: true
    personalised_message?: true
    tracking_id?: true
    tracking_url?: true
    status?: true
    price?: true
    order_date?: true
  }

  export type Pod_order_detailsMaxAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    quantity?: true
    wrapper_type?: true
    personalised_message?: true
    tracking_id?: true
    tracking_url?: true
    status?: true
    price?: true
    order_date?: true
  }

  export type Pod_order_detailsCountAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    book_id?: true
    quantity?: true
    wrapper_type?: true
    personalised_message?: true
    tracking_id?: true
    tracking_url?: true
    status?: true
    price?: true
    order_date?: true
    _all?: true
  }

  export type Pod_order_detailsAggregateArgs = {
    /**
     * Filter which pod_order_details to aggregate.
     * 
    **/
    where?: pod_order_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_order_details to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_order_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pod_order_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_order_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_order_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pod_order_details
    **/
    _count?: true | Pod_order_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pod_order_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pod_order_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pod_order_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pod_order_detailsMaxAggregateInputType
  }

  export type GetPod_order_detailsAggregateType<T extends Pod_order_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePod_order_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod_order_details[P]>
      : GetScalarType<T[P], AggregatePod_order_details[P]>
  }




  export type Pod_order_detailsGroupByArgs = {
    where?: pod_order_detailsWhereInput
    orderBy?: Enumerable<pod_order_detailsOrderByWithAggregationInput>
    by: Array<Pod_order_detailsScalarFieldEnum>
    having?: pod_order_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pod_order_detailsCountAggregateInputType | true
    _avg?: Pod_order_detailsAvgAggregateInputType
    _sum?: Pod_order_detailsSumAggregateInputType
    _min?: Pod_order_detailsMinAggregateInputType
    _max?: Pod_order_detailsMaxAggregateInputType
  }


  export type Pod_order_detailsGroupByOutputType = {
    id: number
    order_id: number | null
    user_id: number | null
    book_id: number | null
    quantity: number | null
    wrapper_type: number | null
    personalised_message: string | null
    tracking_id: string | null
    tracking_url: string | null
    status: number | null
    price: number | null
    order_date: Date | null
    _count: Pod_order_detailsCountAggregateOutputType | null
    _avg: Pod_order_detailsAvgAggregateOutputType | null
    _sum: Pod_order_detailsSumAggregateOutputType | null
    _min: Pod_order_detailsMinAggregateOutputType | null
    _max: Pod_order_detailsMaxAggregateOutputType | null
  }

  type GetPod_order_detailsGroupByPayload<T extends Pod_order_detailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pod_order_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pod_order_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pod_order_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Pod_order_detailsGroupByOutputType[P]>
        }
      >
    >


  export type pod_order_detailsSelect = {
    id?: boolean
    order_id?: boolean
    user_id?: boolean
    book_id?: boolean
    quantity?: boolean
    wrapper_type?: boolean
    personalised_message?: boolean
    tracking_id?: boolean
    tracking_url?: boolean
    status?: boolean
    price?: boolean
    order_date?: boolean
  }


  export type pod_order_detailsGetPayload<S extends boolean | null | undefined | pod_order_detailsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pod_order_details :
    S extends undefined ? never :
    S extends { include: any } & (pod_order_detailsArgs | pod_order_detailsFindManyArgs)
    ? pod_order_details 
    : S extends { select: any } & (pod_order_detailsArgs | pod_order_detailsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof pod_order_details ? pod_order_details[P] : never
  } 
      : pod_order_details


  type pod_order_detailsCountArgs = Merge<
    Omit<pod_order_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Pod_order_detailsCountAggregateInputType | true
    }
  >

  export interface pod_order_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pod_order_details that matches the filter.
     * @param {pod_order_detailsFindUniqueArgs} args - Arguments to find a Pod_order_details
     * @example
     * // Get one Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pod_order_detailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pod_order_detailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pod_order_details'> extends True ? Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>> : Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T> | null, null>

    /**
     * Find the first Pod_order_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_order_detailsFindFirstArgs} args - Arguments to find a Pod_order_details
     * @example
     * // Get one Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pod_order_detailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pod_order_detailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pod_order_details'> extends True ? Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>> : Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T> | null, null>

    /**
     * Find zero or more Pod_order_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_order_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findMany()
     * 
     * // Get first 10 Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pod_order_detailsWithIdOnly = await prisma.pod_order_details.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pod_order_detailsFindManyArgs>(
      args?: SelectSubset<T, pod_order_detailsFindManyArgs>
    ): PrismaPromise<Array<pod_order_detailsGetPayload<T>>>

    /**
     * Create a Pod_order_details.
     * @param {pod_order_detailsCreateArgs} args - Arguments to create a Pod_order_details.
     * @example
     * // Create one Pod_order_details
     * const Pod_order_details = await prisma.pod_order_details.create({
     *   data: {
     *     // ... data to create a Pod_order_details
     *   }
     * })
     * 
    **/
    create<T extends pod_order_detailsCreateArgs>(
      args: SelectSubset<T, pod_order_detailsCreateArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Create many Pod_order_details.
     *     @param {pod_order_detailsCreateManyArgs} args - Arguments to create many Pod_order_details.
     *     @example
     *     // Create many Pod_order_details
     *     const pod_order_details = await prisma.pod_order_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pod_order_detailsCreateManyArgs>(
      args?: SelectSubset<T, pod_order_detailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pod_order_details.
     * @param {pod_order_detailsDeleteArgs} args - Arguments to delete one Pod_order_details.
     * @example
     * // Delete one Pod_order_details
     * const Pod_order_details = await prisma.pod_order_details.delete({
     *   where: {
     *     // ... filter to delete one Pod_order_details
     *   }
     * })
     * 
    **/
    delete<T extends pod_order_detailsDeleteArgs>(
      args: SelectSubset<T, pod_order_detailsDeleteArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Update one Pod_order_details.
     * @param {pod_order_detailsUpdateArgs} args - Arguments to update one Pod_order_details.
     * @example
     * // Update one Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pod_order_detailsUpdateArgs>(
      args: SelectSubset<T, pod_order_detailsUpdateArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Delete zero or more Pod_order_details.
     * @param {pod_order_detailsDeleteManyArgs} args - Arguments to filter Pod_order_details to delete.
     * @example
     * // Delete a few Pod_order_details
     * const { count } = await prisma.pod_order_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pod_order_detailsDeleteManyArgs>(
      args?: SelectSubset<T, pod_order_detailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pod_order_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_order_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pod_order_detailsUpdateManyArgs>(
      args: SelectSubset<T, pod_order_detailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pod_order_details.
     * @param {pod_order_detailsUpsertArgs} args - Arguments to update or create a Pod_order_details.
     * @example
     * // Update or create a Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.upsert({
     *   create: {
     *     // ... data to create a Pod_order_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod_order_details we want to update
     *   }
     * })
    **/
    upsert<T extends pod_order_detailsUpsertArgs>(
      args: SelectSubset<T, pod_order_detailsUpsertArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Find one Pod_order_details that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pod_order_detailsFindUniqueOrThrowArgs} args - Arguments to find a Pod_order_details
     * @example
     * // Get one Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pod_order_detailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pod_order_detailsFindUniqueOrThrowArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Find the first Pod_order_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_order_detailsFindFirstOrThrowArgs} args - Arguments to find a Pod_order_details
     * @example
     * // Get one Pod_order_details
     * const pod_order_details = await prisma.pod_order_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pod_order_detailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pod_order_detailsFindFirstOrThrowArgs>
    ): Prisma__pod_order_detailsClient<pod_order_detailsGetPayload<T>>

    /**
     * Count the number of Pod_order_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_order_detailsCountArgs} args - Arguments to filter Pod_order_details to count.
     * @example
     * // Count the number of Pod_order_details
     * const count = await prisma.pod_order_details.count({
     *   where: {
     *     // ... the filter for the Pod_order_details we want to count
     *   }
     * })
    **/
    count<T extends pod_order_detailsCountArgs>(
      args?: Subset<T, pod_order_detailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pod_order_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod_order_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_order_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pod_order_detailsAggregateArgs>(args: Subset<T, Pod_order_detailsAggregateArgs>): PrismaPromise<GetPod_order_detailsAggregateType<T>>

    /**
     * Group by Pod_order_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_order_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pod_order_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pod_order_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Pod_order_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pod_order_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPod_order_detailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pod_order_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pod_order_detailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pod_order_details base type for findUnique actions
   */
  export type pod_order_detailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * Filter, which pod_order_details to fetch.
     * 
    **/
    where: pod_order_detailsWhereUniqueInput
  }

  /**
   * pod_order_details: findUnique
   */
  export interface pod_order_detailsFindUniqueArgs extends pod_order_detailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_order_details base type for findFirst actions
   */
  export type pod_order_detailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * Filter, which pod_order_details to fetch.
     * 
    **/
    where?: pod_order_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_order_details to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_order_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pod_order_details.
     * 
    **/
    cursor?: pod_order_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_order_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_order_details.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pod_order_details.
     * 
    **/
    distinct?: Enumerable<Pod_order_detailsScalarFieldEnum>
  }

  /**
   * pod_order_details: findFirst
   */
  export interface pod_order_detailsFindFirstArgs extends pod_order_detailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_order_details findMany
   */
  export type pod_order_detailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * Filter, which pod_order_details to fetch.
     * 
    **/
    where?: pod_order_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_order_details to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_order_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pod_order_details.
     * 
    **/
    cursor?: pod_order_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_order_details from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_order_details.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pod_order_detailsScalarFieldEnum>
  }


  /**
   * pod_order_details create
   */
  export type pod_order_detailsCreateArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * The data needed to create a pod_order_details.
     * 
    **/
    data: XOR<pod_order_detailsCreateInput, pod_order_detailsUncheckedCreateInput>
  }


  /**
   * pod_order_details createMany
   */
  export type pod_order_detailsCreateManyArgs = {
    /**
     * The data used to create many pod_order_details.
     * 
    **/
    data: Enumerable<pod_order_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pod_order_details update
   */
  export type pod_order_detailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * The data needed to update a pod_order_details.
     * 
    **/
    data: XOR<pod_order_detailsUpdateInput, pod_order_detailsUncheckedUpdateInput>
    /**
     * Choose, which pod_order_details to update.
     * 
    **/
    where: pod_order_detailsWhereUniqueInput
  }


  /**
   * pod_order_details updateMany
   */
  export type pod_order_detailsUpdateManyArgs = {
    /**
     * The data used to update pod_order_details.
     * 
    **/
    data: XOR<pod_order_detailsUpdateManyMutationInput, pod_order_detailsUncheckedUpdateManyInput>
    /**
     * Filter which pod_order_details to update
     * 
    **/
    where?: pod_order_detailsWhereInput
  }


  /**
   * pod_order_details upsert
   */
  export type pod_order_detailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * The filter to search for the pod_order_details to update in case it exists.
     * 
    **/
    where: pod_order_detailsWhereUniqueInput
    /**
     * In case the pod_order_details found by the `where` argument doesn't exist, create a new pod_order_details with this data.
     * 
    **/
    create: XOR<pod_order_detailsCreateInput, pod_order_detailsUncheckedCreateInput>
    /**
     * In case the pod_order_details was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pod_order_detailsUpdateInput, pod_order_detailsUncheckedUpdateInput>
  }


  /**
   * pod_order_details delete
   */
  export type pod_order_detailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
    /**
     * Filter which pod_order_details to delete.
     * 
    **/
    where: pod_order_detailsWhereUniqueInput
  }


  /**
   * pod_order_details deleteMany
   */
  export type pod_order_detailsDeleteManyArgs = {
    /**
     * Filter which pod_order_details to delete
     * 
    **/
    where?: pod_order_detailsWhereInput
  }


  /**
   * pod_order_details: findUniqueOrThrow
   */
  export type pod_order_detailsFindUniqueOrThrowArgs = pod_order_detailsFindUniqueArgsBase
      

  /**
   * pod_order_details: findFirstOrThrow
   */
  export type pod_order_detailsFindFirstOrThrowArgs = pod_order_detailsFindFirstArgsBase
      

  /**
   * pod_order_details without action
   */
  export type pod_order_detailsArgs = {
    /**
     * Select specific fields to fetch from the pod_order_details
     * 
    **/
    select?: pod_order_detailsSelect | null
  }



  /**
   * Model pod_processing
   */


  export type AggregatePod_processing = {
    _count: Pod_processingCountAggregateOutputType | null
    _avg: Pod_processingAvgAggregateOutputType | null
    _sum: Pod_processingSumAggregateOutputType | null
    _min: Pod_processingMinAggregateOutputType | null
    _max: Pod_processingMaxAggregateOutputType | null
  }

  export type Pod_processingAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    word_page_number: number | null
    pod_estimation_pages: number | null
    cover_status: number | null
    completed: number | null
    rework: number | null
  }

  export type Pod_processingSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    word_page_number: number | null
    pod_estimation_pages: number | null
    cover_status: number | null
    completed: number | null
    rework: number | null
  }

  export type Pod_processingMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    content_type: string | null
    word_page_number: number | null
    pod_estimation_pages: number | null
    cover_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
  }

  export type Pod_processingMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    stage_id: number | null
    content_type: string | null
    word_page_number: number | null
    pod_estimation_pages: number | null
    cover_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
  }

  export type Pod_processingCountAggregateOutputType = {
    id: number
    book_id: number
    stage_id: number
    content_type: number
    word_page_number: number
    pod_estimation_pages: number
    cover_status: number
    priority: number
    date_created: number
    completed: number
    rework: number
    _all: number
  }


  export type Pod_processingAvgAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    word_page_number?: true
    pod_estimation_pages?: true
    cover_status?: true
    completed?: true
    rework?: true
  }

  export type Pod_processingSumAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    word_page_number?: true
    pod_estimation_pages?: true
    cover_status?: true
    completed?: true
    rework?: true
  }

  export type Pod_processingMinAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    content_type?: true
    word_page_number?: true
    pod_estimation_pages?: true
    cover_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
  }

  export type Pod_processingMaxAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    content_type?: true
    word_page_number?: true
    pod_estimation_pages?: true
    cover_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
  }

  export type Pod_processingCountAggregateInputType = {
    id?: true
    book_id?: true
    stage_id?: true
    content_type?: true
    word_page_number?: true
    pod_estimation_pages?: true
    cover_status?: true
    priority?: true
    date_created?: true
    completed?: true
    rework?: true
    _all?: true
  }

  export type Pod_processingAggregateArgs = {
    /**
     * Filter which pod_processing to aggregate.
     * 
    **/
    where?: pod_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pod_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_processings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pod_processings
    **/
    _count?: true | Pod_processingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pod_processingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pod_processingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pod_processingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pod_processingMaxAggregateInputType
  }

  export type GetPod_processingAggregateType<T extends Pod_processingAggregateArgs> = {
        [P in keyof T & keyof AggregatePod_processing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod_processing[P]>
      : GetScalarType<T[P], AggregatePod_processing[P]>
  }




  export type Pod_processingGroupByArgs = {
    where?: pod_processingWhereInput
    orderBy?: Enumerable<pod_processingOrderByWithAggregationInput>
    by: Array<Pod_processingScalarFieldEnum>
    having?: pod_processingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pod_processingCountAggregateInputType | true
    _avg?: Pod_processingAvgAggregateInputType
    _sum?: Pod_processingSumAggregateInputType
    _min?: Pod_processingMinAggregateInputType
    _max?: Pod_processingMaxAggregateInputType
  }


  export type Pod_processingGroupByOutputType = {
    id: number
    book_id: number | null
    stage_id: number | null
    content_type: string | null
    word_page_number: number | null
    pod_estimation_pages: number | null
    cover_status: number | null
    priority: string | null
    date_created: Date | null
    completed: number | null
    rework: number | null
    _count: Pod_processingCountAggregateOutputType | null
    _avg: Pod_processingAvgAggregateOutputType | null
    _sum: Pod_processingSumAggregateOutputType | null
    _min: Pod_processingMinAggregateOutputType | null
    _max: Pod_processingMaxAggregateOutputType | null
  }

  type GetPod_processingGroupByPayload<T extends Pod_processingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pod_processingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pod_processingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pod_processingGroupByOutputType[P]>
            : GetScalarType<T[P], Pod_processingGroupByOutputType[P]>
        }
      >
    >


  export type pod_processingSelect = {
    id?: boolean
    book_id?: boolean
    stage_id?: boolean
    content_type?: boolean
    word_page_number?: boolean
    pod_estimation_pages?: boolean
    cover_status?: boolean
    priority?: boolean
    date_created?: boolean
    completed?: boolean
    rework?: boolean
  }


  export type pod_processingGetPayload<S extends boolean | null | undefined | pod_processingArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pod_processing :
    S extends undefined ? never :
    S extends { include: any } & (pod_processingArgs | pod_processingFindManyArgs)
    ? pod_processing 
    : S extends { select: any } & (pod_processingArgs | pod_processingFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof pod_processing ? pod_processing[P] : never
  } 
      : pod_processing


  type pod_processingCountArgs = Merge<
    Omit<pod_processingFindManyArgs, 'select' | 'include'> & {
      select?: Pod_processingCountAggregateInputType | true
    }
  >

  export interface pod_processingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pod_processing that matches the filter.
     * @param {pod_processingFindUniqueArgs} args - Arguments to find a Pod_processing
     * @example
     * // Get one Pod_processing
     * const pod_processing = await prisma.pod_processing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pod_processingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pod_processingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pod_processing'> extends True ? Prisma__pod_processingClient<pod_processingGetPayload<T>> : Prisma__pod_processingClient<pod_processingGetPayload<T> | null, null>

    /**
     * Find the first Pod_processing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_processingFindFirstArgs} args - Arguments to find a Pod_processing
     * @example
     * // Get one Pod_processing
     * const pod_processing = await prisma.pod_processing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pod_processingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pod_processingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pod_processing'> extends True ? Prisma__pod_processingClient<pod_processingGetPayload<T>> : Prisma__pod_processingClient<pod_processingGetPayload<T> | null, null>

    /**
     * Find zero or more Pod_processings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_processingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pod_processings
     * const pod_processings = await prisma.pod_processing.findMany()
     * 
     * // Get first 10 Pod_processings
     * const pod_processings = await prisma.pod_processing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pod_processingWithIdOnly = await prisma.pod_processing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pod_processingFindManyArgs>(
      args?: SelectSubset<T, pod_processingFindManyArgs>
    ): PrismaPromise<Array<pod_processingGetPayload<T>>>

    /**
     * Create a Pod_processing.
     * @param {pod_processingCreateArgs} args - Arguments to create a Pod_processing.
     * @example
     * // Create one Pod_processing
     * const Pod_processing = await prisma.pod_processing.create({
     *   data: {
     *     // ... data to create a Pod_processing
     *   }
     * })
     * 
    **/
    create<T extends pod_processingCreateArgs>(
      args: SelectSubset<T, pod_processingCreateArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Create many Pod_processings.
     *     @param {pod_processingCreateManyArgs} args - Arguments to create many Pod_processings.
     *     @example
     *     // Create many Pod_processings
     *     const pod_processing = await prisma.pod_processing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pod_processingCreateManyArgs>(
      args?: SelectSubset<T, pod_processingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pod_processing.
     * @param {pod_processingDeleteArgs} args - Arguments to delete one Pod_processing.
     * @example
     * // Delete one Pod_processing
     * const Pod_processing = await prisma.pod_processing.delete({
     *   where: {
     *     // ... filter to delete one Pod_processing
     *   }
     * })
     * 
    **/
    delete<T extends pod_processingDeleteArgs>(
      args: SelectSubset<T, pod_processingDeleteArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Update one Pod_processing.
     * @param {pod_processingUpdateArgs} args - Arguments to update one Pod_processing.
     * @example
     * // Update one Pod_processing
     * const pod_processing = await prisma.pod_processing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pod_processingUpdateArgs>(
      args: SelectSubset<T, pod_processingUpdateArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Delete zero or more Pod_processings.
     * @param {pod_processingDeleteManyArgs} args - Arguments to filter Pod_processings to delete.
     * @example
     * // Delete a few Pod_processings
     * const { count } = await prisma.pod_processing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pod_processingDeleteManyArgs>(
      args?: SelectSubset<T, pod_processingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pod_processings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_processingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pod_processings
     * const pod_processing = await prisma.pod_processing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pod_processingUpdateManyArgs>(
      args: SelectSubset<T, pod_processingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pod_processing.
     * @param {pod_processingUpsertArgs} args - Arguments to update or create a Pod_processing.
     * @example
     * // Update or create a Pod_processing
     * const pod_processing = await prisma.pod_processing.upsert({
     *   create: {
     *     // ... data to create a Pod_processing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod_processing we want to update
     *   }
     * })
    **/
    upsert<T extends pod_processingUpsertArgs>(
      args: SelectSubset<T, pod_processingUpsertArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Find one Pod_processing that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pod_processingFindUniqueOrThrowArgs} args - Arguments to find a Pod_processing
     * @example
     * // Get one Pod_processing
     * const pod_processing = await prisma.pod_processing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pod_processingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pod_processingFindUniqueOrThrowArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Find the first Pod_processing that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_processingFindFirstOrThrowArgs} args - Arguments to find a Pod_processing
     * @example
     * // Get one Pod_processing
     * const pod_processing = await prisma.pod_processing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pod_processingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pod_processingFindFirstOrThrowArgs>
    ): Prisma__pod_processingClient<pod_processingGetPayload<T>>

    /**
     * Count the number of Pod_processings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_processingCountArgs} args - Arguments to filter Pod_processings to count.
     * @example
     * // Count the number of Pod_processings
     * const count = await prisma.pod_processing.count({
     *   where: {
     *     // ... the filter for the Pod_processings we want to count
     *   }
     * })
    **/
    count<T extends pod_processingCountArgs>(
      args?: Subset<T, pod_processingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pod_processingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod_processing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_processingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pod_processingAggregateArgs>(args: Subset<T, Pod_processingAggregateArgs>): PrismaPromise<GetPod_processingAggregateType<T>>

    /**
     * Group by Pod_processing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_processingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pod_processingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pod_processingGroupByArgs['orderBy'] }
        : { orderBy?: Pod_processingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pod_processingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPod_processingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pod_processing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pod_processingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pod_processing base type for findUnique actions
   */
  export type pod_processingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * Filter, which pod_processing to fetch.
     * 
    **/
    where: pod_processingWhereUniqueInput
  }

  /**
   * pod_processing: findUnique
   */
  export interface pod_processingFindUniqueArgs extends pod_processingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_processing base type for findFirst actions
   */
  export type pod_processingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * Filter, which pod_processing to fetch.
     * 
    **/
    where?: pod_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pod_processings.
     * 
    **/
    cursor?: pod_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_processings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pod_processings.
     * 
    **/
    distinct?: Enumerable<Pod_processingScalarFieldEnum>
  }

  /**
   * pod_processing: findFirst
   */
  export interface pod_processingFindFirstArgs extends pod_processingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_processing findMany
   */
  export type pod_processingFindManyArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * Filter, which pod_processings to fetch.
     * 
    **/
    where?: pod_processingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_processings to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_processingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pod_processings.
     * 
    **/
    cursor?: pod_processingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_processings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_processings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pod_processingScalarFieldEnum>
  }


  /**
   * pod_processing create
   */
  export type pod_processingCreateArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * The data needed to create a pod_processing.
     * 
    **/
    data: XOR<pod_processingCreateInput, pod_processingUncheckedCreateInput>
  }


  /**
   * pod_processing createMany
   */
  export type pod_processingCreateManyArgs = {
    /**
     * The data used to create many pod_processings.
     * 
    **/
    data: Enumerable<pod_processingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pod_processing update
   */
  export type pod_processingUpdateArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * The data needed to update a pod_processing.
     * 
    **/
    data: XOR<pod_processingUpdateInput, pod_processingUncheckedUpdateInput>
    /**
     * Choose, which pod_processing to update.
     * 
    **/
    where: pod_processingWhereUniqueInput
  }


  /**
   * pod_processing updateMany
   */
  export type pod_processingUpdateManyArgs = {
    /**
     * The data used to update pod_processings.
     * 
    **/
    data: XOR<pod_processingUpdateManyMutationInput, pod_processingUncheckedUpdateManyInput>
    /**
     * Filter which pod_processings to update
     * 
    **/
    where?: pod_processingWhereInput
  }


  /**
   * pod_processing upsert
   */
  export type pod_processingUpsertArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * The filter to search for the pod_processing to update in case it exists.
     * 
    **/
    where: pod_processingWhereUniqueInput
    /**
     * In case the pod_processing found by the `where` argument doesn't exist, create a new pod_processing with this data.
     * 
    **/
    create: XOR<pod_processingCreateInput, pod_processingUncheckedCreateInput>
    /**
     * In case the pod_processing was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pod_processingUpdateInput, pod_processingUncheckedUpdateInput>
  }


  /**
   * pod_processing delete
   */
  export type pod_processingDeleteArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
    /**
     * Filter which pod_processing to delete.
     * 
    **/
    where: pod_processingWhereUniqueInput
  }


  /**
   * pod_processing deleteMany
   */
  export type pod_processingDeleteManyArgs = {
    /**
     * Filter which pod_processings to delete
     * 
    **/
    where?: pod_processingWhereInput
  }


  /**
   * pod_processing: findUniqueOrThrow
   */
  export type pod_processingFindUniqueOrThrowArgs = pod_processingFindUniqueArgsBase
      

  /**
   * pod_processing: findFirstOrThrow
   */
  export type pod_processingFindFirstOrThrowArgs = pod_processingFindFirstArgsBase
      

  /**
   * pod_processing without action
   */
  export type pod_processingArgs = {
    /**
     * Select specific fields to fetch from the pod_processing
     * 
    **/
    select?: pod_processingSelect | null
  }



  /**
   * Model pod_progress
   */


  export type AggregatePod_progress = {
    _count: Pod_progressCountAggregateOutputType | null
    _avg: Pod_progressAvgAggregateOutputType | null
    _sum: Pod_progressSumAggregateOutputType | null
    _min: Pod_progressMinAggregateOutputType | null
    _max: Pod_progressMaxAggregateOutputType | null
  }

  export type Pod_progressAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
  }

  export type Pod_progressSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
  }

  export type Pod_progressMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
    pause_startdate: Date | null
    pause_enddate: Date | null
  }

  export type Pod_progressMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
    pause_startdate: Date | null
    pause_enddate: Date | null
  }

  export type Pod_progressCountAggregateOutputType = {
    id: number
    book_id: number
    status: number
    stage: number
    startdate: number
    enddate: number
    on_hold_startdate: number
    on_hold_enddate: number
    remarks: number
    pause_startdate: number
    pause_enddate: number
    _all: number
  }


  export type Pod_progressAvgAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
  }

  export type Pod_progressSumAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
  }

  export type Pod_progressMinAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
    pause_startdate?: true
    pause_enddate?: true
  }

  export type Pod_progressMaxAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
    pause_startdate?: true
    pause_enddate?: true
  }

  export type Pod_progressCountAggregateInputType = {
    id?: true
    book_id?: true
    status?: true
    stage?: true
    startdate?: true
    enddate?: true
    on_hold_startdate?: true
    on_hold_enddate?: true
    remarks?: true
    pause_startdate?: true
    pause_enddate?: true
    _all?: true
  }

  export type Pod_progressAggregateArgs = {
    /**
     * Filter which pod_progress to aggregate.
     * 
    **/
    where?: pod_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pod_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_progresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pod_progresses
    **/
    _count?: true | Pod_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pod_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pod_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pod_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pod_progressMaxAggregateInputType
  }

  export type GetPod_progressAggregateType<T extends Pod_progressAggregateArgs> = {
        [P in keyof T & keyof AggregatePod_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod_progress[P]>
      : GetScalarType<T[P], AggregatePod_progress[P]>
  }




  export type Pod_progressGroupByArgs = {
    where?: pod_progressWhereInput
    orderBy?: Enumerable<pod_progressOrderByWithAggregationInput>
    by: Array<Pod_progressScalarFieldEnum>
    having?: pod_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pod_progressCountAggregateInputType | true
    _avg?: Pod_progressAvgAggregateInputType
    _sum?: Pod_progressSumAggregateInputType
    _min?: Pod_progressMinAggregateInputType
    _max?: Pod_progressMaxAggregateInputType
  }


  export type Pod_progressGroupByOutputType = {
    id: number
    book_id: number | null
    status: number | null
    stage: number | null
    startdate: Date | null
    enddate: Date | null
    on_hold_startdate: Date | null
    on_hold_enddate: Date | null
    remarks: string | null
    pause_startdate: Date | null
    pause_enddate: Date | null
    _count: Pod_progressCountAggregateOutputType | null
    _avg: Pod_progressAvgAggregateOutputType | null
    _sum: Pod_progressSumAggregateOutputType | null
    _min: Pod_progressMinAggregateOutputType | null
    _max: Pod_progressMaxAggregateOutputType | null
  }

  type GetPod_progressGroupByPayload<T extends Pod_progressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pod_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pod_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pod_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Pod_progressGroupByOutputType[P]>
        }
      >
    >


  export type pod_progressSelect = {
    id?: boolean
    book_id?: boolean
    status?: boolean
    stage?: boolean
    startdate?: boolean
    enddate?: boolean
    on_hold_startdate?: boolean
    on_hold_enddate?: boolean
    remarks?: boolean
    pause_startdate?: boolean
    pause_enddate?: boolean
  }


  export type pod_progressGetPayload<S extends boolean | null | undefined | pod_progressArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pod_progress :
    S extends undefined ? never :
    S extends { include: any } & (pod_progressArgs | pod_progressFindManyArgs)
    ? pod_progress 
    : S extends { select: any } & (pod_progressArgs | pod_progressFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof pod_progress ? pod_progress[P] : never
  } 
      : pod_progress


  type pod_progressCountArgs = Merge<
    Omit<pod_progressFindManyArgs, 'select' | 'include'> & {
      select?: Pod_progressCountAggregateInputType | true
    }
  >

  export interface pod_progressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pod_progress that matches the filter.
     * @param {pod_progressFindUniqueArgs} args - Arguments to find a Pod_progress
     * @example
     * // Get one Pod_progress
     * const pod_progress = await prisma.pod_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pod_progressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pod_progressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pod_progress'> extends True ? Prisma__pod_progressClient<pod_progressGetPayload<T>> : Prisma__pod_progressClient<pod_progressGetPayload<T> | null, null>

    /**
     * Find the first Pod_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_progressFindFirstArgs} args - Arguments to find a Pod_progress
     * @example
     * // Get one Pod_progress
     * const pod_progress = await prisma.pod_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pod_progressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pod_progressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pod_progress'> extends True ? Prisma__pod_progressClient<pod_progressGetPayload<T>> : Prisma__pod_progressClient<pod_progressGetPayload<T> | null, null>

    /**
     * Find zero or more Pod_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_progressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pod_progresses
     * const pod_progresses = await prisma.pod_progress.findMany()
     * 
     * // Get first 10 Pod_progresses
     * const pod_progresses = await prisma.pod_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pod_progressWithIdOnly = await prisma.pod_progress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pod_progressFindManyArgs>(
      args?: SelectSubset<T, pod_progressFindManyArgs>
    ): PrismaPromise<Array<pod_progressGetPayload<T>>>

    /**
     * Create a Pod_progress.
     * @param {pod_progressCreateArgs} args - Arguments to create a Pod_progress.
     * @example
     * // Create one Pod_progress
     * const Pod_progress = await prisma.pod_progress.create({
     *   data: {
     *     // ... data to create a Pod_progress
     *   }
     * })
     * 
    **/
    create<T extends pod_progressCreateArgs>(
      args: SelectSubset<T, pod_progressCreateArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Create many Pod_progresses.
     *     @param {pod_progressCreateManyArgs} args - Arguments to create many Pod_progresses.
     *     @example
     *     // Create many Pod_progresses
     *     const pod_progress = await prisma.pod_progress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pod_progressCreateManyArgs>(
      args?: SelectSubset<T, pod_progressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pod_progress.
     * @param {pod_progressDeleteArgs} args - Arguments to delete one Pod_progress.
     * @example
     * // Delete one Pod_progress
     * const Pod_progress = await prisma.pod_progress.delete({
     *   where: {
     *     // ... filter to delete one Pod_progress
     *   }
     * })
     * 
    **/
    delete<T extends pod_progressDeleteArgs>(
      args: SelectSubset<T, pod_progressDeleteArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Update one Pod_progress.
     * @param {pod_progressUpdateArgs} args - Arguments to update one Pod_progress.
     * @example
     * // Update one Pod_progress
     * const pod_progress = await prisma.pod_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pod_progressUpdateArgs>(
      args: SelectSubset<T, pod_progressUpdateArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Delete zero or more Pod_progresses.
     * @param {pod_progressDeleteManyArgs} args - Arguments to filter Pod_progresses to delete.
     * @example
     * // Delete a few Pod_progresses
     * const { count } = await prisma.pod_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pod_progressDeleteManyArgs>(
      args?: SelectSubset<T, pod_progressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pod_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pod_progresses
     * const pod_progress = await prisma.pod_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pod_progressUpdateManyArgs>(
      args: SelectSubset<T, pod_progressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pod_progress.
     * @param {pod_progressUpsertArgs} args - Arguments to update or create a Pod_progress.
     * @example
     * // Update or create a Pod_progress
     * const pod_progress = await prisma.pod_progress.upsert({
     *   create: {
     *     // ... data to create a Pod_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod_progress we want to update
     *   }
     * })
    **/
    upsert<T extends pod_progressUpsertArgs>(
      args: SelectSubset<T, pod_progressUpsertArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Find one Pod_progress that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pod_progressFindUniqueOrThrowArgs} args - Arguments to find a Pod_progress
     * @example
     * // Get one Pod_progress
     * const pod_progress = await prisma.pod_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pod_progressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pod_progressFindUniqueOrThrowArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Find the first Pod_progress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_progressFindFirstOrThrowArgs} args - Arguments to find a Pod_progress
     * @example
     * // Get one Pod_progress
     * const pod_progress = await prisma.pod_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pod_progressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pod_progressFindFirstOrThrowArgs>
    ): Prisma__pod_progressClient<pod_progressGetPayload<T>>

    /**
     * Count the number of Pod_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pod_progressCountArgs} args - Arguments to filter Pod_progresses to count.
     * @example
     * // Count the number of Pod_progresses
     * const count = await prisma.pod_progress.count({
     *   where: {
     *     // ... the filter for the Pod_progresses we want to count
     *   }
     * })
    **/
    count<T extends pod_progressCountArgs>(
      args?: Subset<T, pod_progressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pod_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pod_progressAggregateArgs>(args: Subset<T, Pod_progressAggregateArgs>): PrismaPromise<GetPod_progressAggregateType<T>>

    /**
     * Group by Pod_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pod_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pod_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pod_progressGroupByArgs['orderBy'] }
        : { orderBy?: Pod_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pod_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPod_progressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pod_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pod_progressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pod_progress base type for findUnique actions
   */
  export type pod_progressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * Filter, which pod_progress to fetch.
     * 
    **/
    where: pod_progressWhereUniqueInput
  }

  /**
   * pod_progress: findUnique
   */
  export interface pod_progressFindUniqueArgs extends pod_progressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_progress base type for findFirst actions
   */
  export type pod_progressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * Filter, which pod_progress to fetch.
     * 
    **/
    where?: pod_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pod_progresses.
     * 
    **/
    cursor?: pod_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_progresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pod_progresses.
     * 
    **/
    distinct?: Enumerable<Pod_progressScalarFieldEnum>
  }

  /**
   * pod_progress: findFirst
   */
  export interface pod_progressFindFirstArgs extends pod_progressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pod_progress findMany
   */
  export type pod_progressFindManyArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * Filter, which pod_progresses to fetch.
     * 
    **/
    where?: pod_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pod_progresses to fetch.
     * 
    **/
    orderBy?: Enumerable<pod_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pod_progresses.
     * 
    **/
    cursor?: pod_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pod_progresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pod_progresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pod_progressScalarFieldEnum>
  }


  /**
   * pod_progress create
   */
  export type pod_progressCreateArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * The data needed to create a pod_progress.
     * 
    **/
    data: XOR<pod_progressCreateInput, pod_progressUncheckedCreateInput>
  }


  /**
   * pod_progress createMany
   */
  export type pod_progressCreateManyArgs = {
    /**
     * The data used to create many pod_progresses.
     * 
    **/
    data: Enumerable<pod_progressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pod_progress update
   */
  export type pod_progressUpdateArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * The data needed to update a pod_progress.
     * 
    **/
    data: XOR<pod_progressUpdateInput, pod_progressUncheckedUpdateInput>
    /**
     * Choose, which pod_progress to update.
     * 
    **/
    where: pod_progressWhereUniqueInput
  }


  /**
   * pod_progress updateMany
   */
  export type pod_progressUpdateManyArgs = {
    /**
     * The data used to update pod_progresses.
     * 
    **/
    data: XOR<pod_progressUpdateManyMutationInput, pod_progressUncheckedUpdateManyInput>
    /**
     * Filter which pod_progresses to update
     * 
    **/
    where?: pod_progressWhereInput
  }


  /**
   * pod_progress upsert
   */
  export type pod_progressUpsertArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * The filter to search for the pod_progress to update in case it exists.
     * 
    **/
    where: pod_progressWhereUniqueInput
    /**
     * In case the pod_progress found by the `where` argument doesn't exist, create a new pod_progress with this data.
     * 
    **/
    create: XOR<pod_progressCreateInput, pod_progressUncheckedCreateInput>
    /**
     * In case the pod_progress was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pod_progressUpdateInput, pod_progressUncheckedUpdateInput>
  }


  /**
   * pod_progress delete
   */
  export type pod_progressDeleteArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
    /**
     * Filter which pod_progress to delete.
     * 
    **/
    where: pod_progressWhereUniqueInput
  }


  /**
   * pod_progress deleteMany
   */
  export type pod_progressDeleteManyArgs = {
    /**
     * Filter which pod_progresses to delete
     * 
    **/
    where?: pod_progressWhereInput
  }


  /**
   * pod_progress: findUniqueOrThrow
   */
  export type pod_progressFindUniqueOrThrowArgs = pod_progressFindUniqueArgsBase
      

  /**
   * pod_progress: findFirstOrThrow
   */
  export type pod_progressFindFirstOrThrowArgs = pod_progressFindFirstArgsBase
      

  /**
   * pod_progress without action
   */
  export type pod_progressArgs = {
    /**
     * Select specific fields to fetch from the pod_progress
     * 
    **/
    select?: pod_progressSelect | null
  }



  /**
   * Model publisher_tbl
   */


  export type AggregatePublisher_tbl = {
    _count: Publisher_tblCountAggregateOutputType | null
    _avg: Publisher_tblAvgAggregateOutputType | null
    _sum: Publisher_tblSumAggregateOutputType | null
    _min: Publisher_tblMinAggregateOutputType | null
    _max: Publisher_tblMaxAggregateOutputType | null
  }

  export type Publisher_tblAvgAggregateOutputType = {
    publisher_id: number | null
    bonus_percentage: number | null
    status: number | null
    tds_flag: number | null
  }

  export type Publisher_tblSumAggregateOutputType = {
    publisher_id: number | null
    bonus_percentage: number | null
    status: number | null
    tds_flag: number | null
  }

  export type Publisher_tblMinAggregateOutputType = {
    publisher_id: number | null
    publisher_name: string | null
    publisher_url_name: string | null
    publisher_regional_name: string | null
    publisher_image: string | null
    publisher_description: string | null
    email_id: string | null
    mobile: string | null
    address: string | null
    bank_acc_no: string | null
    bank_acc_name: string | null
    bank_acc_type: string | null
    ifsc_code: string | null
    pan_number: string | null
    copyright_owner: string | null
    bonus_percentage: number | null
    status: number | null
    created_at: Date | null
    tds_flag: number | null
  }

  export type Publisher_tblMaxAggregateOutputType = {
    publisher_id: number | null
    publisher_name: string | null
    publisher_url_name: string | null
    publisher_regional_name: string | null
    publisher_image: string | null
    publisher_description: string | null
    email_id: string | null
    mobile: string | null
    address: string | null
    bank_acc_no: string | null
    bank_acc_name: string | null
    bank_acc_type: string | null
    ifsc_code: string | null
    pan_number: string | null
    copyright_owner: string | null
    bonus_percentage: number | null
    status: number | null
    created_at: Date | null
    tds_flag: number | null
  }

  export type Publisher_tblCountAggregateOutputType = {
    publisher_id: number
    publisher_name: number
    publisher_url_name: number
    publisher_regional_name: number
    publisher_image: number
    publisher_description: number
    email_id: number
    mobile: number
    address: number
    bank_acc_no: number
    bank_acc_name: number
    bank_acc_type: number
    ifsc_code: number
    pan_number: number
    copyright_owner: number
    bonus_percentage: number
    status: number
    created_at: number
    tds_flag: number
    _all: number
  }


  export type Publisher_tblAvgAggregateInputType = {
    publisher_id?: true
    bonus_percentage?: true
    status?: true
    tds_flag?: true
  }

  export type Publisher_tblSumAggregateInputType = {
    publisher_id?: true
    bonus_percentage?: true
    status?: true
    tds_flag?: true
  }

  export type Publisher_tblMinAggregateInputType = {
    publisher_id?: true
    publisher_name?: true
    publisher_url_name?: true
    publisher_regional_name?: true
    publisher_image?: true
    publisher_description?: true
    email_id?: true
    mobile?: true
    address?: true
    bank_acc_no?: true
    bank_acc_name?: true
    bank_acc_type?: true
    ifsc_code?: true
    pan_number?: true
    copyright_owner?: true
    bonus_percentage?: true
    status?: true
    created_at?: true
    tds_flag?: true
  }

  export type Publisher_tblMaxAggregateInputType = {
    publisher_id?: true
    publisher_name?: true
    publisher_url_name?: true
    publisher_regional_name?: true
    publisher_image?: true
    publisher_description?: true
    email_id?: true
    mobile?: true
    address?: true
    bank_acc_no?: true
    bank_acc_name?: true
    bank_acc_type?: true
    ifsc_code?: true
    pan_number?: true
    copyright_owner?: true
    bonus_percentage?: true
    status?: true
    created_at?: true
    tds_flag?: true
  }

  export type Publisher_tblCountAggregateInputType = {
    publisher_id?: true
    publisher_name?: true
    publisher_url_name?: true
    publisher_regional_name?: true
    publisher_image?: true
    publisher_description?: true
    email_id?: true
    mobile?: true
    address?: true
    bank_acc_no?: true
    bank_acc_name?: true
    bank_acc_type?: true
    ifsc_code?: true
    pan_number?: true
    copyright_owner?: true
    bonus_percentage?: true
    status?: true
    created_at?: true
    tds_flag?: true
    _all?: true
  }

  export type Publisher_tblAggregateArgs = {
    /**
     * Filter which publisher_tbl to aggregate.
     * 
    **/
    where?: publisher_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<publisher_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: publisher_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publisher_tbls
    **/
    _count?: true | Publisher_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Publisher_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Publisher_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publisher_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publisher_tblMaxAggregateInputType
  }

  export type GetPublisher_tblAggregateType<T extends Publisher_tblAggregateArgs> = {
        [P in keyof T & keyof AggregatePublisher_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublisher_tbl[P]>
      : GetScalarType<T[P], AggregatePublisher_tbl[P]>
  }




  export type Publisher_tblGroupByArgs = {
    where?: publisher_tblWhereInput
    orderBy?: Enumerable<publisher_tblOrderByWithAggregationInput>
    by: Array<Publisher_tblScalarFieldEnum>
    having?: publisher_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publisher_tblCountAggregateInputType | true
    _avg?: Publisher_tblAvgAggregateInputType
    _sum?: Publisher_tblSumAggregateInputType
    _min?: Publisher_tblMinAggregateInputType
    _max?: Publisher_tblMaxAggregateInputType
  }


  export type Publisher_tblGroupByOutputType = {
    publisher_id: number
    publisher_name: string | null
    publisher_url_name: string | null
    publisher_regional_name: string | null
    publisher_image: string | null
    publisher_description: string | null
    email_id: string | null
    mobile: string | null
    address: string | null
    bank_acc_no: string | null
    bank_acc_name: string | null
    bank_acc_type: string | null
    ifsc_code: string | null
    pan_number: string | null
    copyright_owner: string | null
    bonus_percentage: number | null
    status: number | null
    created_at: Date | null
    tds_flag: number | null
    _count: Publisher_tblCountAggregateOutputType | null
    _avg: Publisher_tblAvgAggregateOutputType | null
    _sum: Publisher_tblSumAggregateOutputType | null
    _min: Publisher_tblMinAggregateOutputType | null
    _max: Publisher_tblMaxAggregateOutputType | null
  }

  type GetPublisher_tblGroupByPayload<T extends Publisher_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Publisher_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publisher_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publisher_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Publisher_tblGroupByOutputType[P]>
        }
      >
    >


  export type publisher_tblSelect = {
    publisher_id?: boolean
    publisher_name?: boolean
    publisher_url_name?: boolean
    publisher_regional_name?: boolean
    publisher_image?: boolean
    publisher_description?: boolean
    email_id?: boolean
    mobile?: boolean
    address?: boolean
    bank_acc_no?: boolean
    bank_acc_name?: boolean
    bank_acc_type?: boolean
    ifsc_code?: boolean
    pan_number?: boolean
    copyright_owner?: boolean
    bonus_percentage?: boolean
    status?: boolean
    created_at?: boolean
    tds_flag?: boolean
  }


  export type publisher_tblGetPayload<S extends boolean | null | undefined | publisher_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? publisher_tbl :
    S extends undefined ? never :
    S extends { include: any } & (publisher_tblArgs | publisher_tblFindManyArgs)
    ? publisher_tbl 
    : S extends { select: any } & (publisher_tblArgs | publisher_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof publisher_tbl ? publisher_tbl[P] : never
  } 
      : publisher_tbl


  type publisher_tblCountArgs = Merge<
    Omit<publisher_tblFindManyArgs, 'select' | 'include'> & {
      select?: Publisher_tblCountAggregateInputType | true
    }
  >

  export interface publisher_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Publisher_tbl that matches the filter.
     * @param {publisher_tblFindUniqueArgs} args - Arguments to find a Publisher_tbl
     * @example
     * // Get one Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends publisher_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, publisher_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'publisher_tbl'> extends True ? Prisma__publisher_tblClient<publisher_tblGetPayload<T>> : Prisma__publisher_tblClient<publisher_tblGetPayload<T> | null, null>

    /**
     * Find the first Publisher_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_tblFindFirstArgs} args - Arguments to find a Publisher_tbl
     * @example
     * // Get one Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends publisher_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, publisher_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'publisher_tbl'> extends True ? Prisma__publisher_tblClient<publisher_tblGetPayload<T>> : Prisma__publisher_tblClient<publisher_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Publisher_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publisher_tbls
     * const publisher_tbls = await prisma.publisher_tbl.findMany()
     * 
     * // Get first 10 Publisher_tbls
     * const publisher_tbls = await prisma.publisher_tbl.findMany({ take: 10 })
     * 
     * // Only select the `publisher_id`
     * const publisher_tblWithPublisher_idOnly = await prisma.publisher_tbl.findMany({ select: { publisher_id: true } })
     * 
    **/
    findMany<T extends publisher_tblFindManyArgs>(
      args?: SelectSubset<T, publisher_tblFindManyArgs>
    ): PrismaPromise<Array<publisher_tblGetPayload<T>>>

    /**
     * Create a Publisher_tbl.
     * @param {publisher_tblCreateArgs} args - Arguments to create a Publisher_tbl.
     * @example
     * // Create one Publisher_tbl
     * const Publisher_tbl = await prisma.publisher_tbl.create({
     *   data: {
     *     // ... data to create a Publisher_tbl
     *   }
     * })
     * 
    **/
    create<T extends publisher_tblCreateArgs>(
      args: SelectSubset<T, publisher_tblCreateArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Create many Publisher_tbls.
     *     @param {publisher_tblCreateManyArgs} args - Arguments to create many Publisher_tbls.
     *     @example
     *     // Create many Publisher_tbls
     *     const publisher_tbl = await prisma.publisher_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends publisher_tblCreateManyArgs>(
      args?: SelectSubset<T, publisher_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Publisher_tbl.
     * @param {publisher_tblDeleteArgs} args - Arguments to delete one Publisher_tbl.
     * @example
     * // Delete one Publisher_tbl
     * const Publisher_tbl = await prisma.publisher_tbl.delete({
     *   where: {
     *     // ... filter to delete one Publisher_tbl
     *   }
     * })
     * 
    **/
    delete<T extends publisher_tblDeleteArgs>(
      args: SelectSubset<T, publisher_tblDeleteArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Update one Publisher_tbl.
     * @param {publisher_tblUpdateArgs} args - Arguments to update one Publisher_tbl.
     * @example
     * // Update one Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends publisher_tblUpdateArgs>(
      args: SelectSubset<T, publisher_tblUpdateArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Delete zero or more Publisher_tbls.
     * @param {publisher_tblDeleteManyArgs} args - Arguments to filter Publisher_tbls to delete.
     * @example
     * // Delete a few Publisher_tbls
     * const { count } = await prisma.publisher_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends publisher_tblDeleteManyArgs>(
      args?: SelectSubset<T, publisher_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publisher_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publisher_tbls
     * const publisher_tbl = await prisma.publisher_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends publisher_tblUpdateManyArgs>(
      args: SelectSubset<T, publisher_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Publisher_tbl.
     * @param {publisher_tblUpsertArgs} args - Arguments to update or create a Publisher_tbl.
     * @example
     * // Update or create a Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.upsert({
     *   create: {
     *     // ... data to create a Publisher_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publisher_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends publisher_tblUpsertArgs>(
      args: SelectSubset<T, publisher_tblUpsertArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Find one Publisher_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {publisher_tblFindUniqueOrThrowArgs} args - Arguments to find a Publisher_tbl
     * @example
     * // Get one Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends publisher_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, publisher_tblFindUniqueOrThrowArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Find the first Publisher_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_tblFindFirstOrThrowArgs} args - Arguments to find a Publisher_tbl
     * @example
     * // Get one Publisher_tbl
     * const publisher_tbl = await prisma.publisher_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends publisher_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, publisher_tblFindFirstOrThrowArgs>
    ): Prisma__publisher_tblClient<publisher_tblGetPayload<T>>

    /**
     * Count the number of Publisher_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_tblCountArgs} args - Arguments to filter Publisher_tbls to count.
     * @example
     * // Count the number of Publisher_tbls
     * const count = await prisma.publisher_tbl.count({
     *   where: {
     *     // ... the filter for the Publisher_tbls we want to count
     *   }
     * })
    **/
    count<T extends publisher_tblCountArgs>(
      args?: Subset<T, publisher_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publisher_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publisher_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publisher_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publisher_tblAggregateArgs>(args: Subset<T, Publisher_tblAggregateArgs>): PrismaPromise<GetPublisher_tblAggregateType<T>>

    /**
     * Group by Publisher_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publisher_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Publisher_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Publisher_tblGroupByArgs['orderBy'] }
        : { orderBy?: Publisher_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Publisher_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublisher_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for publisher_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__publisher_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * publisher_tbl base type for findUnique actions
   */
  export type publisher_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * Filter, which publisher_tbl to fetch.
     * 
    **/
    where: publisher_tblWhereUniqueInput
  }

  /**
   * publisher_tbl: findUnique
   */
  export interface publisher_tblFindUniqueArgs extends publisher_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publisher_tbl base type for findFirst actions
   */
  export type publisher_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * Filter, which publisher_tbl to fetch.
     * 
    **/
    where?: publisher_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<publisher_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publisher_tbls.
     * 
    **/
    cursor?: publisher_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publisher_tbls.
     * 
    **/
    distinct?: Enumerable<Publisher_tblScalarFieldEnum>
  }

  /**
   * publisher_tbl: findFirst
   */
  export interface publisher_tblFindFirstArgs extends publisher_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publisher_tbl findMany
   */
  export type publisher_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * Filter, which publisher_tbls to fetch.
     * 
    **/
    where?: publisher_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<publisher_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publisher_tbls.
     * 
    **/
    cursor?: publisher_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Publisher_tblScalarFieldEnum>
  }


  /**
   * publisher_tbl create
   */
  export type publisher_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * The data needed to create a publisher_tbl.
     * 
    **/
    data: XOR<publisher_tblCreateInput, publisher_tblUncheckedCreateInput>
  }


  /**
   * publisher_tbl createMany
   */
  export type publisher_tblCreateManyArgs = {
    /**
     * The data used to create many publisher_tbls.
     * 
    **/
    data: Enumerable<publisher_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * publisher_tbl update
   */
  export type publisher_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * The data needed to update a publisher_tbl.
     * 
    **/
    data: XOR<publisher_tblUpdateInput, publisher_tblUncheckedUpdateInput>
    /**
     * Choose, which publisher_tbl to update.
     * 
    **/
    where: publisher_tblWhereUniqueInput
  }


  /**
   * publisher_tbl updateMany
   */
  export type publisher_tblUpdateManyArgs = {
    /**
     * The data used to update publisher_tbls.
     * 
    **/
    data: XOR<publisher_tblUpdateManyMutationInput, publisher_tblUncheckedUpdateManyInput>
    /**
     * Filter which publisher_tbls to update
     * 
    **/
    where?: publisher_tblWhereInput
  }


  /**
   * publisher_tbl upsert
   */
  export type publisher_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * The filter to search for the publisher_tbl to update in case it exists.
     * 
    **/
    where: publisher_tblWhereUniqueInput
    /**
     * In case the publisher_tbl found by the `where` argument doesn't exist, create a new publisher_tbl with this data.
     * 
    **/
    create: XOR<publisher_tblCreateInput, publisher_tblUncheckedCreateInput>
    /**
     * In case the publisher_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<publisher_tblUpdateInput, publisher_tblUncheckedUpdateInput>
  }


  /**
   * publisher_tbl delete
   */
  export type publisher_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
    /**
     * Filter which publisher_tbl to delete.
     * 
    **/
    where: publisher_tblWhereUniqueInput
  }


  /**
   * publisher_tbl deleteMany
   */
  export type publisher_tblDeleteManyArgs = {
    /**
     * Filter which publisher_tbls to delete
     * 
    **/
    where?: publisher_tblWhereInput
  }


  /**
   * publisher_tbl: findUniqueOrThrow
   */
  export type publisher_tblFindUniqueOrThrowArgs = publisher_tblFindUniqueArgsBase
      

  /**
   * publisher_tbl: findFirstOrThrow
   */
  export type publisher_tblFindFirstOrThrowArgs = publisher_tblFindFirstArgsBase
      

  /**
   * publisher_tbl without action
   */
  export type publisher_tblArgs = {
    /**
     * Select specific fields to fetch from the publisher_tbl
     * 
    **/
    select?: publisher_tblSelect | null
  }



  /**
   * Model rating_review
   */


  export type AggregateRating_review = {
    _count: Rating_reviewCountAggregateOutputType | null
    _avg: Rating_reviewAvgAggregateOutputType | null
    _sum: Rating_reviewSumAggregateOutputType | null
    _min: Rating_reviewMinAggregateOutputType | null
    _max: Rating_reviewMaxAggregateOutputType | null
  }

  export type Rating_reviewAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    rating: number | null
    status: number | null
  }

  export type Rating_reviewSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_id: number | null
    rating: number | null
    status: number | null
  }

  export type Rating_reviewMinAggregateOutputType = {
    id: number | null
    name: string | null
    user_id: number | null
    book_id: number | null
    comment: string | null
    rating: number | null
    status: number | null
    date_created: Date | null
  }

  export type Rating_reviewMaxAggregateOutputType = {
    id: number | null
    name: string | null
    user_id: number | null
    book_id: number | null
    comment: string | null
    rating: number | null
    status: number | null
    date_created: Date | null
  }

  export type Rating_reviewCountAggregateOutputType = {
    id: number
    name: number
    user_id: number
    book_id: number
    comment: number
    rating: number
    status: number
    date_created: number
    _all: number
  }


  export type Rating_reviewAvgAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    rating?: true
    status?: true
  }

  export type Rating_reviewSumAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    rating?: true
    status?: true
  }

  export type Rating_reviewMinAggregateInputType = {
    id?: true
    name?: true
    user_id?: true
    book_id?: true
    comment?: true
    rating?: true
    status?: true
    date_created?: true
  }

  export type Rating_reviewMaxAggregateInputType = {
    id?: true
    name?: true
    user_id?: true
    book_id?: true
    comment?: true
    rating?: true
    status?: true
    date_created?: true
  }

  export type Rating_reviewCountAggregateInputType = {
    id?: true
    name?: true
    user_id?: true
    book_id?: true
    comment?: true
    rating?: true
    status?: true
    date_created?: true
    _all?: true
  }

  export type Rating_reviewAggregateArgs = {
    /**
     * Filter which rating_review to aggregate.
     * 
    **/
    where?: rating_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<rating_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: rating_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rating_reviews
    **/
    _count?: true | Rating_reviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rating_reviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rating_reviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rating_reviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rating_reviewMaxAggregateInputType
  }

  export type GetRating_reviewAggregateType<T extends Rating_reviewAggregateArgs> = {
        [P in keyof T & keyof AggregateRating_review]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating_review[P]>
      : GetScalarType<T[P], AggregateRating_review[P]>
  }




  export type Rating_reviewGroupByArgs = {
    where?: rating_reviewWhereInput
    orderBy?: Enumerable<rating_reviewOrderByWithAggregationInput>
    by: Array<Rating_reviewScalarFieldEnum>
    having?: rating_reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rating_reviewCountAggregateInputType | true
    _avg?: Rating_reviewAvgAggregateInputType
    _sum?: Rating_reviewSumAggregateInputType
    _min?: Rating_reviewMinAggregateInputType
    _max?: Rating_reviewMaxAggregateInputType
  }


  export type Rating_reviewGroupByOutputType = {
    id: number
    name: string
    user_id: number
    book_id: number
    comment: string
    rating: number
    status: number
    date_created: Date
    _count: Rating_reviewCountAggregateOutputType | null
    _avg: Rating_reviewAvgAggregateOutputType | null
    _sum: Rating_reviewSumAggregateOutputType | null
    _min: Rating_reviewMinAggregateOutputType | null
    _max: Rating_reviewMaxAggregateOutputType | null
  }

  type GetRating_reviewGroupByPayload<T extends Rating_reviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Rating_reviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rating_reviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rating_reviewGroupByOutputType[P]>
            : GetScalarType<T[P], Rating_reviewGroupByOutputType[P]>
        }
      >
    >


  export type rating_reviewSelect = {
    id?: boolean
    name?: boolean
    user_id?: boolean
    book_id?: boolean
    comment?: boolean
    rating?: boolean
    status?: boolean
    date_created?: boolean
  }


  export type rating_reviewGetPayload<S extends boolean | null | undefined | rating_reviewArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? rating_review :
    S extends undefined ? never :
    S extends { include: any } & (rating_reviewArgs | rating_reviewFindManyArgs)
    ? rating_review 
    : S extends { select: any } & (rating_reviewArgs | rating_reviewFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof rating_review ? rating_review[P] : never
  } 
      : rating_review


  type rating_reviewCountArgs = Merge<
    Omit<rating_reviewFindManyArgs, 'select' | 'include'> & {
      select?: Rating_reviewCountAggregateInputType | true
    }
  >

  export interface rating_reviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Rating_review that matches the filter.
     * @param {rating_reviewFindUniqueArgs} args - Arguments to find a Rating_review
     * @example
     * // Get one Rating_review
     * const rating_review = await prisma.rating_review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rating_reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rating_reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rating_review'> extends True ? Prisma__rating_reviewClient<rating_reviewGetPayload<T>> : Prisma__rating_reviewClient<rating_reviewGetPayload<T> | null, null>

    /**
     * Find the first Rating_review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_reviewFindFirstArgs} args - Arguments to find a Rating_review
     * @example
     * // Get one Rating_review
     * const rating_review = await prisma.rating_review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rating_reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rating_reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rating_review'> extends True ? Prisma__rating_reviewClient<rating_reviewGetPayload<T>> : Prisma__rating_reviewClient<rating_reviewGetPayload<T> | null, null>

    /**
     * Find zero or more Rating_reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rating_reviews
     * const rating_reviews = await prisma.rating_review.findMany()
     * 
     * // Get first 10 Rating_reviews
     * const rating_reviews = await prisma.rating_review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rating_reviewWithIdOnly = await prisma.rating_review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rating_reviewFindManyArgs>(
      args?: SelectSubset<T, rating_reviewFindManyArgs>
    ): PrismaPromise<Array<rating_reviewGetPayload<T>>>

    /**
     * Create a Rating_review.
     * @param {rating_reviewCreateArgs} args - Arguments to create a Rating_review.
     * @example
     * // Create one Rating_review
     * const Rating_review = await prisma.rating_review.create({
     *   data: {
     *     // ... data to create a Rating_review
     *   }
     * })
     * 
    **/
    create<T extends rating_reviewCreateArgs>(
      args: SelectSubset<T, rating_reviewCreateArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Create many Rating_reviews.
     *     @param {rating_reviewCreateManyArgs} args - Arguments to create many Rating_reviews.
     *     @example
     *     // Create many Rating_reviews
     *     const rating_review = await prisma.rating_review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rating_reviewCreateManyArgs>(
      args?: SelectSubset<T, rating_reviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Rating_review.
     * @param {rating_reviewDeleteArgs} args - Arguments to delete one Rating_review.
     * @example
     * // Delete one Rating_review
     * const Rating_review = await prisma.rating_review.delete({
     *   where: {
     *     // ... filter to delete one Rating_review
     *   }
     * })
     * 
    **/
    delete<T extends rating_reviewDeleteArgs>(
      args: SelectSubset<T, rating_reviewDeleteArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Update one Rating_review.
     * @param {rating_reviewUpdateArgs} args - Arguments to update one Rating_review.
     * @example
     * // Update one Rating_review
     * const rating_review = await prisma.rating_review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rating_reviewUpdateArgs>(
      args: SelectSubset<T, rating_reviewUpdateArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Delete zero or more Rating_reviews.
     * @param {rating_reviewDeleteManyArgs} args - Arguments to filter Rating_reviews to delete.
     * @example
     * // Delete a few Rating_reviews
     * const { count } = await prisma.rating_review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rating_reviewDeleteManyArgs>(
      args?: SelectSubset<T, rating_reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rating_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rating_reviews
     * const rating_review = await prisma.rating_review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rating_reviewUpdateManyArgs>(
      args: SelectSubset<T, rating_reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating_review.
     * @param {rating_reviewUpsertArgs} args - Arguments to update or create a Rating_review.
     * @example
     * // Update or create a Rating_review
     * const rating_review = await prisma.rating_review.upsert({
     *   create: {
     *     // ... data to create a Rating_review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating_review we want to update
     *   }
     * })
    **/
    upsert<T extends rating_reviewUpsertArgs>(
      args: SelectSubset<T, rating_reviewUpsertArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Find one Rating_review that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {rating_reviewFindUniqueOrThrowArgs} args - Arguments to find a Rating_review
     * @example
     * // Get one Rating_review
     * const rating_review = await prisma.rating_review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rating_reviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, rating_reviewFindUniqueOrThrowArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Find the first Rating_review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_reviewFindFirstOrThrowArgs} args - Arguments to find a Rating_review
     * @example
     * // Get one Rating_review
     * const rating_review = await prisma.rating_review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rating_reviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, rating_reviewFindFirstOrThrowArgs>
    ): Prisma__rating_reviewClient<rating_reviewGetPayload<T>>

    /**
     * Count the number of Rating_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_reviewCountArgs} args - Arguments to filter Rating_reviews to count.
     * @example
     * // Count the number of Rating_reviews
     * const count = await prisma.rating_review.count({
     *   where: {
     *     // ... the filter for the Rating_reviews we want to count
     *   }
     * })
    **/
    count<T extends rating_reviewCountArgs>(
      args?: Subset<T, rating_reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rating_reviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rating_reviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rating_reviewAggregateArgs>(args: Subset<T, Rating_reviewAggregateArgs>): PrismaPromise<GetRating_reviewAggregateType<T>>

    /**
     * Group by Rating_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rating_reviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Rating_reviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Rating_reviewGroupByArgs['orderBy'] }
        : { orderBy?: Rating_reviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Rating_reviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRating_reviewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for rating_review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rating_reviewClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * rating_review base type for findUnique actions
   */
  export type rating_reviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * Filter, which rating_review to fetch.
     * 
    **/
    where: rating_reviewWhereUniqueInput
  }

  /**
   * rating_review: findUnique
   */
  export interface rating_reviewFindUniqueArgs extends rating_reviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rating_review base type for findFirst actions
   */
  export type rating_reviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * Filter, which rating_review to fetch.
     * 
    **/
    where?: rating_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<rating_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_reviews.
     * 
    **/
    cursor?: rating_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_reviews.
     * 
    **/
    distinct?: Enumerable<Rating_reviewScalarFieldEnum>
  }

  /**
   * rating_review: findFirst
   */
  export interface rating_reviewFindFirstArgs extends rating_reviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rating_review findMany
   */
  export type rating_reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * Filter, which rating_reviews to fetch.
     * 
    **/
    where?: rating_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<rating_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rating_reviews.
     * 
    **/
    cursor?: rating_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Rating_reviewScalarFieldEnum>
  }


  /**
   * rating_review create
   */
  export type rating_reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * The data needed to create a rating_review.
     * 
    **/
    data: XOR<rating_reviewCreateInput, rating_reviewUncheckedCreateInput>
  }


  /**
   * rating_review createMany
   */
  export type rating_reviewCreateManyArgs = {
    /**
     * The data used to create many rating_reviews.
     * 
    **/
    data: Enumerable<rating_reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * rating_review update
   */
  export type rating_reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * The data needed to update a rating_review.
     * 
    **/
    data: XOR<rating_reviewUpdateInput, rating_reviewUncheckedUpdateInput>
    /**
     * Choose, which rating_review to update.
     * 
    **/
    where: rating_reviewWhereUniqueInput
  }


  /**
   * rating_review updateMany
   */
  export type rating_reviewUpdateManyArgs = {
    /**
     * The data used to update rating_reviews.
     * 
    **/
    data: XOR<rating_reviewUpdateManyMutationInput, rating_reviewUncheckedUpdateManyInput>
    /**
     * Filter which rating_reviews to update
     * 
    **/
    where?: rating_reviewWhereInput
  }


  /**
   * rating_review upsert
   */
  export type rating_reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * The filter to search for the rating_review to update in case it exists.
     * 
    **/
    where: rating_reviewWhereUniqueInput
    /**
     * In case the rating_review found by the `where` argument doesn't exist, create a new rating_review with this data.
     * 
    **/
    create: XOR<rating_reviewCreateInput, rating_reviewUncheckedCreateInput>
    /**
     * In case the rating_review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<rating_reviewUpdateInput, rating_reviewUncheckedUpdateInput>
  }


  /**
   * rating_review delete
   */
  export type rating_reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
    /**
     * Filter which rating_review to delete.
     * 
    **/
    where: rating_reviewWhereUniqueInput
  }


  /**
   * rating_review deleteMany
   */
  export type rating_reviewDeleteManyArgs = {
    /**
     * Filter which rating_reviews to delete
     * 
    **/
    where?: rating_reviewWhereInput
  }


  /**
   * rating_review: findUniqueOrThrow
   */
  export type rating_reviewFindUniqueOrThrowArgs = rating_reviewFindUniqueArgsBase
      

  /**
   * rating_review: findFirstOrThrow
   */
  export type rating_reviewFindFirstOrThrowArgs = rating_reviewFindFirstArgsBase
      

  /**
   * rating_review without action
   */
  export type rating_reviewArgs = {
    /**
     * Select specific fields to fetch from the rating_review
     * 
    **/
    select?: rating_reviewSelect | null
  }



  /**
   * Model razorpay_requests
   */


  export type AggregateRazorpay_requests = {
    _count: Razorpay_requestsCountAggregateOutputType | null
    _avg: Razorpay_requestsAvgAggregateOutputType | null
    _sum: Razorpay_requestsSumAggregateOutputType | null
    _min: Razorpay_requestsMinAggregateOutputType | null
    _max: Razorpay_requestsMaxAggregateOutputType | null
  }

  export type Razorpay_requestsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
  }

  export type Razorpay_requestsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
  }

  export type Razorpay_requestsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    razorpay_payload: string | null
    created: Date | null
  }

  export type Razorpay_requestsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    razorpay_payload: string | null
    created: Date | null
  }

  export type Razorpay_requestsCountAggregateOutputType = {
    id: number
    user_id: number
    plan_id: number
    razorpay_payload: number
    created: number
    _all: number
  }


  export type Razorpay_requestsAvgAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type Razorpay_requestsSumAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type Razorpay_requestsMinAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_payload?: true
    created?: true
  }

  export type Razorpay_requestsMaxAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_payload?: true
    created?: true
  }

  export type Razorpay_requestsCountAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_payload?: true
    created?: true
    _all?: true
  }

  export type Razorpay_requestsAggregateArgs = {
    /**
     * Filter which razorpay_requests to aggregate.
     * 
    **/
    where?: razorpay_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of razorpay_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<razorpay_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: razorpay_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` razorpay_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` razorpay_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned razorpay_requests
    **/
    _count?: true | Razorpay_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Razorpay_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Razorpay_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Razorpay_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Razorpay_requestsMaxAggregateInputType
  }

  export type GetRazorpay_requestsAggregateType<T extends Razorpay_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateRazorpay_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRazorpay_requests[P]>
      : GetScalarType<T[P], AggregateRazorpay_requests[P]>
  }




  export type Razorpay_requestsGroupByArgs = {
    where?: razorpay_requestsWhereInput
    orderBy?: Enumerable<razorpay_requestsOrderByWithAggregationInput>
    by: Array<Razorpay_requestsScalarFieldEnum>
    having?: razorpay_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Razorpay_requestsCountAggregateInputType | true
    _avg?: Razorpay_requestsAvgAggregateInputType
    _sum?: Razorpay_requestsSumAggregateInputType
    _min?: Razorpay_requestsMinAggregateInputType
    _max?: Razorpay_requestsMaxAggregateInputType
  }


  export type Razorpay_requestsGroupByOutputType = {
    id: number
    user_id: number | null
    plan_id: number | null
    razorpay_payload: string | null
    created: Date | null
    _count: Razorpay_requestsCountAggregateOutputType | null
    _avg: Razorpay_requestsAvgAggregateOutputType | null
    _sum: Razorpay_requestsSumAggregateOutputType | null
    _min: Razorpay_requestsMinAggregateOutputType | null
    _max: Razorpay_requestsMaxAggregateOutputType | null
  }

  type GetRazorpay_requestsGroupByPayload<T extends Razorpay_requestsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Razorpay_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Razorpay_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Razorpay_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Razorpay_requestsGroupByOutputType[P]>
        }
      >
    >


  export type razorpay_requestsSelect = {
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    razorpay_payload?: boolean
    created?: boolean
  }


  export type razorpay_requestsGetPayload<S extends boolean | null | undefined | razorpay_requestsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? razorpay_requests :
    S extends undefined ? never :
    S extends { include: any } & (razorpay_requestsArgs | razorpay_requestsFindManyArgs)
    ? razorpay_requests 
    : S extends { select: any } & (razorpay_requestsArgs | razorpay_requestsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof razorpay_requests ? razorpay_requests[P] : never
  } 
      : razorpay_requests


  type razorpay_requestsCountArgs = Merge<
    Omit<razorpay_requestsFindManyArgs, 'select' | 'include'> & {
      select?: Razorpay_requestsCountAggregateInputType | true
    }
  >

  export interface razorpay_requestsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Razorpay_requests that matches the filter.
     * @param {razorpay_requestsFindUniqueArgs} args - Arguments to find a Razorpay_requests
     * @example
     * // Get one Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends razorpay_requestsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, razorpay_requestsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'razorpay_requests'> extends True ? Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>> : Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T> | null, null>

    /**
     * Find the first Razorpay_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {razorpay_requestsFindFirstArgs} args - Arguments to find a Razorpay_requests
     * @example
     * // Get one Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends razorpay_requestsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, razorpay_requestsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'razorpay_requests'> extends True ? Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>> : Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T> | null, null>

    /**
     * Find zero or more Razorpay_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {razorpay_requestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findMany()
     * 
     * // Get first 10 Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const razorpay_requestsWithIdOnly = await prisma.razorpay_requests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends razorpay_requestsFindManyArgs>(
      args?: SelectSubset<T, razorpay_requestsFindManyArgs>
    ): PrismaPromise<Array<razorpay_requestsGetPayload<T>>>

    /**
     * Create a Razorpay_requests.
     * @param {razorpay_requestsCreateArgs} args - Arguments to create a Razorpay_requests.
     * @example
     * // Create one Razorpay_requests
     * const Razorpay_requests = await prisma.razorpay_requests.create({
     *   data: {
     *     // ... data to create a Razorpay_requests
     *   }
     * })
     * 
    **/
    create<T extends razorpay_requestsCreateArgs>(
      args: SelectSubset<T, razorpay_requestsCreateArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Create many Razorpay_requests.
     *     @param {razorpay_requestsCreateManyArgs} args - Arguments to create many Razorpay_requests.
     *     @example
     *     // Create many Razorpay_requests
     *     const razorpay_requests = await prisma.razorpay_requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends razorpay_requestsCreateManyArgs>(
      args?: SelectSubset<T, razorpay_requestsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Razorpay_requests.
     * @param {razorpay_requestsDeleteArgs} args - Arguments to delete one Razorpay_requests.
     * @example
     * // Delete one Razorpay_requests
     * const Razorpay_requests = await prisma.razorpay_requests.delete({
     *   where: {
     *     // ... filter to delete one Razorpay_requests
     *   }
     * })
     * 
    **/
    delete<T extends razorpay_requestsDeleteArgs>(
      args: SelectSubset<T, razorpay_requestsDeleteArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Update one Razorpay_requests.
     * @param {razorpay_requestsUpdateArgs} args - Arguments to update one Razorpay_requests.
     * @example
     * // Update one Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends razorpay_requestsUpdateArgs>(
      args: SelectSubset<T, razorpay_requestsUpdateArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Delete zero or more Razorpay_requests.
     * @param {razorpay_requestsDeleteManyArgs} args - Arguments to filter Razorpay_requests to delete.
     * @example
     * // Delete a few Razorpay_requests
     * const { count } = await prisma.razorpay_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends razorpay_requestsDeleteManyArgs>(
      args?: SelectSubset<T, razorpay_requestsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Razorpay_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {razorpay_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends razorpay_requestsUpdateManyArgs>(
      args: SelectSubset<T, razorpay_requestsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Razorpay_requests.
     * @param {razorpay_requestsUpsertArgs} args - Arguments to update or create a Razorpay_requests.
     * @example
     * // Update or create a Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.upsert({
     *   create: {
     *     // ... data to create a Razorpay_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Razorpay_requests we want to update
     *   }
     * })
    **/
    upsert<T extends razorpay_requestsUpsertArgs>(
      args: SelectSubset<T, razorpay_requestsUpsertArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Find one Razorpay_requests that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {razorpay_requestsFindUniqueOrThrowArgs} args - Arguments to find a Razorpay_requests
     * @example
     * // Get one Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends razorpay_requestsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, razorpay_requestsFindUniqueOrThrowArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Find the first Razorpay_requests that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {razorpay_requestsFindFirstOrThrowArgs} args - Arguments to find a Razorpay_requests
     * @example
     * // Get one Razorpay_requests
     * const razorpay_requests = await prisma.razorpay_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends razorpay_requestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, razorpay_requestsFindFirstOrThrowArgs>
    ): Prisma__razorpay_requestsClient<razorpay_requestsGetPayload<T>>

    /**
     * Count the number of Razorpay_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {razorpay_requestsCountArgs} args - Arguments to filter Razorpay_requests to count.
     * @example
     * // Count the number of Razorpay_requests
     * const count = await prisma.razorpay_requests.count({
     *   where: {
     *     // ... the filter for the Razorpay_requests we want to count
     *   }
     * })
    **/
    count<T extends razorpay_requestsCountArgs>(
      args?: Subset<T, razorpay_requestsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Razorpay_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Razorpay_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Razorpay_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Razorpay_requestsAggregateArgs>(args: Subset<T, Razorpay_requestsAggregateArgs>): PrismaPromise<GetRazorpay_requestsAggregateType<T>>

    /**
     * Group by Razorpay_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Razorpay_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Razorpay_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Razorpay_requestsGroupByArgs['orderBy'] }
        : { orderBy?: Razorpay_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Razorpay_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRazorpay_requestsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for razorpay_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__razorpay_requestsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * razorpay_requests base type for findUnique actions
   */
  export type razorpay_requestsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * Filter, which razorpay_requests to fetch.
     * 
    **/
    where: razorpay_requestsWhereUniqueInput
  }

  /**
   * razorpay_requests: findUnique
   */
  export interface razorpay_requestsFindUniqueArgs extends razorpay_requestsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * razorpay_requests base type for findFirst actions
   */
  export type razorpay_requestsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * Filter, which razorpay_requests to fetch.
     * 
    **/
    where?: razorpay_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of razorpay_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<razorpay_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for razorpay_requests.
     * 
    **/
    cursor?: razorpay_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` razorpay_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` razorpay_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of razorpay_requests.
     * 
    **/
    distinct?: Enumerable<Razorpay_requestsScalarFieldEnum>
  }

  /**
   * razorpay_requests: findFirst
   */
  export interface razorpay_requestsFindFirstArgs extends razorpay_requestsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * razorpay_requests findMany
   */
  export type razorpay_requestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * Filter, which razorpay_requests to fetch.
     * 
    **/
    where?: razorpay_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of razorpay_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<razorpay_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing razorpay_requests.
     * 
    **/
    cursor?: razorpay_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` razorpay_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` razorpay_requests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Razorpay_requestsScalarFieldEnum>
  }


  /**
   * razorpay_requests create
   */
  export type razorpay_requestsCreateArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * The data needed to create a razorpay_requests.
     * 
    **/
    data: XOR<razorpay_requestsCreateInput, razorpay_requestsUncheckedCreateInput>
  }


  /**
   * razorpay_requests createMany
   */
  export type razorpay_requestsCreateManyArgs = {
    /**
     * The data used to create many razorpay_requests.
     * 
    **/
    data: Enumerable<razorpay_requestsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * razorpay_requests update
   */
  export type razorpay_requestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * The data needed to update a razorpay_requests.
     * 
    **/
    data: XOR<razorpay_requestsUpdateInput, razorpay_requestsUncheckedUpdateInput>
    /**
     * Choose, which razorpay_requests to update.
     * 
    **/
    where: razorpay_requestsWhereUniqueInput
  }


  /**
   * razorpay_requests updateMany
   */
  export type razorpay_requestsUpdateManyArgs = {
    /**
     * The data used to update razorpay_requests.
     * 
    **/
    data: XOR<razorpay_requestsUpdateManyMutationInput, razorpay_requestsUncheckedUpdateManyInput>
    /**
     * Filter which razorpay_requests to update
     * 
    **/
    where?: razorpay_requestsWhereInput
  }


  /**
   * razorpay_requests upsert
   */
  export type razorpay_requestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * The filter to search for the razorpay_requests to update in case it exists.
     * 
    **/
    where: razorpay_requestsWhereUniqueInput
    /**
     * In case the razorpay_requests found by the `where` argument doesn't exist, create a new razorpay_requests with this data.
     * 
    **/
    create: XOR<razorpay_requestsCreateInput, razorpay_requestsUncheckedCreateInput>
    /**
     * In case the razorpay_requests was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<razorpay_requestsUpdateInput, razorpay_requestsUncheckedUpdateInput>
  }


  /**
   * razorpay_requests delete
   */
  export type razorpay_requestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
    /**
     * Filter which razorpay_requests to delete.
     * 
    **/
    where: razorpay_requestsWhereUniqueInput
  }


  /**
   * razorpay_requests deleteMany
   */
  export type razorpay_requestsDeleteManyArgs = {
    /**
     * Filter which razorpay_requests to delete
     * 
    **/
    where?: razorpay_requestsWhereInput
  }


  /**
   * razorpay_requests: findUniqueOrThrow
   */
  export type razorpay_requestsFindUniqueOrThrowArgs = razorpay_requestsFindUniqueArgsBase
      

  /**
   * razorpay_requests: findFirstOrThrow
   */
  export type razorpay_requestsFindFirstOrThrowArgs = razorpay_requestsFindFirstArgsBase
      

  /**
   * razorpay_requests without action
   */
  export type razorpay_requestsArgs = {
    /**
     * Select specific fields to fetch from the razorpay_requests
     * 
    **/
    select?: razorpay_requestsSelect | null
  }



  /**
   * Model royalty_settlement
   */


  export type AggregateRoyalty_settlement = {
    _count: Royalty_settlementCountAggregateOutputType | null
    _avg: Royalty_settlementAvgAggregateOutputType | null
    _sum: Royalty_settlementSumAggregateOutputType | null
    _min: Royalty_settlementMinAggregateOutputType | null
    _max: Royalty_settlementMaxAggregateOutputType | null
  }

  export type Royalty_settlementAvgAggregateOutputType = {
    id: number | null
    copy_right_owner_id: number | null
    author_id: number | null
    settlement_amount: number | null
    tds_amount: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    bonus_value: number | null
  }

  export type Royalty_settlementSumAggregateOutputType = {
    id: number | null
    copy_right_owner_id: number | null
    author_id: number | null
    settlement_amount: number | null
    tds_amount: number | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    bonus_value: number | null
  }

  export type Royalty_settlementMinAggregateOutputType = {
    id: number | null
    copy_right_owner_id: number | null
    author_id: number | null
    settlement_date: Date | null
    settlement_amount: number | null
    tds_amount: number | null
    payment_type: string | null
    bank_transaction_details: string | null
    comments: string | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    bonus_value: number | null
  }

  export type Royalty_settlementMaxAggregateOutputType = {
    id: number | null
    copy_right_owner_id: number | null
    author_id: number | null
    settlement_date: Date | null
    settlement_amount: number | null
    tds_amount: number | null
    payment_type: string | null
    bank_transaction_details: string | null
    comments: string | null
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    bonus_value: number | null
  }

  export type Royalty_settlementCountAggregateOutputType = {
    id: number
    copy_right_owner_id: number
    author_id: number
    settlement_date: number
    settlement_amount: number
    tds_amount: number
    payment_type: number
    bank_transaction_details: number
    comments: number
    pustaka: number
    amazon: number
    kobo: number
    scribd: number
    google: number
    overdrive: number
    storytel: number
    audible: number
    bonus_value: number
    _all: number
  }


  export type Royalty_settlementAvgAggregateInputType = {
    id?: true
    copy_right_owner_id?: true
    author_id?: true
    settlement_amount?: true
    tds_amount?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    bonus_value?: true
  }

  export type Royalty_settlementSumAggregateInputType = {
    id?: true
    copy_right_owner_id?: true
    author_id?: true
    settlement_amount?: true
    tds_amount?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    bonus_value?: true
  }

  export type Royalty_settlementMinAggregateInputType = {
    id?: true
    copy_right_owner_id?: true
    author_id?: true
    settlement_date?: true
    settlement_amount?: true
    tds_amount?: true
    payment_type?: true
    bank_transaction_details?: true
    comments?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    bonus_value?: true
  }

  export type Royalty_settlementMaxAggregateInputType = {
    id?: true
    copy_right_owner_id?: true
    author_id?: true
    settlement_date?: true
    settlement_amount?: true
    tds_amount?: true
    payment_type?: true
    bank_transaction_details?: true
    comments?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    bonus_value?: true
  }

  export type Royalty_settlementCountAggregateInputType = {
    id?: true
    copy_right_owner_id?: true
    author_id?: true
    settlement_date?: true
    settlement_amount?: true
    tds_amount?: true
    payment_type?: true
    bank_transaction_details?: true
    comments?: true
    pustaka?: true
    amazon?: true
    kobo?: true
    scribd?: true
    google?: true
    overdrive?: true
    storytel?: true
    audible?: true
    bonus_value?: true
    _all?: true
  }

  export type Royalty_settlementAggregateArgs = {
    /**
     * Filter which royalty_settlement to aggregate.
     * 
    **/
    where?: royalty_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of royalty_settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<royalty_settlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: royalty_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` royalty_settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` royalty_settlements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned royalty_settlements
    **/
    _count?: true | Royalty_settlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Royalty_settlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Royalty_settlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Royalty_settlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Royalty_settlementMaxAggregateInputType
  }

  export type GetRoyalty_settlementAggregateType<T extends Royalty_settlementAggregateArgs> = {
        [P in keyof T & keyof AggregateRoyalty_settlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoyalty_settlement[P]>
      : GetScalarType<T[P], AggregateRoyalty_settlement[P]>
  }




  export type Royalty_settlementGroupByArgs = {
    where?: royalty_settlementWhereInput
    orderBy?: Enumerable<royalty_settlementOrderByWithAggregationInput>
    by: Array<Royalty_settlementScalarFieldEnum>
    having?: royalty_settlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Royalty_settlementCountAggregateInputType | true
    _avg?: Royalty_settlementAvgAggregateInputType
    _sum?: Royalty_settlementSumAggregateInputType
    _min?: Royalty_settlementMinAggregateInputType
    _max?: Royalty_settlementMaxAggregateInputType
  }


  export type Royalty_settlementGroupByOutputType = {
    id: number
    copy_right_owner_id: number
    author_id: number | null
    settlement_date: Date
    settlement_amount: number
    tds_amount: number | null
    payment_type: string
    bank_transaction_details: string
    comments: string
    pustaka: number | null
    amazon: number | null
    kobo: number | null
    scribd: number | null
    google: number | null
    overdrive: number | null
    storytel: number | null
    audible: number | null
    bonus_value: number | null
    _count: Royalty_settlementCountAggregateOutputType | null
    _avg: Royalty_settlementAvgAggregateOutputType | null
    _sum: Royalty_settlementSumAggregateOutputType | null
    _min: Royalty_settlementMinAggregateOutputType | null
    _max: Royalty_settlementMaxAggregateOutputType | null
  }

  type GetRoyalty_settlementGroupByPayload<T extends Royalty_settlementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Royalty_settlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Royalty_settlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Royalty_settlementGroupByOutputType[P]>
            : GetScalarType<T[P], Royalty_settlementGroupByOutputType[P]>
        }
      >
    >


  export type royalty_settlementSelect = {
    id?: boolean
    copy_right_owner_id?: boolean
    author_id?: boolean
    settlement_date?: boolean
    settlement_amount?: boolean
    tds_amount?: boolean
    payment_type?: boolean
    bank_transaction_details?: boolean
    comments?: boolean
    pustaka?: boolean
    amazon?: boolean
    kobo?: boolean
    scribd?: boolean
    google?: boolean
    overdrive?: boolean
    storytel?: boolean
    audible?: boolean
    bonus_value?: boolean
  }


  export type royalty_settlementGetPayload<S extends boolean | null | undefined | royalty_settlementArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? royalty_settlement :
    S extends undefined ? never :
    S extends { include: any } & (royalty_settlementArgs | royalty_settlementFindManyArgs)
    ? royalty_settlement 
    : S extends { select: any } & (royalty_settlementArgs | royalty_settlementFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof royalty_settlement ? royalty_settlement[P] : never
  } 
      : royalty_settlement


  type royalty_settlementCountArgs = Merge<
    Omit<royalty_settlementFindManyArgs, 'select' | 'include'> & {
      select?: Royalty_settlementCountAggregateInputType | true
    }
  >

  export interface royalty_settlementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Royalty_settlement that matches the filter.
     * @param {royalty_settlementFindUniqueArgs} args - Arguments to find a Royalty_settlement
     * @example
     * // Get one Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends royalty_settlementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, royalty_settlementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'royalty_settlement'> extends True ? Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>> : Prisma__royalty_settlementClient<royalty_settlementGetPayload<T> | null, null>

    /**
     * Find the first Royalty_settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {royalty_settlementFindFirstArgs} args - Arguments to find a Royalty_settlement
     * @example
     * // Get one Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends royalty_settlementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, royalty_settlementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'royalty_settlement'> extends True ? Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>> : Prisma__royalty_settlementClient<royalty_settlementGetPayload<T> | null, null>

    /**
     * Find zero or more Royalty_settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {royalty_settlementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Royalty_settlements
     * const royalty_settlements = await prisma.royalty_settlement.findMany()
     * 
     * // Get first 10 Royalty_settlements
     * const royalty_settlements = await prisma.royalty_settlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const royalty_settlementWithIdOnly = await prisma.royalty_settlement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends royalty_settlementFindManyArgs>(
      args?: SelectSubset<T, royalty_settlementFindManyArgs>
    ): PrismaPromise<Array<royalty_settlementGetPayload<T>>>

    /**
     * Create a Royalty_settlement.
     * @param {royalty_settlementCreateArgs} args - Arguments to create a Royalty_settlement.
     * @example
     * // Create one Royalty_settlement
     * const Royalty_settlement = await prisma.royalty_settlement.create({
     *   data: {
     *     // ... data to create a Royalty_settlement
     *   }
     * })
     * 
    **/
    create<T extends royalty_settlementCreateArgs>(
      args: SelectSubset<T, royalty_settlementCreateArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Create many Royalty_settlements.
     *     @param {royalty_settlementCreateManyArgs} args - Arguments to create many Royalty_settlements.
     *     @example
     *     // Create many Royalty_settlements
     *     const royalty_settlement = await prisma.royalty_settlement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends royalty_settlementCreateManyArgs>(
      args?: SelectSubset<T, royalty_settlementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Royalty_settlement.
     * @param {royalty_settlementDeleteArgs} args - Arguments to delete one Royalty_settlement.
     * @example
     * // Delete one Royalty_settlement
     * const Royalty_settlement = await prisma.royalty_settlement.delete({
     *   where: {
     *     // ... filter to delete one Royalty_settlement
     *   }
     * })
     * 
    **/
    delete<T extends royalty_settlementDeleteArgs>(
      args: SelectSubset<T, royalty_settlementDeleteArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Update one Royalty_settlement.
     * @param {royalty_settlementUpdateArgs} args - Arguments to update one Royalty_settlement.
     * @example
     * // Update one Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends royalty_settlementUpdateArgs>(
      args: SelectSubset<T, royalty_settlementUpdateArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Delete zero or more Royalty_settlements.
     * @param {royalty_settlementDeleteManyArgs} args - Arguments to filter Royalty_settlements to delete.
     * @example
     * // Delete a few Royalty_settlements
     * const { count } = await prisma.royalty_settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends royalty_settlementDeleteManyArgs>(
      args?: SelectSubset<T, royalty_settlementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Royalty_settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {royalty_settlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Royalty_settlements
     * const royalty_settlement = await prisma.royalty_settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends royalty_settlementUpdateManyArgs>(
      args: SelectSubset<T, royalty_settlementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Royalty_settlement.
     * @param {royalty_settlementUpsertArgs} args - Arguments to update or create a Royalty_settlement.
     * @example
     * // Update or create a Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.upsert({
     *   create: {
     *     // ... data to create a Royalty_settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Royalty_settlement we want to update
     *   }
     * })
    **/
    upsert<T extends royalty_settlementUpsertArgs>(
      args: SelectSubset<T, royalty_settlementUpsertArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Find one Royalty_settlement that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {royalty_settlementFindUniqueOrThrowArgs} args - Arguments to find a Royalty_settlement
     * @example
     * // Get one Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends royalty_settlementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, royalty_settlementFindUniqueOrThrowArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Find the first Royalty_settlement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {royalty_settlementFindFirstOrThrowArgs} args - Arguments to find a Royalty_settlement
     * @example
     * // Get one Royalty_settlement
     * const royalty_settlement = await prisma.royalty_settlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends royalty_settlementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, royalty_settlementFindFirstOrThrowArgs>
    ): Prisma__royalty_settlementClient<royalty_settlementGetPayload<T>>

    /**
     * Count the number of Royalty_settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {royalty_settlementCountArgs} args - Arguments to filter Royalty_settlements to count.
     * @example
     * // Count the number of Royalty_settlements
     * const count = await prisma.royalty_settlement.count({
     *   where: {
     *     // ... the filter for the Royalty_settlements we want to count
     *   }
     * })
    **/
    count<T extends royalty_settlementCountArgs>(
      args?: Subset<T, royalty_settlementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Royalty_settlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Royalty_settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Royalty_settlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Royalty_settlementAggregateArgs>(args: Subset<T, Royalty_settlementAggregateArgs>): PrismaPromise<GetRoyalty_settlementAggregateType<T>>

    /**
     * Group by Royalty_settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Royalty_settlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Royalty_settlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Royalty_settlementGroupByArgs['orderBy'] }
        : { orderBy?: Royalty_settlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Royalty_settlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoyalty_settlementGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for royalty_settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__royalty_settlementClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * royalty_settlement base type for findUnique actions
   */
  export type royalty_settlementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * Filter, which royalty_settlement to fetch.
     * 
    **/
    where: royalty_settlementWhereUniqueInput
  }

  /**
   * royalty_settlement: findUnique
   */
  export interface royalty_settlementFindUniqueArgs extends royalty_settlementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * royalty_settlement base type for findFirst actions
   */
  export type royalty_settlementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * Filter, which royalty_settlement to fetch.
     * 
    **/
    where?: royalty_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of royalty_settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<royalty_settlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for royalty_settlements.
     * 
    **/
    cursor?: royalty_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` royalty_settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` royalty_settlements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of royalty_settlements.
     * 
    **/
    distinct?: Enumerable<Royalty_settlementScalarFieldEnum>
  }

  /**
   * royalty_settlement: findFirst
   */
  export interface royalty_settlementFindFirstArgs extends royalty_settlementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * royalty_settlement findMany
   */
  export type royalty_settlementFindManyArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * Filter, which royalty_settlements to fetch.
     * 
    **/
    where?: royalty_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of royalty_settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<royalty_settlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing royalty_settlements.
     * 
    **/
    cursor?: royalty_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` royalty_settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` royalty_settlements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Royalty_settlementScalarFieldEnum>
  }


  /**
   * royalty_settlement create
   */
  export type royalty_settlementCreateArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * The data needed to create a royalty_settlement.
     * 
    **/
    data: XOR<royalty_settlementCreateInput, royalty_settlementUncheckedCreateInput>
  }


  /**
   * royalty_settlement createMany
   */
  export type royalty_settlementCreateManyArgs = {
    /**
     * The data used to create many royalty_settlements.
     * 
    **/
    data: Enumerable<royalty_settlementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * royalty_settlement update
   */
  export type royalty_settlementUpdateArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * The data needed to update a royalty_settlement.
     * 
    **/
    data: XOR<royalty_settlementUpdateInput, royalty_settlementUncheckedUpdateInput>
    /**
     * Choose, which royalty_settlement to update.
     * 
    **/
    where: royalty_settlementWhereUniqueInput
  }


  /**
   * royalty_settlement updateMany
   */
  export type royalty_settlementUpdateManyArgs = {
    /**
     * The data used to update royalty_settlements.
     * 
    **/
    data: XOR<royalty_settlementUpdateManyMutationInput, royalty_settlementUncheckedUpdateManyInput>
    /**
     * Filter which royalty_settlements to update
     * 
    **/
    where?: royalty_settlementWhereInput
  }


  /**
   * royalty_settlement upsert
   */
  export type royalty_settlementUpsertArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * The filter to search for the royalty_settlement to update in case it exists.
     * 
    **/
    where: royalty_settlementWhereUniqueInput
    /**
     * In case the royalty_settlement found by the `where` argument doesn't exist, create a new royalty_settlement with this data.
     * 
    **/
    create: XOR<royalty_settlementCreateInput, royalty_settlementUncheckedCreateInput>
    /**
     * In case the royalty_settlement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<royalty_settlementUpdateInput, royalty_settlementUncheckedUpdateInput>
  }


  /**
   * royalty_settlement delete
   */
  export type royalty_settlementDeleteArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
    /**
     * Filter which royalty_settlement to delete.
     * 
    **/
    where: royalty_settlementWhereUniqueInput
  }


  /**
   * royalty_settlement deleteMany
   */
  export type royalty_settlementDeleteManyArgs = {
    /**
     * Filter which royalty_settlements to delete
     * 
    **/
    where?: royalty_settlementWhereInput
  }


  /**
   * royalty_settlement: findUniqueOrThrow
   */
  export type royalty_settlementFindUniqueOrThrowArgs = royalty_settlementFindUniqueArgsBase
      

  /**
   * royalty_settlement: findFirstOrThrow
   */
  export type royalty_settlementFindFirstOrThrowArgs = royalty_settlementFindFirstArgsBase
      

  /**
   * royalty_settlement without action
   */
  export type royalty_settlementArgs = {
    /**
     * Select specific fields to fetch from the royalty_settlement
     * 
    **/
    select?: royalty_settlementSelect | null
  }



  /**
   * Model sales_consolidation
   */


  export type AggregateSales_consolidation = {
    _count: Sales_consolidationCountAggregateOutputType | null
    _avg: Sales_consolidationAvgAggregateOutputType | null
    _sum: Sales_consolidationSumAggregateOutputType | null
    _min: Sales_consolidationMinAggregateOutputType | null
    _max: Sales_consolidationMaxAggregateOutputType | null
  }

  export type Sales_consolidationAvgAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    genre_id: number | null
    language_id: number | null
    type_of_book: number | null
    book_cost: number | null
    downloads: number | null
  }

  export type Sales_consolidationSumAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    genre_id: number | null
    language_id: number | null
    type_of_book: number | null
    book_cost: number | null
    downloads: number | null
  }

  export type Sales_consolidationMinAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    month_year: Date | null
    genre_id: number | null
    language_id: number | null
    type_of_book: number | null
    book_cost: number | null
    downloads: number | null
  }

  export type Sales_consolidationMaxAggregateOutputType = {
    id: number | null
    author_id: number | null
    book_id: number | null
    month_year: Date | null
    genre_id: number | null
    language_id: number | null
    type_of_book: number | null
    book_cost: number | null
    downloads: number | null
  }

  export type Sales_consolidationCountAggregateOutputType = {
    id: number
    author_id: number
    book_id: number
    month_year: number
    genre_id: number
    language_id: number
    type_of_book: number
    book_cost: number
    downloads: number
    _all: number
  }


  export type Sales_consolidationAvgAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    genre_id?: true
    language_id?: true
    type_of_book?: true
    book_cost?: true
    downloads?: true
  }

  export type Sales_consolidationSumAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    genre_id?: true
    language_id?: true
    type_of_book?: true
    book_cost?: true
    downloads?: true
  }

  export type Sales_consolidationMinAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    month_year?: true
    genre_id?: true
    language_id?: true
    type_of_book?: true
    book_cost?: true
    downloads?: true
  }

  export type Sales_consolidationMaxAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    month_year?: true
    genre_id?: true
    language_id?: true
    type_of_book?: true
    book_cost?: true
    downloads?: true
  }

  export type Sales_consolidationCountAggregateInputType = {
    id?: true
    author_id?: true
    book_id?: true
    month_year?: true
    genre_id?: true
    language_id?: true
    type_of_book?: true
    book_cost?: true
    downloads?: true
    _all?: true
  }

  export type Sales_consolidationAggregateArgs = {
    /**
     * Filter which sales_consolidation to aggregate.
     * 
    **/
    where?: sales_consolidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_consolidations to fetch.
     * 
    **/
    orderBy?: Enumerable<sales_consolidationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sales_consolidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_consolidations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_consolidations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales_consolidations
    **/
    _count?: true | Sales_consolidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sales_consolidationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sales_consolidationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sales_consolidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sales_consolidationMaxAggregateInputType
  }

  export type GetSales_consolidationAggregateType<T extends Sales_consolidationAggregateArgs> = {
        [P in keyof T & keyof AggregateSales_consolidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales_consolidation[P]>
      : GetScalarType<T[P], AggregateSales_consolidation[P]>
  }




  export type Sales_consolidationGroupByArgs = {
    where?: sales_consolidationWhereInput
    orderBy?: Enumerable<sales_consolidationOrderByWithAggregationInput>
    by: Array<Sales_consolidationScalarFieldEnum>
    having?: sales_consolidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sales_consolidationCountAggregateInputType | true
    _avg?: Sales_consolidationAvgAggregateInputType
    _sum?: Sales_consolidationSumAggregateInputType
    _min?: Sales_consolidationMinAggregateInputType
    _max?: Sales_consolidationMaxAggregateInputType
  }


  export type Sales_consolidationGroupByOutputType = {
    id: number
    author_id: number | null
    book_id: number | null
    month_year: Date | null
    genre_id: number | null
    language_id: number | null
    type_of_book: number | null
    book_cost: number | null
    downloads: number
    _count: Sales_consolidationCountAggregateOutputType | null
    _avg: Sales_consolidationAvgAggregateOutputType | null
    _sum: Sales_consolidationSumAggregateOutputType | null
    _min: Sales_consolidationMinAggregateOutputType | null
    _max: Sales_consolidationMaxAggregateOutputType | null
  }

  type GetSales_consolidationGroupByPayload<T extends Sales_consolidationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Sales_consolidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sales_consolidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sales_consolidationGroupByOutputType[P]>
            : GetScalarType<T[P], Sales_consolidationGroupByOutputType[P]>
        }
      >
    >


  export type sales_consolidationSelect = {
    id?: boolean
    author_id?: boolean
    book_id?: boolean
    month_year?: boolean
    genre_id?: boolean
    language_id?: boolean
    type_of_book?: boolean
    book_cost?: boolean
    downloads?: boolean
  }


  export type sales_consolidationGetPayload<S extends boolean | null | undefined | sales_consolidationArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sales_consolidation :
    S extends undefined ? never :
    S extends { include: any } & (sales_consolidationArgs | sales_consolidationFindManyArgs)
    ? sales_consolidation 
    : S extends { select: any } & (sales_consolidationArgs | sales_consolidationFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof sales_consolidation ? sales_consolidation[P] : never
  } 
      : sales_consolidation


  type sales_consolidationCountArgs = Merge<
    Omit<sales_consolidationFindManyArgs, 'select' | 'include'> & {
      select?: Sales_consolidationCountAggregateInputType | true
    }
  >

  export interface sales_consolidationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sales_consolidation that matches the filter.
     * @param {sales_consolidationFindUniqueArgs} args - Arguments to find a Sales_consolidation
     * @example
     * // Get one Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sales_consolidationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sales_consolidationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sales_consolidation'> extends True ? Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>> : Prisma__sales_consolidationClient<sales_consolidationGetPayload<T> | null, null>

    /**
     * Find the first Sales_consolidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_consolidationFindFirstArgs} args - Arguments to find a Sales_consolidation
     * @example
     * // Get one Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sales_consolidationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sales_consolidationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sales_consolidation'> extends True ? Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>> : Prisma__sales_consolidationClient<sales_consolidationGetPayload<T> | null, null>

    /**
     * Find zero or more Sales_consolidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_consolidationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales_consolidations
     * const sales_consolidations = await prisma.sales_consolidation.findMany()
     * 
     * // Get first 10 Sales_consolidations
     * const sales_consolidations = await prisma.sales_consolidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sales_consolidationWithIdOnly = await prisma.sales_consolidation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sales_consolidationFindManyArgs>(
      args?: SelectSubset<T, sales_consolidationFindManyArgs>
    ): PrismaPromise<Array<sales_consolidationGetPayload<T>>>

    /**
     * Create a Sales_consolidation.
     * @param {sales_consolidationCreateArgs} args - Arguments to create a Sales_consolidation.
     * @example
     * // Create one Sales_consolidation
     * const Sales_consolidation = await prisma.sales_consolidation.create({
     *   data: {
     *     // ... data to create a Sales_consolidation
     *   }
     * })
     * 
    **/
    create<T extends sales_consolidationCreateArgs>(
      args: SelectSubset<T, sales_consolidationCreateArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Create many Sales_consolidations.
     *     @param {sales_consolidationCreateManyArgs} args - Arguments to create many Sales_consolidations.
     *     @example
     *     // Create many Sales_consolidations
     *     const sales_consolidation = await prisma.sales_consolidation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sales_consolidationCreateManyArgs>(
      args?: SelectSubset<T, sales_consolidationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sales_consolidation.
     * @param {sales_consolidationDeleteArgs} args - Arguments to delete one Sales_consolidation.
     * @example
     * // Delete one Sales_consolidation
     * const Sales_consolidation = await prisma.sales_consolidation.delete({
     *   where: {
     *     // ... filter to delete one Sales_consolidation
     *   }
     * })
     * 
    **/
    delete<T extends sales_consolidationDeleteArgs>(
      args: SelectSubset<T, sales_consolidationDeleteArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Update one Sales_consolidation.
     * @param {sales_consolidationUpdateArgs} args - Arguments to update one Sales_consolidation.
     * @example
     * // Update one Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sales_consolidationUpdateArgs>(
      args: SelectSubset<T, sales_consolidationUpdateArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Delete zero or more Sales_consolidations.
     * @param {sales_consolidationDeleteManyArgs} args - Arguments to filter Sales_consolidations to delete.
     * @example
     * // Delete a few Sales_consolidations
     * const { count } = await prisma.sales_consolidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sales_consolidationDeleteManyArgs>(
      args?: SelectSubset<T, sales_consolidationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales_consolidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_consolidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales_consolidations
     * const sales_consolidation = await prisma.sales_consolidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sales_consolidationUpdateManyArgs>(
      args: SelectSubset<T, sales_consolidationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sales_consolidation.
     * @param {sales_consolidationUpsertArgs} args - Arguments to update or create a Sales_consolidation.
     * @example
     * // Update or create a Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.upsert({
     *   create: {
     *     // ... data to create a Sales_consolidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales_consolidation we want to update
     *   }
     * })
    **/
    upsert<T extends sales_consolidationUpsertArgs>(
      args: SelectSubset<T, sales_consolidationUpsertArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Find one Sales_consolidation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {sales_consolidationFindUniqueOrThrowArgs} args - Arguments to find a Sales_consolidation
     * @example
     * // Get one Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sales_consolidationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sales_consolidationFindUniqueOrThrowArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Find the first Sales_consolidation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_consolidationFindFirstOrThrowArgs} args - Arguments to find a Sales_consolidation
     * @example
     * // Get one Sales_consolidation
     * const sales_consolidation = await prisma.sales_consolidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sales_consolidationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sales_consolidationFindFirstOrThrowArgs>
    ): Prisma__sales_consolidationClient<sales_consolidationGetPayload<T>>

    /**
     * Count the number of Sales_consolidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_consolidationCountArgs} args - Arguments to filter Sales_consolidations to count.
     * @example
     * // Count the number of Sales_consolidations
     * const count = await prisma.sales_consolidation.count({
     *   where: {
     *     // ... the filter for the Sales_consolidations we want to count
     *   }
     * })
    **/
    count<T extends sales_consolidationCountArgs>(
      args?: Subset<T, sales_consolidationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sales_consolidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales_consolidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sales_consolidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sales_consolidationAggregateArgs>(args: Subset<T, Sales_consolidationAggregateArgs>): PrismaPromise<GetSales_consolidationAggregateType<T>>

    /**
     * Group by Sales_consolidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sales_consolidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sales_consolidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sales_consolidationGroupByArgs['orderBy'] }
        : { orderBy?: Sales_consolidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sales_consolidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSales_consolidationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sales_consolidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sales_consolidationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sales_consolidation base type for findUnique actions
   */
  export type sales_consolidationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * Filter, which sales_consolidation to fetch.
     * 
    **/
    where: sales_consolidationWhereUniqueInput
  }

  /**
   * sales_consolidation: findUnique
   */
  export interface sales_consolidationFindUniqueArgs extends sales_consolidationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sales_consolidation base type for findFirst actions
   */
  export type sales_consolidationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * Filter, which sales_consolidation to fetch.
     * 
    **/
    where?: sales_consolidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_consolidations to fetch.
     * 
    **/
    orderBy?: Enumerable<sales_consolidationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales_consolidations.
     * 
    **/
    cursor?: sales_consolidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_consolidations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_consolidations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales_consolidations.
     * 
    **/
    distinct?: Enumerable<Sales_consolidationScalarFieldEnum>
  }

  /**
   * sales_consolidation: findFirst
   */
  export interface sales_consolidationFindFirstArgs extends sales_consolidationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sales_consolidation findMany
   */
  export type sales_consolidationFindManyArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * Filter, which sales_consolidations to fetch.
     * 
    **/
    where?: sales_consolidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_consolidations to fetch.
     * 
    **/
    orderBy?: Enumerable<sales_consolidationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales_consolidations.
     * 
    **/
    cursor?: sales_consolidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_consolidations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_consolidations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Sales_consolidationScalarFieldEnum>
  }


  /**
   * sales_consolidation create
   */
  export type sales_consolidationCreateArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * The data needed to create a sales_consolidation.
     * 
    **/
    data: XOR<sales_consolidationCreateInput, sales_consolidationUncheckedCreateInput>
  }


  /**
   * sales_consolidation createMany
   */
  export type sales_consolidationCreateManyArgs = {
    /**
     * The data used to create many sales_consolidations.
     * 
    **/
    data: Enumerable<sales_consolidationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sales_consolidation update
   */
  export type sales_consolidationUpdateArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * The data needed to update a sales_consolidation.
     * 
    **/
    data: XOR<sales_consolidationUpdateInput, sales_consolidationUncheckedUpdateInput>
    /**
     * Choose, which sales_consolidation to update.
     * 
    **/
    where: sales_consolidationWhereUniqueInput
  }


  /**
   * sales_consolidation updateMany
   */
  export type sales_consolidationUpdateManyArgs = {
    /**
     * The data used to update sales_consolidations.
     * 
    **/
    data: XOR<sales_consolidationUpdateManyMutationInput, sales_consolidationUncheckedUpdateManyInput>
    /**
     * Filter which sales_consolidations to update
     * 
    **/
    where?: sales_consolidationWhereInput
  }


  /**
   * sales_consolidation upsert
   */
  export type sales_consolidationUpsertArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * The filter to search for the sales_consolidation to update in case it exists.
     * 
    **/
    where: sales_consolidationWhereUniqueInput
    /**
     * In case the sales_consolidation found by the `where` argument doesn't exist, create a new sales_consolidation with this data.
     * 
    **/
    create: XOR<sales_consolidationCreateInput, sales_consolidationUncheckedCreateInput>
    /**
     * In case the sales_consolidation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sales_consolidationUpdateInput, sales_consolidationUncheckedUpdateInput>
  }


  /**
   * sales_consolidation delete
   */
  export type sales_consolidationDeleteArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
    /**
     * Filter which sales_consolidation to delete.
     * 
    **/
    where: sales_consolidationWhereUniqueInput
  }


  /**
   * sales_consolidation deleteMany
   */
  export type sales_consolidationDeleteManyArgs = {
    /**
     * Filter which sales_consolidations to delete
     * 
    **/
    where?: sales_consolidationWhereInput
  }


  /**
   * sales_consolidation: findUniqueOrThrow
   */
  export type sales_consolidationFindUniqueOrThrowArgs = sales_consolidationFindUniqueArgsBase
      

  /**
   * sales_consolidation: findFirstOrThrow
   */
  export type sales_consolidationFindFirstOrThrowArgs = sales_consolidationFindFirstArgsBase
      

  /**
   * sales_consolidation without action
   */
  export type sales_consolidationArgs = {
    /**
     * Select specific fields to fetch from the sales_consolidation
     * 
    **/
    select?: sales_consolidationSelect | null
  }



  /**
   * Model scribd_books
   */


  export type AggregateScribd_books = {
    _count: Scribd_booksCountAggregateOutputType | null
    _avg: Scribd_booksAvgAggregateOutputType | null
    _sum: Scribd_booksSumAggregateOutputType | null
    _min: Scribd_booksMinAggregateOutputType | null
    _max: Scribd_booksMaxAggregateOutputType | null
  }

  export type Scribd_booksAvgAggregateOutputType = {
    id: number | null
    import_id: number | null
    doc_id: number | null
    publisher_tools_config_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    duplicate_flag: number | null
  }

  export type Scribd_booksSumAggregateOutputType = {
    id: number | null
    import_id: number | null
    doc_id: number | null
    publisher_tools_config_id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    duplicate_flag: number | null
  }

  export type Scribd_booksMinAggregateOutputType = {
    id: number | null
    updated_at: Date | null
    import_id: number | null
    doc_id: number | null
    identifier: string | null
    title: string | null
    published: boolean | null
    in_subscription: boolean | null
    product_page_url: string | null
    imprints: string | null
    status: string | null
    publisher_tools_config_id: number | null
    metadata_status: string | null
    conversion_status: string | null
    product_page_pending: string | null
    subscription_pending: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    duplicate_flag: number | null
  }

  export type Scribd_booksMaxAggregateOutputType = {
    id: number | null
    updated_at: Date | null
    import_id: number | null
    doc_id: number | null
    identifier: string | null
    title: string | null
    published: boolean | null
    in_subscription: boolean | null
    product_page_url: string | null
    imprints: string | null
    status: string | null
    publisher_tools_config_id: number | null
    metadata_status: string | null
    conversion_status: string | null
    product_page_pending: string | null
    subscription_pending: string | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    duplicate_flag: number | null
  }

  export type Scribd_booksCountAggregateOutputType = {
    id: number
    updated_at: number
    import_id: number
    doc_id: number
    identifier: number
    title: number
    published: number
    in_subscription: number
    product_page_url: number
    imprints: number
    status: number
    publisher_tools_config_id: number
    metadata_status: number
    conversion_status: number
    product_page_pending: number
    subscription_pending: number
    book_id: number
    author_id: number
    copyright_owner: number
    language_id: number
    duplicate_flag: number
    _all: number
  }


  export type Scribd_booksAvgAggregateInputType = {
    id?: true
    import_id?: true
    doc_id?: true
    publisher_tools_config_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    duplicate_flag?: true
  }

  export type Scribd_booksSumAggregateInputType = {
    id?: true
    import_id?: true
    doc_id?: true
    publisher_tools_config_id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    duplicate_flag?: true
  }

  export type Scribd_booksMinAggregateInputType = {
    id?: true
    updated_at?: true
    import_id?: true
    doc_id?: true
    identifier?: true
    title?: true
    published?: true
    in_subscription?: true
    product_page_url?: true
    imprints?: true
    status?: true
    publisher_tools_config_id?: true
    metadata_status?: true
    conversion_status?: true
    product_page_pending?: true
    subscription_pending?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    duplicate_flag?: true
  }

  export type Scribd_booksMaxAggregateInputType = {
    id?: true
    updated_at?: true
    import_id?: true
    doc_id?: true
    identifier?: true
    title?: true
    published?: true
    in_subscription?: true
    product_page_url?: true
    imprints?: true
    status?: true
    publisher_tools_config_id?: true
    metadata_status?: true
    conversion_status?: true
    product_page_pending?: true
    subscription_pending?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    duplicate_flag?: true
  }

  export type Scribd_booksCountAggregateInputType = {
    id?: true
    updated_at?: true
    import_id?: true
    doc_id?: true
    identifier?: true
    title?: true
    published?: true
    in_subscription?: true
    product_page_url?: true
    imprints?: true
    status?: true
    publisher_tools_config_id?: true
    metadata_status?: true
    conversion_status?: true
    product_page_pending?: true
    subscription_pending?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    duplicate_flag?: true
    _all?: true
  }

  export type Scribd_booksAggregateArgs = {
    /**
     * Filter which scribd_books to aggregate.
     * 
    **/
    where?: scribd_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_books to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: scribd_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scribd_books
    **/
    _count?: true | Scribd_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Scribd_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Scribd_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Scribd_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Scribd_booksMaxAggregateInputType
  }

  export type GetScribd_booksAggregateType<T extends Scribd_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateScribd_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScribd_books[P]>
      : GetScalarType<T[P], AggregateScribd_books[P]>
  }




  export type Scribd_booksGroupByArgs = {
    where?: scribd_booksWhereInput
    orderBy?: Enumerable<scribd_booksOrderByWithAggregationInput>
    by: Array<Scribd_booksScalarFieldEnum>
    having?: scribd_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Scribd_booksCountAggregateInputType | true
    _avg?: Scribd_booksAvgAggregateInputType
    _sum?: Scribd_booksSumAggregateInputType
    _min?: Scribd_booksMinAggregateInputType
    _max?: Scribd_booksMaxAggregateInputType
  }


  export type Scribd_booksGroupByOutputType = {
    id: number
    updated_at: Date
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url: string | null
    imprints: string | null
    status: string
    publisher_tools_config_id: number | null
    metadata_status: string | null
    conversion_status: string | null
    product_page_pending: string | null
    subscription_pending: string | null
    book_id: number
    author_id: number
    copyright_owner: number | null
    language_id: number
    duplicate_flag: number | null
    _count: Scribd_booksCountAggregateOutputType | null
    _avg: Scribd_booksAvgAggregateOutputType | null
    _sum: Scribd_booksSumAggregateOutputType | null
    _min: Scribd_booksMinAggregateOutputType | null
    _max: Scribd_booksMaxAggregateOutputType | null
  }

  type GetScribd_booksGroupByPayload<T extends Scribd_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Scribd_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Scribd_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Scribd_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Scribd_booksGroupByOutputType[P]>
        }
      >
    >


  export type scribd_booksSelect = {
    id?: boolean
    updated_at?: boolean
    import_id?: boolean
    doc_id?: boolean
    identifier?: boolean
    title?: boolean
    published?: boolean
    in_subscription?: boolean
    product_page_url?: boolean
    imprints?: boolean
    status?: boolean
    publisher_tools_config_id?: boolean
    metadata_status?: boolean
    conversion_status?: boolean
    product_page_pending?: boolean
    subscription_pending?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    duplicate_flag?: boolean
  }


  export type scribd_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type scribd_booksGetPayload<S extends boolean | null | undefined | scribd_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? scribd_books :
    S extends undefined ? never :
    S extends { include: any } & (scribd_booksArgs | scribd_booksFindManyArgs)
    ? scribd_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (scribd_booksArgs | scribd_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof scribd_books ? scribd_books[P] : never
  } 
      : scribd_books


  type scribd_booksCountArgs = Merge<
    Omit<scribd_booksFindManyArgs, 'select' | 'include'> & {
      select?: Scribd_booksCountAggregateInputType | true
    }
  >

  export interface scribd_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Scribd_books that matches the filter.
     * @param {scribd_booksFindUniqueArgs} args - Arguments to find a Scribd_books
     * @example
     * // Get one Scribd_books
     * const scribd_books = await prisma.scribd_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends scribd_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, scribd_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'scribd_books'> extends True ? Prisma__scribd_booksClient<scribd_booksGetPayload<T>> : Prisma__scribd_booksClient<scribd_booksGetPayload<T> | null, null>

    /**
     * Find the first Scribd_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_booksFindFirstArgs} args - Arguments to find a Scribd_books
     * @example
     * // Get one Scribd_books
     * const scribd_books = await prisma.scribd_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends scribd_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, scribd_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'scribd_books'> extends True ? Prisma__scribd_booksClient<scribd_booksGetPayload<T>> : Prisma__scribd_booksClient<scribd_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Scribd_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scribd_books
     * const scribd_books = await prisma.scribd_books.findMany()
     * 
     * // Get first 10 Scribd_books
     * const scribd_books = await prisma.scribd_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scribd_booksWithIdOnly = await prisma.scribd_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends scribd_booksFindManyArgs>(
      args?: SelectSubset<T, scribd_booksFindManyArgs>
    ): PrismaPromise<Array<scribd_booksGetPayload<T>>>

    /**
     * Create a Scribd_books.
     * @param {scribd_booksCreateArgs} args - Arguments to create a Scribd_books.
     * @example
     * // Create one Scribd_books
     * const Scribd_books = await prisma.scribd_books.create({
     *   data: {
     *     // ... data to create a Scribd_books
     *   }
     * })
     * 
    **/
    create<T extends scribd_booksCreateArgs>(
      args: SelectSubset<T, scribd_booksCreateArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Create many Scribd_books.
     *     @param {scribd_booksCreateManyArgs} args - Arguments to create many Scribd_books.
     *     @example
     *     // Create many Scribd_books
     *     const scribd_books = await prisma.scribd_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends scribd_booksCreateManyArgs>(
      args?: SelectSubset<T, scribd_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Scribd_books.
     * @param {scribd_booksDeleteArgs} args - Arguments to delete one Scribd_books.
     * @example
     * // Delete one Scribd_books
     * const Scribd_books = await prisma.scribd_books.delete({
     *   where: {
     *     // ... filter to delete one Scribd_books
     *   }
     * })
     * 
    **/
    delete<T extends scribd_booksDeleteArgs>(
      args: SelectSubset<T, scribd_booksDeleteArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Update one Scribd_books.
     * @param {scribd_booksUpdateArgs} args - Arguments to update one Scribd_books.
     * @example
     * // Update one Scribd_books
     * const scribd_books = await prisma.scribd_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends scribd_booksUpdateArgs>(
      args: SelectSubset<T, scribd_booksUpdateArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Delete zero or more Scribd_books.
     * @param {scribd_booksDeleteManyArgs} args - Arguments to filter Scribd_books to delete.
     * @example
     * // Delete a few Scribd_books
     * const { count } = await prisma.scribd_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends scribd_booksDeleteManyArgs>(
      args?: SelectSubset<T, scribd_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scribd_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scribd_books
     * const scribd_books = await prisma.scribd_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends scribd_booksUpdateManyArgs>(
      args: SelectSubset<T, scribd_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Scribd_books.
     * @param {scribd_booksUpsertArgs} args - Arguments to update or create a Scribd_books.
     * @example
     * // Update or create a Scribd_books
     * const scribd_books = await prisma.scribd_books.upsert({
     *   create: {
     *     // ... data to create a Scribd_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scribd_books we want to update
     *   }
     * })
    **/
    upsert<T extends scribd_booksUpsertArgs>(
      args: SelectSubset<T, scribd_booksUpsertArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Find one Scribd_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {scribd_booksFindUniqueOrThrowArgs} args - Arguments to find a Scribd_books
     * @example
     * // Get one Scribd_books
     * const scribd_books = await prisma.scribd_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends scribd_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, scribd_booksFindUniqueOrThrowArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Find the first Scribd_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_booksFindFirstOrThrowArgs} args - Arguments to find a Scribd_books
     * @example
     * // Get one Scribd_books
     * const scribd_books = await prisma.scribd_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends scribd_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, scribd_booksFindFirstOrThrowArgs>
    ): Prisma__scribd_booksClient<scribd_booksGetPayload<T>>

    /**
     * Count the number of Scribd_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_booksCountArgs} args - Arguments to filter Scribd_books to count.
     * @example
     * // Count the number of Scribd_books
     * const count = await prisma.scribd_books.count({
     *   where: {
     *     // ... the filter for the Scribd_books we want to count
     *   }
     * })
    **/
    count<T extends scribd_booksCountArgs>(
      args?: Subset<T, scribd_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Scribd_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scribd_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Scribd_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Scribd_booksAggregateArgs>(args: Subset<T, Scribd_booksAggregateArgs>): PrismaPromise<GetScribd_booksAggregateType<T>>

    /**
     * Group by Scribd_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Scribd_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Scribd_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Scribd_booksGroupByArgs['orderBy'] }
        : { orderBy?: Scribd_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Scribd_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScribd_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for scribd_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__scribd_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * scribd_books base type for findUnique actions
   */
  export type scribd_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * Filter, which scribd_books to fetch.
     * 
    **/
    where: scribd_booksWhereUniqueInput
  }

  /**
   * scribd_books: findUnique
   */
  export interface scribd_booksFindUniqueArgs extends scribd_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * scribd_books base type for findFirst actions
   */
  export type scribd_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * Filter, which scribd_books to fetch.
     * 
    **/
    where?: scribd_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_books to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scribd_books.
     * 
    **/
    cursor?: scribd_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scribd_books.
     * 
    **/
    distinct?: Enumerable<Scribd_booksScalarFieldEnum>
  }

  /**
   * scribd_books: findFirst
   */
  export interface scribd_booksFindFirstArgs extends scribd_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * scribd_books findMany
   */
  export type scribd_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * Filter, which scribd_books to fetch.
     * 
    **/
    where?: scribd_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_books to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scribd_books.
     * 
    **/
    cursor?: scribd_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Scribd_booksScalarFieldEnum>
  }


  /**
   * scribd_books create
   */
  export type scribd_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * The data needed to create a scribd_books.
     * 
    **/
    data: XOR<scribd_booksCreateInput, scribd_booksUncheckedCreateInput>
  }


  /**
   * scribd_books createMany
   */
  export type scribd_booksCreateManyArgs = {
    /**
     * The data used to create many scribd_books.
     * 
    **/
    data: Enumerable<scribd_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * scribd_books update
   */
  export type scribd_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * The data needed to update a scribd_books.
     * 
    **/
    data: XOR<scribd_booksUpdateInput, scribd_booksUncheckedUpdateInput>
    /**
     * Choose, which scribd_books to update.
     * 
    **/
    where: scribd_booksWhereUniqueInput
  }


  /**
   * scribd_books updateMany
   */
  export type scribd_booksUpdateManyArgs = {
    /**
     * The data used to update scribd_books.
     * 
    **/
    data: XOR<scribd_booksUpdateManyMutationInput, scribd_booksUncheckedUpdateManyInput>
    /**
     * Filter which scribd_books to update
     * 
    **/
    where?: scribd_booksWhereInput
  }


  /**
   * scribd_books upsert
   */
  export type scribd_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * The filter to search for the scribd_books to update in case it exists.
     * 
    **/
    where: scribd_booksWhereUniqueInput
    /**
     * In case the scribd_books found by the `where` argument doesn't exist, create a new scribd_books with this data.
     * 
    **/
    create: XOR<scribd_booksCreateInput, scribd_booksUncheckedCreateInput>
    /**
     * In case the scribd_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<scribd_booksUpdateInput, scribd_booksUncheckedUpdateInput>
  }


  /**
   * scribd_books delete
   */
  export type scribd_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
    /**
     * Filter which scribd_books to delete.
     * 
    **/
    where: scribd_booksWhereUniqueInput
  }


  /**
   * scribd_books deleteMany
   */
  export type scribd_booksDeleteManyArgs = {
    /**
     * Filter which scribd_books to delete
     * 
    **/
    where?: scribd_booksWhereInput
  }


  /**
   * scribd_books: findUniqueOrThrow
   */
  export type scribd_booksFindUniqueOrThrowArgs = scribd_booksFindUniqueArgsBase
      

  /**
   * scribd_books: findFirstOrThrow
   */
  export type scribd_booksFindFirstOrThrowArgs = scribd_booksFindFirstArgsBase
      

  /**
   * scribd_books without action
   */
  export type scribd_booksArgs = {
    /**
     * Select specific fields to fetch from the scribd_books
     * 
    **/
    select?: scribd_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_booksInclude | null
  }



  /**
   * Model scribd_transaction
   */


  export type AggregateScribd_transaction = {
    _count: Scribd_transactionCountAggregateOutputType | null
    _avg: Scribd_transactionAvgAggregateOutputType | null
    _sum: Scribd_transactionSumAggregateOutputType | null
    _min: Scribd_transactionMinAggregateOutputType | null
    _max: Scribd_transactionMaxAggregateOutputType | null
  }

  export type Scribd_transactionAvgAggregateOutputType = {
    S_No: number | null
    Amount_owed_for_this_interaction: number | null
    Price_in_original_currency: number | null
    Digital_list_price: number | null
    ISBN: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    converted_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    exchange_rate: number | null
    converted_inr_full: number | null
  }

  export type Scribd_transactionSumAggregateOutputType = {
    S_No: number | null
    Amount_owed_for_this_interaction: number | null
    Price_in_original_currency: number | null
    Digital_list_price: number | null
    ISBN: bigint | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    converted_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    exchange_rate: number | null
    converted_inr_full: number | null
  }

  export type Scribd_transactionMinAggregateOutputType = {
    S_No: number | null
    Payout_month: Date | null
    Publisher: string | null
    Amount_owed_for_this_interaction: number | null
    Amount_owed_currency: string | null
    Price_in_original_currency: number | null
    Digital_list_price: number | null
    Original_currency: string | null
    Price_type: string | null
    ISBN: bigint | null
    Title: string | null
    Authors: string | null
    Imprints: string | null
    Viewed: string | null
    Payout_type: string | null
    Start_date_of_interaction: Date | null
    Last_date_of_interaction: Date | null
    Country_of_reader: string | null
    Unique_interaction_ID: string | null
    ISO_Country_Code: string | null
    Threshold_Date: Date | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    converted_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
    exchange_rate: number | null
    converted_inr_full: number | null
  }

  export type Scribd_transactionMaxAggregateOutputType = {
    S_No: number | null
    Payout_month: Date | null
    Publisher: string | null
    Amount_owed_for_this_interaction: number | null
    Amount_owed_currency: string | null
    Price_in_original_currency: number | null
    Digital_list_price: number | null
    Original_currency: string | null
    Price_type: string | null
    ISBN: bigint | null
    Title: string | null
    Authors: string | null
    Imprints: string | null
    Viewed: string | null
    Payout_type: string | null
    Start_date_of_interaction: Date | null
    Last_date_of_interaction: Date | null
    Country_of_reader: string | null
    Unique_interaction_ID: string | null
    ISO_Country_Code: string | null
    Threshold_Date: Date | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    converted_inr: number | null
    user_id: number | null
    copyright_owner: number | null
    status: string | null
    exchange_rate: number | null
    converted_inr_full: number | null
  }

  export type Scribd_transactionCountAggregateOutputType = {
    S_No: number
    Payout_month: number
    Publisher: number
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: number
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: number
    Price_type: number
    ISBN: number
    Title: number
    Authors: number
    Imprints: number
    Viewed: number
    Payout_type: number
    Start_date_of_interaction: number
    Last_date_of_interaction: number
    Country_of_reader: number
    Unique_interaction_ID: number
    ISO_Country_Code: number
    Threshold_Date: number
    book_id: number
    author_id: number
    language_id: number
    converted_inr: number
    user_id: number
    copyright_owner: number
    status: number
    exchange_rate: number
    converted_inr_full: number
    _all: number
  }


  export type Scribd_transactionAvgAggregateInputType = {
    S_No?: true
    Amount_owed_for_this_interaction?: true
    Price_in_original_currency?: true
    Digital_list_price?: true
    ISBN?: true
    book_id?: true
    author_id?: true
    language_id?: true
    converted_inr?: true
    user_id?: true
    copyright_owner?: true
    exchange_rate?: true
    converted_inr_full?: true
  }

  export type Scribd_transactionSumAggregateInputType = {
    S_No?: true
    Amount_owed_for_this_interaction?: true
    Price_in_original_currency?: true
    Digital_list_price?: true
    ISBN?: true
    book_id?: true
    author_id?: true
    language_id?: true
    converted_inr?: true
    user_id?: true
    copyright_owner?: true
    exchange_rate?: true
    converted_inr_full?: true
  }

  export type Scribd_transactionMinAggregateInputType = {
    S_No?: true
    Payout_month?: true
    Publisher?: true
    Amount_owed_for_this_interaction?: true
    Amount_owed_currency?: true
    Price_in_original_currency?: true
    Digital_list_price?: true
    Original_currency?: true
    Price_type?: true
    ISBN?: true
    Title?: true
    Authors?: true
    Imprints?: true
    Viewed?: true
    Payout_type?: true
    Start_date_of_interaction?: true
    Last_date_of_interaction?: true
    Country_of_reader?: true
    Unique_interaction_ID?: true
    ISO_Country_Code?: true
    Threshold_Date?: true
    book_id?: true
    author_id?: true
    language_id?: true
    converted_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    exchange_rate?: true
    converted_inr_full?: true
  }

  export type Scribd_transactionMaxAggregateInputType = {
    S_No?: true
    Payout_month?: true
    Publisher?: true
    Amount_owed_for_this_interaction?: true
    Amount_owed_currency?: true
    Price_in_original_currency?: true
    Digital_list_price?: true
    Original_currency?: true
    Price_type?: true
    ISBN?: true
    Title?: true
    Authors?: true
    Imprints?: true
    Viewed?: true
    Payout_type?: true
    Start_date_of_interaction?: true
    Last_date_of_interaction?: true
    Country_of_reader?: true
    Unique_interaction_ID?: true
    ISO_Country_Code?: true
    Threshold_Date?: true
    book_id?: true
    author_id?: true
    language_id?: true
    converted_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    exchange_rate?: true
    converted_inr_full?: true
  }

  export type Scribd_transactionCountAggregateInputType = {
    S_No?: true
    Payout_month?: true
    Publisher?: true
    Amount_owed_for_this_interaction?: true
    Amount_owed_currency?: true
    Price_in_original_currency?: true
    Digital_list_price?: true
    Original_currency?: true
    Price_type?: true
    ISBN?: true
    Title?: true
    Authors?: true
    Imprints?: true
    Viewed?: true
    Payout_type?: true
    Start_date_of_interaction?: true
    Last_date_of_interaction?: true
    Country_of_reader?: true
    Unique_interaction_ID?: true
    ISO_Country_Code?: true
    Threshold_Date?: true
    book_id?: true
    author_id?: true
    language_id?: true
    converted_inr?: true
    user_id?: true
    copyright_owner?: true
    status?: true
    exchange_rate?: true
    converted_inr_full?: true
    _all?: true
  }

  export type Scribd_transactionAggregateArgs = {
    /**
     * Filter which scribd_transaction to aggregate.
     * 
    **/
    where?: scribd_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: scribd_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scribd_transactions
    **/
    _count?: true | Scribd_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Scribd_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Scribd_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Scribd_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Scribd_transactionMaxAggregateInputType
  }

  export type GetScribd_transactionAggregateType<T extends Scribd_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateScribd_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScribd_transaction[P]>
      : GetScalarType<T[P], AggregateScribd_transaction[P]>
  }




  export type Scribd_transactionGroupByArgs = {
    where?: scribd_transactionWhereInput
    orderBy?: Enumerable<scribd_transactionOrderByWithAggregationInput>
    by: Array<Scribd_transactionScalarFieldEnum>
    having?: scribd_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Scribd_transactionCountAggregateInputType | true
    _avg?: Scribd_transactionAvgAggregateInputType
    _sum?: Scribd_transactionSumAggregateInputType
    _min?: Scribd_transactionMinAggregateInputType
    _max?: Scribd_transactionMaxAggregateInputType
  }


  export type Scribd_transactionGroupByOutputType = {
    S_No: number
    Payout_month: Date
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date
    Last_date_of_interaction: Date
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date
    book_id: number
    author_id: number
    language_id: number | null
    converted_inr: number
    user_id: number | null
    copyright_owner: number | null
    status: string
    exchange_rate: number
    converted_inr_full: number | null
    _count: Scribd_transactionCountAggregateOutputType | null
    _avg: Scribd_transactionAvgAggregateOutputType | null
    _sum: Scribd_transactionSumAggregateOutputType | null
    _min: Scribd_transactionMinAggregateOutputType | null
    _max: Scribd_transactionMaxAggregateOutputType | null
  }

  type GetScribd_transactionGroupByPayload<T extends Scribd_transactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Scribd_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Scribd_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Scribd_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Scribd_transactionGroupByOutputType[P]>
        }
      >
    >


  export type scribd_transactionSelect = {
    S_No?: boolean
    Payout_month?: boolean
    Publisher?: boolean
    Amount_owed_for_this_interaction?: boolean
    Amount_owed_currency?: boolean
    Price_in_original_currency?: boolean
    Digital_list_price?: boolean
    Original_currency?: boolean
    Price_type?: boolean
    ISBN?: boolean
    Title?: boolean
    Authors?: boolean
    Imprints?: boolean
    Viewed?: boolean
    Payout_type?: boolean
    Start_date_of_interaction?: boolean
    Last_date_of_interaction?: boolean
    Country_of_reader?: boolean
    Unique_interaction_ID?: boolean
    ISO_Country_Code?: boolean
    Threshold_Date?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    language_id?: boolean
    converted_inr?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    status?: boolean
    exchange_rate?: boolean
    converted_inr_full?: boolean
  }


  export type scribd_transactionInclude = {
    book?: boolean | book_tblArgs
  } 

  export type scribd_transactionGetPayload<S extends boolean | null | undefined | scribd_transactionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? scribd_transaction :
    S extends undefined ? never :
    S extends { include: any } & (scribd_transactionArgs | scribd_transactionFindManyArgs)
    ? scribd_transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (scribd_transactionArgs | scribd_transactionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof scribd_transaction ? scribd_transaction[P] : never
  } 
      : scribd_transaction


  type scribd_transactionCountArgs = Merge<
    Omit<scribd_transactionFindManyArgs, 'select' | 'include'> & {
      select?: Scribd_transactionCountAggregateInputType | true
    }
  >

  export interface scribd_transactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Scribd_transaction that matches the filter.
     * @param {scribd_transactionFindUniqueArgs} args - Arguments to find a Scribd_transaction
     * @example
     * // Get one Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends scribd_transactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, scribd_transactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'scribd_transaction'> extends True ? Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>> : Prisma__scribd_transactionClient<scribd_transactionGetPayload<T> | null, null>

    /**
     * Find the first Scribd_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_transactionFindFirstArgs} args - Arguments to find a Scribd_transaction
     * @example
     * // Get one Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends scribd_transactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, scribd_transactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'scribd_transaction'> extends True ? Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>> : Prisma__scribd_transactionClient<scribd_transactionGetPayload<T> | null, null>

    /**
     * Find zero or more Scribd_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scribd_transactions
     * const scribd_transactions = await prisma.scribd_transaction.findMany()
     * 
     * // Get first 10 Scribd_transactions
     * const scribd_transactions = await prisma.scribd_transaction.findMany({ take: 10 })
     * 
     * // Only select the `S_No`
     * const scribd_transactionWithS_NoOnly = await prisma.scribd_transaction.findMany({ select: { S_No: true } })
     * 
    **/
    findMany<T extends scribd_transactionFindManyArgs>(
      args?: SelectSubset<T, scribd_transactionFindManyArgs>
    ): PrismaPromise<Array<scribd_transactionGetPayload<T>>>

    /**
     * Create a Scribd_transaction.
     * @param {scribd_transactionCreateArgs} args - Arguments to create a Scribd_transaction.
     * @example
     * // Create one Scribd_transaction
     * const Scribd_transaction = await prisma.scribd_transaction.create({
     *   data: {
     *     // ... data to create a Scribd_transaction
     *   }
     * })
     * 
    **/
    create<T extends scribd_transactionCreateArgs>(
      args: SelectSubset<T, scribd_transactionCreateArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Create many Scribd_transactions.
     *     @param {scribd_transactionCreateManyArgs} args - Arguments to create many Scribd_transactions.
     *     @example
     *     // Create many Scribd_transactions
     *     const scribd_transaction = await prisma.scribd_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends scribd_transactionCreateManyArgs>(
      args?: SelectSubset<T, scribd_transactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Scribd_transaction.
     * @param {scribd_transactionDeleteArgs} args - Arguments to delete one Scribd_transaction.
     * @example
     * // Delete one Scribd_transaction
     * const Scribd_transaction = await prisma.scribd_transaction.delete({
     *   where: {
     *     // ... filter to delete one Scribd_transaction
     *   }
     * })
     * 
    **/
    delete<T extends scribd_transactionDeleteArgs>(
      args: SelectSubset<T, scribd_transactionDeleteArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Update one Scribd_transaction.
     * @param {scribd_transactionUpdateArgs} args - Arguments to update one Scribd_transaction.
     * @example
     * // Update one Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends scribd_transactionUpdateArgs>(
      args: SelectSubset<T, scribd_transactionUpdateArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Delete zero or more Scribd_transactions.
     * @param {scribd_transactionDeleteManyArgs} args - Arguments to filter Scribd_transactions to delete.
     * @example
     * // Delete a few Scribd_transactions
     * const { count } = await prisma.scribd_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends scribd_transactionDeleteManyArgs>(
      args?: SelectSubset<T, scribd_transactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scribd_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scribd_transactions
     * const scribd_transaction = await prisma.scribd_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends scribd_transactionUpdateManyArgs>(
      args: SelectSubset<T, scribd_transactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Scribd_transaction.
     * @param {scribd_transactionUpsertArgs} args - Arguments to update or create a Scribd_transaction.
     * @example
     * // Update or create a Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.upsert({
     *   create: {
     *     // ... data to create a Scribd_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scribd_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends scribd_transactionUpsertArgs>(
      args: SelectSubset<T, scribd_transactionUpsertArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Find one Scribd_transaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {scribd_transactionFindUniqueOrThrowArgs} args - Arguments to find a Scribd_transaction
     * @example
     * // Get one Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends scribd_transactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, scribd_transactionFindUniqueOrThrowArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Find the first Scribd_transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_transactionFindFirstOrThrowArgs} args - Arguments to find a Scribd_transaction
     * @example
     * // Get one Scribd_transaction
     * const scribd_transaction = await prisma.scribd_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends scribd_transactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, scribd_transactionFindFirstOrThrowArgs>
    ): Prisma__scribd_transactionClient<scribd_transactionGetPayload<T>>

    /**
     * Count the number of Scribd_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scribd_transactionCountArgs} args - Arguments to filter Scribd_transactions to count.
     * @example
     * // Count the number of Scribd_transactions
     * const count = await prisma.scribd_transaction.count({
     *   where: {
     *     // ... the filter for the Scribd_transactions we want to count
     *   }
     * })
    **/
    count<T extends scribd_transactionCountArgs>(
      args?: Subset<T, scribd_transactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Scribd_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scribd_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Scribd_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Scribd_transactionAggregateArgs>(args: Subset<T, Scribd_transactionAggregateArgs>): PrismaPromise<GetScribd_transactionAggregateType<T>>

    /**
     * Group by Scribd_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Scribd_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Scribd_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Scribd_transactionGroupByArgs['orderBy'] }
        : { orderBy?: Scribd_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Scribd_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScribd_transactionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for scribd_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__scribd_transactionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * scribd_transaction base type for findUnique actions
   */
  export type scribd_transactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * Filter, which scribd_transaction to fetch.
     * 
    **/
    where: scribd_transactionWhereUniqueInput
  }

  /**
   * scribd_transaction: findUnique
   */
  export interface scribd_transactionFindUniqueArgs extends scribd_transactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * scribd_transaction base type for findFirst actions
   */
  export type scribd_transactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * Filter, which scribd_transaction to fetch.
     * 
    **/
    where?: scribd_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scribd_transactions.
     * 
    **/
    cursor?: scribd_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scribd_transactions.
     * 
    **/
    distinct?: Enumerable<Scribd_transactionScalarFieldEnum>
  }

  /**
   * scribd_transaction: findFirst
   */
  export interface scribd_transactionFindFirstArgs extends scribd_transactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * scribd_transaction findMany
   */
  export type scribd_transactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * Filter, which scribd_transactions to fetch.
     * 
    **/
    where?: scribd_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scribd_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<scribd_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scribd_transactions.
     * 
    **/
    cursor?: scribd_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scribd_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scribd_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Scribd_transactionScalarFieldEnum>
  }


  /**
   * scribd_transaction create
   */
  export type scribd_transactionCreateArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * The data needed to create a scribd_transaction.
     * 
    **/
    data: XOR<scribd_transactionCreateInput, scribd_transactionUncheckedCreateInput>
  }


  /**
   * scribd_transaction createMany
   */
  export type scribd_transactionCreateManyArgs = {
    /**
     * The data used to create many scribd_transactions.
     * 
    **/
    data: Enumerable<scribd_transactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * scribd_transaction update
   */
  export type scribd_transactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * The data needed to update a scribd_transaction.
     * 
    **/
    data: XOR<scribd_transactionUpdateInput, scribd_transactionUncheckedUpdateInput>
    /**
     * Choose, which scribd_transaction to update.
     * 
    **/
    where: scribd_transactionWhereUniqueInput
  }


  /**
   * scribd_transaction updateMany
   */
  export type scribd_transactionUpdateManyArgs = {
    /**
     * The data used to update scribd_transactions.
     * 
    **/
    data: XOR<scribd_transactionUpdateManyMutationInput, scribd_transactionUncheckedUpdateManyInput>
    /**
     * Filter which scribd_transactions to update
     * 
    **/
    where?: scribd_transactionWhereInput
  }


  /**
   * scribd_transaction upsert
   */
  export type scribd_transactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * The filter to search for the scribd_transaction to update in case it exists.
     * 
    **/
    where: scribd_transactionWhereUniqueInput
    /**
     * In case the scribd_transaction found by the `where` argument doesn't exist, create a new scribd_transaction with this data.
     * 
    **/
    create: XOR<scribd_transactionCreateInput, scribd_transactionUncheckedCreateInput>
    /**
     * In case the scribd_transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<scribd_transactionUpdateInput, scribd_transactionUncheckedUpdateInput>
  }


  /**
   * scribd_transaction delete
   */
  export type scribd_transactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
    /**
     * Filter which scribd_transaction to delete.
     * 
    **/
    where: scribd_transactionWhereUniqueInput
  }


  /**
   * scribd_transaction deleteMany
   */
  export type scribd_transactionDeleteManyArgs = {
    /**
     * Filter which scribd_transactions to delete
     * 
    **/
    where?: scribd_transactionWhereInput
  }


  /**
   * scribd_transaction: findUniqueOrThrow
   */
  export type scribd_transactionFindUniqueOrThrowArgs = scribd_transactionFindUniqueArgsBase
      

  /**
   * scribd_transaction: findFirstOrThrow
   */
  export type scribd_transactionFindFirstOrThrowArgs = scribd_transactionFindFirstArgsBase
      

  /**
   * scribd_transaction without action
   */
  export type scribd_transactionArgs = {
    /**
     * Select specific fields to fetch from the scribd_transaction
     * 
    **/
    select?: scribd_transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scribd_transactionInclude | null
  }



  /**
   * Model storytel_books
   */


  export type AggregateStorytel_books = {
    _count: Storytel_booksCountAggregateOutputType | null
    _avg: Storytel_booksAvgAggregateOutputType | null
    _sum: Storytel_booksSumAggregateOutputType | null
    _min: Storytel_booksMinAggregateOutputType | null
    _max: Storytel_booksMaxAggregateOutputType | null
  }

  export type Storytel_booksAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    genre_id: number | null
    type_of_book: number | null
  }

  export type Storytel_booksSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    genre_id: number | null
    type_of_book: number | null
  }

  export type Storytel_booksMinAggregateOutputType = {
    id: number | null
    storytel_book_id: string | null
    isbn: string | null
    title: string | null
    author_name: string | null
    narrator: string | null
    category: string | null
    publication_date: Date | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    genre_id: number | null
    type_of_book: number | null
  }

  export type Storytel_booksMaxAggregateOutputType = {
    id: number | null
    storytel_book_id: string | null
    isbn: string | null
    title: string | null
    author_name: string | null
    narrator: string | null
    category: string | null
    publication_date: Date | null
    book_id: number | null
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    genre_id: number | null
    type_of_book: number | null
  }

  export type Storytel_booksCountAggregateOutputType = {
    id: number
    storytel_book_id: number
    isbn: number
    title: number
    author_name: number
    narrator: number
    category: number
    publication_date: number
    book_id: number
    author_id: number
    copyright_owner: number
    language_id: number
    genre_id: number
    type_of_book: number
    _all: number
  }


  export type Storytel_booksAvgAggregateInputType = {
    id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    genre_id?: true
    type_of_book?: true
  }

  export type Storytel_booksSumAggregateInputType = {
    id?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    genre_id?: true
    type_of_book?: true
  }

  export type Storytel_booksMinAggregateInputType = {
    id?: true
    storytel_book_id?: true
    isbn?: true
    title?: true
    author_name?: true
    narrator?: true
    category?: true
    publication_date?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    genre_id?: true
    type_of_book?: true
  }

  export type Storytel_booksMaxAggregateInputType = {
    id?: true
    storytel_book_id?: true
    isbn?: true
    title?: true
    author_name?: true
    narrator?: true
    category?: true
    publication_date?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    genre_id?: true
    type_of_book?: true
  }

  export type Storytel_booksCountAggregateInputType = {
    id?: true
    storytel_book_id?: true
    isbn?: true
    title?: true
    author_name?: true
    narrator?: true
    category?: true
    publication_date?: true
    book_id?: true
    author_id?: true
    copyright_owner?: true
    language_id?: true
    genre_id?: true
    type_of_book?: true
    _all?: true
  }

  export type Storytel_booksAggregateArgs = {
    /**
     * Filter which storytel_books to aggregate.
     * 
    **/
    where?: storytel_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_books to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: storytel_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned storytel_books
    **/
    _count?: true | Storytel_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Storytel_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Storytel_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Storytel_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Storytel_booksMaxAggregateInputType
  }

  export type GetStorytel_booksAggregateType<T extends Storytel_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateStorytel_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorytel_books[P]>
      : GetScalarType<T[P], AggregateStorytel_books[P]>
  }




  export type Storytel_booksGroupByArgs = {
    where?: storytel_booksWhereInput
    orderBy?: Enumerable<storytel_booksOrderByWithAggregationInput>
    by: Array<Storytel_booksScalarFieldEnum>
    having?: storytel_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Storytel_booksCountAggregateInputType | true
    _avg?: Storytel_booksAvgAggregateInputType
    _sum?: Storytel_booksSumAggregateInputType
    _min?: Storytel_booksMinAggregateInputType
    _max?: Storytel_booksMaxAggregateInputType
  }


  export type Storytel_booksGroupByOutputType = {
    id: number
    storytel_book_id: string | null
    isbn: string | null
    title: string | null
    author_name: string | null
    narrator: string | null
    category: string | null
    publication_date: Date | null
    book_id: number
    author_id: number | null
    copyright_owner: number | null
    language_id: number | null
    genre_id: number | null
    type_of_book: number | null
    _count: Storytel_booksCountAggregateOutputType | null
    _avg: Storytel_booksAvgAggregateOutputType | null
    _sum: Storytel_booksSumAggregateOutputType | null
    _min: Storytel_booksMinAggregateOutputType | null
    _max: Storytel_booksMaxAggregateOutputType | null
  }

  type GetStorytel_booksGroupByPayload<T extends Storytel_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Storytel_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Storytel_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Storytel_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Storytel_booksGroupByOutputType[P]>
        }
      >
    >


  export type storytel_booksSelect = {
    id?: boolean
    storytel_book_id?: boolean
    isbn?: boolean
    title?: boolean
    author_name?: boolean
    narrator?: boolean
    category?: boolean
    publication_date?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    copyright_owner?: boolean
    language_id?: boolean
    genre_id?: boolean
    type_of_book?: boolean
  }


  export type storytel_booksInclude = {
    book?: boolean | book_tblArgs
  } 

  export type storytel_booksGetPayload<S extends boolean | null | undefined | storytel_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? storytel_books :
    S extends undefined ? never :
    S extends { include: any } & (storytel_booksArgs | storytel_booksFindManyArgs)
    ? storytel_books  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (storytel_booksArgs | storytel_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof storytel_books ? storytel_books[P] : never
  } 
      : storytel_books


  type storytel_booksCountArgs = Merge<
    Omit<storytel_booksFindManyArgs, 'select' | 'include'> & {
      select?: Storytel_booksCountAggregateInputType | true
    }
  >

  export interface storytel_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Storytel_books that matches the filter.
     * @param {storytel_booksFindUniqueArgs} args - Arguments to find a Storytel_books
     * @example
     * // Get one Storytel_books
     * const storytel_books = await prisma.storytel_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends storytel_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, storytel_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'storytel_books'> extends True ? Prisma__storytel_booksClient<storytel_booksGetPayload<T>> : Prisma__storytel_booksClient<storytel_booksGetPayload<T> | null, null>

    /**
     * Find the first Storytel_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_booksFindFirstArgs} args - Arguments to find a Storytel_books
     * @example
     * // Get one Storytel_books
     * const storytel_books = await prisma.storytel_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends storytel_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, storytel_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'storytel_books'> extends True ? Prisma__storytel_booksClient<storytel_booksGetPayload<T>> : Prisma__storytel_booksClient<storytel_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Storytel_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storytel_books
     * const storytel_books = await prisma.storytel_books.findMany()
     * 
     * // Get first 10 Storytel_books
     * const storytel_books = await prisma.storytel_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storytel_booksWithIdOnly = await prisma.storytel_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends storytel_booksFindManyArgs>(
      args?: SelectSubset<T, storytel_booksFindManyArgs>
    ): PrismaPromise<Array<storytel_booksGetPayload<T>>>

    /**
     * Create a Storytel_books.
     * @param {storytel_booksCreateArgs} args - Arguments to create a Storytel_books.
     * @example
     * // Create one Storytel_books
     * const Storytel_books = await prisma.storytel_books.create({
     *   data: {
     *     // ... data to create a Storytel_books
     *   }
     * })
     * 
    **/
    create<T extends storytel_booksCreateArgs>(
      args: SelectSubset<T, storytel_booksCreateArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Create many Storytel_books.
     *     @param {storytel_booksCreateManyArgs} args - Arguments to create many Storytel_books.
     *     @example
     *     // Create many Storytel_books
     *     const storytel_books = await prisma.storytel_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends storytel_booksCreateManyArgs>(
      args?: SelectSubset<T, storytel_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Storytel_books.
     * @param {storytel_booksDeleteArgs} args - Arguments to delete one Storytel_books.
     * @example
     * // Delete one Storytel_books
     * const Storytel_books = await prisma.storytel_books.delete({
     *   where: {
     *     // ... filter to delete one Storytel_books
     *   }
     * })
     * 
    **/
    delete<T extends storytel_booksDeleteArgs>(
      args: SelectSubset<T, storytel_booksDeleteArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Update one Storytel_books.
     * @param {storytel_booksUpdateArgs} args - Arguments to update one Storytel_books.
     * @example
     * // Update one Storytel_books
     * const storytel_books = await prisma.storytel_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends storytel_booksUpdateArgs>(
      args: SelectSubset<T, storytel_booksUpdateArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Delete zero or more Storytel_books.
     * @param {storytel_booksDeleteManyArgs} args - Arguments to filter Storytel_books to delete.
     * @example
     * // Delete a few Storytel_books
     * const { count } = await prisma.storytel_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends storytel_booksDeleteManyArgs>(
      args?: SelectSubset<T, storytel_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storytel_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storytel_books
     * const storytel_books = await prisma.storytel_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends storytel_booksUpdateManyArgs>(
      args: SelectSubset<T, storytel_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Storytel_books.
     * @param {storytel_booksUpsertArgs} args - Arguments to update or create a Storytel_books.
     * @example
     * // Update or create a Storytel_books
     * const storytel_books = await prisma.storytel_books.upsert({
     *   create: {
     *     // ... data to create a Storytel_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storytel_books we want to update
     *   }
     * })
    **/
    upsert<T extends storytel_booksUpsertArgs>(
      args: SelectSubset<T, storytel_booksUpsertArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Find one Storytel_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {storytel_booksFindUniqueOrThrowArgs} args - Arguments to find a Storytel_books
     * @example
     * // Get one Storytel_books
     * const storytel_books = await prisma.storytel_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends storytel_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, storytel_booksFindUniqueOrThrowArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Find the first Storytel_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_booksFindFirstOrThrowArgs} args - Arguments to find a Storytel_books
     * @example
     * // Get one Storytel_books
     * const storytel_books = await prisma.storytel_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends storytel_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, storytel_booksFindFirstOrThrowArgs>
    ): Prisma__storytel_booksClient<storytel_booksGetPayload<T>>

    /**
     * Count the number of Storytel_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_booksCountArgs} args - Arguments to filter Storytel_books to count.
     * @example
     * // Count the number of Storytel_books
     * const count = await prisma.storytel_books.count({
     *   where: {
     *     // ... the filter for the Storytel_books we want to count
     *   }
     * })
    **/
    count<T extends storytel_booksCountArgs>(
      args?: Subset<T, storytel_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Storytel_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storytel_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Storytel_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Storytel_booksAggregateArgs>(args: Subset<T, Storytel_booksAggregateArgs>): PrismaPromise<GetStorytel_booksAggregateType<T>>

    /**
     * Group by Storytel_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Storytel_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Storytel_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Storytel_booksGroupByArgs['orderBy'] }
        : { orderBy?: Storytel_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Storytel_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorytel_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for storytel_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__storytel_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * storytel_books base type for findUnique actions
   */
  export type storytel_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * Filter, which storytel_books to fetch.
     * 
    **/
    where: storytel_booksWhereUniqueInput
  }

  /**
   * storytel_books: findUnique
   */
  export interface storytel_booksFindUniqueArgs extends storytel_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * storytel_books base type for findFirst actions
   */
  export type storytel_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * Filter, which storytel_books to fetch.
     * 
    **/
    where?: storytel_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_books to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for storytel_books.
     * 
    **/
    cursor?: storytel_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of storytel_books.
     * 
    **/
    distinct?: Enumerable<Storytel_booksScalarFieldEnum>
  }

  /**
   * storytel_books: findFirst
   */
  export interface storytel_booksFindFirstArgs extends storytel_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * storytel_books findMany
   */
  export type storytel_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * Filter, which storytel_books to fetch.
     * 
    **/
    where?: storytel_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_books to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing storytel_books.
     * 
    **/
    cursor?: storytel_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Storytel_booksScalarFieldEnum>
  }


  /**
   * storytel_books create
   */
  export type storytel_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * The data needed to create a storytel_books.
     * 
    **/
    data: XOR<storytel_booksCreateInput, storytel_booksUncheckedCreateInput>
  }


  /**
   * storytel_books createMany
   */
  export type storytel_booksCreateManyArgs = {
    /**
     * The data used to create many storytel_books.
     * 
    **/
    data: Enumerable<storytel_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * storytel_books update
   */
  export type storytel_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * The data needed to update a storytel_books.
     * 
    **/
    data: XOR<storytel_booksUpdateInput, storytel_booksUncheckedUpdateInput>
    /**
     * Choose, which storytel_books to update.
     * 
    **/
    where: storytel_booksWhereUniqueInput
  }


  /**
   * storytel_books updateMany
   */
  export type storytel_booksUpdateManyArgs = {
    /**
     * The data used to update storytel_books.
     * 
    **/
    data: XOR<storytel_booksUpdateManyMutationInput, storytel_booksUncheckedUpdateManyInput>
    /**
     * Filter which storytel_books to update
     * 
    **/
    where?: storytel_booksWhereInput
  }


  /**
   * storytel_books upsert
   */
  export type storytel_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * The filter to search for the storytel_books to update in case it exists.
     * 
    **/
    where: storytel_booksWhereUniqueInput
    /**
     * In case the storytel_books found by the `where` argument doesn't exist, create a new storytel_books with this data.
     * 
    **/
    create: XOR<storytel_booksCreateInput, storytel_booksUncheckedCreateInput>
    /**
     * In case the storytel_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<storytel_booksUpdateInput, storytel_booksUncheckedUpdateInput>
  }


  /**
   * storytel_books delete
   */
  export type storytel_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
    /**
     * Filter which storytel_books to delete.
     * 
    **/
    where: storytel_booksWhereUniqueInput
  }


  /**
   * storytel_books deleteMany
   */
  export type storytel_booksDeleteManyArgs = {
    /**
     * Filter which storytel_books to delete
     * 
    **/
    where?: storytel_booksWhereInput
  }


  /**
   * storytel_books: findUniqueOrThrow
   */
  export type storytel_booksFindUniqueOrThrowArgs = storytel_booksFindUniqueArgsBase
      

  /**
   * storytel_books: findFirstOrThrow
   */
  export type storytel_booksFindFirstOrThrowArgs = storytel_booksFindFirstArgsBase
      

  /**
   * storytel_books without action
   */
  export type storytel_booksArgs = {
    /**
     * Select specific fields to fetch from the storytel_books
     * 
    **/
    select?: storytel_booksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_booksInclude | null
  }



  /**
   * Model storytel_transactions
   */


  export type AggregateStorytel_transactions = {
    _count: Storytel_transactionsCountAggregateOutputType | null
    _avg: Storytel_transactionsAvgAggregateOutputType | null
    _sum: Storytel_transactionsSumAggregateOutputType | null
    _min: Storytel_transactionsMinAggregateOutputType | null
    _max: Storytel_transactionsMaxAggregateOutputType | null
  }

  export type Storytel_transactionsAvgAggregateOutputType = {
    id: number | null
    no_of_units: number | null
    net_receipts_per_hour_local: number | null
    net_receipts_per_hour_inr: number | null
    book_length_in_hours: number | null
    price_per_unit: number | null
    remuneration_eur: number | null
    remuneration_inr: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    user_id: number | null
    copyright_owner: number | null
    final_royalty_value: number | null
  }

  export type Storytel_transactionsSumAggregateOutputType = {
    id: number | null
    no_of_units: number | null
    net_receipts_per_hour_local: number | null
    net_receipts_per_hour_inr: number | null
    book_length_in_hours: number | null
    price_per_unit: number | null
    remuneration_eur: number | null
    remuneration_inr: number | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    user_id: bigint | null
    copyright_owner: number | null
    final_royalty_value: number | null
  }

  export type Storytel_transactionsMinAggregateOutputType = {
    id: number | null
    author: string | null
    title: string | null
    isbn: string | null
    country: string | null
    price_model: string | null
    no_of_units: number | null
    net_receipts_per_hour_local: number | null
    ecb_exchange_rate: string | null
    net_receipts_per_hour_inr: number | null
    book_length_in_hours: number | null
    price_per_unit: number | null
    remuneration_eur: number | null
    remuneration_inr: number | null
    publisher: string | null
    imprint: string | null
    consumption_dates: string | null
    book_type: string | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    user_id: bigint | null
    copyright_owner: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
  }

  export type Storytel_transactionsMaxAggregateOutputType = {
    id: number | null
    author: string | null
    title: string | null
    isbn: string | null
    country: string | null
    price_model: string | null
    no_of_units: number | null
    net_receipts_per_hour_local: number | null
    ecb_exchange_rate: string | null
    net_receipts_per_hour_inr: number | null
    book_length_in_hours: number | null
    price_per_unit: number | null
    remuneration_eur: number | null
    remuneration_inr: number | null
    publisher: string | null
    imprint: string | null
    consumption_dates: string | null
    book_type: string | null
    book_id: number | null
    author_id: number | null
    language_id: number | null
    user_id: bigint | null
    copyright_owner: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
  }

  export type Storytel_transactionsCountAggregateOutputType = {
    id: number
    author: number
    title: number
    isbn: number
    country: number
    price_model: number
    no_of_units: number
    net_receipts_per_hour_local: number
    ecb_exchange_rate: number
    net_receipts_per_hour_inr: number
    book_length_in_hours: number
    price_per_unit: number
    remuneration_eur: number
    remuneration_inr: number
    publisher: number
    imprint: number
    consumption_dates: number
    book_type: number
    book_id: number
    author_id: number
    language_id: number
    user_id: number
    copyright_owner: number
    final_royalty_value: number
    transaction_date: number
    status: number
    _all: number
  }


  export type Storytel_transactionsAvgAggregateInputType = {
    id?: true
    no_of_units?: true
    net_receipts_per_hour_local?: true
    net_receipts_per_hour_inr?: true
    book_length_in_hours?: true
    price_per_unit?: true
    remuneration_eur?: true
    remuneration_inr?: true
    book_id?: true
    author_id?: true
    language_id?: true
    user_id?: true
    copyright_owner?: true
    final_royalty_value?: true
  }

  export type Storytel_transactionsSumAggregateInputType = {
    id?: true
    no_of_units?: true
    net_receipts_per_hour_local?: true
    net_receipts_per_hour_inr?: true
    book_length_in_hours?: true
    price_per_unit?: true
    remuneration_eur?: true
    remuneration_inr?: true
    book_id?: true
    author_id?: true
    language_id?: true
    user_id?: true
    copyright_owner?: true
    final_royalty_value?: true
  }

  export type Storytel_transactionsMinAggregateInputType = {
    id?: true
    author?: true
    title?: true
    isbn?: true
    country?: true
    price_model?: true
    no_of_units?: true
    net_receipts_per_hour_local?: true
    ecb_exchange_rate?: true
    net_receipts_per_hour_inr?: true
    book_length_in_hours?: true
    price_per_unit?: true
    remuneration_eur?: true
    remuneration_inr?: true
    publisher?: true
    imprint?: true
    consumption_dates?: true
    book_type?: true
    book_id?: true
    author_id?: true
    language_id?: true
    user_id?: true
    copyright_owner?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
  }

  export type Storytel_transactionsMaxAggregateInputType = {
    id?: true
    author?: true
    title?: true
    isbn?: true
    country?: true
    price_model?: true
    no_of_units?: true
    net_receipts_per_hour_local?: true
    ecb_exchange_rate?: true
    net_receipts_per_hour_inr?: true
    book_length_in_hours?: true
    price_per_unit?: true
    remuneration_eur?: true
    remuneration_inr?: true
    publisher?: true
    imprint?: true
    consumption_dates?: true
    book_type?: true
    book_id?: true
    author_id?: true
    language_id?: true
    user_id?: true
    copyright_owner?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
  }

  export type Storytel_transactionsCountAggregateInputType = {
    id?: true
    author?: true
    title?: true
    isbn?: true
    country?: true
    price_model?: true
    no_of_units?: true
    net_receipts_per_hour_local?: true
    ecb_exchange_rate?: true
    net_receipts_per_hour_inr?: true
    book_length_in_hours?: true
    price_per_unit?: true
    remuneration_eur?: true
    remuneration_inr?: true
    publisher?: true
    imprint?: true
    consumption_dates?: true
    book_type?: true
    book_id?: true
    author_id?: true
    language_id?: true
    user_id?: true
    copyright_owner?: true
    final_royalty_value?: true
    transaction_date?: true
    status?: true
    _all?: true
  }

  export type Storytel_transactionsAggregateArgs = {
    /**
     * Filter which storytel_transactions to aggregate.
     * 
    **/
    where?: storytel_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: storytel_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned storytel_transactions
    **/
    _count?: true | Storytel_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Storytel_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Storytel_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Storytel_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Storytel_transactionsMaxAggregateInputType
  }

  export type GetStorytel_transactionsAggregateType<T extends Storytel_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateStorytel_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorytel_transactions[P]>
      : GetScalarType<T[P], AggregateStorytel_transactions[P]>
  }




  export type Storytel_transactionsGroupByArgs = {
    where?: storytel_transactionsWhereInput
    orderBy?: Enumerable<storytel_transactionsOrderByWithAggregationInput>
    by: Array<Storytel_transactionsScalarFieldEnum>
    having?: storytel_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Storytel_transactionsCountAggregateInputType | true
    _avg?: Storytel_transactionsAvgAggregateInputType
    _sum?: Storytel_transactionsSumAggregateInputType
    _min?: Storytel_transactionsMinAggregateInputType
    _max?: Storytel_transactionsMaxAggregateInputType
  }


  export type Storytel_transactionsGroupByOutputType = {
    id: number
    author: string | null
    title: string | null
    isbn: string | null
    country: string | null
    price_model: string | null
    no_of_units: number | null
    net_receipts_per_hour_local: number | null
    ecb_exchange_rate: string | null
    net_receipts_per_hour_inr: number | null
    book_length_in_hours: number | null
    price_per_unit: number | null
    remuneration_eur: number | null
    remuneration_inr: number | null
    publisher: string | null
    imprint: string | null
    consumption_dates: string | null
    book_type: string | null
    book_id: number
    author_id: number | null
    language_id: number | null
    user_id: bigint | null
    copyright_owner: number | null
    final_royalty_value: number | null
    transaction_date: Date | null
    status: string | null
    _count: Storytel_transactionsCountAggregateOutputType | null
    _avg: Storytel_transactionsAvgAggregateOutputType | null
    _sum: Storytel_transactionsSumAggregateOutputType | null
    _min: Storytel_transactionsMinAggregateOutputType | null
    _max: Storytel_transactionsMaxAggregateOutputType | null
  }

  type GetStorytel_transactionsGroupByPayload<T extends Storytel_transactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Storytel_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Storytel_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Storytel_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Storytel_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type storytel_transactionsSelect = {
    id?: boolean
    author?: boolean
    title?: boolean
    isbn?: boolean
    country?: boolean
    price_model?: boolean
    no_of_units?: boolean
    net_receipts_per_hour_local?: boolean
    ecb_exchange_rate?: boolean
    net_receipts_per_hour_inr?: boolean
    book_length_in_hours?: boolean
    price_per_unit?: boolean
    remuneration_eur?: boolean
    remuneration_inr?: boolean
    publisher?: boolean
    imprint?: boolean
    consumption_dates?: boolean
    book_type?: boolean
    book?: boolean | book_tblArgs
    book_id?: boolean
    author_id?: boolean
    language_id?: boolean
    user_id?: boolean
    copyright_owner?: boolean
    final_royalty_value?: boolean
    transaction_date?: boolean
    status?: boolean
  }


  export type storytel_transactionsInclude = {
    book?: boolean | book_tblArgs
  } 

  export type storytel_transactionsGetPayload<S extends boolean | null | undefined | storytel_transactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? storytel_transactions :
    S extends undefined ? never :
    S extends { include: any } & (storytel_transactionsArgs | storytel_transactionsFindManyArgs)
    ? storytel_transactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (storytel_transactionsArgs | storytel_transactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'book' ? book_tblGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof storytel_transactions ? storytel_transactions[P] : never
  } 
      : storytel_transactions


  type storytel_transactionsCountArgs = Merge<
    Omit<storytel_transactionsFindManyArgs, 'select' | 'include'> & {
      select?: Storytel_transactionsCountAggregateInputType | true
    }
  >

  export interface storytel_transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Storytel_transactions that matches the filter.
     * @param {storytel_transactionsFindUniqueArgs} args - Arguments to find a Storytel_transactions
     * @example
     * // Get one Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends storytel_transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, storytel_transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'storytel_transactions'> extends True ? Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>> : Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T> | null, null>

    /**
     * Find the first Storytel_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_transactionsFindFirstArgs} args - Arguments to find a Storytel_transactions
     * @example
     * // Get one Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends storytel_transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, storytel_transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'storytel_transactions'> extends True ? Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>> : Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T> | null, null>

    /**
     * Find zero or more Storytel_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findMany()
     * 
     * // Get first 10 Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storytel_transactionsWithIdOnly = await prisma.storytel_transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends storytel_transactionsFindManyArgs>(
      args?: SelectSubset<T, storytel_transactionsFindManyArgs>
    ): PrismaPromise<Array<storytel_transactionsGetPayload<T>>>

    /**
     * Create a Storytel_transactions.
     * @param {storytel_transactionsCreateArgs} args - Arguments to create a Storytel_transactions.
     * @example
     * // Create one Storytel_transactions
     * const Storytel_transactions = await prisma.storytel_transactions.create({
     *   data: {
     *     // ... data to create a Storytel_transactions
     *   }
     * })
     * 
    **/
    create<T extends storytel_transactionsCreateArgs>(
      args: SelectSubset<T, storytel_transactionsCreateArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Create many Storytel_transactions.
     *     @param {storytel_transactionsCreateManyArgs} args - Arguments to create many Storytel_transactions.
     *     @example
     *     // Create many Storytel_transactions
     *     const storytel_transactions = await prisma.storytel_transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends storytel_transactionsCreateManyArgs>(
      args?: SelectSubset<T, storytel_transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Storytel_transactions.
     * @param {storytel_transactionsDeleteArgs} args - Arguments to delete one Storytel_transactions.
     * @example
     * // Delete one Storytel_transactions
     * const Storytel_transactions = await prisma.storytel_transactions.delete({
     *   where: {
     *     // ... filter to delete one Storytel_transactions
     *   }
     * })
     * 
    **/
    delete<T extends storytel_transactionsDeleteArgs>(
      args: SelectSubset<T, storytel_transactionsDeleteArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Update one Storytel_transactions.
     * @param {storytel_transactionsUpdateArgs} args - Arguments to update one Storytel_transactions.
     * @example
     * // Update one Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends storytel_transactionsUpdateArgs>(
      args: SelectSubset<T, storytel_transactionsUpdateArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Delete zero or more Storytel_transactions.
     * @param {storytel_transactionsDeleteManyArgs} args - Arguments to filter Storytel_transactions to delete.
     * @example
     * // Delete a few Storytel_transactions
     * const { count } = await prisma.storytel_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends storytel_transactionsDeleteManyArgs>(
      args?: SelectSubset<T, storytel_transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storytel_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends storytel_transactionsUpdateManyArgs>(
      args: SelectSubset<T, storytel_transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Storytel_transactions.
     * @param {storytel_transactionsUpsertArgs} args - Arguments to update or create a Storytel_transactions.
     * @example
     * // Update or create a Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.upsert({
     *   create: {
     *     // ... data to create a Storytel_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storytel_transactions we want to update
     *   }
     * })
    **/
    upsert<T extends storytel_transactionsUpsertArgs>(
      args: SelectSubset<T, storytel_transactionsUpsertArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Find one Storytel_transactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {storytel_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Storytel_transactions
     * @example
     * // Get one Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends storytel_transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, storytel_transactionsFindUniqueOrThrowArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Find the first Storytel_transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_transactionsFindFirstOrThrowArgs} args - Arguments to find a Storytel_transactions
     * @example
     * // Get one Storytel_transactions
     * const storytel_transactions = await prisma.storytel_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends storytel_transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, storytel_transactionsFindFirstOrThrowArgs>
    ): Prisma__storytel_transactionsClient<storytel_transactionsGetPayload<T>>

    /**
     * Count the number of Storytel_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storytel_transactionsCountArgs} args - Arguments to filter Storytel_transactions to count.
     * @example
     * // Count the number of Storytel_transactions
     * const count = await prisma.storytel_transactions.count({
     *   where: {
     *     // ... the filter for the Storytel_transactions we want to count
     *   }
     * })
    **/
    count<T extends storytel_transactionsCountArgs>(
      args?: Subset<T, storytel_transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Storytel_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storytel_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Storytel_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Storytel_transactionsAggregateArgs>(args: Subset<T, Storytel_transactionsAggregateArgs>): PrismaPromise<GetStorytel_transactionsAggregateType<T>>

    /**
     * Group by Storytel_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Storytel_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Storytel_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Storytel_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: Storytel_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Storytel_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorytel_transactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for storytel_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__storytel_transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends book_tblArgs= {}>(args?: Subset<T, book_tblArgs>): Prisma__book_tblClient<book_tblGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * storytel_transactions base type for findUnique actions
   */
  export type storytel_transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * Filter, which storytel_transactions to fetch.
     * 
    **/
    where: storytel_transactionsWhereUniqueInput
  }

  /**
   * storytel_transactions: findUnique
   */
  export interface storytel_transactionsFindUniqueArgs extends storytel_transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * storytel_transactions base type for findFirst actions
   */
  export type storytel_transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * Filter, which storytel_transactions to fetch.
     * 
    **/
    where?: storytel_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for storytel_transactions.
     * 
    **/
    cursor?: storytel_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of storytel_transactions.
     * 
    **/
    distinct?: Enumerable<Storytel_transactionsScalarFieldEnum>
  }

  /**
   * storytel_transactions: findFirst
   */
  export interface storytel_transactionsFindFirstArgs extends storytel_transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * storytel_transactions findMany
   */
  export type storytel_transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * Filter, which storytel_transactions to fetch.
     * 
    **/
    where?: storytel_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of storytel_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<storytel_transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing storytel_transactions.
     * 
    **/
    cursor?: storytel_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` storytel_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` storytel_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Storytel_transactionsScalarFieldEnum>
  }


  /**
   * storytel_transactions create
   */
  export type storytel_transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * The data needed to create a storytel_transactions.
     * 
    **/
    data: XOR<storytel_transactionsCreateInput, storytel_transactionsUncheckedCreateInput>
  }


  /**
   * storytel_transactions createMany
   */
  export type storytel_transactionsCreateManyArgs = {
    /**
     * The data used to create many storytel_transactions.
     * 
    **/
    data: Enumerable<storytel_transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * storytel_transactions update
   */
  export type storytel_transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * The data needed to update a storytel_transactions.
     * 
    **/
    data: XOR<storytel_transactionsUpdateInput, storytel_transactionsUncheckedUpdateInput>
    /**
     * Choose, which storytel_transactions to update.
     * 
    **/
    where: storytel_transactionsWhereUniqueInput
  }


  /**
   * storytel_transactions updateMany
   */
  export type storytel_transactionsUpdateManyArgs = {
    /**
     * The data used to update storytel_transactions.
     * 
    **/
    data: XOR<storytel_transactionsUpdateManyMutationInput, storytel_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which storytel_transactions to update
     * 
    **/
    where?: storytel_transactionsWhereInput
  }


  /**
   * storytel_transactions upsert
   */
  export type storytel_transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * The filter to search for the storytel_transactions to update in case it exists.
     * 
    **/
    where: storytel_transactionsWhereUniqueInput
    /**
     * In case the storytel_transactions found by the `where` argument doesn't exist, create a new storytel_transactions with this data.
     * 
    **/
    create: XOR<storytel_transactionsCreateInput, storytel_transactionsUncheckedCreateInput>
    /**
     * In case the storytel_transactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<storytel_transactionsUpdateInput, storytel_transactionsUncheckedUpdateInput>
  }


  /**
   * storytel_transactions delete
   */
  export type storytel_transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
    /**
     * Filter which storytel_transactions to delete.
     * 
    **/
    where: storytel_transactionsWhereUniqueInput
  }


  /**
   * storytel_transactions deleteMany
   */
  export type storytel_transactionsDeleteManyArgs = {
    /**
     * Filter which storytel_transactions to delete
     * 
    **/
    where?: storytel_transactionsWhereInput
  }


  /**
   * storytel_transactions: findUniqueOrThrow
   */
  export type storytel_transactionsFindUniqueOrThrowArgs = storytel_transactionsFindUniqueArgsBase
      

  /**
   * storytel_transactions: findFirstOrThrow
   */
  export type storytel_transactionsFindFirstOrThrowArgs = storytel_transactionsFindFirstArgsBase
      

  /**
   * storytel_transactions without action
   */
  export type storytel_transactionsArgs = {
    /**
     * Select specific fields to fetch from the storytel_transactions
     * 
    **/
    select?: storytel_transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: storytel_transactionsInclude | null
  }



  /**
   * Model subscribe_newsletter
   */


  export type AggregateSubscribe_newsletter = {
    _count: Subscribe_newsletterCountAggregateOutputType | null
    _avg: Subscribe_newsletterAvgAggregateOutputType | null
    _sum: Subscribe_newsletterSumAggregateOutputType | null
    _min: Subscribe_newsletterMinAggregateOutputType | null
    _max: Subscribe_newsletterMaxAggregateOutputType | null
  }

  export type Subscribe_newsletterAvgAggregateOutputType = {
    id: number | null
  }

  export type Subscribe_newsletterSumAggregateOutputType = {
    id: number | null
  }

  export type Subscribe_newsletterMinAggregateOutputType = {
    id: number | null
    email_id: string | null
    subscribe_date: Date | null
  }

  export type Subscribe_newsletterMaxAggregateOutputType = {
    id: number | null
    email_id: string | null
    subscribe_date: Date | null
  }

  export type Subscribe_newsletterCountAggregateOutputType = {
    id: number
    email_id: number
    subscribe_date: number
    _all: number
  }


  export type Subscribe_newsletterAvgAggregateInputType = {
    id?: true
  }

  export type Subscribe_newsletterSumAggregateInputType = {
    id?: true
  }

  export type Subscribe_newsletterMinAggregateInputType = {
    id?: true
    email_id?: true
    subscribe_date?: true
  }

  export type Subscribe_newsletterMaxAggregateInputType = {
    id?: true
    email_id?: true
    subscribe_date?: true
  }

  export type Subscribe_newsletterCountAggregateInputType = {
    id?: true
    email_id?: true
    subscribe_date?: true
    _all?: true
  }

  export type Subscribe_newsletterAggregateArgs = {
    /**
     * Filter which subscribe_newsletter to aggregate.
     * 
    **/
    where?: subscribe_newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscribe_newsletters to fetch.
     * 
    **/
    orderBy?: Enumerable<subscribe_newsletterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subscribe_newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscribe_newsletters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscribe_newsletters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscribe_newsletters
    **/
    _count?: true | Subscribe_newsletterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subscribe_newsletterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subscribe_newsletterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subscribe_newsletterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subscribe_newsletterMaxAggregateInputType
  }

  export type GetSubscribe_newsletterAggregateType<T extends Subscribe_newsletterAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscribe_newsletter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscribe_newsletter[P]>
      : GetScalarType<T[P], AggregateSubscribe_newsletter[P]>
  }




  export type Subscribe_newsletterGroupByArgs = {
    where?: subscribe_newsletterWhereInput
    orderBy?: Enumerable<subscribe_newsletterOrderByWithAggregationInput>
    by: Array<Subscribe_newsletterScalarFieldEnum>
    having?: subscribe_newsletterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subscribe_newsletterCountAggregateInputType | true
    _avg?: Subscribe_newsletterAvgAggregateInputType
    _sum?: Subscribe_newsletterSumAggregateInputType
    _min?: Subscribe_newsletterMinAggregateInputType
    _max?: Subscribe_newsletterMaxAggregateInputType
  }


  export type Subscribe_newsletterGroupByOutputType = {
    id: number
    email_id: string | null
    subscribe_date: Date | null
    _count: Subscribe_newsletterCountAggregateOutputType | null
    _avg: Subscribe_newsletterAvgAggregateOutputType | null
    _sum: Subscribe_newsletterSumAggregateOutputType | null
    _min: Subscribe_newsletterMinAggregateOutputType | null
    _max: Subscribe_newsletterMaxAggregateOutputType | null
  }

  type GetSubscribe_newsletterGroupByPayload<T extends Subscribe_newsletterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Subscribe_newsletterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subscribe_newsletterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subscribe_newsletterGroupByOutputType[P]>
            : GetScalarType<T[P], Subscribe_newsletterGroupByOutputType[P]>
        }
      >
    >


  export type subscribe_newsletterSelect = {
    id?: boolean
    email_id?: boolean
    subscribe_date?: boolean
  }


  export type subscribe_newsletterGetPayload<S extends boolean | null | undefined | subscribe_newsletterArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? subscribe_newsletter :
    S extends undefined ? never :
    S extends { include: any } & (subscribe_newsletterArgs | subscribe_newsletterFindManyArgs)
    ? subscribe_newsletter 
    : S extends { select: any } & (subscribe_newsletterArgs | subscribe_newsletterFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof subscribe_newsletter ? subscribe_newsletter[P] : never
  } 
      : subscribe_newsletter


  type subscribe_newsletterCountArgs = Merge<
    Omit<subscribe_newsletterFindManyArgs, 'select' | 'include'> & {
      select?: Subscribe_newsletterCountAggregateInputType | true
    }
  >

  export interface subscribe_newsletterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subscribe_newsletter that matches the filter.
     * @param {subscribe_newsletterFindUniqueArgs} args - Arguments to find a Subscribe_newsletter
     * @example
     * // Get one Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subscribe_newsletterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subscribe_newsletterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subscribe_newsletter'> extends True ? Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>> : Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T> | null, null>

    /**
     * Find the first Subscribe_newsletter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscribe_newsletterFindFirstArgs} args - Arguments to find a Subscribe_newsletter
     * @example
     * // Get one Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subscribe_newsletterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subscribe_newsletterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subscribe_newsletter'> extends True ? Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>> : Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T> | null, null>

    /**
     * Find zero or more Subscribe_newsletters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscribe_newsletterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribe_newsletters
     * const subscribe_newsletters = await prisma.subscribe_newsletter.findMany()
     * 
     * // Get first 10 Subscribe_newsletters
     * const subscribe_newsletters = await prisma.subscribe_newsletter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscribe_newsletterWithIdOnly = await prisma.subscribe_newsletter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subscribe_newsletterFindManyArgs>(
      args?: SelectSubset<T, subscribe_newsletterFindManyArgs>
    ): PrismaPromise<Array<subscribe_newsletterGetPayload<T>>>

    /**
     * Create a Subscribe_newsletter.
     * @param {subscribe_newsletterCreateArgs} args - Arguments to create a Subscribe_newsletter.
     * @example
     * // Create one Subscribe_newsletter
     * const Subscribe_newsletter = await prisma.subscribe_newsletter.create({
     *   data: {
     *     // ... data to create a Subscribe_newsletter
     *   }
     * })
     * 
    **/
    create<T extends subscribe_newsletterCreateArgs>(
      args: SelectSubset<T, subscribe_newsletterCreateArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Create many Subscribe_newsletters.
     *     @param {subscribe_newsletterCreateManyArgs} args - Arguments to create many Subscribe_newsletters.
     *     @example
     *     // Create many Subscribe_newsletters
     *     const subscribe_newsletter = await prisma.subscribe_newsletter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subscribe_newsletterCreateManyArgs>(
      args?: SelectSubset<T, subscribe_newsletterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscribe_newsletter.
     * @param {subscribe_newsletterDeleteArgs} args - Arguments to delete one Subscribe_newsletter.
     * @example
     * // Delete one Subscribe_newsletter
     * const Subscribe_newsletter = await prisma.subscribe_newsletter.delete({
     *   where: {
     *     // ... filter to delete one Subscribe_newsletter
     *   }
     * })
     * 
    **/
    delete<T extends subscribe_newsletterDeleteArgs>(
      args: SelectSubset<T, subscribe_newsletterDeleteArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Update one Subscribe_newsletter.
     * @param {subscribe_newsletterUpdateArgs} args - Arguments to update one Subscribe_newsletter.
     * @example
     * // Update one Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subscribe_newsletterUpdateArgs>(
      args: SelectSubset<T, subscribe_newsletterUpdateArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Delete zero or more Subscribe_newsletters.
     * @param {subscribe_newsletterDeleteManyArgs} args - Arguments to filter Subscribe_newsletters to delete.
     * @example
     * // Delete a few Subscribe_newsletters
     * const { count } = await prisma.subscribe_newsletter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subscribe_newsletterDeleteManyArgs>(
      args?: SelectSubset<T, subscribe_newsletterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribe_newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscribe_newsletterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribe_newsletters
     * const subscribe_newsletter = await prisma.subscribe_newsletter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subscribe_newsletterUpdateManyArgs>(
      args: SelectSubset<T, subscribe_newsletterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscribe_newsletter.
     * @param {subscribe_newsletterUpsertArgs} args - Arguments to update or create a Subscribe_newsletter.
     * @example
     * // Update or create a Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.upsert({
     *   create: {
     *     // ... data to create a Subscribe_newsletter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscribe_newsletter we want to update
     *   }
     * })
    **/
    upsert<T extends subscribe_newsletterUpsertArgs>(
      args: SelectSubset<T, subscribe_newsletterUpsertArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Find one Subscribe_newsletter that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subscribe_newsletterFindUniqueOrThrowArgs} args - Arguments to find a Subscribe_newsletter
     * @example
     * // Get one Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subscribe_newsletterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subscribe_newsletterFindUniqueOrThrowArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Find the first Subscribe_newsletter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscribe_newsletterFindFirstOrThrowArgs} args - Arguments to find a Subscribe_newsletter
     * @example
     * // Get one Subscribe_newsletter
     * const subscribe_newsletter = await prisma.subscribe_newsletter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subscribe_newsletterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subscribe_newsletterFindFirstOrThrowArgs>
    ): Prisma__subscribe_newsletterClient<subscribe_newsletterGetPayload<T>>

    /**
     * Count the number of Subscribe_newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscribe_newsletterCountArgs} args - Arguments to filter Subscribe_newsletters to count.
     * @example
     * // Count the number of Subscribe_newsletters
     * const count = await prisma.subscribe_newsletter.count({
     *   where: {
     *     // ... the filter for the Subscribe_newsletters we want to count
     *   }
     * })
    **/
    count<T extends subscribe_newsletterCountArgs>(
      args?: Subset<T, subscribe_newsletterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subscribe_newsletterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscribe_newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscribe_newsletterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subscribe_newsletterAggregateArgs>(args: Subset<T, Subscribe_newsletterAggregateArgs>): PrismaPromise<GetSubscribe_newsletterAggregateType<T>>

    /**
     * Group by Subscribe_newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscribe_newsletterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Subscribe_newsletterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Subscribe_newsletterGroupByArgs['orderBy'] }
        : { orderBy?: Subscribe_newsletterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Subscribe_newsletterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscribe_newsletterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subscribe_newsletter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subscribe_newsletterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subscribe_newsletter base type for findUnique actions
   */
  export type subscribe_newsletterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * Filter, which subscribe_newsletter to fetch.
     * 
    **/
    where: subscribe_newsletterWhereUniqueInput
  }

  /**
   * subscribe_newsletter: findUnique
   */
  export interface subscribe_newsletterFindUniqueArgs extends subscribe_newsletterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subscribe_newsletter base type for findFirst actions
   */
  export type subscribe_newsletterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * Filter, which subscribe_newsletter to fetch.
     * 
    **/
    where?: subscribe_newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscribe_newsletters to fetch.
     * 
    **/
    orderBy?: Enumerable<subscribe_newsletterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscribe_newsletters.
     * 
    **/
    cursor?: subscribe_newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscribe_newsletters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscribe_newsletters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscribe_newsletters.
     * 
    **/
    distinct?: Enumerable<Subscribe_newsletterScalarFieldEnum>
  }

  /**
   * subscribe_newsletter: findFirst
   */
  export interface subscribe_newsletterFindFirstArgs extends subscribe_newsletterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subscribe_newsletter findMany
   */
  export type subscribe_newsletterFindManyArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * Filter, which subscribe_newsletters to fetch.
     * 
    **/
    where?: subscribe_newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscribe_newsletters to fetch.
     * 
    **/
    orderBy?: Enumerable<subscribe_newsletterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscribe_newsletters.
     * 
    **/
    cursor?: subscribe_newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscribe_newsletters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscribe_newsletters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Subscribe_newsletterScalarFieldEnum>
  }


  /**
   * subscribe_newsletter create
   */
  export type subscribe_newsletterCreateArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * The data needed to create a subscribe_newsletter.
     * 
    **/
    data: XOR<subscribe_newsletterCreateInput, subscribe_newsletterUncheckedCreateInput>
  }


  /**
   * subscribe_newsletter createMany
   */
  export type subscribe_newsletterCreateManyArgs = {
    /**
     * The data used to create many subscribe_newsletters.
     * 
    **/
    data: Enumerable<subscribe_newsletterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subscribe_newsletter update
   */
  export type subscribe_newsletterUpdateArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * The data needed to update a subscribe_newsletter.
     * 
    **/
    data: XOR<subscribe_newsletterUpdateInput, subscribe_newsletterUncheckedUpdateInput>
    /**
     * Choose, which subscribe_newsletter to update.
     * 
    **/
    where: subscribe_newsletterWhereUniqueInput
  }


  /**
   * subscribe_newsletter updateMany
   */
  export type subscribe_newsletterUpdateManyArgs = {
    /**
     * The data used to update subscribe_newsletters.
     * 
    **/
    data: XOR<subscribe_newsletterUpdateManyMutationInput, subscribe_newsletterUncheckedUpdateManyInput>
    /**
     * Filter which subscribe_newsletters to update
     * 
    **/
    where?: subscribe_newsletterWhereInput
  }


  /**
   * subscribe_newsletter upsert
   */
  export type subscribe_newsletterUpsertArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * The filter to search for the subscribe_newsletter to update in case it exists.
     * 
    **/
    where: subscribe_newsletterWhereUniqueInput
    /**
     * In case the subscribe_newsletter found by the `where` argument doesn't exist, create a new subscribe_newsletter with this data.
     * 
    **/
    create: XOR<subscribe_newsletterCreateInput, subscribe_newsletterUncheckedCreateInput>
    /**
     * In case the subscribe_newsletter was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subscribe_newsletterUpdateInput, subscribe_newsletterUncheckedUpdateInput>
  }


  /**
   * subscribe_newsletter delete
   */
  export type subscribe_newsletterDeleteArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
    /**
     * Filter which subscribe_newsletter to delete.
     * 
    **/
    where: subscribe_newsletterWhereUniqueInput
  }


  /**
   * subscribe_newsletter deleteMany
   */
  export type subscribe_newsletterDeleteManyArgs = {
    /**
     * Filter which subscribe_newsletters to delete
     * 
    **/
    where?: subscribe_newsletterWhereInput
  }


  /**
   * subscribe_newsletter: findUniqueOrThrow
   */
  export type subscribe_newsletterFindUniqueOrThrowArgs = subscribe_newsletterFindUniqueArgsBase
      

  /**
   * subscribe_newsletter: findFirstOrThrow
   */
  export type subscribe_newsletterFindFirstOrThrowArgs = subscribe_newsletterFindFirstArgsBase
      

  /**
   * subscribe_newsletter without action
   */
  export type subscribe_newsletterArgs = {
    /**
     * Select specific fields to fetch from the subscribe_newsletter
     * 
    **/
    select?: subscribe_newsletterSelect | null
  }



  /**
   * Model subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    subscription_id: number | null
    plan_type: number | null
    number_of_days: number | null
    total_books_applicable: number | null
    status: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    subscription_id: number | null
    plan_type: number | null
    number_of_days: number | null
    total_books_applicable: number | null
    status: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    subscription_id: number | null
    plan_type: number | null
    number_of_days: number | null
    start_date: Date | null
    end_date: Date | null
    total_books_applicable: number | null
    date_inserted: Date | null
    status: number | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    subscription_id: number | null
    plan_type: number | null
    number_of_days: number | null
    start_date: Date | null
    end_date: Date | null
    total_books_applicable: number | null
    date_inserted: Date | null
    status: number | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    order_id: number
    user_id: number
    subscription_id: number
    plan_type: number
    number_of_days: number
    start_date: number
    end_date: number
    total_books_applicable: number
    date_inserted: number
    status: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subscription_id?: true
    plan_type?: true
    number_of_days?: true
    total_books_applicable?: true
    status?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subscription_id?: true
    plan_type?: true
    number_of_days?: true
    total_books_applicable?: true
    status?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subscription_id?: true
    plan_type?: true
    number_of_days?: true
    start_date?: true
    end_date?: true
    total_books_applicable?: true
    date_inserted?: true
    status?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subscription_id?: true
    plan_type?: true
    number_of_days?: true
    start_date?: true
    end_date?: true
    total_books_applicable?: true
    date_inserted?: true
    status?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subscription_id?: true
    plan_type?: true
    number_of_days?: true
    start_date?: true
    end_date?: true
    total_books_applicable?: true
    date_inserted?: true
    status?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which subscription to aggregate.
     * 
    **/
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: subscriptionWhereInput
    orderBy?: Enumerable<subscriptionOrderByWithAggregationInput>
    by: Array<SubscriptionScalarFieldEnum>
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: number
    order_id: bigint
    user_id: number
    subscription_id: number
    plan_type: number | null
    number_of_days: number
    start_date: Date | null
    end_date: Date
    total_books_applicable: number
    date_inserted: Date
    status: number
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect = {
    id?: boolean
    order_id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    plan_type?: boolean
    number_of_days?: boolean
    start_date?: boolean
    end_date?: boolean
    total_books_applicable?: boolean
    date_inserted?: boolean
    status?: boolean
  }


  export type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? subscription :
    S extends undefined ? never :
    S extends { include: any } & (subscriptionArgs | subscriptionFindManyArgs)
    ? subscription 
    : S extends { select: any } & (subscriptionArgs | subscriptionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof subscription ? subscription[P] : never
  } 
      : subscription


  type subscriptionCountArgs = Merge<
    Omit<subscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }
  >

  export interface subscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subscription'> extends True ? Prisma__subscriptionClient<subscriptionGetPayload<T>> : Prisma__subscriptionClient<subscriptionGetPayload<T> | null, null>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subscription'> extends True ? Prisma__subscriptionClient<subscriptionGetPayload<T>> : Prisma__subscriptionClient<subscriptionGetPayload<T> | null, null>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subscriptionFindManyArgs>(
      args?: SelectSubset<T, subscriptionFindManyArgs>
    ): PrismaPromise<Array<subscriptionGetPayload<T>>>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends subscriptionCreateArgs>(
      args: SelectSubset<T, subscriptionCreateArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Create many Subscriptions.
     *     @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subscriptionCreateManyArgs>(
      args?: SelectSubset<T, subscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends subscriptionDeleteArgs>(
      args: SelectSubset<T, subscriptionDeleteArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subscriptionUpdateArgs>(
      args: SelectSubset<T, subscriptionUpdateArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subscriptionDeleteManyArgs>(
      args?: SelectSubset<T, subscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subscriptionUpdateManyArgs>(
      args: SelectSubset<T, subscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends subscriptionUpsertArgs>(
      args: SelectSubset<T, subscriptionUpsertArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Find one Subscription that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subscriptionFindUniqueOrThrowArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs>
    ): Prisma__subscriptionClient<subscriptionGetPayload<T>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subscriptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subscription base type for findUnique actions
   */
  export type subscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * Filter, which subscription to fetch.
     * 
    **/
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription: findUnique
   */
  export interface subscriptionFindUniqueArgs extends subscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subscription base type for findFirst actions
   */
  export type subscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * Filter, which subscription to fetch.
     * 
    **/
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     * 
    **/
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     * 
    **/
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * subscription: findFirst
   */
  export interface subscriptionFindFirstArgs extends subscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * Filter, which subscriptions to fetch.
     * 
    **/
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<subscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     * 
    **/
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * subscription create
   */
  export type subscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * The data needed to create a subscription.
     * 
    **/
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }


  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs = {
    /**
     * The data used to create many subscriptions.
     * 
    **/
    data: Enumerable<subscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subscription update
   */
  export type subscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * The data needed to update a subscription.
     * 
    **/
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     * 
    **/
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs = {
    /**
     * The data used to update subscriptions.
     * 
    **/
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     * 
    **/
    where?: subscriptionWhereInput
  }


  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * The filter to search for the subscription to update in case it exists.
     * 
    **/
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     * 
    **/
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }


  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
    /**
     * Filter which subscription to delete.
     * 
    **/
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs = {
    /**
     * Filter which subscriptions to delete
     * 
    **/
    where?: subscriptionWhereInput
  }


  /**
   * subscription: findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs = subscriptionFindUniqueArgsBase
      

  /**
   * subscription: findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs = subscriptionFindFirstArgsBase
      

  /**
   * subscription without action
   */
  export type subscriptionArgs = {
    /**
     * Select specific fields to fetch from the subscription
     * 
    **/
    select?: subscriptionSelect | null
  }



  /**
   * Model today_deals
   */


  export type AggregateToday_deals = {
    _count: Today_dealsCountAggregateOutputType | null
    _avg: Today_dealsAvgAggregateOutputType | null
    _sum: Today_dealsSumAggregateOutputType | null
    _min: Today_dealsMinAggregateOutputType | null
    _max: Today_dealsMaxAggregateOutputType | null
  }

  export type Today_dealsAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    language_id: number | null
    discount: number | null
  }

  export type Today_dealsSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    language_id: number | null
    discount: number | null
  }

  export type Today_dealsMinAggregateOutputType = {
    id: number | null
    date: Date | null
    book_id: number | null
    language_id: number | null
    discount: number | null
    status: string | null
    type: string | null
  }

  export type Today_dealsMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    book_id: number | null
    language_id: number | null
    discount: number | null
    status: string | null
    type: string | null
  }

  export type Today_dealsCountAggregateOutputType = {
    id: number
    date: number
    book_id: number
    language_id: number
    discount: number
    status: number
    type: number
    _all: number
  }


  export type Today_dealsAvgAggregateInputType = {
    id?: true
    book_id?: true
    language_id?: true
    discount?: true
  }

  export type Today_dealsSumAggregateInputType = {
    id?: true
    book_id?: true
    language_id?: true
    discount?: true
  }

  export type Today_dealsMinAggregateInputType = {
    id?: true
    date?: true
    book_id?: true
    language_id?: true
    discount?: true
    status?: true
    type?: true
  }

  export type Today_dealsMaxAggregateInputType = {
    id?: true
    date?: true
    book_id?: true
    language_id?: true
    discount?: true
    status?: true
    type?: true
  }

  export type Today_dealsCountAggregateInputType = {
    id?: true
    date?: true
    book_id?: true
    language_id?: true
    discount?: true
    status?: true
    type?: true
    _all?: true
  }

  export type Today_dealsAggregateArgs = {
    /**
     * Filter which today_deals to aggregate.
     * 
    **/
    where?: today_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_deals to fetch.
     * 
    **/
    orderBy?: Enumerable<today_dealsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: today_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_deals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_deals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned today_deals
    **/
    _count?: true | Today_dealsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Today_dealsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Today_dealsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Today_dealsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Today_dealsMaxAggregateInputType
  }

  export type GetToday_dealsAggregateType<T extends Today_dealsAggregateArgs> = {
        [P in keyof T & keyof AggregateToday_deals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToday_deals[P]>
      : GetScalarType<T[P], AggregateToday_deals[P]>
  }




  export type Today_dealsGroupByArgs = {
    where?: today_dealsWhereInput
    orderBy?: Enumerable<today_dealsOrderByWithAggregationInput>
    by: Array<Today_dealsScalarFieldEnum>
    having?: today_dealsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Today_dealsCountAggregateInputType | true
    _avg?: Today_dealsAvgAggregateInputType
    _sum?: Today_dealsSumAggregateInputType
    _min?: Today_dealsMinAggregateInputType
    _max?: Today_dealsMaxAggregateInputType
  }


  export type Today_dealsGroupByOutputType = {
    id: number
    date: Date
    book_id: number
    language_id: number | null
    discount: number
    status: string
    type: string
    _count: Today_dealsCountAggregateOutputType | null
    _avg: Today_dealsAvgAggregateOutputType | null
    _sum: Today_dealsSumAggregateOutputType | null
    _min: Today_dealsMinAggregateOutputType | null
    _max: Today_dealsMaxAggregateOutputType | null
  }

  type GetToday_dealsGroupByPayload<T extends Today_dealsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Today_dealsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Today_dealsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Today_dealsGroupByOutputType[P]>
            : GetScalarType<T[P], Today_dealsGroupByOutputType[P]>
        }
      >
    >


  export type today_dealsSelect = {
    id?: boolean
    date?: boolean
    book_id?: boolean
    language_id?: boolean
    discount?: boolean
    status?: boolean
    type?: boolean
  }


  export type today_dealsGetPayload<S extends boolean | null | undefined | today_dealsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? today_deals :
    S extends undefined ? never :
    S extends { include: any } & (today_dealsArgs | today_dealsFindManyArgs)
    ? today_deals 
    : S extends { select: any } & (today_dealsArgs | today_dealsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof today_deals ? today_deals[P] : never
  } 
      : today_deals


  type today_dealsCountArgs = Merge<
    Omit<today_dealsFindManyArgs, 'select' | 'include'> & {
      select?: Today_dealsCountAggregateInputType | true
    }
  >

  export interface today_dealsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Today_deals that matches the filter.
     * @param {today_dealsFindUniqueArgs} args - Arguments to find a Today_deals
     * @example
     * // Get one Today_deals
     * const today_deals = await prisma.today_deals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends today_dealsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, today_dealsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'today_deals'> extends True ? Prisma__today_dealsClient<today_dealsGetPayload<T>> : Prisma__today_dealsClient<today_dealsGetPayload<T> | null, null>

    /**
     * Find the first Today_deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_dealsFindFirstArgs} args - Arguments to find a Today_deals
     * @example
     * // Get one Today_deals
     * const today_deals = await prisma.today_deals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends today_dealsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, today_dealsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'today_deals'> extends True ? Prisma__today_dealsClient<today_dealsGetPayload<T>> : Prisma__today_dealsClient<today_dealsGetPayload<T> | null, null>

    /**
     * Find zero or more Today_deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_dealsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Today_deals
     * const today_deals = await prisma.today_deals.findMany()
     * 
     * // Get first 10 Today_deals
     * const today_deals = await prisma.today_deals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const today_dealsWithIdOnly = await prisma.today_deals.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends today_dealsFindManyArgs>(
      args?: SelectSubset<T, today_dealsFindManyArgs>
    ): PrismaPromise<Array<today_dealsGetPayload<T>>>

    /**
     * Create a Today_deals.
     * @param {today_dealsCreateArgs} args - Arguments to create a Today_deals.
     * @example
     * // Create one Today_deals
     * const Today_deals = await prisma.today_deals.create({
     *   data: {
     *     // ... data to create a Today_deals
     *   }
     * })
     * 
    **/
    create<T extends today_dealsCreateArgs>(
      args: SelectSubset<T, today_dealsCreateArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Create many Today_deals.
     *     @param {today_dealsCreateManyArgs} args - Arguments to create many Today_deals.
     *     @example
     *     // Create many Today_deals
     *     const today_deals = await prisma.today_deals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends today_dealsCreateManyArgs>(
      args?: SelectSubset<T, today_dealsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Today_deals.
     * @param {today_dealsDeleteArgs} args - Arguments to delete one Today_deals.
     * @example
     * // Delete one Today_deals
     * const Today_deals = await prisma.today_deals.delete({
     *   where: {
     *     // ... filter to delete one Today_deals
     *   }
     * })
     * 
    **/
    delete<T extends today_dealsDeleteArgs>(
      args: SelectSubset<T, today_dealsDeleteArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Update one Today_deals.
     * @param {today_dealsUpdateArgs} args - Arguments to update one Today_deals.
     * @example
     * // Update one Today_deals
     * const today_deals = await prisma.today_deals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends today_dealsUpdateArgs>(
      args: SelectSubset<T, today_dealsUpdateArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Delete zero or more Today_deals.
     * @param {today_dealsDeleteManyArgs} args - Arguments to filter Today_deals to delete.
     * @example
     * // Delete a few Today_deals
     * const { count } = await prisma.today_deals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends today_dealsDeleteManyArgs>(
      args?: SelectSubset<T, today_dealsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Today_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_dealsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Today_deals
     * const today_deals = await prisma.today_deals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends today_dealsUpdateManyArgs>(
      args: SelectSubset<T, today_dealsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Today_deals.
     * @param {today_dealsUpsertArgs} args - Arguments to update or create a Today_deals.
     * @example
     * // Update or create a Today_deals
     * const today_deals = await prisma.today_deals.upsert({
     *   create: {
     *     // ... data to create a Today_deals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Today_deals we want to update
     *   }
     * })
    **/
    upsert<T extends today_dealsUpsertArgs>(
      args: SelectSubset<T, today_dealsUpsertArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Find one Today_deals that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {today_dealsFindUniqueOrThrowArgs} args - Arguments to find a Today_deals
     * @example
     * // Get one Today_deals
     * const today_deals = await prisma.today_deals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends today_dealsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, today_dealsFindUniqueOrThrowArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Find the first Today_deals that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_dealsFindFirstOrThrowArgs} args - Arguments to find a Today_deals
     * @example
     * // Get one Today_deals
     * const today_deals = await prisma.today_deals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends today_dealsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, today_dealsFindFirstOrThrowArgs>
    ): Prisma__today_dealsClient<today_dealsGetPayload<T>>

    /**
     * Count the number of Today_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_dealsCountArgs} args - Arguments to filter Today_deals to count.
     * @example
     * // Count the number of Today_deals
     * const count = await prisma.today_deals.count({
     *   where: {
     *     // ... the filter for the Today_deals we want to count
     *   }
     * })
    **/
    count<T extends today_dealsCountArgs>(
      args?: Subset<T, today_dealsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Today_dealsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Today_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Today_dealsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Today_dealsAggregateArgs>(args: Subset<T, Today_dealsAggregateArgs>): PrismaPromise<GetToday_dealsAggregateType<T>>

    /**
     * Group by Today_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Today_dealsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Today_dealsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Today_dealsGroupByArgs['orderBy'] }
        : { orderBy?: Today_dealsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Today_dealsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToday_dealsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for today_deals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__today_dealsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * today_deals base type for findUnique actions
   */
  export type today_dealsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * Filter, which today_deals to fetch.
     * 
    **/
    where: today_dealsWhereUniqueInput
  }

  /**
   * today_deals: findUnique
   */
  export interface today_dealsFindUniqueArgs extends today_dealsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * today_deals base type for findFirst actions
   */
  export type today_dealsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * Filter, which today_deals to fetch.
     * 
    **/
    where?: today_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_deals to fetch.
     * 
    **/
    orderBy?: Enumerable<today_dealsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for today_deals.
     * 
    **/
    cursor?: today_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_deals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_deals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of today_deals.
     * 
    **/
    distinct?: Enumerable<Today_dealsScalarFieldEnum>
  }

  /**
   * today_deals: findFirst
   */
  export interface today_dealsFindFirstArgs extends today_dealsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * today_deals findMany
   */
  export type today_dealsFindManyArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * Filter, which today_deals to fetch.
     * 
    **/
    where?: today_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_deals to fetch.
     * 
    **/
    orderBy?: Enumerable<today_dealsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing today_deals.
     * 
    **/
    cursor?: today_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_deals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_deals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Today_dealsScalarFieldEnum>
  }


  /**
   * today_deals create
   */
  export type today_dealsCreateArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * The data needed to create a today_deals.
     * 
    **/
    data: XOR<today_dealsCreateInput, today_dealsUncheckedCreateInput>
  }


  /**
   * today_deals createMany
   */
  export type today_dealsCreateManyArgs = {
    /**
     * The data used to create many today_deals.
     * 
    **/
    data: Enumerable<today_dealsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * today_deals update
   */
  export type today_dealsUpdateArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * The data needed to update a today_deals.
     * 
    **/
    data: XOR<today_dealsUpdateInput, today_dealsUncheckedUpdateInput>
    /**
     * Choose, which today_deals to update.
     * 
    **/
    where: today_dealsWhereUniqueInput
  }


  /**
   * today_deals updateMany
   */
  export type today_dealsUpdateManyArgs = {
    /**
     * The data used to update today_deals.
     * 
    **/
    data: XOR<today_dealsUpdateManyMutationInput, today_dealsUncheckedUpdateManyInput>
    /**
     * Filter which today_deals to update
     * 
    **/
    where?: today_dealsWhereInput
  }


  /**
   * today_deals upsert
   */
  export type today_dealsUpsertArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * The filter to search for the today_deals to update in case it exists.
     * 
    **/
    where: today_dealsWhereUniqueInput
    /**
     * In case the today_deals found by the `where` argument doesn't exist, create a new today_deals with this data.
     * 
    **/
    create: XOR<today_dealsCreateInput, today_dealsUncheckedCreateInput>
    /**
     * In case the today_deals was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<today_dealsUpdateInput, today_dealsUncheckedUpdateInput>
  }


  /**
   * today_deals delete
   */
  export type today_dealsDeleteArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
    /**
     * Filter which today_deals to delete.
     * 
    **/
    where: today_dealsWhereUniqueInput
  }


  /**
   * today_deals deleteMany
   */
  export type today_dealsDeleteManyArgs = {
    /**
     * Filter which today_deals to delete
     * 
    **/
    where?: today_dealsWhereInput
  }


  /**
   * today_deals: findUniqueOrThrow
   */
  export type today_dealsFindUniqueOrThrowArgs = today_dealsFindUniqueArgsBase
      

  /**
   * today_deals: findFirstOrThrow
   */
  export type today_dealsFindFirstOrThrowArgs = today_dealsFindFirstArgsBase
      

  /**
   * today_deals without action
   */
  export type today_dealsArgs = {
    /**
     * Select specific fields to fetch from the today_deals
     * 
    **/
    select?: today_dealsSelect | null
  }



  /**
   * Model top_books
   */


  export type AggregateTop_books = {
    _count: Top_booksCountAggregateOutputType | null
    _avg: Top_booksAvgAggregateOutputType | null
    _sum: Top_booksSumAggregateOutputType | null
    _min: Top_booksMinAggregateOutputType | null
    _max: Top_booksMaxAggregateOutputType | null
  }

  export type Top_booksAvgAggregateOutputType = {
    id: number | null
    sales_count_by_bk_id: number | null
    book_id: number | null
    language_id: number | null
    language_id_tmp: number | null
    type_of_book: number | null
    author_id: number | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    genre_id_tmp: number | null
  }

  export type Top_booksSumAggregateOutputType = {
    id: number | null
    sales_count_by_bk_id: number | null
    book_id: number | null
    language_id: number | null
    language_id_tmp: number | null
    type_of_book: number | null
    author_id: number | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    genre_id_tmp: number | null
  }

  export type Top_booksMinAggregateOutputType = {
    id: number | null
    purpose: string | null
    sales_count_by_bk_id: number | null
    book_id: number | null
    book_title: string | null
    url_name: string | null
    regional_book_title: string | null
    language_id: number | null
    language_id_tmp: number | null
    type_of_book: number | null
    author_id: number | null
    author_name: string | null
    description: string | null
    download_link: string | null
    cover_image: string | null
    epub_url: string | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    genre_id_tmp: number | null
    genre_name: string | null
    book_category: string | null
  }

  export type Top_booksMaxAggregateOutputType = {
    id: number | null
    purpose: string | null
    sales_count_by_bk_id: number | null
    book_id: number | null
    book_title: string | null
    url_name: string | null
    regional_book_title: string | null
    language_id: number | null
    language_id_tmp: number | null
    type_of_book: number | null
    author_id: number | null
    author_name: string | null
    description: string | null
    download_link: string | null
    cover_image: string | null
    epub_url: string | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    genre_id_tmp: number | null
    genre_name: string | null
    book_category: string | null
  }

  export type Top_booksCountAggregateOutputType = {
    id: number
    purpose: number
    sales_count_by_bk_id: number
    book_id: number
    book_title: number
    url_name: number
    regional_book_title: number
    language_id: number
    language_id_tmp: number
    type_of_book: number
    author_id: number
    author_name: number
    description: number
    download_link: number
    cover_image: number
    epub_url: number
    cost: number
    number_of_page: number
    genre_id: number
    genre_id_tmp: number
    genre_name: number
    book_category: number
    _all: number
  }


  export type Top_booksAvgAggregateInputType = {
    id?: true
    sales_count_by_bk_id?: true
    book_id?: true
    language_id?: true
    language_id_tmp?: true
    type_of_book?: true
    author_id?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    genre_id_tmp?: true
  }

  export type Top_booksSumAggregateInputType = {
    id?: true
    sales_count_by_bk_id?: true
    book_id?: true
    language_id?: true
    language_id_tmp?: true
    type_of_book?: true
    author_id?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    genre_id_tmp?: true
  }

  export type Top_booksMinAggregateInputType = {
    id?: true
    purpose?: true
    sales_count_by_bk_id?: true
    book_id?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language_id?: true
    language_id_tmp?: true
    type_of_book?: true
    author_id?: true
    author_name?: true
    description?: true
    download_link?: true
    cover_image?: true
    epub_url?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    genre_id_tmp?: true
    genre_name?: true
    book_category?: true
  }

  export type Top_booksMaxAggregateInputType = {
    id?: true
    purpose?: true
    sales_count_by_bk_id?: true
    book_id?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language_id?: true
    language_id_tmp?: true
    type_of_book?: true
    author_id?: true
    author_name?: true
    description?: true
    download_link?: true
    cover_image?: true
    epub_url?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    genre_id_tmp?: true
    genre_name?: true
    book_category?: true
  }

  export type Top_booksCountAggregateInputType = {
    id?: true
    purpose?: true
    sales_count_by_bk_id?: true
    book_id?: true
    book_title?: true
    url_name?: true
    regional_book_title?: true
    language_id?: true
    language_id_tmp?: true
    type_of_book?: true
    author_id?: true
    author_name?: true
    description?: true
    download_link?: true
    cover_image?: true
    epub_url?: true
    cost?: true
    number_of_page?: true
    genre_id?: true
    genre_id_tmp?: true
    genre_name?: true
    book_category?: true
    _all?: true
  }

  export type Top_booksAggregateArgs = {
    /**
     * Filter which top_books to aggregate.
     * 
    **/
    where?: top_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of top_books to fetch.
     * 
    **/
    orderBy?: Enumerable<top_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: top_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` top_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` top_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned top_books
    **/
    _count?: true | Top_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Top_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Top_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Top_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Top_booksMaxAggregateInputType
  }

  export type GetTop_booksAggregateType<T extends Top_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateTop_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTop_books[P]>
      : GetScalarType<T[P], AggregateTop_books[P]>
  }




  export type Top_booksGroupByArgs = {
    where?: top_booksWhereInput
    orderBy?: Enumerable<top_booksOrderByWithAggregationInput>
    by: Array<Top_booksScalarFieldEnum>
    having?: top_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Top_booksCountAggregateInputType | true
    _avg?: Top_booksAvgAggregateInputType
    _sum?: Top_booksSumAggregateInputType
    _min?: Top_booksMinAggregateInputType
    _max?: Top_booksMaxAggregateInputType
  }


  export type Top_booksGroupByOutputType = {
    id: number
    purpose: string | null
    sales_count_by_bk_id: number | null
    book_id: number | null
    book_title: string | null
    url_name: string | null
    regional_book_title: string | null
    language_id: number | null
    language_id_tmp: number | null
    type_of_book: number | null
    author_id: number | null
    author_name: string | null
    description: string | null
    download_link: string | null
    cover_image: string | null
    epub_url: string | null
    cost: number | null
    number_of_page: number | null
    genre_id: number | null
    genre_id_tmp: number | null
    genre_name: string | null
    book_category: string | null
    _count: Top_booksCountAggregateOutputType | null
    _avg: Top_booksAvgAggregateOutputType | null
    _sum: Top_booksSumAggregateOutputType | null
    _min: Top_booksMinAggregateOutputType | null
    _max: Top_booksMaxAggregateOutputType | null
  }

  type GetTop_booksGroupByPayload<T extends Top_booksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Top_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Top_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Top_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Top_booksGroupByOutputType[P]>
        }
      >
    >


  export type top_booksSelect = {
    id?: boolean
    purpose?: boolean
    sales_count_by_bk_id?: boolean
    book_id?: boolean
    book_title?: boolean
    url_name?: boolean
    regional_book_title?: boolean
    language_id?: boolean
    language_id_tmp?: boolean
    type_of_book?: boolean
    author_id?: boolean
    author_name?: boolean
    description?: boolean
    download_link?: boolean
    cover_image?: boolean
    epub_url?: boolean
    cost?: boolean
    number_of_page?: boolean
    genre_id?: boolean
    genre_id_tmp?: boolean
    genre_name?: boolean
    book_category?: boolean
  }


  export type top_booksGetPayload<S extends boolean | null | undefined | top_booksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? top_books :
    S extends undefined ? never :
    S extends { include: any } & (top_booksArgs | top_booksFindManyArgs)
    ? top_books 
    : S extends { select: any } & (top_booksArgs | top_booksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof top_books ? top_books[P] : never
  } 
      : top_books


  type top_booksCountArgs = Merge<
    Omit<top_booksFindManyArgs, 'select' | 'include'> & {
      select?: Top_booksCountAggregateInputType | true
    }
  >

  export interface top_booksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Top_books that matches the filter.
     * @param {top_booksFindUniqueArgs} args - Arguments to find a Top_books
     * @example
     * // Get one Top_books
     * const top_books = await prisma.top_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends top_booksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, top_booksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'top_books'> extends True ? Prisma__top_booksClient<top_booksGetPayload<T>> : Prisma__top_booksClient<top_booksGetPayload<T> | null, null>

    /**
     * Find the first Top_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {top_booksFindFirstArgs} args - Arguments to find a Top_books
     * @example
     * // Get one Top_books
     * const top_books = await prisma.top_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends top_booksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, top_booksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'top_books'> extends True ? Prisma__top_booksClient<top_booksGetPayload<T>> : Prisma__top_booksClient<top_booksGetPayload<T> | null, null>

    /**
     * Find zero or more Top_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {top_booksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Top_books
     * const top_books = await prisma.top_books.findMany()
     * 
     * // Get first 10 Top_books
     * const top_books = await prisma.top_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const top_booksWithIdOnly = await prisma.top_books.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends top_booksFindManyArgs>(
      args?: SelectSubset<T, top_booksFindManyArgs>
    ): PrismaPromise<Array<top_booksGetPayload<T>>>

    /**
     * Create a Top_books.
     * @param {top_booksCreateArgs} args - Arguments to create a Top_books.
     * @example
     * // Create one Top_books
     * const Top_books = await prisma.top_books.create({
     *   data: {
     *     // ... data to create a Top_books
     *   }
     * })
     * 
    **/
    create<T extends top_booksCreateArgs>(
      args: SelectSubset<T, top_booksCreateArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Create many Top_books.
     *     @param {top_booksCreateManyArgs} args - Arguments to create many Top_books.
     *     @example
     *     // Create many Top_books
     *     const top_books = await prisma.top_books.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends top_booksCreateManyArgs>(
      args?: SelectSubset<T, top_booksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Top_books.
     * @param {top_booksDeleteArgs} args - Arguments to delete one Top_books.
     * @example
     * // Delete one Top_books
     * const Top_books = await prisma.top_books.delete({
     *   where: {
     *     // ... filter to delete one Top_books
     *   }
     * })
     * 
    **/
    delete<T extends top_booksDeleteArgs>(
      args: SelectSubset<T, top_booksDeleteArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Update one Top_books.
     * @param {top_booksUpdateArgs} args - Arguments to update one Top_books.
     * @example
     * // Update one Top_books
     * const top_books = await prisma.top_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends top_booksUpdateArgs>(
      args: SelectSubset<T, top_booksUpdateArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Delete zero or more Top_books.
     * @param {top_booksDeleteManyArgs} args - Arguments to filter Top_books to delete.
     * @example
     * // Delete a few Top_books
     * const { count } = await prisma.top_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends top_booksDeleteManyArgs>(
      args?: SelectSubset<T, top_booksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Top_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {top_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Top_books
     * const top_books = await prisma.top_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends top_booksUpdateManyArgs>(
      args: SelectSubset<T, top_booksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Top_books.
     * @param {top_booksUpsertArgs} args - Arguments to update or create a Top_books.
     * @example
     * // Update or create a Top_books
     * const top_books = await prisma.top_books.upsert({
     *   create: {
     *     // ... data to create a Top_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Top_books we want to update
     *   }
     * })
    **/
    upsert<T extends top_booksUpsertArgs>(
      args: SelectSubset<T, top_booksUpsertArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Find one Top_books that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {top_booksFindUniqueOrThrowArgs} args - Arguments to find a Top_books
     * @example
     * // Get one Top_books
     * const top_books = await prisma.top_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends top_booksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, top_booksFindUniqueOrThrowArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Find the first Top_books that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {top_booksFindFirstOrThrowArgs} args - Arguments to find a Top_books
     * @example
     * // Get one Top_books
     * const top_books = await prisma.top_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends top_booksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, top_booksFindFirstOrThrowArgs>
    ): Prisma__top_booksClient<top_booksGetPayload<T>>

    /**
     * Count the number of Top_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {top_booksCountArgs} args - Arguments to filter Top_books to count.
     * @example
     * // Count the number of Top_books
     * const count = await prisma.top_books.count({
     *   where: {
     *     // ... the filter for the Top_books we want to count
     *   }
     * })
    **/
    count<T extends top_booksCountArgs>(
      args?: Subset<T, top_booksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Top_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Top_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Top_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Top_booksAggregateArgs>(args: Subset<T, Top_booksAggregateArgs>): PrismaPromise<GetTop_booksAggregateType<T>>

    /**
     * Group by Top_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Top_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Top_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Top_booksGroupByArgs['orderBy'] }
        : { orderBy?: Top_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Top_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTop_booksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for top_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__top_booksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * top_books base type for findUnique actions
   */
  export type top_booksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * Filter, which top_books to fetch.
     * 
    **/
    where: top_booksWhereUniqueInput
  }

  /**
   * top_books: findUnique
   */
  export interface top_booksFindUniqueArgs extends top_booksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * top_books base type for findFirst actions
   */
  export type top_booksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * Filter, which top_books to fetch.
     * 
    **/
    where?: top_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of top_books to fetch.
     * 
    **/
    orderBy?: Enumerable<top_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for top_books.
     * 
    **/
    cursor?: top_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` top_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` top_books.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of top_books.
     * 
    **/
    distinct?: Enumerable<Top_booksScalarFieldEnum>
  }

  /**
   * top_books: findFirst
   */
  export interface top_booksFindFirstArgs extends top_booksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * top_books findMany
   */
  export type top_booksFindManyArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * Filter, which top_books to fetch.
     * 
    **/
    where?: top_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of top_books to fetch.
     * 
    **/
    orderBy?: Enumerable<top_booksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing top_books.
     * 
    **/
    cursor?: top_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` top_books from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` top_books.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Top_booksScalarFieldEnum>
  }


  /**
   * top_books create
   */
  export type top_booksCreateArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * The data needed to create a top_books.
     * 
    **/
    data: XOR<top_booksCreateInput, top_booksUncheckedCreateInput>
  }


  /**
   * top_books createMany
   */
  export type top_booksCreateManyArgs = {
    /**
     * The data used to create many top_books.
     * 
    **/
    data: Enumerable<top_booksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * top_books update
   */
  export type top_booksUpdateArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * The data needed to update a top_books.
     * 
    **/
    data: XOR<top_booksUpdateInput, top_booksUncheckedUpdateInput>
    /**
     * Choose, which top_books to update.
     * 
    **/
    where: top_booksWhereUniqueInput
  }


  /**
   * top_books updateMany
   */
  export type top_booksUpdateManyArgs = {
    /**
     * The data used to update top_books.
     * 
    **/
    data: XOR<top_booksUpdateManyMutationInput, top_booksUncheckedUpdateManyInput>
    /**
     * Filter which top_books to update
     * 
    **/
    where?: top_booksWhereInput
  }


  /**
   * top_books upsert
   */
  export type top_booksUpsertArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * The filter to search for the top_books to update in case it exists.
     * 
    **/
    where: top_booksWhereUniqueInput
    /**
     * In case the top_books found by the `where` argument doesn't exist, create a new top_books with this data.
     * 
    **/
    create: XOR<top_booksCreateInput, top_booksUncheckedCreateInput>
    /**
     * In case the top_books was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<top_booksUpdateInput, top_booksUncheckedUpdateInput>
  }


  /**
   * top_books delete
   */
  export type top_booksDeleteArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
    /**
     * Filter which top_books to delete.
     * 
    **/
    where: top_booksWhereUniqueInput
  }


  /**
   * top_books deleteMany
   */
  export type top_booksDeleteManyArgs = {
    /**
     * Filter which top_books to delete
     * 
    **/
    where?: top_booksWhereInput
  }


  /**
   * top_books: findUniqueOrThrow
   */
  export type top_booksFindUniqueOrThrowArgs = top_booksFindUniqueArgsBase
      

  /**
   * top_books: findFirstOrThrow
   */
  export type top_booksFindFirstOrThrowArgs = top_booksFindFirstArgsBase
      

  /**
   * top_books without action
   */
  export type top_booksArgs = {
    /**
     * Select specific fields to fetch from the top_books
     * 
    **/
    select?: top_booksSelect | null
  }



  /**
   * Model user_address
   */


  export type AggregateUser_address = {
    _count: User_addressCountAggregateOutputType | null
    _avg: User_addressAvgAggregateOutputType | null
    _sum: User_addressSumAggregateOutputType | null
    _min: User_addressMinAggregateOutputType | null
    _max: User_addressMaxAggregateOutputType | null
  }

  export type User_addressAvgAggregateOutputType = {
    user_id: number | null
  }

  export type User_addressSumAggregateOutputType = {
    user_id: number | null
  }

  export type User_addressMinAggregateOutputType = {
    user_id: number | null
    billing_name: string | null
    billing_address1: string | null
    billing_address2: string | null
    billing_area_name: string | null
    billing_landmark: string | null
    billing_city: string | null
    billing_state: string | null
    billing_pincode: string | null
    billing_mobile_no: string | null
    billing_alternate_no: string | null
    shipping_name: string | null
    shipping_address1: string | null
    shipping_address2: string | null
    shipping_area_name: string | null
    shipping_landmark: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_pincode: string | null
    shipping_mobile_no: string | null
    shipping_alternate_no: string | null
  }

  export type User_addressMaxAggregateOutputType = {
    user_id: number | null
    billing_name: string | null
    billing_address1: string | null
    billing_address2: string | null
    billing_area_name: string | null
    billing_landmark: string | null
    billing_city: string | null
    billing_state: string | null
    billing_pincode: string | null
    billing_mobile_no: string | null
    billing_alternate_no: string | null
    shipping_name: string | null
    shipping_address1: string | null
    shipping_address2: string | null
    shipping_area_name: string | null
    shipping_landmark: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_pincode: string | null
    shipping_mobile_no: string | null
    shipping_alternate_no: string | null
  }

  export type User_addressCountAggregateOutputType = {
    user_id: number
    billing_name: number
    billing_address1: number
    billing_address2: number
    billing_area_name: number
    billing_landmark: number
    billing_city: number
    billing_state: number
    billing_pincode: number
    billing_mobile_no: number
    billing_alternate_no: number
    shipping_name: number
    shipping_address1: number
    shipping_address2: number
    shipping_area_name: number
    shipping_landmark: number
    shipping_city: number
    shipping_state: number
    shipping_pincode: number
    shipping_mobile_no: number
    shipping_alternate_no: number
    _all: number
  }


  export type User_addressAvgAggregateInputType = {
    user_id?: true
  }

  export type User_addressSumAggregateInputType = {
    user_id?: true
  }

  export type User_addressMinAggregateInputType = {
    user_id?: true
    billing_name?: true
    billing_address1?: true
    billing_address2?: true
    billing_area_name?: true
    billing_landmark?: true
    billing_city?: true
    billing_state?: true
    billing_pincode?: true
    billing_mobile_no?: true
    billing_alternate_no?: true
    shipping_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_area_name?: true
    shipping_landmark?: true
    shipping_city?: true
    shipping_state?: true
    shipping_pincode?: true
    shipping_mobile_no?: true
    shipping_alternate_no?: true
  }

  export type User_addressMaxAggregateInputType = {
    user_id?: true
    billing_name?: true
    billing_address1?: true
    billing_address2?: true
    billing_area_name?: true
    billing_landmark?: true
    billing_city?: true
    billing_state?: true
    billing_pincode?: true
    billing_mobile_no?: true
    billing_alternate_no?: true
    shipping_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_area_name?: true
    shipping_landmark?: true
    shipping_city?: true
    shipping_state?: true
    shipping_pincode?: true
    shipping_mobile_no?: true
    shipping_alternate_no?: true
  }

  export type User_addressCountAggregateInputType = {
    user_id?: true
    billing_name?: true
    billing_address1?: true
    billing_address2?: true
    billing_area_name?: true
    billing_landmark?: true
    billing_city?: true
    billing_state?: true
    billing_pincode?: true
    billing_mobile_no?: true
    billing_alternate_no?: true
    shipping_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_area_name?: true
    shipping_landmark?: true
    shipping_city?: true
    shipping_state?: true
    shipping_pincode?: true
    shipping_mobile_no?: true
    shipping_alternate_no?: true
    _all?: true
  }

  export type User_addressAggregateArgs = {
    /**
     * Filter which user_address to aggregate.
     * 
    **/
    where?: user_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_addresses
    **/
    _count?: true | User_addressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_addressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_addressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_addressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_addressMaxAggregateInputType
  }

  export type GetUser_addressAggregateType<T extends User_addressAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_address]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_address[P]>
      : GetScalarType<T[P], AggregateUser_address[P]>
  }




  export type User_addressGroupByArgs = {
    where?: user_addressWhereInput
    orderBy?: Enumerable<user_addressOrderByWithAggregationInput>
    by: Array<User_addressScalarFieldEnum>
    having?: user_addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_addressCountAggregateInputType | true
    _avg?: User_addressAvgAggregateInputType
    _sum?: User_addressSumAggregateInputType
    _min?: User_addressMinAggregateInputType
    _max?: User_addressMaxAggregateInputType
  }


  export type User_addressGroupByOutputType = {
    user_id: number
    billing_name: string | null
    billing_address1: string | null
    billing_address2: string | null
    billing_area_name: string | null
    billing_landmark: string | null
    billing_city: string | null
    billing_state: string | null
    billing_pincode: string | null
    billing_mobile_no: string | null
    billing_alternate_no: string | null
    shipping_name: string | null
    shipping_address1: string | null
    shipping_address2: string | null
    shipping_area_name: string | null
    shipping_landmark: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_pincode: string | null
    shipping_mobile_no: string | null
    shipping_alternate_no: string | null
    _count: User_addressCountAggregateOutputType | null
    _avg: User_addressAvgAggregateOutputType | null
    _sum: User_addressSumAggregateOutputType | null
    _min: User_addressMinAggregateOutputType | null
    _max: User_addressMaxAggregateOutputType | null
  }

  type GetUser_addressGroupByPayload<T extends User_addressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_addressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_addressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_addressGroupByOutputType[P]>
            : GetScalarType<T[P], User_addressGroupByOutputType[P]>
        }
      >
    >


  export type user_addressSelect = {
    user_id?: boolean
    billing_name?: boolean
    billing_address1?: boolean
    billing_address2?: boolean
    billing_area_name?: boolean
    billing_landmark?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_pincode?: boolean
    billing_mobile_no?: boolean
    billing_alternate_no?: boolean
    shipping_name?: boolean
    shipping_address1?: boolean
    shipping_address2?: boolean
    shipping_area_name?: boolean
    shipping_landmark?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_pincode?: boolean
    shipping_mobile_no?: boolean
    shipping_alternate_no?: boolean
  }


  export type user_addressGetPayload<S extends boolean | null | undefined | user_addressArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user_address :
    S extends undefined ? never :
    S extends { include: any } & (user_addressArgs | user_addressFindManyArgs)
    ? user_address 
    : S extends { select: any } & (user_addressArgs | user_addressFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user_address ? user_address[P] : never
  } 
      : user_address


  type user_addressCountArgs = Merge<
    Omit<user_addressFindManyArgs, 'select' | 'include'> & {
      select?: User_addressCountAggregateInputType | true
    }
  >

  export interface user_addressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User_address that matches the filter.
     * @param {user_addressFindUniqueArgs} args - Arguments to find a User_address
     * @example
     * // Get one User_address
     * const user_address = await prisma.user_address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_addressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_addressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_address'> extends True ? Prisma__user_addressClient<user_addressGetPayload<T>> : Prisma__user_addressClient<user_addressGetPayload<T> | null, null>

    /**
     * Find the first User_address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressFindFirstArgs} args - Arguments to find a User_address
     * @example
     * // Get one User_address
     * const user_address = await prisma.user_address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_addressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_addressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_address'> extends True ? Prisma__user_addressClient<user_addressGetPayload<T>> : Prisma__user_addressClient<user_addressGetPayload<T> | null, null>

    /**
     * Find zero or more User_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_addresses
     * const user_addresses = await prisma.user_address.findMany()
     * 
     * // Get first 10 User_addresses
     * const user_addresses = await prisma.user_address.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_addressWithUser_idOnly = await prisma.user_address.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_addressFindManyArgs>(
      args?: SelectSubset<T, user_addressFindManyArgs>
    ): PrismaPromise<Array<user_addressGetPayload<T>>>

    /**
     * Create a User_address.
     * @param {user_addressCreateArgs} args - Arguments to create a User_address.
     * @example
     * // Create one User_address
     * const User_address = await prisma.user_address.create({
     *   data: {
     *     // ... data to create a User_address
     *   }
     * })
     * 
    **/
    create<T extends user_addressCreateArgs>(
      args: SelectSubset<T, user_addressCreateArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Create many User_addresses.
     *     @param {user_addressCreateManyArgs} args - Arguments to create many User_addresses.
     *     @example
     *     // Create many User_addresses
     *     const user_address = await prisma.user_address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_addressCreateManyArgs>(
      args?: SelectSubset<T, user_addressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_address.
     * @param {user_addressDeleteArgs} args - Arguments to delete one User_address.
     * @example
     * // Delete one User_address
     * const User_address = await prisma.user_address.delete({
     *   where: {
     *     // ... filter to delete one User_address
     *   }
     * })
     * 
    **/
    delete<T extends user_addressDeleteArgs>(
      args: SelectSubset<T, user_addressDeleteArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Update one User_address.
     * @param {user_addressUpdateArgs} args - Arguments to update one User_address.
     * @example
     * // Update one User_address
     * const user_address = await prisma.user_address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_addressUpdateArgs>(
      args: SelectSubset<T, user_addressUpdateArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Delete zero or more User_addresses.
     * @param {user_addressDeleteManyArgs} args - Arguments to filter User_addresses to delete.
     * @example
     * // Delete a few User_addresses
     * const { count } = await prisma.user_address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_addressDeleteManyArgs>(
      args?: SelectSubset<T, user_addressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_addresses
     * const user_address = await prisma.user_address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_addressUpdateManyArgs>(
      args: SelectSubset<T, user_addressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_address.
     * @param {user_addressUpsertArgs} args - Arguments to update or create a User_address.
     * @example
     * // Update or create a User_address
     * const user_address = await prisma.user_address.upsert({
     *   create: {
     *     // ... data to create a User_address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_address we want to update
     *   }
     * })
    **/
    upsert<T extends user_addressUpsertArgs>(
      args: SelectSubset<T, user_addressUpsertArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Find one User_address that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_addressFindUniqueOrThrowArgs} args - Arguments to find a User_address
     * @example
     * // Get one User_address
     * const user_address = await prisma.user_address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_addressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_addressFindUniqueOrThrowArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Find the first User_address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressFindFirstOrThrowArgs} args - Arguments to find a User_address
     * @example
     * // Get one User_address
     * const user_address = await prisma.user_address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_addressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_addressFindFirstOrThrowArgs>
    ): Prisma__user_addressClient<user_addressGetPayload<T>>

    /**
     * Count the number of User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressCountArgs} args - Arguments to filter User_addresses to count.
     * @example
     * // Count the number of User_addresses
     * const count = await prisma.user_address.count({
     *   where: {
     *     // ... the filter for the User_addresses we want to count
     *   }
     * })
    **/
    count<T extends user_addressCountArgs>(
      args?: Subset<T, user_addressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_addressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_addressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_addressAggregateArgs>(args: Subset<T, User_addressAggregateArgs>): PrismaPromise<GetUser_addressAggregateType<T>>

    /**
     * Group by User_address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_addressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_addressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_addressGroupByArgs['orderBy'] }
        : { orderBy?: User_addressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_addressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_addressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_addressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_address base type for findUnique actions
   */
  export type user_addressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * Filter, which user_address to fetch.
     * 
    **/
    where: user_addressWhereUniqueInput
  }

  /**
   * user_address: findUnique
   */
  export interface user_addressFindUniqueArgs extends user_addressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_address base type for findFirst actions
   */
  export type user_addressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * Filter, which user_address to fetch.
     * 
    **/
    where?: user_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_addresses.
     * 
    **/
    cursor?: user_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_addresses.
     * 
    **/
    distinct?: Enumerable<User_addressScalarFieldEnum>
  }

  /**
   * user_address: findFirst
   */
  export interface user_addressFindFirstArgs extends user_addressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_address findMany
   */
  export type user_addressFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * Filter, which user_addresses to fetch.
     * 
    **/
    where?: user_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_addresses.
     * 
    **/
    cursor?: user_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_addressScalarFieldEnum>
  }


  /**
   * user_address create
   */
  export type user_addressCreateArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * The data needed to create a user_address.
     * 
    **/
    data: XOR<user_addressCreateInput, user_addressUncheckedCreateInput>
  }


  /**
   * user_address createMany
   */
  export type user_addressCreateManyArgs = {
    /**
     * The data used to create many user_addresses.
     * 
    **/
    data: Enumerable<user_addressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_address update
   */
  export type user_addressUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * The data needed to update a user_address.
     * 
    **/
    data: XOR<user_addressUpdateInput, user_addressUncheckedUpdateInput>
    /**
     * Choose, which user_address to update.
     * 
    **/
    where: user_addressWhereUniqueInput
  }


  /**
   * user_address updateMany
   */
  export type user_addressUpdateManyArgs = {
    /**
     * The data used to update user_addresses.
     * 
    **/
    data: XOR<user_addressUpdateManyMutationInput, user_addressUncheckedUpdateManyInput>
    /**
     * Filter which user_addresses to update
     * 
    **/
    where?: user_addressWhereInput
  }


  /**
   * user_address upsert
   */
  export type user_addressUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * The filter to search for the user_address to update in case it exists.
     * 
    **/
    where: user_addressWhereUniqueInput
    /**
     * In case the user_address found by the `where` argument doesn't exist, create a new user_address with this data.
     * 
    **/
    create: XOR<user_addressCreateInput, user_addressUncheckedCreateInput>
    /**
     * In case the user_address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_addressUpdateInput, user_addressUncheckedUpdateInput>
  }


  /**
   * user_address delete
   */
  export type user_addressDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
    /**
     * Filter which user_address to delete.
     * 
    **/
    where: user_addressWhereUniqueInput
  }


  /**
   * user_address deleteMany
   */
  export type user_addressDeleteManyArgs = {
    /**
     * Filter which user_addresses to delete
     * 
    **/
    where?: user_addressWhereInput
  }


  /**
   * user_address: findUniqueOrThrow
   */
  export type user_addressFindUniqueOrThrowArgs = user_addressFindUniqueArgsBase
      

  /**
   * user_address: findFirstOrThrow
   */
  export type user_addressFindFirstOrThrowArgs = user_addressFindFirstArgsBase
      

  /**
   * user_address without action
   */
  export type user_addressArgs = {
    /**
     * Select specific fields to fetch from the user_address
     * 
    **/
    select?: user_addressSelect | null
  }



  /**
   * Model user_devices
   */


  export type AggregateUser_devices = {
    _count: User_devicesCountAggregateOutputType | null
    _avg: User_devicesAvgAggregateOutputType | null
    _sum: User_devicesSumAggregateOutputType | null
    _min: User_devicesMinAggregateOutputType | null
    _max: User_devicesMaxAggregateOutputType | null
  }

  export type User_devicesAvgAggregateOutputType = {
    user_id: number | null
  }

  export type User_devicesSumAggregateOutputType = {
    user_id: number | null
  }

  export type User_devicesMinAggregateOutputType = {
    user_id: number | null
    device_id1: string | null
    device_info1: string | null
    device_id2: string | null
    device_info2: string | null
    device_id3: string | null
    device_info3: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_devicesMaxAggregateOutputType = {
    user_id: number | null
    device_id1: string | null
    device_info1: string | null
    device_id2: string | null
    device_info2: string | null
    device_id3: string | null
    device_info3: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_devicesCountAggregateOutputType = {
    user_id: number
    device_id1: number
    device_info1: number
    device_id2: number
    device_info2: number
    device_id3: number
    device_info3: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_devicesAvgAggregateInputType = {
    user_id?: true
  }

  export type User_devicesSumAggregateInputType = {
    user_id?: true
  }

  export type User_devicesMinAggregateInputType = {
    user_id?: true
    device_id1?: true
    device_info1?: true
    device_id2?: true
    device_info2?: true
    device_id3?: true
    device_info3?: true
    created_at?: true
    updated_at?: true
  }

  export type User_devicesMaxAggregateInputType = {
    user_id?: true
    device_id1?: true
    device_info1?: true
    device_id2?: true
    device_info2?: true
    device_id3?: true
    device_info3?: true
    created_at?: true
    updated_at?: true
  }

  export type User_devicesCountAggregateInputType = {
    user_id?: true
    device_id1?: true
    device_info1?: true
    device_id2?: true
    device_info2?: true
    device_id3?: true
    device_info3?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_devicesAggregateArgs = {
    /**
     * Filter which user_devices to aggregate.
     * 
    **/
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     * 
    **/
    orderBy?: Enumerable<user_devicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_devices
    **/
    _count?: true | User_devicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_devicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_devicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_devicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_devicesMaxAggregateInputType
  }

  export type GetUser_devicesAggregateType<T extends User_devicesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_devices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_devices[P]>
      : GetScalarType<T[P], AggregateUser_devices[P]>
  }




  export type User_devicesGroupByArgs = {
    where?: user_devicesWhereInput
    orderBy?: Enumerable<user_devicesOrderByWithAggregationInput>
    by: Array<User_devicesScalarFieldEnum>
    having?: user_devicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_devicesCountAggregateInputType | true
    _avg?: User_devicesAvgAggregateInputType
    _sum?: User_devicesSumAggregateInputType
    _min?: User_devicesMinAggregateInputType
    _max?: User_devicesMaxAggregateInputType
  }


  export type User_devicesGroupByOutputType = {
    user_id: number
    device_id1: string
    device_info1: string
    device_id2: string
    device_info2: string
    device_id3: string
    device_info3: string
    created_at: Date
    updated_at: Date
    _count: User_devicesCountAggregateOutputType | null
    _avg: User_devicesAvgAggregateOutputType | null
    _sum: User_devicesSumAggregateOutputType | null
    _min: User_devicesMinAggregateOutputType | null
    _max: User_devicesMaxAggregateOutputType | null
  }

  type GetUser_devicesGroupByPayload<T extends User_devicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_devicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_devicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_devicesGroupByOutputType[P]>
            : GetScalarType<T[P], User_devicesGroupByOutputType[P]>
        }
      >
    >


  export type user_devicesSelect = {
    user_id?: boolean
    device_id1?: boolean
    device_info1?: boolean
    device_id2?: boolean
    device_info2?: boolean
    device_id3?: boolean
    device_info3?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type user_devicesGetPayload<S extends boolean | null | undefined | user_devicesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user_devices :
    S extends undefined ? never :
    S extends { include: any } & (user_devicesArgs | user_devicesFindManyArgs)
    ? user_devices 
    : S extends { select: any } & (user_devicesArgs | user_devicesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user_devices ? user_devices[P] : never
  } 
      : user_devices


  type user_devicesCountArgs = Merge<
    Omit<user_devicesFindManyArgs, 'select' | 'include'> & {
      select?: User_devicesCountAggregateInputType | true
    }
  >

  export interface user_devicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User_devices that matches the filter.
     * @param {user_devicesFindUniqueArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_devicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_devicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_devices'> extends True ? Prisma__user_devicesClient<user_devicesGetPayload<T>> : Prisma__user_devicesClient<user_devicesGetPayload<T> | null, null>

    /**
     * Find the first User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_devicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_devicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_devices'> extends True ? Prisma__user_devicesClient<user_devicesGetPayload<T>> : Prisma__user_devicesClient<user_devicesGetPayload<T> | null, null>

    /**
     * Find zero or more User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_devices
     * const user_devices = await prisma.user_devices.findMany()
     * 
     * // Get first 10 User_devices
     * const user_devices = await prisma.user_devices.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_devicesWithUser_idOnly = await prisma.user_devices.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_devicesFindManyArgs>(
      args?: SelectSubset<T, user_devicesFindManyArgs>
    ): PrismaPromise<Array<user_devicesGetPayload<T>>>

    /**
     * Create a User_devices.
     * @param {user_devicesCreateArgs} args - Arguments to create a User_devices.
     * @example
     * // Create one User_devices
     * const User_devices = await prisma.user_devices.create({
     *   data: {
     *     // ... data to create a User_devices
     *   }
     * })
     * 
    **/
    create<T extends user_devicesCreateArgs>(
      args: SelectSubset<T, user_devicesCreateArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Create many User_devices.
     *     @param {user_devicesCreateManyArgs} args - Arguments to create many User_devices.
     *     @example
     *     // Create many User_devices
     *     const user_devices = await prisma.user_devices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_devicesCreateManyArgs>(
      args?: SelectSubset<T, user_devicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_devices.
     * @param {user_devicesDeleteArgs} args - Arguments to delete one User_devices.
     * @example
     * // Delete one User_devices
     * const User_devices = await prisma.user_devices.delete({
     *   where: {
     *     // ... filter to delete one User_devices
     *   }
     * })
     * 
    **/
    delete<T extends user_devicesDeleteArgs>(
      args: SelectSubset<T, user_devicesDeleteArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Update one User_devices.
     * @param {user_devicesUpdateArgs} args - Arguments to update one User_devices.
     * @example
     * // Update one User_devices
     * const user_devices = await prisma.user_devices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_devicesUpdateArgs>(
      args: SelectSubset<T, user_devicesUpdateArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Delete zero or more User_devices.
     * @param {user_devicesDeleteManyArgs} args - Arguments to filter User_devices to delete.
     * @example
     * // Delete a few User_devices
     * const { count } = await prisma.user_devices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_devicesDeleteManyArgs>(
      args?: SelectSubset<T, user_devicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_devices
     * const user_devices = await prisma.user_devices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_devicesUpdateManyArgs>(
      args: SelectSubset<T, user_devicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_devices.
     * @param {user_devicesUpsertArgs} args - Arguments to update or create a User_devices.
     * @example
     * // Update or create a User_devices
     * const user_devices = await prisma.user_devices.upsert({
     *   create: {
     *     // ... data to create a User_devices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_devices we want to update
     *   }
     * })
    **/
    upsert<T extends user_devicesUpsertArgs>(
      args: SelectSubset<T, user_devicesUpsertArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Find one User_devices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_devicesFindUniqueOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_devicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_devicesFindUniqueOrThrowArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Find the first User_devices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_devicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_devicesFindFirstOrThrowArgs>
    ): Prisma__user_devicesClient<user_devicesGetPayload<T>>

    /**
     * Count the number of User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesCountArgs} args - Arguments to filter User_devices to count.
     * @example
     * // Count the number of User_devices
     * const count = await prisma.user_devices.count({
     *   where: {
     *     // ... the filter for the User_devices we want to count
     *   }
     * })
    **/
    count<T extends user_devicesCountArgs>(
      args?: Subset<T, user_devicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_devicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_devicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_devicesAggregateArgs>(args: Subset<T, User_devicesAggregateArgs>): PrismaPromise<GetUser_devicesAggregateType<T>>

    /**
     * Group by User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_devicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_devicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_devicesGroupByArgs['orderBy'] }
        : { orderBy?: User_devicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_devicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_devicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_devices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_devicesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_devices base type for findUnique actions
   */
  export type user_devicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * Filter, which user_devices to fetch.
     * 
    **/
    where: user_devicesWhereUniqueInput
  }

  /**
   * user_devices: findUnique
   */
  export interface user_devicesFindUniqueArgs extends user_devicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_devices base type for findFirst actions
   */
  export type user_devicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * Filter, which user_devices to fetch.
     * 
    **/
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     * 
    **/
    orderBy?: Enumerable<user_devicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_devices.
     * 
    **/
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_devices.
     * 
    **/
    distinct?: Enumerable<User_devicesScalarFieldEnum>
  }

  /**
   * user_devices: findFirst
   */
  export interface user_devicesFindFirstArgs extends user_devicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_devices findMany
   */
  export type user_devicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * Filter, which user_devices to fetch.
     * 
    **/
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     * 
    **/
    orderBy?: Enumerable<user_devicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_devices.
     * 
    **/
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_devicesScalarFieldEnum>
  }


  /**
   * user_devices create
   */
  export type user_devicesCreateArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * The data needed to create a user_devices.
     * 
    **/
    data: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>
  }


  /**
   * user_devices createMany
   */
  export type user_devicesCreateManyArgs = {
    /**
     * The data used to create many user_devices.
     * 
    **/
    data: Enumerable<user_devicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_devices update
   */
  export type user_devicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * The data needed to update a user_devices.
     * 
    **/
    data: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>
    /**
     * Choose, which user_devices to update.
     * 
    **/
    where: user_devicesWhereUniqueInput
  }


  /**
   * user_devices updateMany
   */
  export type user_devicesUpdateManyArgs = {
    /**
     * The data used to update user_devices.
     * 
    **/
    data: XOR<user_devicesUpdateManyMutationInput, user_devicesUncheckedUpdateManyInput>
    /**
     * Filter which user_devices to update
     * 
    **/
    where?: user_devicesWhereInput
  }


  /**
   * user_devices upsert
   */
  export type user_devicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * The filter to search for the user_devices to update in case it exists.
     * 
    **/
    where: user_devicesWhereUniqueInput
    /**
     * In case the user_devices found by the `where` argument doesn't exist, create a new user_devices with this data.
     * 
    **/
    create: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>
    /**
     * In case the user_devices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>
  }


  /**
   * user_devices delete
   */
  export type user_devicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
    /**
     * Filter which user_devices to delete.
     * 
    **/
    where: user_devicesWhereUniqueInput
  }


  /**
   * user_devices deleteMany
   */
  export type user_devicesDeleteManyArgs = {
    /**
     * Filter which user_devices to delete
     * 
    **/
    where?: user_devicesWhereInput
  }


  /**
   * user_devices: findUniqueOrThrow
   */
  export type user_devicesFindUniqueOrThrowArgs = user_devicesFindUniqueArgsBase
      

  /**
   * user_devices: findFirstOrThrow
   */
  export type user_devicesFindFirstOrThrowArgs = user_devicesFindFirstArgsBase
      

  /**
   * user_devices without action
   */
  export type user_devicesArgs = {
    /**
     * Select specific fields to fetch from the user_devices
     * 
    **/
    select?: user_devicesSelect | null
  }



  /**
   * Model user_subscription_tbl
   */


  export type AggregateUser_subscription_tbl = {
    _count: User_subscription_tblCountAggregateOutputType | null
    _avg: User_subscription_tblAvgAggregateOutputType | null
    _sum: User_subscription_tblSumAggregateOutputType | null
    _min: User_subscription_tblMinAggregateOutputType | null
    _max: User_subscription_tblMaxAggregateOutputType | null
  }

  export type User_subscription_tblAvgAggregateOutputType = {
    subscription_id: number | null
    user_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type User_subscription_tblSumAggregateOutputType = {
    subscription_id: number | null
    user_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type User_subscription_tblMinAggregateOutputType = {
    subscription_id: number | null
    user_id: number | null
    user_email_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type User_subscription_tblMaxAggregateOutputType = {
    subscription_id: number | null
    user_id: number | null
    user_email_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type User_subscription_tblCountAggregateOutputType = {
    subscription_id: number
    user_id: number
    user_email_id: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type User_subscription_tblAvgAggregateInputType = {
    subscription_id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type User_subscription_tblSumAggregateInputType = {
    subscription_id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type User_subscription_tblMinAggregateInputType = {
    subscription_id?: true
    user_id?: true
    user_email_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type User_subscription_tblMaxAggregateInputType = {
    subscription_id?: true
    user_id?: true
    user_email_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type User_subscription_tblCountAggregateInputType = {
    subscription_id?: true
    user_id?: true
    user_email_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type User_subscription_tblAggregateArgs = {
    /**
     * Filter which user_subscription_tbl to aggregate.
     * 
    **/
    where?: user_subscription_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_subscription_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<user_subscription_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_subscription_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_subscription_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_subscription_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_subscription_tbls
    **/
    _count?: true | User_subscription_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_subscription_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_subscription_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_subscription_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_subscription_tblMaxAggregateInputType
  }

  export type GetUser_subscription_tblAggregateType<T extends User_subscription_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_subscription_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_subscription_tbl[P]>
      : GetScalarType<T[P], AggregateUser_subscription_tbl[P]>
  }




  export type User_subscription_tblGroupByArgs = {
    where?: user_subscription_tblWhereInput
    orderBy?: Enumerable<user_subscription_tblOrderByWithAggregationInput>
    by: Array<User_subscription_tblScalarFieldEnum>
    having?: user_subscription_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_subscription_tblCountAggregateInputType | true
    _avg?: User_subscription_tblAvgAggregateInputType
    _sum?: User_subscription_tblSumAggregateInputType
    _min?: User_subscription_tblMinAggregateInputType
    _max?: User_subscription_tblMaxAggregateInputType
  }


  export type User_subscription_tblGroupByOutputType = {
    subscription_id: number
    user_id: number
    user_email_id: string
    created_at: Date
    updated_at: Date | null
    created_by: number
    updated_by: number
    _count: User_subscription_tblCountAggregateOutputType | null
    _avg: User_subscription_tblAvgAggregateOutputType | null
    _sum: User_subscription_tblSumAggregateOutputType | null
    _min: User_subscription_tblMinAggregateOutputType | null
    _max: User_subscription_tblMaxAggregateOutputType | null
  }

  type GetUser_subscription_tblGroupByPayload<T extends User_subscription_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_subscription_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_subscription_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_subscription_tblGroupByOutputType[P]>
            : GetScalarType<T[P], User_subscription_tblGroupByOutputType[P]>
        }
      >
    >


  export type user_subscription_tblSelect = {
    subscription_id?: boolean
    user_id?: boolean
    user_email_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type user_subscription_tblGetPayload<S extends boolean | null | undefined | user_subscription_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user_subscription_tbl :
    S extends undefined ? never :
    S extends { include: any } & (user_subscription_tblArgs | user_subscription_tblFindManyArgs)
    ? user_subscription_tbl 
    : S extends { select: any } & (user_subscription_tblArgs | user_subscription_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user_subscription_tbl ? user_subscription_tbl[P] : never
  } 
      : user_subscription_tbl


  type user_subscription_tblCountArgs = Merge<
    Omit<user_subscription_tblFindManyArgs, 'select' | 'include'> & {
      select?: User_subscription_tblCountAggregateInputType | true
    }
  >

  export interface user_subscription_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User_subscription_tbl that matches the filter.
     * @param {user_subscription_tblFindUniqueArgs} args - Arguments to find a User_subscription_tbl
     * @example
     * // Get one User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_subscription_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_subscription_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_subscription_tbl'> extends True ? Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>> : Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T> | null, null>

    /**
     * Find the first User_subscription_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscription_tblFindFirstArgs} args - Arguments to find a User_subscription_tbl
     * @example
     * // Get one User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_subscription_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_subscription_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_subscription_tbl'> extends True ? Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>> : Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T> | null, null>

    /**
     * Find zero or more User_subscription_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscription_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_subscription_tbls
     * const user_subscription_tbls = await prisma.user_subscription_tbl.findMany()
     * 
     * // Get first 10 User_subscription_tbls
     * const user_subscription_tbls = await prisma.user_subscription_tbl.findMany({ take: 10 })
     * 
     * // Only select the `subscription_id`
     * const user_subscription_tblWithSubscription_idOnly = await prisma.user_subscription_tbl.findMany({ select: { subscription_id: true } })
     * 
    **/
    findMany<T extends user_subscription_tblFindManyArgs>(
      args?: SelectSubset<T, user_subscription_tblFindManyArgs>
    ): PrismaPromise<Array<user_subscription_tblGetPayload<T>>>

    /**
     * Create a User_subscription_tbl.
     * @param {user_subscription_tblCreateArgs} args - Arguments to create a User_subscription_tbl.
     * @example
     * // Create one User_subscription_tbl
     * const User_subscription_tbl = await prisma.user_subscription_tbl.create({
     *   data: {
     *     // ... data to create a User_subscription_tbl
     *   }
     * })
     * 
    **/
    create<T extends user_subscription_tblCreateArgs>(
      args: SelectSubset<T, user_subscription_tblCreateArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Create many User_subscription_tbls.
     *     @param {user_subscription_tblCreateManyArgs} args - Arguments to create many User_subscription_tbls.
     *     @example
     *     // Create many User_subscription_tbls
     *     const user_subscription_tbl = await prisma.user_subscription_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_subscription_tblCreateManyArgs>(
      args?: SelectSubset<T, user_subscription_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_subscription_tbl.
     * @param {user_subscription_tblDeleteArgs} args - Arguments to delete one User_subscription_tbl.
     * @example
     * // Delete one User_subscription_tbl
     * const User_subscription_tbl = await prisma.user_subscription_tbl.delete({
     *   where: {
     *     // ... filter to delete one User_subscription_tbl
     *   }
     * })
     * 
    **/
    delete<T extends user_subscription_tblDeleteArgs>(
      args: SelectSubset<T, user_subscription_tblDeleteArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Update one User_subscription_tbl.
     * @param {user_subscription_tblUpdateArgs} args - Arguments to update one User_subscription_tbl.
     * @example
     * // Update one User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_subscription_tblUpdateArgs>(
      args: SelectSubset<T, user_subscription_tblUpdateArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Delete zero or more User_subscription_tbls.
     * @param {user_subscription_tblDeleteManyArgs} args - Arguments to filter User_subscription_tbls to delete.
     * @example
     * // Delete a few User_subscription_tbls
     * const { count } = await prisma.user_subscription_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_subscription_tblDeleteManyArgs>(
      args?: SelectSubset<T, user_subscription_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_subscription_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscription_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_subscription_tbls
     * const user_subscription_tbl = await prisma.user_subscription_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_subscription_tblUpdateManyArgs>(
      args: SelectSubset<T, user_subscription_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_subscription_tbl.
     * @param {user_subscription_tblUpsertArgs} args - Arguments to update or create a User_subscription_tbl.
     * @example
     * // Update or create a User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.upsert({
     *   create: {
     *     // ... data to create a User_subscription_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_subscription_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends user_subscription_tblUpsertArgs>(
      args: SelectSubset<T, user_subscription_tblUpsertArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Find one User_subscription_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_subscription_tblFindUniqueOrThrowArgs} args - Arguments to find a User_subscription_tbl
     * @example
     * // Get one User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_subscription_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_subscription_tblFindUniqueOrThrowArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Find the first User_subscription_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscription_tblFindFirstOrThrowArgs} args - Arguments to find a User_subscription_tbl
     * @example
     * // Get one User_subscription_tbl
     * const user_subscription_tbl = await prisma.user_subscription_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_subscription_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_subscription_tblFindFirstOrThrowArgs>
    ): Prisma__user_subscription_tblClient<user_subscription_tblGetPayload<T>>

    /**
     * Count the number of User_subscription_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscription_tblCountArgs} args - Arguments to filter User_subscription_tbls to count.
     * @example
     * // Count the number of User_subscription_tbls
     * const count = await prisma.user_subscription_tbl.count({
     *   where: {
     *     // ... the filter for the User_subscription_tbls we want to count
     *   }
     * })
    **/
    count<T extends user_subscription_tblCountArgs>(
      args?: Subset<T, user_subscription_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_subscription_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_subscription_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_subscription_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_subscription_tblAggregateArgs>(args: Subset<T, User_subscription_tblAggregateArgs>): PrismaPromise<GetUser_subscription_tblAggregateType<T>>

    /**
     * Group by User_subscription_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_subscription_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_subscription_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_subscription_tblGroupByArgs['orderBy'] }
        : { orderBy?: User_subscription_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_subscription_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_subscription_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_subscription_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_subscription_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_subscription_tbl base type for findUnique actions
   */
  export type user_subscription_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * Filter, which user_subscription_tbl to fetch.
     * 
    **/
    where: user_subscription_tblWhereUniqueInput
  }

  /**
   * user_subscription_tbl: findUnique
   */
  export interface user_subscription_tblFindUniqueArgs extends user_subscription_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_subscription_tbl base type for findFirst actions
   */
  export type user_subscription_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * Filter, which user_subscription_tbl to fetch.
     * 
    **/
    where?: user_subscription_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_subscription_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<user_subscription_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_subscription_tbls.
     * 
    **/
    cursor?: user_subscription_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_subscription_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_subscription_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_subscription_tbls.
     * 
    **/
    distinct?: Enumerable<User_subscription_tblScalarFieldEnum>
  }

  /**
   * user_subscription_tbl: findFirst
   */
  export interface user_subscription_tblFindFirstArgs extends user_subscription_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_subscription_tbl findMany
   */
  export type user_subscription_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * Filter, which user_subscription_tbls to fetch.
     * 
    **/
    where?: user_subscription_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_subscription_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<user_subscription_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_subscription_tbls.
     * 
    **/
    cursor?: user_subscription_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_subscription_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_subscription_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_subscription_tblScalarFieldEnum>
  }


  /**
   * user_subscription_tbl create
   */
  export type user_subscription_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * The data needed to create a user_subscription_tbl.
     * 
    **/
    data: XOR<user_subscription_tblCreateInput, user_subscription_tblUncheckedCreateInput>
  }


  /**
   * user_subscription_tbl createMany
   */
  export type user_subscription_tblCreateManyArgs = {
    /**
     * The data used to create many user_subscription_tbls.
     * 
    **/
    data: Enumerable<user_subscription_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_subscription_tbl update
   */
  export type user_subscription_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * The data needed to update a user_subscription_tbl.
     * 
    **/
    data: XOR<user_subscription_tblUpdateInput, user_subscription_tblUncheckedUpdateInput>
    /**
     * Choose, which user_subscription_tbl to update.
     * 
    **/
    where: user_subscription_tblWhereUniqueInput
  }


  /**
   * user_subscription_tbl updateMany
   */
  export type user_subscription_tblUpdateManyArgs = {
    /**
     * The data used to update user_subscription_tbls.
     * 
    **/
    data: XOR<user_subscription_tblUpdateManyMutationInput, user_subscription_tblUncheckedUpdateManyInput>
    /**
     * Filter which user_subscription_tbls to update
     * 
    **/
    where?: user_subscription_tblWhereInput
  }


  /**
   * user_subscription_tbl upsert
   */
  export type user_subscription_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * The filter to search for the user_subscription_tbl to update in case it exists.
     * 
    **/
    where: user_subscription_tblWhereUniqueInput
    /**
     * In case the user_subscription_tbl found by the `where` argument doesn't exist, create a new user_subscription_tbl with this data.
     * 
    **/
    create: XOR<user_subscription_tblCreateInput, user_subscription_tblUncheckedCreateInput>
    /**
     * In case the user_subscription_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_subscription_tblUpdateInput, user_subscription_tblUncheckedUpdateInput>
  }


  /**
   * user_subscription_tbl delete
   */
  export type user_subscription_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
    /**
     * Filter which user_subscription_tbl to delete.
     * 
    **/
    where: user_subscription_tblWhereUniqueInput
  }


  /**
   * user_subscription_tbl deleteMany
   */
  export type user_subscription_tblDeleteManyArgs = {
    /**
     * Filter which user_subscription_tbls to delete
     * 
    **/
    where?: user_subscription_tblWhereInput
  }


  /**
   * user_subscription_tbl: findUniqueOrThrow
   */
  export type user_subscription_tblFindUniqueOrThrowArgs = user_subscription_tblFindUniqueArgsBase
      

  /**
   * user_subscription_tbl: findFirstOrThrow
   */
  export type user_subscription_tblFindFirstOrThrowArgs = user_subscription_tblFindFirstArgsBase
      

  /**
   * user_subscription_tbl without action
   */
  export type user_subscription_tblArgs = {
    /**
     * Select specific fields to fetch from the user_subscription_tbl
     * 
    **/
    select?: user_subscription_tblSelect | null
  }



  /**
   * Model user_wallet
   */


  export type AggregateUser_wallet = {
    _count: User_walletCountAggregateOutputType | null
    _avg: User_walletAvgAggregateOutputType | null
    _sum: User_walletSumAggregateOutputType | null
    _min: User_walletMinAggregateOutputType | null
    _max: User_walletMaxAggregateOutputType | null
  }

  export type User_walletAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    balance_inr: number | null
    balance_usd: number | null
  }

  export type User_walletSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    balance_inr: number | null
    balance_usd: number | null
  }

  export type User_walletMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    balance_inr: number | null
    balance_usd: number | null
    date: Date | null
  }

  export type User_walletMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    balance_inr: number | null
    balance_usd: number | null
    date: Date | null
  }

  export type User_walletCountAggregateOutputType = {
    id: number
    user_id: number
    balance_inr: number
    balance_usd: number
    date: number
    _all: number
  }


  export type User_walletAvgAggregateInputType = {
    id?: true
    user_id?: true
    balance_inr?: true
    balance_usd?: true
  }

  export type User_walletSumAggregateInputType = {
    id?: true
    user_id?: true
    balance_inr?: true
    balance_usd?: true
  }

  export type User_walletMinAggregateInputType = {
    id?: true
    user_id?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
  }

  export type User_walletMaxAggregateInputType = {
    id?: true
    user_id?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
  }

  export type User_walletCountAggregateInputType = {
    id?: true
    user_id?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
    _all?: true
  }

  export type User_walletAggregateArgs = {
    /**
     * Filter which user_wallet to aggregate.
     * 
    **/
    where?: user_walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<user_walletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_wallets
    **/
    _count?: true | User_walletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_walletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_walletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_walletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_walletMaxAggregateInputType
  }

  export type GetUser_walletAggregateType<T extends User_walletAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_wallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_wallet[P]>
      : GetScalarType<T[P], AggregateUser_wallet[P]>
  }




  export type User_walletGroupByArgs = {
    where?: user_walletWhereInput
    orderBy?: Enumerable<user_walletOrderByWithAggregationInput>
    by: Array<User_walletScalarFieldEnum>
    having?: user_walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_walletCountAggregateInputType | true
    _avg?: User_walletAvgAggregateInputType
    _sum?: User_walletSumAggregateInputType
    _min?: User_walletMinAggregateInputType
    _max?: User_walletMaxAggregateInputType
  }


  export type User_walletGroupByOutputType = {
    id: number
    user_id: number
    balance_inr: number
    balance_usd: number
    date: Date
    _count: User_walletCountAggregateOutputType | null
    _avg: User_walletAvgAggregateOutputType | null
    _sum: User_walletSumAggregateOutputType | null
    _min: User_walletMinAggregateOutputType | null
    _max: User_walletMaxAggregateOutputType | null
  }

  type GetUser_walletGroupByPayload<T extends User_walletGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_walletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_walletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_walletGroupByOutputType[P]>
            : GetScalarType<T[P], User_walletGroupByOutputType[P]>
        }
      >
    >


  export type user_walletSelect = {
    id?: boolean
    user_id?: boolean
    balance_inr?: boolean
    balance_usd?: boolean
    date?: boolean
  }


  export type user_walletGetPayload<S extends boolean | null | undefined | user_walletArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user_wallet :
    S extends undefined ? never :
    S extends { include: any } & (user_walletArgs | user_walletFindManyArgs)
    ? user_wallet 
    : S extends { select: any } & (user_walletArgs | user_walletFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user_wallet ? user_wallet[P] : never
  } 
      : user_wallet


  type user_walletCountArgs = Merge<
    Omit<user_walletFindManyArgs, 'select' | 'include'> & {
      select?: User_walletCountAggregateInputType | true
    }
  >

  export interface user_walletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User_wallet that matches the filter.
     * @param {user_walletFindUniqueArgs} args - Arguments to find a User_wallet
     * @example
     * // Get one User_wallet
     * const user_wallet = await prisma.user_wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_walletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_walletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_wallet'> extends True ? Prisma__user_walletClient<user_walletGetPayload<T>> : Prisma__user_walletClient<user_walletGetPayload<T> | null, null>

    /**
     * Find the first User_wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_walletFindFirstArgs} args - Arguments to find a User_wallet
     * @example
     * // Get one User_wallet
     * const user_wallet = await prisma.user_wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_walletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_walletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_wallet'> extends True ? Prisma__user_walletClient<user_walletGetPayload<T>> : Prisma__user_walletClient<user_walletGetPayload<T> | null, null>

    /**
     * Find zero or more User_wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_walletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_wallets
     * const user_wallets = await prisma.user_wallet.findMany()
     * 
     * // Get first 10 User_wallets
     * const user_wallets = await prisma.user_wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_walletWithIdOnly = await prisma.user_wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_walletFindManyArgs>(
      args?: SelectSubset<T, user_walletFindManyArgs>
    ): PrismaPromise<Array<user_walletGetPayload<T>>>

    /**
     * Create a User_wallet.
     * @param {user_walletCreateArgs} args - Arguments to create a User_wallet.
     * @example
     * // Create one User_wallet
     * const User_wallet = await prisma.user_wallet.create({
     *   data: {
     *     // ... data to create a User_wallet
     *   }
     * })
     * 
    **/
    create<T extends user_walletCreateArgs>(
      args: SelectSubset<T, user_walletCreateArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Create many User_wallets.
     *     @param {user_walletCreateManyArgs} args - Arguments to create many User_wallets.
     *     @example
     *     // Create many User_wallets
     *     const user_wallet = await prisma.user_wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_walletCreateManyArgs>(
      args?: SelectSubset<T, user_walletCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_wallet.
     * @param {user_walletDeleteArgs} args - Arguments to delete one User_wallet.
     * @example
     * // Delete one User_wallet
     * const User_wallet = await prisma.user_wallet.delete({
     *   where: {
     *     // ... filter to delete one User_wallet
     *   }
     * })
     * 
    **/
    delete<T extends user_walletDeleteArgs>(
      args: SelectSubset<T, user_walletDeleteArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Update one User_wallet.
     * @param {user_walletUpdateArgs} args - Arguments to update one User_wallet.
     * @example
     * // Update one User_wallet
     * const user_wallet = await prisma.user_wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_walletUpdateArgs>(
      args: SelectSubset<T, user_walletUpdateArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Delete zero or more User_wallets.
     * @param {user_walletDeleteManyArgs} args - Arguments to filter User_wallets to delete.
     * @example
     * // Delete a few User_wallets
     * const { count } = await prisma.user_wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_walletDeleteManyArgs>(
      args?: SelectSubset<T, user_walletDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_wallets
     * const user_wallet = await prisma.user_wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_walletUpdateManyArgs>(
      args: SelectSubset<T, user_walletUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_wallet.
     * @param {user_walletUpsertArgs} args - Arguments to update or create a User_wallet.
     * @example
     * // Update or create a User_wallet
     * const user_wallet = await prisma.user_wallet.upsert({
     *   create: {
     *     // ... data to create a User_wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_wallet we want to update
     *   }
     * })
    **/
    upsert<T extends user_walletUpsertArgs>(
      args: SelectSubset<T, user_walletUpsertArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Find one User_wallet that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_walletFindUniqueOrThrowArgs} args - Arguments to find a User_wallet
     * @example
     * // Get one User_wallet
     * const user_wallet = await prisma.user_wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_walletFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_walletFindUniqueOrThrowArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Find the first User_wallet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_walletFindFirstOrThrowArgs} args - Arguments to find a User_wallet
     * @example
     * // Get one User_wallet
     * const user_wallet = await prisma.user_wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_walletFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_walletFindFirstOrThrowArgs>
    ): Prisma__user_walletClient<user_walletGetPayload<T>>

    /**
     * Count the number of User_wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_walletCountArgs} args - Arguments to filter User_wallets to count.
     * @example
     * // Count the number of User_wallets
     * const count = await prisma.user_wallet.count({
     *   where: {
     *     // ... the filter for the User_wallets we want to count
     *   }
     * })
    **/
    count<T extends user_walletCountArgs>(
      args?: Subset<T, user_walletCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_walletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_walletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_walletAggregateArgs>(args: Subset<T, User_walletAggregateArgs>): PrismaPromise<GetUser_walletAggregateType<T>>

    /**
     * Group by User_wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_walletGroupByArgs['orderBy'] }
        : { orderBy?: User_walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_walletGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_walletClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_wallet base type for findUnique actions
   */
  export type user_walletFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * Filter, which user_wallet to fetch.
     * 
    **/
    where: user_walletWhereUniqueInput
  }

  /**
   * user_wallet: findUnique
   */
  export interface user_walletFindUniqueArgs extends user_walletFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_wallet base type for findFirst actions
   */
  export type user_walletFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * Filter, which user_wallet to fetch.
     * 
    **/
    where?: user_walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<user_walletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_wallets.
     * 
    **/
    cursor?: user_walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_wallets.
     * 
    **/
    distinct?: Enumerable<User_walletScalarFieldEnum>
  }

  /**
   * user_wallet: findFirst
   */
  export interface user_walletFindFirstArgs extends user_walletFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_wallet findMany
   */
  export type user_walletFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * Filter, which user_wallets to fetch.
     * 
    **/
    where?: user_walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<user_walletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_wallets.
     * 
    **/
    cursor?: user_walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_walletScalarFieldEnum>
  }


  /**
   * user_wallet create
   */
  export type user_walletCreateArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * The data needed to create a user_wallet.
     * 
    **/
    data: XOR<user_walletCreateInput, user_walletUncheckedCreateInput>
  }


  /**
   * user_wallet createMany
   */
  export type user_walletCreateManyArgs = {
    /**
     * The data used to create many user_wallets.
     * 
    **/
    data: Enumerable<user_walletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_wallet update
   */
  export type user_walletUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * The data needed to update a user_wallet.
     * 
    **/
    data: XOR<user_walletUpdateInput, user_walletUncheckedUpdateInput>
    /**
     * Choose, which user_wallet to update.
     * 
    **/
    where: user_walletWhereUniqueInput
  }


  /**
   * user_wallet updateMany
   */
  export type user_walletUpdateManyArgs = {
    /**
     * The data used to update user_wallets.
     * 
    **/
    data: XOR<user_walletUpdateManyMutationInput, user_walletUncheckedUpdateManyInput>
    /**
     * Filter which user_wallets to update
     * 
    **/
    where?: user_walletWhereInput
  }


  /**
   * user_wallet upsert
   */
  export type user_walletUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * The filter to search for the user_wallet to update in case it exists.
     * 
    **/
    where: user_walletWhereUniqueInput
    /**
     * In case the user_wallet found by the `where` argument doesn't exist, create a new user_wallet with this data.
     * 
    **/
    create: XOR<user_walletCreateInput, user_walletUncheckedCreateInput>
    /**
     * In case the user_wallet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_walletUpdateInput, user_walletUncheckedUpdateInput>
  }


  /**
   * user_wallet delete
   */
  export type user_walletDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
    /**
     * Filter which user_wallet to delete.
     * 
    **/
    where: user_walletWhereUniqueInput
  }


  /**
   * user_wallet deleteMany
   */
  export type user_walletDeleteManyArgs = {
    /**
     * Filter which user_wallets to delete
     * 
    **/
    where?: user_walletWhereInput
  }


  /**
   * user_wallet: findUniqueOrThrow
   */
  export type user_walletFindUniqueOrThrowArgs = user_walletFindUniqueArgsBase
      

  /**
   * user_wallet: findFirstOrThrow
   */
  export type user_walletFindFirstOrThrowArgs = user_walletFindFirstArgsBase
      

  /**
   * user_wallet without action
   */
  export type user_walletArgs = {
    /**
     * Select specific fields to fetch from the user_wallet
     * 
    **/
    select?: user_walletSelect | null
  }



  /**
   * Model user_wallet_transaction
   */


  export type AggregateUser_wallet_transaction = {
    _count: User_wallet_transactionCountAggregateOutputType | null
    _avg: User_wallet_transactionAvgAggregateOutputType | null
    _sum: User_wallet_transactionSumAggregateOutputType | null
    _min: User_wallet_transactionMinAggregateOutputType | null
    _max: User_wallet_transactionMaxAggregateOutputType | null
  }

  export type User_wallet_transactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_id: number | null
    amount: number | null
    transaction_type: number | null
    balance_inr: number | null
    balance_usd: number | null
  }

  export type User_wallet_transactionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_id: bigint | null
    amount: number | null
    transaction_type: number | null
    balance_inr: number | null
    balance_usd: number | null
  }

  export type User_wallet_transactionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_id: bigint | null
    amount: number | null
    currency: string | null
    transaction_type: number | null
    balance_inr: number | null
    balance_usd: number | null
    date: Date | null
  }

  export type User_wallet_transactionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_id: bigint | null
    amount: number | null
    currency: string | null
    transaction_type: number | null
    balance_inr: number | null
    balance_usd: number | null
    date: Date | null
  }

  export type User_wallet_transactionCountAggregateOutputType = {
    id: number
    user_id: number
    order_id: number
    amount: number
    currency: number
    transaction_type: number
    balance_inr: number
    balance_usd: number
    date: number
    _all: number
  }


  export type User_wallet_transactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    order_id?: true
    amount?: true
    transaction_type?: true
    balance_inr?: true
    balance_usd?: true
  }

  export type User_wallet_transactionSumAggregateInputType = {
    id?: true
    user_id?: true
    order_id?: true
    amount?: true
    transaction_type?: true
    balance_inr?: true
    balance_usd?: true
  }

  export type User_wallet_transactionMinAggregateInputType = {
    id?: true
    user_id?: true
    order_id?: true
    amount?: true
    currency?: true
    transaction_type?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
  }

  export type User_wallet_transactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    order_id?: true
    amount?: true
    currency?: true
    transaction_type?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
  }

  export type User_wallet_transactionCountAggregateInputType = {
    id?: true
    user_id?: true
    order_id?: true
    amount?: true
    currency?: true
    transaction_type?: true
    balance_inr?: true
    balance_usd?: true
    date?: true
    _all?: true
  }

  export type User_wallet_transactionAggregateArgs = {
    /**
     * Filter which user_wallet_transaction to aggregate.
     * 
    **/
    where?: user_wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallet_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_wallet_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallet_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallet_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_wallet_transactions
    **/
    _count?: true | User_wallet_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_wallet_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_wallet_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_wallet_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_wallet_transactionMaxAggregateInputType
  }

  export type GetUser_wallet_transactionAggregateType<T extends User_wallet_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_wallet_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_wallet_transaction[P]>
      : GetScalarType<T[P], AggregateUser_wallet_transaction[P]>
  }




  export type User_wallet_transactionGroupByArgs = {
    where?: user_wallet_transactionWhereInput
    orderBy?: Enumerable<user_wallet_transactionOrderByWithAggregationInput>
    by: Array<User_wallet_transactionScalarFieldEnum>
    having?: user_wallet_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_wallet_transactionCountAggregateInputType | true
    _avg?: User_wallet_transactionAvgAggregateInputType
    _sum?: User_wallet_transactionSumAggregateInputType
    _min?: User_wallet_transactionMinAggregateInputType
    _max?: User_wallet_transactionMaxAggregateInputType
  }


  export type User_wallet_transactionGroupByOutputType = {
    id: number
    user_id: number
    order_id: bigint
    amount: number
    currency: string
    transaction_type: number
    balance_inr: number
    balance_usd: number
    date: Date
    _count: User_wallet_transactionCountAggregateOutputType | null
    _avg: User_wallet_transactionAvgAggregateOutputType | null
    _sum: User_wallet_transactionSumAggregateOutputType | null
    _min: User_wallet_transactionMinAggregateOutputType | null
    _max: User_wallet_transactionMaxAggregateOutputType | null
  }

  type GetUser_wallet_transactionGroupByPayload<T extends User_wallet_transactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_wallet_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_wallet_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_wallet_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], User_wallet_transactionGroupByOutputType[P]>
        }
      >
    >


  export type user_wallet_transactionSelect = {
    id?: boolean
    user_id?: boolean
    order_id?: boolean
    amount?: boolean
    currency?: boolean
    transaction_type?: boolean
    balance_inr?: boolean
    balance_usd?: boolean
    date?: boolean
  }


  export type user_wallet_transactionGetPayload<S extends boolean | null | undefined | user_wallet_transactionArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user_wallet_transaction :
    S extends undefined ? never :
    S extends { include: any } & (user_wallet_transactionArgs | user_wallet_transactionFindManyArgs)
    ? user_wallet_transaction 
    : S extends { select: any } & (user_wallet_transactionArgs | user_wallet_transactionFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user_wallet_transaction ? user_wallet_transaction[P] : never
  } 
      : user_wallet_transaction


  type user_wallet_transactionCountArgs = Merge<
    Omit<user_wallet_transactionFindManyArgs, 'select' | 'include'> & {
      select?: User_wallet_transactionCountAggregateInputType | true
    }
  >

  export interface user_wallet_transactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User_wallet_transaction that matches the filter.
     * @param {user_wallet_transactionFindUniqueArgs} args - Arguments to find a User_wallet_transaction
     * @example
     * // Get one User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_wallet_transactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_wallet_transactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_wallet_transaction'> extends True ? Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>> : Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T> | null, null>

    /**
     * Find the first User_wallet_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_wallet_transactionFindFirstArgs} args - Arguments to find a User_wallet_transaction
     * @example
     * // Get one User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_wallet_transactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_wallet_transactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_wallet_transaction'> extends True ? Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>> : Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T> | null, null>

    /**
     * Find zero or more User_wallet_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_wallet_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_wallet_transactions
     * const user_wallet_transactions = await prisma.user_wallet_transaction.findMany()
     * 
     * // Get first 10 User_wallet_transactions
     * const user_wallet_transactions = await prisma.user_wallet_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_wallet_transactionWithIdOnly = await prisma.user_wallet_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_wallet_transactionFindManyArgs>(
      args?: SelectSubset<T, user_wallet_transactionFindManyArgs>
    ): PrismaPromise<Array<user_wallet_transactionGetPayload<T>>>

    /**
     * Create a User_wallet_transaction.
     * @param {user_wallet_transactionCreateArgs} args - Arguments to create a User_wallet_transaction.
     * @example
     * // Create one User_wallet_transaction
     * const User_wallet_transaction = await prisma.user_wallet_transaction.create({
     *   data: {
     *     // ... data to create a User_wallet_transaction
     *   }
     * })
     * 
    **/
    create<T extends user_wallet_transactionCreateArgs>(
      args: SelectSubset<T, user_wallet_transactionCreateArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Create many User_wallet_transactions.
     *     @param {user_wallet_transactionCreateManyArgs} args - Arguments to create many User_wallet_transactions.
     *     @example
     *     // Create many User_wallet_transactions
     *     const user_wallet_transaction = await prisma.user_wallet_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_wallet_transactionCreateManyArgs>(
      args?: SelectSubset<T, user_wallet_transactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_wallet_transaction.
     * @param {user_wallet_transactionDeleteArgs} args - Arguments to delete one User_wallet_transaction.
     * @example
     * // Delete one User_wallet_transaction
     * const User_wallet_transaction = await prisma.user_wallet_transaction.delete({
     *   where: {
     *     // ... filter to delete one User_wallet_transaction
     *   }
     * })
     * 
    **/
    delete<T extends user_wallet_transactionDeleteArgs>(
      args: SelectSubset<T, user_wallet_transactionDeleteArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Update one User_wallet_transaction.
     * @param {user_wallet_transactionUpdateArgs} args - Arguments to update one User_wallet_transaction.
     * @example
     * // Update one User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_wallet_transactionUpdateArgs>(
      args: SelectSubset<T, user_wallet_transactionUpdateArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Delete zero or more User_wallet_transactions.
     * @param {user_wallet_transactionDeleteManyArgs} args - Arguments to filter User_wallet_transactions to delete.
     * @example
     * // Delete a few User_wallet_transactions
     * const { count } = await prisma.user_wallet_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_wallet_transactionDeleteManyArgs>(
      args?: SelectSubset<T, user_wallet_transactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_wallet_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_wallet_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_wallet_transactions
     * const user_wallet_transaction = await prisma.user_wallet_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_wallet_transactionUpdateManyArgs>(
      args: SelectSubset<T, user_wallet_transactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_wallet_transaction.
     * @param {user_wallet_transactionUpsertArgs} args - Arguments to update or create a User_wallet_transaction.
     * @example
     * // Update or create a User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.upsert({
     *   create: {
     *     // ... data to create a User_wallet_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_wallet_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends user_wallet_transactionUpsertArgs>(
      args: SelectSubset<T, user_wallet_transactionUpsertArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Find one User_wallet_transaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_wallet_transactionFindUniqueOrThrowArgs} args - Arguments to find a User_wallet_transaction
     * @example
     * // Get one User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_wallet_transactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_wallet_transactionFindUniqueOrThrowArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Find the first User_wallet_transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_wallet_transactionFindFirstOrThrowArgs} args - Arguments to find a User_wallet_transaction
     * @example
     * // Get one User_wallet_transaction
     * const user_wallet_transaction = await prisma.user_wallet_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_wallet_transactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_wallet_transactionFindFirstOrThrowArgs>
    ): Prisma__user_wallet_transactionClient<user_wallet_transactionGetPayload<T>>

    /**
     * Count the number of User_wallet_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_wallet_transactionCountArgs} args - Arguments to filter User_wallet_transactions to count.
     * @example
     * // Count the number of User_wallet_transactions
     * const count = await prisma.user_wallet_transaction.count({
     *   where: {
     *     // ... the filter for the User_wallet_transactions we want to count
     *   }
     * })
    **/
    count<T extends user_wallet_transactionCountArgs>(
      args?: Subset<T, user_wallet_transactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_wallet_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_wallet_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_wallet_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_wallet_transactionAggregateArgs>(args: Subset<T, User_wallet_transactionAggregateArgs>): PrismaPromise<GetUser_wallet_transactionAggregateType<T>>

    /**
     * Group by User_wallet_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_wallet_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_wallet_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_wallet_transactionGroupByArgs['orderBy'] }
        : { orderBy?: User_wallet_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_wallet_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_wallet_transactionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_wallet_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_wallet_transactionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_wallet_transaction base type for findUnique actions
   */
  export type user_wallet_transactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * Filter, which user_wallet_transaction to fetch.
     * 
    **/
    where: user_wallet_transactionWhereUniqueInput
  }

  /**
   * user_wallet_transaction: findUnique
   */
  export interface user_wallet_transactionFindUniqueArgs extends user_wallet_transactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_wallet_transaction base type for findFirst actions
   */
  export type user_wallet_transactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * Filter, which user_wallet_transaction to fetch.
     * 
    **/
    where?: user_wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallet_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_wallet_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_wallet_transactions.
     * 
    **/
    cursor?: user_wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallet_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallet_transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_wallet_transactions.
     * 
    **/
    distinct?: Enumerable<User_wallet_transactionScalarFieldEnum>
  }

  /**
   * user_wallet_transaction: findFirst
   */
  export interface user_wallet_transactionFindFirstArgs extends user_wallet_transactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_wallet_transaction findMany
   */
  export type user_wallet_transactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * Filter, which user_wallet_transactions to fetch.
     * 
    **/
    where?: user_wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_wallet_transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_wallet_transactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_wallet_transactions.
     * 
    **/
    cursor?: user_wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_wallet_transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_wallet_transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_wallet_transactionScalarFieldEnum>
  }


  /**
   * user_wallet_transaction create
   */
  export type user_wallet_transactionCreateArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * The data needed to create a user_wallet_transaction.
     * 
    **/
    data: XOR<user_wallet_transactionCreateInput, user_wallet_transactionUncheckedCreateInput>
  }


  /**
   * user_wallet_transaction createMany
   */
  export type user_wallet_transactionCreateManyArgs = {
    /**
     * The data used to create many user_wallet_transactions.
     * 
    **/
    data: Enumerable<user_wallet_transactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_wallet_transaction update
   */
  export type user_wallet_transactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * The data needed to update a user_wallet_transaction.
     * 
    **/
    data: XOR<user_wallet_transactionUpdateInput, user_wallet_transactionUncheckedUpdateInput>
    /**
     * Choose, which user_wallet_transaction to update.
     * 
    **/
    where: user_wallet_transactionWhereUniqueInput
  }


  /**
   * user_wallet_transaction updateMany
   */
  export type user_wallet_transactionUpdateManyArgs = {
    /**
     * The data used to update user_wallet_transactions.
     * 
    **/
    data: XOR<user_wallet_transactionUpdateManyMutationInput, user_wallet_transactionUncheckedUpdateManyInput>
    /**
     * Filter which user_wallet_transactions to update
     * 
    **/
    where?: user_wallet_transactionWhereInput
  }


  /**
   * user_wallet_transaction upsert
   */
  export type user_wallet_transactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * The filter to search for the user_wallet_transaction to update in case it exists.
     * 
    **/
    where: user_wallet_transactionWhereUniqueInput
    /**
     * In case the user_wallet_transaction found by the `where` argument doesn't exist, create a new user_wallet_transaction with this data.
     * 
    **/
    create: XOR<user_wallet_transactionCreateInput, user_wallet_transactionUncheckedCreateInput>
    /**
     * In case the user_wallet_transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_wallet_transactionUpdateInput, user_wallet_transactionUncheckedUpdateInput>
  }


  /**
   * user_wallet_transaction delete
   */
  export type user_wallet_transactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
    /**
     * Filter which user_wallet_transaction to delete.
     * 
    **/
    where: user_wallet_transactionWhereUniqueInput
  }


  /**
   * user_wallet_transaction deleteMany
   */
  export type user_wallet_transactionDeleteManyArgs = {
    /**
     * Filter which user_wallet_transactions to delete
     * 
    **/
    where?: user_wallet_transactionWhereInput
  }


  /**
   * user_wallet_transaction: findUniqueOrThrow
   */
  export type user_wallet_transactionFindUniqueOrThrowArgs = user_wallet_transactionFindUniqueArgsBase
      

  /**
   * user_wallet_transaction: findFirstOrThrow
   */
  export type user_wallet_transactionFindFirstOrThrowArgs = user_wallet_transactionFindFirstArgsBase
      

  /**
   * user_wallet_transaction without action
   */
  export type user_wallet_transactionArgs = {
    /**
     * Select specific fields to fetch from the user_wallet_transaction
     * 
    **/
    select?: user_wallet_transactionSelect | null
  }



  /**
   * Model users_tbl
   */


  export type AggregateUsers_tbl = {
    _count: Users_tblCountAggregateOutputType | null
    _avg: Users_tblAvgAggregateOutputType | null
    _sum: Users_tblSumAggregateOutputType | null
    _min: Users_tblMinAggregateOutputType | null
    _max: Users_tblMaxAggregateOutputType | null
  }

  export type Users_tblAvgAggregateOutputType = {
    user_id: number | null
    language_id: number | null
    zipcode: number | null
  }

  export type Users_tblSumAggregateOutputType = {
    user_id: number | null
    language_id: number | null
    zipcode: number | null
  }

  export type Users_tblMinAggregateOutputType = {
    user_id: number | null
    username: string | null
    password: string | null
    dob: Date | null
    gender: string | null
    phone: string | null
    language_id: number | null
    genre_ids: string | null
    address: string | null
    city: string | null
    zipcode: number | null
    country: string | null
    user_type: string | null
    created_at: Date | null
    email: string | null
    secret_code: string | null
    channel: string | null
    profile_img_url: string | null
  }

  export type Users_tblMaxAggregateOutputType = {
    user_id: number | null
    username: string | null
    password: string | null
    dob: Date | null
    gender: string | null
    phone: string | null
    language_id: number | null
    genre_ids: string | null
    address: string | null
    city: string | null
    zipcode: number | null
    country: string | null
    user_type: string | null
    created_at: Date | null
    email: string | null
    secret_code: string | null
    channel: string | null
    profile_img_url: string | null
  }

  export type Users_tblCountAggregateOutputType = {
    user_id: number
    username: number
    password: number
    dob: number
    gender: number
    phone: number
    language_id: number
    genre_ids: number
    address: number
    city: number
    zipcode: number
    country: number
    user_type: number
    created_at: number
    email: number
    secret_code: number
    channel: number
    profile_img_url: number
    _all: number
  }


  export type Users_tblAvgAggregateInputType = {
    user_id?: true
    language_id?: true
    zipcode?: true
  }

  export type Users_tblSumAggregateInputType = {
    user_id?: true
    language_id?: true
    zipcode?: true
  }

  export type Users_tblMinAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    dob?: true
    gender?: true
    phone?: true
    language_id?: true
    genre_ids?: true
    address?: true
    city?: true
    zipcode?: true
    country?: true
    user_type?: true
    created_at?: true
    email?: true
    secret_code?: true
    channel?: true
    profile_img_url?: true
  }

  export type Users_tblMaxAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    dob?: true
    gender?: true
    phone?: true
    language_id?: true
    genre_ids?: true
    address?: true
    city?: true
    zipcode?: true
    country?: true
    user_type?: true
    created_at?: true
    email?: true
    secret_code?: true
    channel?: true
    profile_img_url?: true
  }

  export type Users_tblCountAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    dob?: true
    gender?: true
    phone?: true
    language_id?: true
    genre_ids?: true
    address?: true
    city?: true
    zipcode?: true
    country?: true
    user_type?: true
    created_at?: true
    email?: true
    secret_code?: true
    channel?: true
    profile_img_url?: true
    _all?: true
  }

  export type Users_tblAggregateArgs = {
    /**
     * Filter which users_tbl to aggregate.
     * 
    **/
    where?: users_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<users_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: users_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_tbls
    **/
    _count?: true | Users_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_tblMaxAggregateInputType
  }

  export type GetUsers_tblAggregateType<T extends Users_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_tbl[P]>
      : GetScalarType<T[P], AggregateUsers_tbl[P]>
  }




  export type Users_tblGroupByArgs = {
    where?: users_tblWhereInput
    orderBy?: Enumerable<users_tblOrderByWithAggregationInput>
    by: Array<Users_tblScalarFieldEnum>
    having?: users_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_tblCountAggregateInputType | true
    _avg?: Users_tblAvgAggregateInputType
    _sum?: Users_tblSumAggregateInputType
    _min?: Users_tblMinAggregateInputType
    _max?: Users_tblMaxAggregateInputType
  }


  export type Users_tblGroupByOutputType = {
    user_id: number
    username: string
    password: string
    dob: Date | null
    gender: string | null
    phone: string | null
    language_id: number | null
    genre_ids: string | null
    address: string
    city: string | null
    zipcode: number
    country: string
    user_type: string
    created_at: Date
    email: string
    secret_code: string | null
    channel: string | null
    profile_img_url: string | null
    _count: Users_tblCountAggregateOutputType | null
    _avg: Users_tblAvgAggregateOutputType | null
    _sum: Users_tblSumAggregateOutputType | null
    _min: Users_tblMinAggregateOutputType | null
    _max: Users_tblMaxAggregateOutputType | null
  }

  type GetUsers_tblGroupByPayload<T extends Users_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Users_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Users_tblGroupByOutputType[P]>
        }
      >
    >


  export type users_tblSelect = {
    user_id?: boolean
    username?: boolean
    password?: boolean
    dob?: boolean
    gender?: boolean
    phone?: boolean
    language_id?: boolean
    genre_ids?: boolean
    address?: boolean
    city?: boolean
    zipcode?: boolean
    country?: boolean
    user_type?: boolean
    created_at?: boolean
    email?: boolean
    secret_code?: boolean
    channel?: boolean
    profile_img_url?: boolean
    giftBooks?: boolean | author_gift_booksFindManyArgs
    _count?: boolean | Users_tblCountOutputTypeArgs
  }


  export type users_tblInclude = {
    giftBooks?: boolean | author_gift_booksFindManyArgs
    _count?: boolean | Users_tblCountOutputTypeArgs
  } 

  export type users_tblGetPayload<S extends boolean | null | undefined | users_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users_tbl :
    S extends undefined ? never :
    S extends { include: any } & (users_tblArgs | users_tblFindManyArgs)
    ? users_tbl  & {
    [P in TrueKeys<S['include']>]:
        P extends 'giftBooks' ? Array < author_gift_booksGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Users_tblCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (users_tblArgs | users_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'giftBooks' ? Array < author_gift_booksGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Users_tblCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof users_tbl ? users_tbl[P] : never
  } 
      : users_tbl


  type users_tblCountArgs = Merge<
    Omit<users_tblFindManyArgs, 'select' | 'include'> & {
      select?: Users_tblCountAggregateInputType | true
    }
  >

  export interface users_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Users_tbl that matches the filter.
     * @param {users_tblFindUniqueArgs} args - Arguments to find a Users_tbl
     * @example
     * // Get one Users_tbl
     * const users_tbl = await prisma.users_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends users_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, users_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users_tbl'> extends True ? Prisma__users_tblClient<users_tblGetPayload<T>> : Prisma__users_tblClient<users_tblGetPayload<T> | null, null>

    /**
     * Find the first Users_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_tblFindFirstArgs} args - Arguments to find a Users_tbl
     * @example
     * // Get one Users_tbl
     * const users_tbl = await prisma.users_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends users_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, users_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users_tbl'> extends True ? Prisma__users_tblClient<users_tblGetPayload<T>> : Prisma__users_tblClient<users_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Users_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_tbls
     * const users_tbls = await prisma.users_tbl.findMany()
     * 
     * // Get first 10 Users_tbls
     * const users_tbls = await prisma.users_tbl.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const users_tblWithUser_idOnly = await prisma.users_tbl.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends users_tblFindManyArgs>(
      args?: SelectSubset<T, users_tblFindManyArgs>
    ): PrismaPromise<Array<users_tblGetPayload<T>>>

    /**
     * Create a Users_tbl.
     * @param {users_tblCreateArgs} args - Arguments to create a Users_tbl.
     * @example
     * // Create one Users_tbl
     * const Users_tbl = await prisma.users_tbl.create({
     *   data: {
     *     // ... data to create a Users_tbl
     *   }
     * })
     * 
    **/
    create<T extends users_tblCreateArgs>(
      args: SelectSubset<T, users_tblCreateArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Create many Users_tbls.
     *     @param {users_tblCreateManyArgs} args - Arguments to create many Users_tbls.
     *     @example
     *     // Create many Users_tbls
     *     const users_tbl = await prisma.users_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends users_tblCreateManyArgs>(
      args?: SelectSubset<T, users_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users_tbl.
     * @param {users_tblDeleteArgs} args - Arguments to delete one Users_tbl.
     * @example
     * // Delete one Users_tbl
     * const Users_tbl = await prisma.users_tbl.delete({
     *   where: {
     *     // ... filter to delete one Users_tbl
     *   }
     * })
     * 
    **/
    delete<T extends users_tblDeleteArgs>(
      args: SelectSubset<T, users_tblDeleteArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Update one Users_tbl.
     * @param {users_tblUpdateArgs} args - Arguments to update one Users_tbl.
     * @example
     * // Update one Users_tbl
     * const users_tbl = await prisma.users_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends users_tblUpdateArgs>(
      args: SelectSubset<T, users_tblUpdateArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Delete zero or more Users_tbls.
     * @param {users_tblDeleteManyArgs} args - Arguments to filter Users_tbls to delete.
     * @example
     * // Delete a few Users_tbls
     * const { count } = await prisma.users_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends users_tblDeleteManyArgs>(
      args?: SelectSubset<T, users_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_tbls
     * const users_tbl = await prisma.users_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends users_tblUpdateManyArgs>(
      args: SelectSubset<T, users_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_tbl.
     * @param {users_tblUpsertArgs} args - Arguments to update or create a Users_tbl.
     * @example
     * // Update or create a Users_tbl
     * const users_tbl = await prisma.users_tbl.upsert({
     *   create: {
     *     // ... data to create a Users_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends users_tblUpsertArgs>(
      args: SelectSubset<T, users_tblUpsertArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Find one Users_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {users_tblFindUniqueOrThrowArgs} args - Arguments to find a Users_tbl
     * @example
     * // Get one Users_tbl
     * const users_tbl = await prisma.users_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends users_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, users_tblFindUniqueOrThrowArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Find the first Users_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_tblFindFirstOrThrowArgs} args - Arguments to find a Users_tbl
     * @example
     * // Get one Users_tbl
     * const users_tbl = await prisma.users_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends users_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, users_tblFindFirstOrThrowArgs>
    ): Prisma__users_tblClient<users_tblGetPayload<T>>

    /**
     * Count the number of Users_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_tblCountArgs} args - Arguments to filter Users_tbls to count.
     * @example
     * // Count the number of Users_tbls
     * const count = await prisma.users_tbl.count({
     *   where: {
     *     // ... the filter for the Users_tbls we want to count
     *   }
     * })
    **/
    count<T extends users_tblCountArgs>(
      args?: Subset<T, users_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_tblAggregateArgs>(args: Subset<T, Users_tblAggregateArgs>): PrismaPromise<GetUsers_tblAggregateType<T>>

    /**
     * Group by Users_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Users_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Users_tblGroupByArgs['orderBy'] }
        : { orderBy?: Users_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Users_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__users_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    giftBooks<T extends author_gift_booksFindManyArgs= {}>(args?: Subset<T, author_gift_booksFindManyArgs>): PrismaPromise<Array<author_gift_booksGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users_tbl base type for findUnique actions
   */
  export type users_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * Filter, which users_tbl to fetch.
     * 
    **/
    where: users_tblWhereUniqueInput
  }

  /**
   * users_tbl: findUnique
   */
  export interface users_tblFindUniqueArgs extends users_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users_tbl base type for findFirst actions
   */
  export type users_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * Filter, which users_tbl to fetch.
     * 
    **/
    where?: users_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<users_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_tbls.
     * 
    **/
    cursor?: users_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_tbls.
     * 
    **/
    distinct?: Enumerable<Users_tblScalarFieldEnum>
  }

  /**
   * users_tbl: findFirst
   */
  export interface users_tblFindFirstArgs extends users_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users_tbl findMany
   */
  export type users_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * Filter, which users_tbls to fetch.
     * 
    **/
    where?: users_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<users_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_tbls.
     * 
    **/
    cursor?: users_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Users_tblScalarFieldEnum>
  }


  /**
   * users_tbl create
   */
  export type users_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * The data needed to create a users_tbl.
     * 
    **/
    data: XOR<users_tblCreateInput, users_tblUncheckedCreateInput>
  }


  /**
   * users_tbl createMany
   */
  export type users_tblCreateManyArgs = {
    /**
     * The data used to create many users_tbls.
     * 
    **/
    data: Enumerable<users_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users_tbl update
   */
  export type users_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * The data needed to update a users_tbl.
     * 
    **/
    data: XOR<users_tblUpdateInput, users_tblUncheckedUpdateInput>
    /**
     * Choose, which users_tbl to update.
     * 
    **/
    where: users_tblWhereUniqueInput
  }


  /**
   * users_tbl updateMany
   */
  export type users_tblUpdateManyArgs = {
    /**
     * The data used to update users_tbls.
     * 
    **/
    data: XOR<users_tblUpdateManyMutationInput, users_tblUncheckedUpdateManyInput>
    /**
     * Filter which users_tbls to update
     * 
    **/
    where?: users_tblWhereInput
  }


  /**
   * users_tbl upsert
   */
  export type users_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * The filter to search for the users_tbl to update in case it exists.
     * 
    **/
    where: users_tblWhereUniqueInput
    /**
     * In case the users_tbl found by the `where` argument doesn't exist, create a new users_tbl with this data.
     * 
    **/
    create: XOR<users_tblCreateInput, users_tblUncheckedCreateInput>
    /**
     * In case the users_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<users_tblUpdateInput, users_tblUncheckedUpdateInput>
  }


  /**
   * users_tbl delete
   */
  export type users_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
    /**
     * Filter which users_tbl to delete.
     * 
    **/
    where: users_tblWhereUniqueInput
  }


  /**
   * users_tbl deleteMany
   */
  export type users_tblDeleteManyArgs = {
    /**
     * Filter which users_tbls to delete
     * 
    **/
    where?: users_tblWhereInput
  }


  /**
   * users_tbl: findUniqueOrThrow
   */
  export type users_tblFindUniqueOrThrowArgs = users_tblFindUniqueArgsBase
      

  /**
   * users_tbl: findFirstOrThrow
   */
  export type users_tblFindFirstOrThrowArgs = users_tblFindFirstArgsBase
      

  /**
   * users_tbl without action
   */
  export type users_tblArgs = {
    /**
     * Select specific fields to fetch from the users_tbl
     * 
    **/
    select?: users_tblSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_tblInclude | null
  }



  /**
   * Model wallet_order_tbl
   */


  export type AggregateWallet_order_tbl = {
    _count: Wallet_order_tblCountAggregateOutputType | null
    _avg: Wallet_order_tblAvgAggregateOutputType | null
    _sum: Wallet_order_tblSumAggregateOutputType | null
    _min: Wallet_order_tblMinAggregateOutputType | null
    _max: Wallet_order_tblMaxAggregateOutputType | null
  }

  export type Wallet_order_tblAvgAggregateOutputType = {
    id: number | null
    order_id: number | null
    user_id: number | null
    subtotal: number | null
    service_tax: number | null
    net_total: number | null
    discount: Decimal | null
  }

  export type Wallet_order_tblSumAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    subtotal: number | null
    service_tax: number | null
    net_total: number | null
    discount: Decimal | null
  }

  export type Wallet_order_tblMinAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    cart_type: string | null
    currency: string | null
    subtotal: number | null
    service_tax: number | null
    net_total: number | null
    discount: Decimal | null
  }

  export type Wallet_order_tblMaxAggregateOutputType = {
    id: number | null
    order_id: bigint | null
    user_id: number | null
    cart_type: string | null
    currency: string | null
    subtotal: number | null
    service_tax: number | null
    net_total: number | null
    discount: Decimal | null
  }

  export type Wallet_order_tblCountAggregateOutputType = {
    id: number
    order_id: number
    user_id: number
    cart_type: number
    currency: number
    subtotal: number
    service_tax: number
    net_total: number
    discount: number
    _all: number
  }


  export type Wallet_order_tblAvgAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subtotal?: true
    service_tax?: true
    net_total?: true
    discount?: true
  }

  export type Wallet_order_tblSumAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    subtotal?: true
    service_tax?: true
    net_total?: true
    discount?: true
  }

  export type Wallet_order_tblMinAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    cart_type?: true
    currency?: true
    subtotal?: true
    service_tax?: true
    net_total?: true
    discount?: true
  }

  export type Wallet_order_tblMaxAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    cart_type?: true
    currency?: true
    subtotal?: true
    service_tax?: true
    net_total?: true
    discount?: true
  }

  export type Wallet_order_tblCountAggregateInputType = {
    id?: true
    order_id?: true
    user_id?: true
    cart_type?: true
    currency?: true
    subtotal?: true
    service_tax?: true
    net_total?: true
    discount?: true
    _all?: true
  }

  export type Wallet_order_tblAggregateArgs = {
    /**
     * Filter which wallet_order_tbl to aggregate.
     * 
    **/
    where?: wallet_order_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_order_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_order_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: wallet_order_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_order_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_order_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_order_tbls
    **/
    _count?: true | Wallet_order_tblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_order_tblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_order_tblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_order_tblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_order_tblMaxAggregateInputType
  }

  export type GetWallet_order_tblAggregateType<T extends Wallet_order_tblAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_order_tbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_order_tbl[P]>
      : GetScalarType<T[P], AggregateWallet_order_tbl[P]>
  }




  export type Wallet_order_tblGroupByArgs = {
    where?: wallet_order_tblWhereInput
    orderBy?: Enumerable<wallet_order_tblOrderByWithAggregationInput>
    by: Array<Wallet_order_tblScalarFieldEnum>
    having?: wallet_order_tblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_order_tblCountAggregateInputType | true
    _avg?: Wallet_order_tblAvgAggregateInputType
    _sum?: Wallet_order_tblSumAggregateInputType
    _min?: Wallet_order_tblMinAggregateInputType
    _max?: Wallet_order_tblMaxAggregateInputType
  }


  export type Wallet_order_tblGroupByOutputType = {
    id: number
    order_id: bigint
    user_id: number
    cart_type: string
    currency: string
    subtotal: number
    service_tax: number
    net_total: number
    discount: Decimal
    _count: Wallet_order_tblCountAggregateOutputType | null
    _avg: Wallet_order_tblAvgAggregateOutputType | null
    _sum: Wallet_order_tblSumAggregateOutputType | null
    _min: Wallet_order_tblMinAggregateOutputType | null
    _max: Wallet_order_tblMaxAggregateOutputType | null
  }

  type GetWallet_order_tblGroupByPayload<T extends Wallet_order_tblGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Wallet_order_tblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_order_tblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_order_tblGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_order_tblGroupByOutputType[P]>
        }
      >
    >


  export type wallet_order_tblSelect = {
    id?: boolean
    order_id?: boolean
    user_id?: boolean
    cart_type?: boolean
    currency?: boolean
    subtotal?: boolean
    service_tax?: boolean
    net_total?: boolean
    discount?: boolean
  }


  export type wallet_order_tblGetPayload<S extends boolean | null | undefined | wallet_order_tblArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? wallet_order_tbl :
    S extends undefined ? never :
    S extends { include: any } & (wallet_order_tblArgs | wallet_order_tblFindManyArgs)
    ? wallet_order_tbl 
    : S extends { select: any } & (wallet_order_tblArgs | wallet_order_tblFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof wallet_order_tbl ? wallet_order_tbl[P] : never
  } 
      : wallet_order_tbl


  type wallet_order_tblCountArgs = Merge<
    Omit<wallet_order_tblFindManyArgs, 'select' | 'include'> & {
      select?: Wallet_order_tblCountAggregateInputType | true
    }
  >

  export interface wallet_order_tblDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Wallet_order_tbl that matches the filter.
     * @param {wallet_order_tblFindUniqueArgs} args - Arguments to find a Wallet_order_tbl
     * @example
     * // Get one Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wallet_order_tblFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, wallet_order_tblFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'wallet_order_tbl'> extends True ? Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>> : Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T> | null, null>

    /**
     * Find the first Wallet_order_tbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_order_tblFindFirstArgs} args - Arguments to find a Wallet_order_tbl
     * @example
     * // Get one Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wallet_order_tblFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, wallet_order_tblFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'wallet_order_tbl'> extends True ? Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>> : Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T> | null, null>

    /**
     * Find zero or more Wallet_order_tbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_order_tblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_order_tbls
     * const wallet_order_tbls = await prisma.wallet_order_tbl.findMany()
     * 
     * // Get first 10 Wallet_order_tbls
     * const wallet_order_tbls = await prisma.wallet_order_tbl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_order_tblWithIdOnly = await prisma.wallet_order_tbl.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wallet_order_tblFindManyArgs>(
      args?: SelectSubset<T, wallet_order_tblFindManyArgs>
    ): PrismaPromise<Array<wallet_order_tblGetPayload<T>>>

    /**
     * Create a Wallet_order_tbl.
     * @param {wallet_order_tblCreateArgs} args - Arguments to create a Wallet_order_tbl.
     * @example
     * // Create one Wallet_order_tbl
     * const Wallet_order_tbl = await prisma.wallet_order_tbl.create({
     *   data: {
     *     // ... data to create a Wallet_order_tbl
     *   }
     * })
     * 
    **/
    create<T extends wallet_order_tblCreateArgs>(
      args: SelectSubset<T, wallet_order_tblCreateArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Create many Wallet_order_tbls.
     *     @param {wallet_order_tblCreateManyArgs} args - Arguments to create many Wallet_order_tbls.
     *     @example
     *     // Create many Wallet_order_tbls
     *     const wallet_order_tbl = await prisma.wallet_order_tbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wallet_order_tblCreateManyArgs>(
      args?: SelectSubset<T, wallet_order_tblCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_order_tbl.
     * @param {wallet_order_tblDeleteArgs} args - Arguments to delete one Wallet_order_tbl.
     * @example
     * // Delete one Wallet_order_tbl
     * const Wallet_order_tbl = await prisma.wallet_order_tbl.delete({
     *   where: {
     *     // ... filter to delete one Wallet_order_tbl
     *   }
     * })
     * 
    **/
    delete<T extends wallet_order_tblDeleteArgs>(
      args: SelectSubset<T, wallet_order_tblDeleteArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Update one Wallet_order_tbl.
     * @param {wallet_order_tblUpdateArgs} args - Arguments to update one Wallet_order_tbl.
     * @example
     * // Update one Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wallet_order_tblUpdateArgs>(
      args: SelectSubset<T, wallet_order_tblUpdateArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Delete zero or more Wallet_order_tbls.
     * @param {wallet_order_tblDeleteManyArgs} args - Arguments to filter Wallet_order_tbls to delete.
     * @example
     * // Delete a few Wallet_order_tbls
     * const { count } = await prisma.wallet_order_tbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wallet_order_tblDeleteManyArgs>(
      args?: SelectSubset<T, wallet_order_tblDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_order_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_order_tblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_order_tbls
     * const wallet_order_tbl = await prisma.wallet_order_tbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wallet_order_tblUpdateManyArgs>(
      args: SelectSubset<T, wallet_order_tblUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_order_tbl.
     * @param {wallet_order_tblUpsertArgs} args - Arguments to update or create a Wallet_order_tbl.
     * @example
     * // Update or create a Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.upsert({
     *   create: {
     *     // ... data to create a Wallet_order_tbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_order_tbl we want to update
     *   }
     * })
    **/
    upsert<T extends wallet_order_tblUpsertArgs>(
      args: SelectSubset<T, wallet_order_tblUpsertArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Find one Wallet_order_tbl that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {wallet_order_tblFindUniqueOrThrowArgs} args - Arguments to find a Wallet_order_tbl
     * @example
     * // Get one Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wallet_order_tblFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, wallet_order_tblFindUniqueOrThrowArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Find the first Wallet_order_tbl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_order_tblFindFirstOrThrowArgs} args - Arguments to find a Wallet_order_tbl
     * @example
     * // Get one Wallet_order_tbl
     * const wallet_order_tbl = await prisma.wallet_order_tbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wallet_order_tblFindFirstOrThrowArgs>(
      args?: SelectSubset<T, wallet_order_tblFindFirstOrThrowArgs>
    ): Prisma__wallet_order_tblClient<wallet_order_tblGetPayload<T>>

    /**
     * Count the number of Wallet_order_tbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_order_tblCountArgs} args - Arguments to filter Wallet_order_tbls to count.
     * @example
     * // Count the number of Wallet_order_tbls
     * const count = await prisma.wallet_order_tbl.count({
     *   where: {
     *     // ... the filter for the Wallet_order_tbls we want to count
     *   }
     * })
    **/
    count<T extends wallet_order_tblCountArgs>(
      args?: Subset<T, wallet_order_tblCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_order_tblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_order_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_order_tblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_order_tblAggregateArgs>(args: Subset<T, Wallet_order_tblAggregateArgs>): PrismaPromise<GetWallet_order_tblAggregateType<T>>

    /**
     * Group by Wallet_order_tbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_order_tblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Wallet_order_tblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Wallet_order_tblGroupByArgs['orderBy'] }
        : { orderBy?: Wallet_order_tblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Wallet_order_tblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_order_tblGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_order_tbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wallet_order_tblClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * wallet_order_tbl base type for findUnique actions
   */
  export type wallet_order_tblFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * Filter, which wallet_order_tbl to fetch.
     * 
    **/
    where: wallet_order_tblWhereUniqueInput
  }

  /**
   * wallet_order_tbl: findUnique
   */
  export interface wallet_order_tblFindUniqueArgs extends wallet_order_tblFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wallet_order_tbl base type for findFirst actions
   */
  export type wallet_order_tblFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * Filter, which wallet_order_tbl to fetch.
     * 
    **/
    where?: wallet_order_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_order_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_order_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_order_tbls.
     * 
    **/
    cursor?: wallet_order_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_order_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_order_tbls.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_order_tbls.
     * 
    **/
    distinct?: Enumerable<Wallet_order_tblScalarFieldEnum>
  }

  /**
   * wallet_order_tbl: findFirst
   */
  export interface wallet_order_tblFindFirstArgs extends wallet_order_tblFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wallet_order_tbl findMany
   */
  export type wallet_order_tblFindManyArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * Filter, which wallet_order_tbls to fetch.
     * 
    **/
    where?: wallet_order_tblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_order_tbls to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_order_tblOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_order_tbls.
     * 
    **/
    cursor?: wallet_order_tblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_order_tbls from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_order_tbls.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Wallet_order_tblScalarFieldEnum>
  }


  /**
   * wallet_order_tbl create
   */
  export type wallet_order_tblCreateArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * The data needed to create a wallet_order_tbl.
     * 
    **/
    data: XOR<wallet_order_tblCreateInput, wallet_order_tblUncheckedCreateInput>
  }


  /**
   * wallet_order_tbl createMany
   */
  export type wallet_order_tblCreateManyArgs = {
    /**
     * The data used to create many wallet_order_tbls.
     * 
    **/
    data: Enumerable<wallet_order_tblCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * wallet_order_tbl update
   */
  export type wallet_order_tblUpdateArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * The data needed to update a wallet_order_tbl.
     * 
    **/
    data: XOR<wallet_order_tblUpdateInput, wallet_order_tblUncheckedUpdateInput>
    /**
     * Choose, which wallet_order_tbl to update.
     * 
    **/
    where: wallet_order_tblWhereUniqueInput
  }


  /**
   * wallet_order_tbl updateMany
   */
  export type wallet_order_tblUpdateManyArgs = {
    /**
     * The data used to update wallet_order_tbls.
     * 
    **/
    data: XOR<wallet_order_tblUpdateManyMutationInput, wallet_order_tblUncheckedUpdateManyInput>
    /**
     * Filter which wallet_order_tbls to update
     * 
    **/
    where?: wallet_order_tblWhereInput
  }


  /**
   * wallet_order_tbl upsert
   */
  export type wallet_order_tblUpsertArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * The filter to search for the wallet_order_tbl to update in case it exists.
     * 
    **/
    where: wallet_order_tblWhereUniqueInput
    /**
     * In case the wallet_order_tbl found by the `where` argument doesn't exist, create a new wallet_order_tbl with this data.
     * 
    **/
    create: XOR<wallet_order_tblCreateInput, wallet_order_tblUncheckedCreateInput>
    /**
     * In case the wallet_order_tbl was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<wallet_order_tblUpdateInput, wallet_order_tblUncheckedUpdateInput>
  }


  /**
   * wallet_order_tbl delete
   */
  export type wallet_order_tblDeleteArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
    /**
     * Filter which wallet_order_tbl to delete.
     * 
    **/
    where: wallet_order_tblWhereUniqueInput
  }


  /**
   * wallet_order_tbl deleteMany
   */
  export type wallet_order_tblDeleteManyArgs = {
    /**
     * Filter which wallet_order_tbls to delete
     * 
    **/
    where?: wallet_order_tblWhereInput
  }


  /**
   * wallet_order_tbl: findUniqueOrThrow
   */
  export type wallet_order_tblFindUniqueOrThrowArgs = wallet_order_tblFindUniqueArgsBase
      

  /**
   * wallet_order_tbl: findFirstOrThrow
   */
  export type wallet_order_tblFindFirstOrThrowArgs = wallet_order_tblFindFirstArgsBase
      

  /**
   * wallet_order_tbl without action
   */
  export type wallet_order_tblArgs = {
    /**
     * Select specific fields to fetch from the wallet_order_tbl
     * 
    **/
    select?: wallet_order_tblSelect | null
  }



  /**
   * Model wallet_transaction_type
   */


  export type AggregateWallet_transaction_type = {
    _count: Wallet_transaction_typeCountAggregateOutputType | null
    _avg: Wallet_transaction_typeAvgAggregateOutputType | null
    _sum: Wallet_transaction_typeSumAggregateOutputType | null
    _min: Wallet_transaction_typeMinAggregateOutputType | null
    _max: Wallet_transaction_typeMaxAggregateOutputType | null
  }

  export type Wallet_transaction_typeAvgAggregateOutputType = {
    transaction_type: number | null
  }

  export type Wallet_transaction_typeSumAggregateOutputType = {
    transaction_type: number | null
  }

  export type Wallet_transaction_typeMinAggregateOutputType = {
    transaction_type: number | null
    transaction_value: string | null
  }

  export type Wallet_transaction_typeMaxAggregateOutputType = {
    transaction_type: number | null
    transaction_value: string | null
  }

  export type Wallet_transaction_typeCountAggregateOutputType = {
    transaction_type: number
    transaction_value: number
    _all: number
  }


  export type Wallet_transaction_typeAvgAggregateInputType = {
    transaction_type?: true
  }

  export type Wallet_transaction_typeSumAggregateInputType = {
    transaction_type?: true
  }

  export type Wallet_transaction_typeMinAggregateInputType = {
    transaction_type?: true
    transaction_value?: true
  }

  export type Wallet_transaction_typeMaxAggregateInputType = {
    transaction_type?: true
    transaction_value?: true
  }

  export type Wallet_transaction_typeCountAggregateInputType = {
    transaction_type?: true
    transaction_value?: true
    _all?: true
  }

  export type Wallet_transaction_typeAggregateArgs = {
    /**
     * Filter which wallet_transaction_type to aggregate.
     * 
    **/
    where?: wallet_transaction_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transaction_types to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_transaction_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: wallet_transaction_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transaction_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transaction_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_transaction_types
    **/
    _count?: true | Wallet_transaction_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_transaction_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_transaction_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_transaction_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_transaction_typeMaxAggregateInputType
  }

  export type GetWallet_transaction_typeAggregateType<T extends Wallet_transaction_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_transaction_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_transaction_type[P]>
      : GetScalarType<T[P], AggregateWallet_transaction_type[P]>
  }




  export type Wallet_transaction_typeGroupByArgs = {
    where?: wallet_transaction_typeWhereInput
    orderBy?: Enumerable<wallet_transaction_typeOrderByWithAggregationInput>
    by: Array<Wallet_transaction_typeScalarFieldEnum>
    having?: wallet_transaction_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_transaction_typeCountAggregateInputType | true
    _avg?: Wallet_transaction_typeAvgAggregateInputType
    _sum?: Wallet_transaction_typeSumAggregateInputType
    _min?: Wallet_transaction_typeMinAggregateInputType
    _max?: Wallet_transaction_typeMaxAggregateInputType
  }


  export type Wallet_transaction_typeGroupByOutputType = {
    transaction_type: number
    transaction_value: string
    _count: Wallet_transaction_typeCountAggregateOutputType | null
    _avg: Wallet_transaction_typeAvgAggregateOutputType | null
    _sum: Wallet_transaction_typeSumAggregateOutputType | null
    _min: Wallet_transaction_typeMinAggregateOutputType | null
    _max: Wallet_transaction_typeMaxAggregateOutputType | null
  }

  type GetWallet_transaction_typeGroupByPayload<T extends Wallet_transaction_typeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Wallet_transaction_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_transaction_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_transaction_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_transaction_typeGroupByOutputType[P]>
        }
      >
    >


  export type wallet_transaction_typeSelect = {
    transaction_type?: boolean
    transaction_value?: boolean
  }


  export type wallet_transaction_typeGetPayload<S extends boolean | null | undefined | wallet_transaction_typeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? wallet_transaction_type :
    S extends undefined ? never :
    S extends { include: any } & (wallet_transaction_typeArgs | wallet_transaction_typeFindManyArgs)
    ? wallet_transaction_type 
    : S extends { select: any } & (wallet_transaction_typeArgs | wallet_transaction_typeFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof wallet_transaction_type ? wallet_transaction_type[P] : never
  } 
      : wallet_transaction_type


  type wallet_transaction_typeCountArgs = Merge<
    Omit<wallet_transaction_typeFindManyArgs, 'select' | 'include'> & {
      select?: Wallet_transaction_typeCountAggregateInputType | true
    }
  >

  export interface wallet_transaction_typeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Wallet_transaction_type that matches the filter.
     * @param {wallet_transaction_typeFindUniqueArgs} args - Arguments to find a Wallet_transaction_type
     * @example
     * // Get one Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wallet_transaction_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, wallet_transaction_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'wallet_transaction_type'> extends True ? Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>> : Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T> | null, null>

    /**
     * Find the first Wallet_transaction_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transaction_typeFindFirstArgs} args - Arguments to find a Wallet_transaction_type
     * @example
     * // Get one Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wallet_transaction_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, wallet_transaction_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'wallet_transaction_type'> extends True ? Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>> : Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T> | null, null>

    /**
     * Find zero or more Wallet_transaction_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transaction_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_transaction_types
     * const wallet_transaction_types = await prisma.wallet_transaction_type.findMany()
     * 
     * // Get first 10 Wallet_transaction_types
     * const wallet_transaction_types = await prisma.wallet_transaction_type.findMany({ take: 10 })
     * 
     * // Only select the `transaction_type`
     * const wallet_transaction_typeWithTransaction_typeOnly = await prisma.wallet_transaction_type.findMany({ select: { transaction_type: true } })
     * 
    **/
    findMany<T extends wallet_transaction_typeFindManyArgs>(
      args?: SelectSubset<T, wallet_transaction_typeFindManyArgs>
    ): PrismaPromise<Array<wallet_transaction_typeGetPayload<T>>>

    /**
     * Create a Wallet_transaction_type.
     * @param {wallet_transaction_typeCreateArgs} args - Arguments to create a Wallet_transaction_type.
     * @example
     * // Create one Wallet_transaction_type
     * const Wallet_transaction_type = await prisma.wallet_transaction_type.create({
     *   data: {
     *     // ... data to create a Wallet_transaction_type
     *   }
     * })
     * 
    **/
    create<T extends wallet_transaction_typeCreateArgs>(
      args: SelectSubset<T, wallet_transaction_typeCreateArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Create many Wallet_transaction_types.
     *     @param {wallet_transaction_typeCreateManyArgs} args - Arguments to create many Wallet_transaction_types.
     *     @example
     *     // Create many Wallet_transaction_types
     *     const wallet_transaction_type = await prisma.wallet_transaction_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wallet_transaction_typeCreateManyArgs>(
      args?: SelectSubset<T, wallet_transaction_typeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_transaction_type.
     * @param {wallet_transaction_typeDeleteArgs} args - Arguments to delete one Wallet_transaction_type.
     * @example
     * // Delete one Wallet_transaction_type
     * const Wallet_transaction_type = await prisma.wallet_transaction_type.delete({
     *   where: {
     *     // ... filter to delete one Wallet_transaction_type
     *   }
     * })
     * 
    **/
    delete<T extends wallet_transaction_typeDeleteArgs>(
      args: SelectSubset<T, wallet_transaction_typeDeleteArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Update one Wallet_transaction_type.
     * @param {wallet_transaction_typeUpdateArgs} args - Arguments to update one Wallet_transaction_type.
     * @example
     * // Update one Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wallet_transaction_typeUpdateArgs>(
      args: SelectSubset<T, wallet_transaction_typeUpdateArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Delete zero or more Wallet_transaction_types.
     * @param {wallet_transaction_typeDeleteManyArgs} args - Arguments to filter Wallet_transaction_types to delete.
     * @example
     * // Delete a few Wallet_transaction_types
     * const { count } = await prisma.wallet_transaction_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wallet_transaction_typeDeleteManyArgs>(
      args?: SelectSubset<T, wallet_transaction_typeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transaction_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_transaction_types
     * const wallet_transaction_type = await prisma.wallet_transaction_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wallet_transaction_typeUpdateManyArgs>(
      args: SelectSubset<T, wallet_transaction_typeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_transaction_type.
     * @param {wallet_transaction_typeUpsertArgs} args - Arguments to update or create a Wallet_transaction_type.
     * @example
     * // Update or create a Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.upsert({
     *   create: {
     *     // ... data to create a Wallet_transaction_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_transaction_type we want to update
     *   }
     * })
    **/
    upsert<T extends wallet_transaction_typeUpsertArgs>(
      args: SelectSubset<T, wallet_transaction_typeUpsertArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Find one Wallet_transaction_type that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {wallet_transaction_typeFindUniqueOrThrowArgs} args - Arguments to find a Wallet_transaction_type
     * @example
     * // Get one Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wallet_transaction_typeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, wallet_transaction_typeFindUniqueOrThrowArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Find the first Wallet_transaction_type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transaction_typeFindFirstOrThrowArgs} args - Arguments to find a Wallet_transaction_type
     * @example
     * // Get one Wallet_transaction_type
     * const wallet_transaction_type = await prisma.wallet_transaction_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wallet_transaction_typeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, wallet_transaction_typeFindFirstOrThrowArgs>
    ): Prisma__wallet_transaction_typeClient<wallet_transaction_typeGetPayload<T>>

    /**
     * Count the number of Wallet_transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transaction_typeCountArgs} args - Arguments to filter Wallet_transaction_types to count.
     * @example
     * // Count the number of Wallet_transaction_types
     * const count = await prisma.wallet_transaction_type.count({
     *   where: {
     *     // ... the filter for the Wallet_transaction_types we want to count
     *   }
     * })
    **/
    count<T extends wallet_transaction_typeCountArgs>(
      args?: Subset<T, wallet_transaction_typeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_transaction_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_transaction_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_transaction_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_transaction_typeAggregateArgs>(args: Subset<T, Wallet_transaction_typeAggregateArgs>): PrismaPromise<GetWallet_transaction_typeAggregateType<T>>

    /**
     * Group by Wallet_transaction_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_transaction_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Wallet_transaction_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Wallet_transaction_typeGroupByArgs['orderBy'] }
        : { orderBy?: Wallet_transaction_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Wallet_transaction_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_transaction_typeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_transaction_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wallet_transaction_typeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * wallet_transaction_type base type for findUnique actions
   */
  export type wallet_transaction_typeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * Filter, which wallet_transaction_type to fetch.
     * 
    **/
    where: wallet_transaction_typeWhereUniqueInput
  }

  /**
   * wallet_transaction_type: findUnique
   */
  export interface wallet_transaction_typeFindUniqueArgs extends wallet_transaction_typeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wallet_transaction_type base type for findFirst actions
   */
  export type wallet_transaction_typeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * Filter, which wallet_transaction_type to fetch.
     * 
    **/
    where?: wallet_transaction_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transaction_types to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_transaction_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_transaction_types.
     * 
    **/
    cursor?: wallet_transaction_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transaction_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transaction_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_transaction_types.
     * 
    **/
    distinct?: Enumerable<Wallet_transaction_typeScalarFieldEnum>
  }

  /**
   * wallet_transaction_type: findFirst
   */
  export interface wallet_transaction_typeFindFirstArgs extends wallet_transaction_typeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wallet_transaction_type findMany
   */
  export type wallet_transaction_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * Filter, which wallet_transaction_types to fetch.
     * 
    **/
    where?: wallet_transaction_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transaction_types to fetch.
     * 
    **/
    orderBy?: Enumerable<wallet_transaction_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_transaction_types.
     * 
    **/
    cursor?: wallet_transaction_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transaction_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transaction_types.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Wallet_transaction_typeScalarFieldEnum>
  }


  /**
   * wallet_transaction_type create
   */
  export type wallet_transaction_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * The data needed to create a wallet_transaction_type.
     * 
    **/
    data: XOR<wallet_transaction_typeCreateInput, wallet_transaction_typeUncheckedCreateInput>
  }


  /**
   * wallet_transaction_type createMany
   */
  export type wallet_transaction_typeCreateManyArgs = {
    /**
     * The data used to create many wallet_transaction_types.
     * 
    **/
    data: Enumerable<wallet_transaction_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * wallet_transaction_type update
   */
  export type wallet_transaction_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * The data needed to update a wallet_transaction_type.
     * 
    **/
    data: XOR<wallet_transaction_typeUpdateInput, wallet_transaction_typeUncheckedUpdateInput>
    /**
     * Choose, which wallet_transaction_type to update.
     * 
    **/
    where: wallet_transaction_typeWhereUniqueInput
  }


  /**
   * wallet_transaction_type updateMany
   */
  export type wallet_transaction_typeUpdateManyArgs = {
    /**
     * The data used to update wallet_transaction_types.
     * 
    **/
    data: XOR<wallet_transaction_typeUpdateManyMutationInput, wallet_transaction_typeUncheckedUpdateManyInput>
    /**
     * Filter which wallet_transaction_types to update
     * 
    **/
    where?: wallet_transaction_typeWhereInput
  }


  /**
   * wallet_transaction_type upsert
   */
  export type wallet_transaction_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * The filter to search for the wallet_transaction_type to update in case it exists.
     * 
    **/
    where: wallet_transaction_typeWhereUniqueInput
    /**
     * In case the wallet_transaction_type found by the `where` argument doesn't exist, create a new wallet_transaction_type with this data.
     * 
    **/
    create: XOR<wallet_transaction_typeCreateInput, wallet_transaction_typeUncheckedCreateInput>
    /**
     * In case the wallet_transaction_type was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<wallet_transaction_typeUpdateInput, wallet_transaction_typeUncheckedUpdateInput>
  }


  /**
   * wallet_transaction_type delete
   */
  export type wallet_transaction_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
    /**
     * Filter which wallet_transaction_type to delete.
     * 
    **/
    where: wallet_transaction_typeWhereUniqueInput
  }


  /**
   * wallet_transaction_type deleteMany
   */
  export type wallet_transaction_typeDeleteManyArgs = {
    /**
     * Filter which wallet_transaction_types to delete
     * 
    **/
    where?: wallet_transaction_typeWhereInput
  }


  /**
   * wallet_transaction_type: findUniqueOrThrow
   */
  export type wallet_transaction_typeFindUniqueOrThrowArgs = wallet_transaction_typeFindUniqueArgsBase
      

  /**
   * wallet_transaction_type: findFirstOrThrow
   */
  export type wallet_transaction_typeFindFirstOrThrowArgs = wallet_transaction_typeFindFirstArgsBase
      

  /**
   * wallet_transaction_type without action
   */
  export type wallet_transaction_typeArgs = {
    /**
     * Select specific fields to fetch from the wallet_transaction_type
     * 
    **/
    select?: wallet_transaction_typeSelect | null
  }



  /**
   * Model wishlist
   */


  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistAvgAggregateOutputType = {
    id: number | null
    book_id: number | null
    user_id: number | null
  }

  export type WishlistSumAggregateOutputType = {
    id: number | null
    book_id: number | null
    user_id: number | null
  }

  export type WishlistMinAggregateOutputType = {
    id: number | null
    book_id: number | null
    user_id: number | null
    date_created: Date | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: number | null
    book_id: number | null
    user_id: number | null
    date_created: Date | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    book_id: number
    user_id: number
    date_created: number
    _all: number
  }


  export type WishlistAvgAggregateInputType = {
    id?: true
    book_id?: true
    user_id?: true
  }

  export type WishlistSumAggregateInputType = {
    id?: true
    book_id?: true
    user_id?: true
  }

  export type WishlistMinAggregateInputType = {
    id?: true
    book_id?: true
    user_id?: true
    date_created?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    book_id?: true
    user_id?: true
    date_created?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    book_id?: true
    user_id?: true
    date_created?: true
    _all?: true
  }

  export type WishlistAggregateArgs = {
    /**
     * Filter which wishlist to aggregate.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs = {
    where?: wishlistWhereInput
    orderBy?: Enumerable<wishlistOrderByWithAggregationInput>
    by: Array<WishlistScalarFieldEnum>
    having?: wishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _avg?: WishlistAvgAggregateInputType
    _sum?: WishlistSumAggregateInputType
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }


  export type WishlistGroupByOutputType = {
    id: number
    book_id: number
    user_id: number
    date_created: Date
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type wishlistSelect = {
    id?: boolean
    book_id?: boolean
    user_id?: boolean
    date_created?: boolean
  }


  export type wishlistGetPayload<S extends boolean | null | undefined | wishlistArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? wishlist :
    S extends undefined ? never :
    S extends { include: any } & (wishlistArgs | wishlistFindManyArgs)
    ? wishlist 
    : S extends { select: any } & (wishlistArgs | wishlistFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof wishlist ? wishlist[P] : never
  } 
      : wishlist


  type wishlistCountArgs = Merge<
    Omit<wishlistFindManyArgs, 'select' | 'include'> & {
      select?: WishlistCountAggregateInputType | true
    }
  >

  export interface wishlistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {wishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wishlistFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, wishlistFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'wishlist'> extends True ? Prisma__wishlistClient<wishlistGetPayload<T>> : Prisma__wishlistClient<wishlistGetPayload<T> | null, null>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wishlistFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, wishlistFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'wishlist'> extends True ? Prisma__wishlistClient<wishlistGetPayload<T>> : Prisma__wishlistClient<wishlistGetPayload<T> | null, null>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wishlistFindManyArgs>(
      args?: SelectSubset<T, wishlistFindManyArgs>
    ): PrismaPromise<Array<wishlistGetPayload<T>>>

    /**
     * Create a Wishlist.
     * @param {wishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
    **/
    create<T extends wishlistCreateArgs>(
      args: SelectSubset<T, wishlistCreateArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Create many Wishlists.
     *     @param {wishlistCreateManyArgs} args - Arguments to create many Wishlists.
     *     @example
     *     // Create many Wishlists
     *     const wishlist = await prisma.wishlist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wishlistCreateManyArgs>(
      args?: SelectSubset<T, wishlistCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wishlist.
     * @param {wishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
    **/
    delete<T extends wishlistDeleteArgs>(
      args: SelectSubset<T, wishlistDeleteArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Update one Wishlist.
     * @param {wishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wishlistUpdateArgs>(
      args: SelectSubset<T, wishlistUpdateArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Delete zero or more Wishlists.
     * @param {wishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wishlistDeleteManyArgs>(
      args?: SelectSubset<T, wishlistDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wishlistUpdateManyArgs>(
      args: SelectSubset<T, wishlistUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {wishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
    **/
    upsert<T extends wishlistUpsertArgs>(
      args: SelectSubset<T, wishlistUpsertArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Find one Wishlist that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {wishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wishlistFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, wishlistFindUniqueOrThrowArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wishlistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, wishlistFindFirstOrThrowArgs>
    ): Prisma__wishlistClient<wishlistGetPayload<T>>

    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends wishlistCountArgs>(
      args?: Subset<T, wishlistCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wishlistClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * wishlist base type for findUnique actions
   */
  export type wishlistFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Filter, which wishlist to fetch.
     * 
    **/
    where: wishlistWhereUniqueInput
  }

  /**
   * wishlist: findUnique
   */
  export interface wishlistFindUniqueArgs extends wishlistFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wishlist base type for findFirst actions
   */
  export type wishlistFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Filter, which wishlist to fetch.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wishlists.
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wishlists.
     * 
    **/
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }

  /**
   * wishlist: findFirst
   */
  export interface wishlistFindFirstArgs extends wishlistFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * wishlist findMany
   */
  export type wishlistFindManyArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Filter, which wishlists to fetch.
     * 
    **/
    where?: wishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishlists to fetch.
     * 
    **/
    orderBy?: Enumerable<wishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wishlists.
     * 
    **/
    cursor?: wishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishlists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishlists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }


  /**
   * wishlist create
   */
  export type wishlistCreateArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * The data needed to create a wishlist.
     * 
    **/
    data: XOR<wishlistCreateInput, wishlistUncheckedCreateInput>
  }


  /**
   * wishlist createMany
   */
  export type wishlistCreateManyArgs = {
    /**
     * The data used to create many wishlists.
     * 
    **/
    data: Enumerable<wishlistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * wishlist update
   */
  export type wishlistUpdateArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * The data needed to update a wishlist.
     * 
    **/
    data: XOR<wishlistUpdateInput, wishlistUncheckedUpdateInput>
    /**
     * Choose, which wishlist to update.
     * 
    **/
    where: wishlistWhereUniqueInput
  }


  /**
   * wishlist updateMany
   */
  export type wishlistUpdateManyArgs = {
    /**
     * The data used to update wishlists.
     * 
    **/
    data: XOR<wishlistUpdateManyMutationInput, wishlistUncheckedUpdateManyInput>
    /**
     * Filter which wishlists to update
     * 
    **/
    where?: wishlistWhereInput
  }


  /**
   * wishlist upsert
   */
  export type wishlistUpsertArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * The filter to search for the wishlist to update in case it exists.
     * 
    **/
    where: wishlistWhereUniqueInput
    /**
     * In case the wishlist found by the `where` argument doesn't exist, create a new wishlist with this data.
     * 
    **/
    create: XOR<wishlistCreateInput, wishlistUncheckedCreateInput>
    /**
     * In case the wishlist was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<wishlistUpdateInput, wishlistUncheckedUpdateInput>
  }


  /**
   * wishlist delete
   */
  export type wishlistDeleteArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
    /**
     * Filter which wishlist to delete.
     * 
    **/
    where: wishlistWhereUniqueInput
  }


  /**
   * wishlist deleteMany
   */
  export type wishlistDeleteManyArgs = {
    /**
     * Filter which wishlists to delete
     * 
    **/
    where?: wishlistWhereInput
  }


  /**
   * wishlist: findUniqueOrThrow
   */
  export type wishlistFindUniqueOrThrowArgs = wishlistFindUniqueArgsBase
      

  /**
   * wishlist: findFirstOrThrow
   */
  export type wishlistFindFirstOrThrowArgs = wishlistFindFirstArgsBase
      

  /**
   * wishlist without action
   */
  export type wishlistArgs = {
    /**
     * Select specific fields to fetch from the wishlist
     * 
    **/
    select?: wishlistSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Amazon_booksScalarFieldEnum: {
    id: 'id',
    activate: 'activate',
    reference_id: 'reference_id',
    print_book_isbn: 'print_book_isbn',
    eisbn: 'eisbn',
    imprint: 'imprint',
    title: 'title',
    author: 'author',
    editors: 'editors',
    illustrators: 'illustrators',
    contributors: 'contributors',
    translators: 'translators',
    photographers: 'photographers',
    language: 'language',
    digital_list_price_usd: 'digital_list_price_usd',
    digital_list_price_inr: 'digital_list_price_inr',
    release_date: 'release_date',
    publishing_date: 'publishing_date',
    description: 'description',
    bisac: 'bisac',
    bic: 'bic',
    territory: 'territory',
    exclude_territory: 'exclude_territory',
    adult_flag: 'adult_flag',
    edition: 'edition',
    series_title: 'series_title',
    series_number: 'series_number',
    volume: 'volume',
    keywords: 'keywords',
    asin: 'asin',
    amazon_url: 'amazon_url',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    status: 'status',
    ku_enabled: 'ku_enabled',
    ku_activation_date: 'ku_activation_date',
    ku_us_enabled: 'ku_us_enabled',
    ku_uk_enabled: 'ku_uk_enabled'
  };

  export type Amazon_booksScalarFieldEnum = (typeof Amazon_booksScalarFieldEnum)[keyof typeof Amazon_booksScalarFieldEnum]


  export const Amazon_transactionsScalarFieldEnum: {
    id: 'id',
    invoice_date: 'invoice_date',
    original_invoice_date: 'original_invoice_date',
    asin: 'asin',
    physical_isbn10: 'physical_isbn10',
    physical_isbn13: 'physical_isbn13',
    digital_isbn: 'digital_isbn',
    title: 'title',
    author: 'author',
    units_purchased: 'units_purchased',
    units_refunded: 'units_refunded',
    net_units: 'net_units',
    net_units_mtd: 'net_units_mtd',
    adjustments_made: 'adjustments_made',
    list_price: 'list_price',
    list_price_currency: 'list_price_currency',
    publisher_price: 'publisher_price',
    publisher_price_currency: 'publisher_price_currency',
    discount_percentage: 'discount_percentage',
    payment_amount: 'payment_amount',
    payment_currency: 'payment_currency',
    program_type: 'program_type',
    book_id: 'book_id',
    author_id: 'author_id',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    currency_exchange: 'currency_exchange',
    inr_value: 'inr_value',
    tax_value: 'tax_value',
    final_royalty_value: 'final_royalty_value',
    status: 'status'
  };

  export type Amazon_transactionsScalarFieldEnum = (typeof Amazon_transactionsScalarFieldEnum)[keyof typeof Amazon_transactionsScalarFieldEnum]


  export const Audible_booksScalarFieldEnum: {
    id: 'id',
    product_id: 'product_id',
    audible_asin: 'audible_asin',
    amazon_asin: 'amazon_asin',
    title: 'title',
    authors: 'authors',
    narrators: 'narrators',
    first_online_date: 'first_online_date',
    language_id: 'language_id',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner'
  };

  export type Audible_booksScalarFieldEnum = (typeof Audible_booksScalarFieldEnum)[keyof typeof Audible_booksScalarFieldEnum]


  export const Audible_transactionsScalarFieldEnum: {
    id: 'id',
    royalty_earner: 'royalty_earner',
    parent_product_id: 'parent_product_id',
    name: 'name',
    author: 'author',
    isbn: 'isbn',
    provider_product_id: 'provider_product_id',
    market_place: 'market_place',
    offer: 'offer',
    royalty_rate: 'royalty_rate',
    alc_qty: 'alc_qty',
    alc_net_sales: 'alc_net_sales',
    alc_royalty: 'alc_royalty',
    al_qty: 'al_qty',
    al_net_sales: 'al_net_sales',
    al_royalty: 'al_royalty',
    alop_qty: 'alop_qty',
    alop_net_sales: 'alop_net_sales',
    alop_royalty: 'alop_royalty',
    total_qty: 'total_qty',
    total_net_sales: 'total_net_sales',
    total_royalty: 'total_royalty',
    book_id: 'book_id',
    author_id: 'author_id',
    language_id: 'language_id',
    copyright_owner: 'copyright_owner',
    user_id: 'user_id',
    final_royalty_value: 'final_royalty_value',
    transaction_date: 'transaction_date',
    status: 'status'
  };

  export type Audible_transactionsScalarFieldEnum = (typeof Audible_transactionsScalarFieldEnum)[keyof typeof Audible_transactionsScalarFieldEnum]


  export const Audio_book_detailsScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    chapter_id: 'chapter_id',
    chapter_name: 'chapter_name',
    chapter_name_english: 'chapter_name_english',
    chapter_url: 'chapter_url',
    chapter_duration: 'chapter_duration',
    created_at: 'created_at'
  };

  export type Audio_book_detailsScalarFieldEnum = (typeof Audio_book_detailsScalarFieldEnum)[keyof typeof Audio_book_detailsScalarFieldEnum]


  export const Author_gift_booksScalarFieldEnum: {
    id: 'id',
    author_id: 'author_id',
    book_id: 'book_id',
    user_id: 'user_id',
    date: 'date',
    bookId: 'bookId'
  };

  export type Author_gift_booksScalarFieldEnum = (typeof Author_gift_booksScalarFieldEnum)[keyof typeof Author_gift_booksScalarFieldEnum]


  export const Author_languageScalarFieldEnum: {
    id: 'id',
    author_id: 'author_id',
    language_id: 'language_id',
    display_name1: 'display_name1',
    display_name2: 'display_name2',
    regional_author_name: 'regional_author_name'
  };

  export type Author_languageScalarFieldEnum = (typeof Author_languageScalarFieldEnum)[keyof typeof Author_languageScalarFieldEnum]


  export const Author_royalty_detailsScalarFieldEnum: {
    id: 'id',
    copyright_owner: 'copyright_owner',
    author_id: 'author_id',
    pustaka: 'pustaka',
    amazon: 'amazon',
    kobo: 'kobo',
    scribd: 'scribd',
    google: 'google',
    overdrive: 'overdrive',
    storytel: 'storytel',
    audible: 'audible',
    settlement_date: 'settlement_date',
    bank_transaction_details: 'bank_transaction_details'
  };

  export type Author_royalty_detailsScalarFieldEnum = (typeof Author_royalty_detailsScalarFieldEnum)[keyof typeof Author_royalty_detailsScalarFieldEnum]


  export const Author_tblScalarFieldEnum: {
    author_id: 'author_id',
    author_name: 'author_name',
    url_name: 'url_name',
    author_type: 'author_type',
    author_image: 'author_image',
    copy_right_owner_name: 'copy_right_owner_name',
    relationship: 'relationship',
    mobile: 'mobile',
    phone: 'phone',
    email: 'email',
    address: 'address',
    fb_url: 'fb_url',
    twitter_url: 'twitter_url',
    blog_url: 'blog_url',
    description: 'description',
    status: 'status',
    created_at: 'created_at',
    activated_at: 'activated_at',
    created_by: 'created_by',
    gender: 'gender',
    copyright_owner: 'copyright_owner',
    user_id: 'user_id',
    narrator_id: 'narrator_id',
    amazon_link: 'amazon_link',
    pratilipi_link: 'pratilipi_link',
    audible_link: 'audible_link',
    odilo_link: 'odilo_link',
    scribd_link: 'scribd_link',
    googlebooks_link: 'googlebooks_link',
    storytel_link: 'storytel_link',
    overdrive_link: 'overdrive_link',
    pinterest_link: 'pinterest_link',
    agreement_details: 'agreement_details',
    agreement_ebook_count: 'agreement_ebook_count',
    agreement_audiobook_count: 'agreement_audiobook_count',
    agreement_paperback_count: 'agreement_paperback_count'
  };

  export type Author_tblScalarFieldEnum = (typeof Author_tblScalarFieldEnum)[keyof typeof Author_tblScalarFieldEnum]


  export const Author_transactionScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    order_date: 'order_date',
    book_id: 'book_id',
    author_id: 'author_id',
    order_type: 'order_type',
    copy_right_seller: 'copy_right_seller',
    copy_right_lender: 'copy_right_lender',
    copyright_owner: 'copyright_owner',
    currency: 'currency',
    book_final_royalty_value_inr: 'book_final_royalty_value_inr',
    book_final_royalty_value_usd: 'book_final_royalty_value_usd',
    discount_provided: 'discount_provided',
    usd_exchange_rate: 'usd_exchange_rate',
    converted_book_final_royalty_value_inr: 'converted_book_final_royalty_value_inr',
    exchange_rate_comments: 'exchange_rate_comments',
    selling_royalty_percentage: 'selling_royalty_percentage',
    lending_royalty_percentage: 'lending_royalty_percentage',
    pay_status: 'pay_status',
    comments: 'comments'
  };

  export type Author_transactionScalarFieldEnum = (typeof Author_transactionScalarFieldEnum)[keyof typeof Author_transactionScalarFieldEnum]


  export const Blog_commentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_name: 'user_name',
    blog_name: 'blog_name',
    comments: 'comments',
    email_id: 'email_id',
    status: 'status',
    date_created: 'date_created'
  };

  export type Blog_commentsScalarFieldEnum = (typeof Blog_commentsScalarFieldEnum)[keyof typeof Blog_commentsScalarFieldEnum]


  export const Book_tblScalarFieldEnum: {
    book_id: 'book_id',
    author_name: 'author_name',
    book_title: 'book_title',
    url_name: 'url_name',
    regional_book_title: 'regional_book_title',
    language: 'language',
    isbn_number: 'isbn_number',
    cover_image: 'cover_image',
    description: 'description',
    cost: 'cost',
    number_of_page: 'number_of_page',
    genre_id: 'genre_id',
    book_category: 'book_category',
    type_of_book: 'type_of_book',
    publisher: 'publisher',
    download_link: 'download_link',
    epub_url: 'epub_url',
    royalty: 'royalty',
    copyright_owner: 'copyright_owner',
    status: 'status',
    created_at: 'created_at',
    activated_at: 'activated_at',
    created_by: 'created_by',
    book_cost_international: 'book_cost_international',
    narrator_id: 'narrator_id',
    rental_cost_inr: 'rental_cost_inr',
    rental_cost_usd: 'rental_cost_usd',
    paper_back_flag: 'paper_back_flag',
    paper_back_inr: 'paper_back_inr',
    paper_back_royalty: 'paper_back_royalty',
    paper_back_readiness_flag: 'paper_back_readiness_flag',
    book_id_mapping: 'book_id_mapping',
    agreement_flag: 'agreement_flag',
    paper_back_pages: 'paper_back_pages',
    paper_back_weight: 'paper_back_weight',
    paper_back_copyright_owner: 'paper_back_copyright_owner',
    paper_back_isbn: 'paper_back_isbn',
    paper_back_remarks: 'paper_back_remarks',
    mintbook_cost: 'mintbook_cost'
  };

  export type Book_tblScalarFieldEnum = (typeof Book_tblScalarFieldEnum)[keyof typeof Book_tblScalarFieldEnum]


  export const Book_typesScalarFieldEnum: {
    book_type_id: 'book_type_id',
    type_name: 'type_name',
    url_name: 'url_name',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    image_url: 'image_url'
  };

  export type Book_typesScalarFieldEnum = (typeof Book_typesScalarFieldEnum)[keyof typeof Book_typesScalarFieldEnum]


  export const Books_metadataScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    description: 'description',
    type_of_book: 'type_of_book',
    content_type: 'content_type',
    hard_copy_type: 'hard_copy_type',
    soft_copy_type: 'soft_copy_type',
    final_page_number: 'final_page_number',
    allocated_date: 'allocated_date',
    start_date: 'start_date',
    completion_date: 'completion_date',
    payment_date: 'payment_date',
    settled_page_number: 'settled_page_number',
    payment_status: 'payment_status',
    assigned_by: 'assigned_by',
    assigned_to: 'assigned_to',
    price_per_page: 'price_per_page',
    initial_page_number: 'initial_page_number',
    general_file_path: 'general_file_path',
    url_title: 'url_title',
    unique_key: 'unique_key',
    pustaka_cover_status: 'pustaka_cover_status',
    general_cover_status: 'general_cover_status',
    general_epub_status: 'general_epub_status',
    pustaka_epub_status: 'pustaka_epub_status',
    amazon_epub_status: 'amazon_epub_status',
    pustaka_flippdf_status: 'pustaka_flippdf_status',
    pustaka_word_status: 'pustaka_word_status',
    priority: 'priority',
    current_state: 'current_state',
    remarks: 'remarks'
  };

  export type Books_metadataScalarFieldEnum = (typeof Books_metadataScalarFieldEnum)[keyof typeof Books_metadataScalarFieldEnum]


  export const Books_processingScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    stage_id: 'stage_id',
    type_of_book: 'type_of_book',
    content_type: 'content_type',
    hard_copy_type: 'hard_copy_type',
    soft_copy_type: 'soft_copy_type',
    initial_page_number: 'initial_page_number',
    pustaka_cover_status: 'pustaka_cover_status',
    pustaka_epub_status: 'pustaka_epub_status',
    pustaka_flippdf_status: 'pustaka_flippdf_status',
    priority: 'priority',
    date_created: 'date_created',
    completed: 'completed',
    rework: 'rework'
  };

  export type Books_processingScalarFieldEnum = (typeof Books_processingScalarFieldEnum)[keyof typeof Books_processingScalarFieldEnum]


  export const Books_progressScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    status: 'status',
    stage: 'stage',
    startdate: 'startdate',
    enddate: 'enddate',
    on_hold_startdate: 'on_hold_startdate',
    on_hold_enddate: 'on_hold_enddate',
    remarks: 'remarks'
  };

  export type Books_progressScalarFieldEnum = (typeof Books_progressScalarFieldEnum)[keyof typeof Books_progressScalarFieldEnum]


  export const Contact_usScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    subject: 'subject',
    message: 'message',
    date_created: 'date_created'
  };

  export type Contact_usScalarFieldEnum = (typeof Contact_usScalarFieldEnum)[keyof typeof Contact_usScalarFieldEnum]


  export const Copyright_mappingScalarFieldEnum: {
    id: 'id',
    copyright_owner: 'copyright_owner',
    author_id: 'author_id',
    date_created: 'date_created'
  };

  export type Copyright_mappingScalarFieldEnum = (typeof Copyright_mappingScalarFieldEnum)[keyof typeof Copyright_mappingScalarFieldEnum]


  export const Episode_book_detailsScalarFieldEnum: {
    id: 'id',
    episode_book_id: 'episode_book_id',
    chapter_name: 'chapter_name',
    chapter_name_english: 'chapter_name_english',
    chapter_epub_url: 'chapter_epub_url',
    chapter_num_pages: 'chapter_num_pages',
    chapter_status: 'chapter_status',
    chapter_activated_at: 'chapter_activated_at'
  };

  export type Episode_book_detailsScalarFieldEnum = (typeof Episode_book_detailsScalarFieldEnum)[keyof typeof Episode_book_detailsScalarFieldEnum]


  export const Episode_book_tblScalarFieldEnum: {
    episode_book_id: 'episode_book_id',
    book_title: 'book_title',
    author_id: 'author_id',
    url_name: 'url_name',
    cover_image: 'cover_image',
    regional_book_title: 'regional_book_title',
    language: 'language',
    type_of_book: 'type_of_book',
    genre_id: 'genre_id',
    book_category: 'book_category',
    description: 'description',
    status: 'status',
    day_of_chapter: 'day_of_chapter',
    activated_at: 'activated_at'
  };

  export type Episode_book_tblScalarFieldEnum = (typeof Episode_book_tblScalarFieldEnum)[keyof typeof Episode_book_tblScalarFieldEnum]


  export const Fixed_royaltyScalarFieldEnum: {
    id: 'id',
    transaction_date: 'transaction_date',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    fixed_royalty_value: 'fixed_royalty_value',
    author_id: 'author_id',
    status: 'status'
  };

  export type Fixed_royaltyScalarFieldEnum = (typeof Fixed_royaltyScalarFieldEnum)[keyof typeof Fixed_royaltyScalarFieldEnum]


  export const Free_book_subscriptionScalarFieldEnum: {
    seq_id: 'seq_id',
    user_id: 'user_id',
    book_id: 'book_id',
    date_subscribed: 'date_subscribed',
    comments: 'comments'
  };

  export type Free_book_subscriptionScalarFieldEnum = (typeof Free_book_subscriptionScalarFieldEnum)[keyof typeof Free_book_subscriptionScalarFieldEnum]


  export const Genre_details_tblScalarFieldEnum: {
    genre_id: 'genre_id',
    admin_id: 'admin_id',
    genre_name: 'genre_name',
    url_name: 'url_name',
    lang_0: 'lang_0',
    lang_1: 'lang_1',
    lang_2: 'lang_2',
    lang_3: 'lang_3',
    lang_4: 'lang_4',
    lang_5: 'lang_5',
    status: 'status',
    bisac_code: 'bisac_code',
    image_url: 'image_url'
  };

  export type Genre_details_tblScalarFieldEnum = (typeof Genre_details_tblScalarFieldEnum)[keyof typeof Genre_details_tblScalarFieldEnum]


  export const Google_booksScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    status: 'status',
    label: 'label',
    play_store_link: 'play_store_link',
    enable_for_sale: 'enable_for_sale',
    title: 'title',
    subtitle: 'subtitle',
    book_format: 'book_format',
    related_identifier: 'related_identifier',
    contributor: 'contributor',
    biographical_note: 'biographical_note',
    language: 'language',
    subject_code: 'subject_code',
    age_group: 'age_group',
    description: 'description',
    publication_date: 'publication_date',
    page_count: 'page_count',
    series_name: 'series_name',
    volume_in_series: 'volume_in_series',
    preview_type: 'preview_type',
    preview_territories: 'preview_territories',
    buy_link_text: 'buy_link_text',
    buy_link: 'buy_link',
    publisher_name: 'publisher_name',
    publisher_website: 'publisher_website',
    show_photos_preview: 'show_photos_preview',
    pdf_download: 'pdf_download',
    on_sale_date: 'on_sale_date',
    drm_enabled: 'drm_enabled',
    show_photos_ebook: 'show_photos_ebook',
    include_scanned_pages: 'include_scanned_pages',
    mature_audiences: 'mature_audiences',
    copy_paste_percentage: 'copy_paste_percentage',
    enable_school_use: 'enable_school_use',
    school_list_price_60: 'school_list_price_60',
    school_list_price_180: 'school_list_price_180',
    school_list_price_360: 'school_list_price_360',
    school_use_countries: 'school_use_countries',
    duration: 'duration',
    preview_length_minutes: 'preview_length_minutes',
    preview_length_percentage: 'preview_length_percentage',
    abridged_version: 'abridged_version',
    inr_price_including_tax: 'inr_price_including_tax',
    inr_countries_including_tax: 'inr_countries_including_tax',
    usd_price_including_tax: 'usd_price_including_tax',
    usd_countries_including_tax: 'usd_countries_including_tax',
    inr_price_excluding_tax: 'inr_price_excluding_tax',
    inr_countries_excluding_tax: 'inr_countries_excluding_tax',
    usd_price_excluding_tax: 'usd_price_excluding_tax',
    usd_countries_excluding_tax: 'usd_countries_excluding_tax',
    eur_price_including_tax: 'eur_price_including_tax',
    eur_price_excluding_tax: 'eur_price_excluding_tax',
    eur_countries_including_tax: 'eur_countries_including_tax',
    eur_countries_excluding_tax: 'eur_countries_excluding_tax',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    publish_date: 'publish_date'
  };

  export type Google_booksScalarFieldEnum = (typeof Google_booksScalarFieldEnum)[keyof typeof Google_booksScalarFieldEnum]


  export const Google_transactionsScalarFieldEnum: {
    id: 'id',
    earnings_date: 'earnings_date',
    transaction_date: 'transaction_date',
    unique_id: 'unique_id',
    product: 'product',
    type: 'type',
    preorder: 'preorder',
    qty: 'qty',
    primary_isbn: 'primary_isbn',
    imprint_name: 'imprint_name',
    title: 'title',
    author: 'author',
    original_list_price_currency: 'original_list_price_currency',
    original_list_price: 'original_list_price',
    list_price_currency: 'list_price_currency',
    list_price_tax_inclusive: 'list_price_tax_inclusive',
    list_price_tax_exclusive: 'list_price_tax_exclusive',
    country_of_sale: 'country_of_sale',
    publisher_revenue_percentage: 'publisher_revenue_percentage',
    publisher_revenue: 'publisher_revenue',
    earnings_currency: 'earnings_currency',
    earnings_amount: 'earnings_amount',
    currency_conversion_rate: 'currency_conversion_rate',
    line_of_business: 'line_of_business',
    book_id: 'book_id',
    author_id: 'author_id',
    language_id: 'language_id',
    currency_exchange: 'currency_exchange',
    inr_value: 'inr_value',
    final_royalty_value: 'final_royalty_value',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    status: 'status'
  };

  export type Google_transactionsScalarFieldEnum = (typeof Google_transactionsScalarFieldEnum)[keyof typeof Google_transactionsScalarFieldEnum]


  export const Kobo_transactionScalarFieldEnum: {
    id: 'id',
    transaction_date: 'transaction_date',
    country: 'country',
    state: 'state',
    zipcode: 'zipcode',
    content_type: 'content_type',
    quantity: 'quantity',
    refund_reason: 'refund_reason',
    dealID: 'dealID',
    publisher_name: 'publisher_name',
    imprint: 'imprint',
    eISBN: 'eISBN',
    author_name: 'author_name',
    book_title: 'book_title',
    list_price: 'list_price',
    tax_excluded: 'tax_excluded',
    COGS_percentage: 'COGS_percentage',
    COGS_amount: 'COGS_amount',
    list_price_currency: 'list_price_currency',
    foreign_exchange: 'foreign_exchange',
    COGS_payable: 'COGS_payable',
    COGS_based_lp: 'COGS_based_lp',
    COGS_based_lp_excluded_tax: 'COGS_based_lp_excluded_tax',
    COGS_based_lp_currency: 'COGS_based_lp_currency',
    COGS_adjustment: 'COGS_adjustment',
    net_due: 'net_due',
    payable_currency: 'payable_currency',
    total_tax: 'total_tax',
    book_id: 'book_id',
    author_id: 'author_id',
    paid_inr: 'paid_inr',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    status: 'status'
  };

  export type Kobo_transactionScalarFieldEnum = (typeof Kobo_transactionScalarFieldEnum)[keyof typeof Kobo_transactionScalarFieldEnum]


  export const Language_tblScalarFieldEnum: {
    language_id: 'language_id',
    admin_id: 'admin_id',
    language_name: 'language_name',
    regional_language_name: 'regional_language_name',
    url_name: 'url_name',
    image_url: 'image_url',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Language_tblScalarFieldEnum = (typeof Language_tblScalarFieldEnum)[keyof typeof Language_tblScalarFieldEnum]


  export const Ledger_head_tblScalarFieldEnum: {
    id: 'id',
    ledger_head_name: 'ledger_head_name',
    date_created: 'date_created'
  };

  export type Ledger_head_tblScalarFieldEnum = (typeof Ledger_head_tblScalarFieldEnum)[keyof typeof Ledger_head_tblScalarFieldEnum]


  export const Narrator_tblScalarFieldEnum: {
    narrator_id: 'narrator_id',
    narrator_name: 'narrator_name',
    narrator_url: 'narrator_url',
    narrator_image: 'narrator_image',
    mobile: 'mobile',
    email: 'email',
    description: 'description',
    status: 'status',
    user_id: 'user_id',
    image_alt_text: 'image_alt_text',
    image_title_text: 'image_title_text',
    created_at: 'created_at'
  };

  export type Narrator_tblScalarFieldEnum = (typeof Narrator_tblScalarFieldEnum)[keyof typeof Narrator_tblScalarFieldEnum]


  export const Offline_paymentScalarFieldEnum: {
    id: 'id',
    cart_type: 'cart_type',
    cart_items: 'cart_items',
    user_id: 'user_id',
    amount: 'amount',
    currency: 'currency',
    date_created: 'date_created',
    status: 'status'
  };

  export type Offline_paymentScalarFieldEnum = (typeof Offline_paymentScalarFieldEnum)[keyof typeof Offline_paymentScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    tracking_id: 'tracking_id',
    bank_ref_no: 'bank_ref_no',
    order_status: 'order_status',
    failure_message: 'failure_message',
    payment_mode: 'payment_mode',
    card_name: 'card_name',
    status_code: 'status_code',
    status_message: 'status_message',
    currency: 'currency',
    amount: 'amount',
    channel: 'channel',
    billing_name: 'billing_name',
    billing_address: 'billing_address',
    billing_city: 'billing_city',
    billing_state: 'billing_state',
    billing_zip: 'billing_zip',
    billing_country: 'billing_country',
    billing_tel: 'billing_tel',
    billing_email: 'billing_email',
    delivery_name: 'delivery_name',
    delivery_address: 'delivery_address',
    delivery_city: 'delivery_city',
    delivery_state: 'delivery_state',
    delivery_zip: 'delivery_zip',
    delivery_country: 'delivery_country',
    delivery_tel: 'delivery_tel',
    user_id: 'user_id',
    cart_type: 'cart_type',
    subtotal: 'subtotal',
    service_tax: 'service_tax',
    net_revenue: 'net_revenue',
    net_total: 'net_total',
    date_created: 'date_created',
    coupon_id: 'coupon_id',
    coupon_discount_amt: 'coupon_discount_amt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const Order_book_detailsScalarFieldEnum: {
    book_order_id: 'book_order_id',
    order_id: 'order_id',
    user_id: 'user_id',
    book_id: 'book_id',
    book_cost: 'book_cost',
    order_type: 'order_type',
    start_date: 'start_date',
    end_date: 'end_date',
    order_date: 'order_date',
    rent_plan: 'rent_plan',
    author_id: 'author_id',
    language_id: 'language_id',
    copyright_owner: 'copyright_owner',
    channel: 'channel',
    status: 'status',
    date_created: 'date_created',
    user_ip: 'user_ip'
  };

  export type Order_book_detailsScalarFieldEnum = (typeof Order_book_detailsScalarFieldEnum)[keyof typeof Order_book_detailsScalarFieldEnum]


  export const Overdrive_booksScalarFieldEnum: {
    id: 'id',
    overdrive_id: 'overdrive_id',
    catalogue_id: 'catalogue_id',
    isbn: 'isbn',
    physical_isbn: 'physical_isbn',
    title: 'title',
    subtitle: 'subtitle',
    edition: 'edition',
    series: 'series',
    publisher: 'publisher',
    imprint: 'imprint',
    creators: 'creators',
    subject: 'subject',
    format: 'format',
    filesize: 'filesize',
    whs_usd: 'whs_usd',
    whs_usddiscount: 'whs_usddiscount',
    lib_usd: 'lib_usd',
    lib_usddiscount: 'lib_usddiscount',
    onsale_date: 'onsale_date',
    pub_date: 'pub_date',
    status: 'status',
    sample_link: 'sample_link',
    readbox_enabled: 'readbox_enabled',
    special_features: 'special_features',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    type_of_book: 'type_of_book'
  };

  export type Overdrive_booksScalarFieldEnum = (typeof Overdrive_booksScalarFieldEnum)[keyof typeof Overdrive_booksScalarFieldEnum]


  export const Overdrive_transactionsScalarFieldEnum: {
    id: 'id',
    transaction_date: 'transaction_date',
    overdrive_id: 'overdrive_id',
    isbn: 'isbn',
    title: 'title',
    subtitle: 'subtitle',
    author: 'author',
    retailer: 'retailer',
    country_of_sale: 'country_of_sale',
    format: 'format',
    srp_usd: 'srp_usd',
    discount: 'discount',
    amt_owed_usd: 'amt_owed_usd',
    book_id: 'book_id',
    author_id: 'author_id',
    language_id: 'language_id',
    exchange_rate: 'exchange_rate',
    inr_value: 'inr_value',
    final_royalty_value: 'final_royalty_value',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    status: 'status'
  };

  export type Overdrive_transactionsScalarFieldEnum = (typeof Overdrive_transactionsScalarFieldEnum)[keyof typeof Overdrive_transactionsScalarFieldEnum]


  export const Payout_sessionScalarFieldEnum: {
    session_id: 'session_id',
    session_data: 'session_data',
    user_id: 'user_id',
    order_id: 'order_id'
  };

  export type Payout_sessionScalarFieldEnum = (typeof Payout_sessionScalarFieldEnum)[keyof typeof Payout_sessionScalarFieldEnum]


  export const Plan_tblScalarFieldEnum: {
    plan_id: 'plan_id',
    plan_name: 'plan_name',
    plan_display_name: 'plan_display_name',
    plan_url_name: 'plan_url_name',
    plan_type: 'plan_type',
    plan_image: 'plan_image',
    plan_cost: 'plan_cost',
    plan_caption: 'plan_caption',
    plan_cost_international: 'plan_cost_international',
    validity_days: 'validity_days',
    book_validity_days: 'book_validity_days',
    available_books: 'available_books',
    discount: 'discount',
    plan_intro_date: 'plan_intro_date',
    status: 'status'
  };

  export type Plan_tblScalarFieldEnum = (typeof Plan_tblScalarFieldEnum)[keyof typeof Plan_tblScalarFieldEnum]


  export const Pod_cost_notificationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    date_created: 'date_created',
    mail_status: 'mail_status'
  };

  export type Pod_cost_notificationScalarFieldEnum = (typeof Pod_cost_notificationScalarFieldEnum)[keyof typeof Pod_cost_notificationScalarFieldEnum]


  export const Pod_orderScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    user_id: 'user_id',
    shipping_charges: 'shipping_charges',
    discount: 'discount',
    order_status: 'order_status',
    split_flag: 'split_flag',
    tracking_id: 'tracking_id',
    tracking_url: 'tracking_url',
    order_date: 'order_date'
  };

  export type Pod_orderScalarFieldEnum = (typeof Pod_orderScalarFieldEnum)[keyof typeof Pod_orderScalarFieldEnum]


  export const Pod_order_detailsScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    user_id: 'user_id',
    book_id: 'book_id',
    quantity: 'quantity',
    wrapper_type: 'wrapper_type',
    personalised_message: 'personalised_message',
    tracking_id: 'tracking_id',
    tracking_url: 'tracking_url',
    status: 'status',
    price: 'price',
    order_date: 'order_date'
  };

  export type Pod_order_detailsScalarFieldEnum = (typeof Pod_order_detailsScalarFieldEnum)[keyof typeof Pod_order_detailsScalarFieldEnum]


  export const Pod_processingScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    stage_id: 'stage_id',
    content_type: 'content_type',
    word_page_number: 'word_page_number',
    pod_estimation_pages: 'pod_estimation_pages',
    cover_status: 'cover_status',
    priority: 'priority',
    date_created: 'date_created',
    completed: 'completed',
    rework: 'rework'
  };

  export type Pod_processingScalarFieldEnum = (typeof Pod_processingScalarFieldEnum)[keyof typeof Pod_processingScalarFieldEnum]


  export const Pod_progressScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    status: 'status',
    stage: 'stage',
    startdate: 'startdate',
    enddate: 'enddate',
    on_hold_startdate: 'on_hold_startdate',
    on_hold_enddate: 'on_hold_enddate',
    remarks: 'remarks',
    pause_startdate: 'pause_startdate',
    pause_enddate: 'pause_enddate'
  };

  export type Pod_progressScalarFieldEnum = (typeof Pod_progressScalarFieldEnum)[keyof typeof Pod_progressScalarFieldEnum]


  export const Publisher_tblScalarFieldEnum: {
    publisher_id: 'publisher_id',
    publisher_name: 'publisher_name',
    publisher_url_name: 'publisher_url_name',
    publisher_regional_name: 'publisher_regional_name',
    publisher_image: 'publisher_image',
    publisher_description: 'publisher_description',
    email_id: 'email_id',
    mobile: 'mobile',
    address: 'address',
    bank_acc_no: 'bank_acc_no',
    bank_acc_name: 'bank_acc_name',
    bank_acc_type: 'bank_acc_type',
    ifsc_code: 'ifsc_code',
    pan_number: 'pan_number',
    copyright_owner: 'copyright_owner',
    bonus_percentage: 'bonus_percentage',
    status: 'status',
    created_at: 'created_at',
    tds_flag: 'tds_flag'
  };

  export type Publisher_tblScalarFieldEnum = (typeof Publisher_tblScalarFieldEnum)[keyof typeof Publisher_tblScalarFieldEnum]


  export const Rating_reviewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    user_id: 'user_id',
    book_id: 'book_id',
    comment: 'comment',
    rating: 'rating',
    status: 'status',
    date_created: 'date_created'
  };

  export type Rating_reviewScalarFieldEnum = (typeof Rating_reviewScalarFieldEnum)[keyof typeof Rating_reviewScalarFieldEnum]


  export const Razorpay_requestsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    plan_id: 'plan_id',
    razorpay_payload: 'razorpay_payload',
    created: 'created'
  };

  export type Razorpay_requestsScalarFieldEnum = (typeof Razorpay_requestsScalarFieldEnum)[keyof typeof Razorpay_requestsScalarFieldEnum]


  export const Royalty_settlementScalarFieldEnum: {
    id: 'id',
    copy_right_owner_id: 'copy_right_owner_id',
    author_id: 'author_id',
    settlement_date: 'settlement_date',
    settlement_amount: 'settlement_amount',
    tds_amount: 'tds_amount',
    payment_type: 'payment_type',
    bank_transaction_details: 'bank_transaction_details',
    comments: 'comments',
    pustaka: 'pustaka',
    amazon: 'amazon',
    kobo: 'kobo',
    scribd: 'scribd',
    google: 'google',
    overdrive: 'overdrive',
    storytel: 'storytel',
    audible: 'audible',
    bonus_value: 'bonus_value'
  };

  export type Royalty_settlementScalarFieldEnum = (typeof Royalty_settlementScalarFieldEnum)[keyof typeof Royalty_settlementScalarFieldEnum]


  export const Sales_consolidationScalarFieldEnum: {
    id: 'id',
    author_id: 'author_id',
    book_id: 'book_id',
    month_year: 'month_year',
    genre_id: 'genre_id',
    language_id: 'language_id',
    type_of_book: 'type_of_book',
    book_cost: 'book_cost',
    downloads: 'downloads'
  };

  export type Sales_consolidationScalarFieldEnum = (typeof Sales_consolidationScalarFieldEnum)[keyof typeof Sales_consolidationScalarFieldEnum]


  export const Scribd_booksScalarFieldEnum: {
    id: 'id',
    updated_at: 'updated_at',
    import_id: 'import_id',
    doc_id: 'doc_id',
    identifier: 'identifier',
    title: 'title',
    published: 'published',
    in_subscription: 'in_subscription',
    product_page_url: 'product_page_url',
    imprints: 'imprints',
    status: 'status',
    publisher_tools_config_id: 'publisher_tools_config_id',
    metadata_status: 'metadata_status',
    conversion_status: 'conversion_status',
    product_page_pending: 'product_page_pending',
    subscription_pending: 'subscription_pending',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    duplicate_flag: 'duplicate_flag'
  };

  export type Scribd_booksScalarFieldEnum = (typeof Scribd_booksScalarFieldEnum)[keyof typeof Scribd_booksScalarFieldEnum]


  export const Scribd_transactionScalarFieldEnum: {
    S_No: 'S_No',
    Payout_month: 'Payout_month',
    Publisher: 'Publisher',
    Amount_owed_for_this_interaction: 'Amount_owed_for_this_interaction',
    Amount_owed_currency: 'Amount_owed_currency',
    Price_in_original_currency: 'Price_in_original_currency',
    Digital_list_price: 'Digital_list_price',
    Original_currency: 'Original_currency',
    Price_type: 'Price_type',
    ISBN: 'ISBN',
    Title: 'Title',
    Authors: 'Authors',
    Imprints: 'Imprints',
    Viewed: 'Viewed',
    Payout_type: 'Payout_type',
    Start_date_of_interaction: 'Start_date_of_interaction',
    Last_date_of_interaction: 'Last_date_of_interaction',
    Country_of_reader: 'Country_of_reader',
    Unique_interaction_ID: 'Unique_interaction_ID',
    ISO_Country_Code: 'ISO_Country_Code',
    Threshold_Date: 'Threshold_Date',
    book_id: 'book_id',
    author_id: 'author_id',
    language_id: 'language_id',
    converted_inr: 'converted_inr',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    status: 'status',
    exchange_rate: 'exchange_rate',
    converted_inr_full: 'converted_inr_full'
  };

  export type Scribd_transactionScalarFieldEnum = (typeof Scribd_transactionScalarFieldEnum)[keyof typeof Scribd_transactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const Storytel_booksScalarFieldEnum: {
    id: 'id',
    storytel_book_id: 'storytel_book_id',
    isbn: 'isbn',
    title: 'title',
    author_name: 'author_name',
    narrator: 'narrator',
    category: 'category',
    publication_date: 'publication_date',
    book_id: 'book_id',
    author_id: 'author_id',
    copyright_owner: 'copyright_owner',
    language_id: 'language_id',
    genre_id: 'genre_id',
    type_of_book: 'type_of_book'
  };

  export type Storytel_booksScalarFieldEnum = (typeof Storytel_booksScalarFieldEnum)[keyof typeof Storytel_booksScalarFieldEnum]


  export const Storytel_transactionsScalarFieldEnum: {
    id: 'id',
    author: 'author',
    title: 'title',
    isbn: 'isbn',
    country: 'country',
    price_model: 'price_model',
    no_of_units: 'no_of_units',
    net_receipts_per_hour_local: 'net_receipts_per_hour_local',
    ecb_exchange_rate: 'ecb_exchange_rate',
    net_receipts_per_hour_inr: 'net_receipts_per_hour_inr',
    book_length_in_hours: 'book_length_in_hours',
    price_per_unit: 'price_per_unit',
    remuneration_eur: 'remuneration_eur',
    remuneration_inr: 'remuneration_inr',
    publisher: 'publisher',
    imprint: 'imprint',
    consumption_dates: 'consumption_dates',
    book_type: 'book_type',
    book_id: 'book_id',
    author_id: 'author_id',
    language_id: 'language_id',
    user_id: 'user_id',
    copyright_owner: 'copyright_owner',
    final_royalty_value: 'final_royalty_value',
    transaction_date: 'transaction_date',
    status: 'status'
  };

  export type Storytel_transactionsScalarFieldEnum = (typeof Storytel_transactionsScalarFieldEnum)[keyof typeof Storytel_transactionsScalarFieldEnum]


  export const Subscribe_newsletterScalarFieldEnum: {
    id: 'id',
    email_id: 'email_id',
    subscribe_date: 'subscribe_date'
  };

  export type Subscribe_newsletterScalarFieldEnum = (typeof Subscribe_newsletterScalarFieldEnum)[keyof typeof Subscribe_newsletterScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    user_id: 'user_id',
    subscription_id: 'subscription_id',
    plan_type: 'plan_type',
    number_of_days: 'number_of_days',
    start_date: 'start_date',
    end_date: 'end_date',
    total_books_applicable: 'total_books_applicable',
    date_inserted: 'date_inserted',
    status: 'status'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const Today_dealsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    book_id: 'book_id',
    language_id: 'language_id',
    discount: 'discount',
    status: 'status',
    type: 'type'
  };

  export type Today_dealsScalarFieldEnum = (typeof Today_dealsScalarFieldEnum)[keyof typeof Today_dealsScalarFieldEnum]


  export const Top_booksScalarFieldEnum: {
    id: 'id',
    purpose: 'purpose',
    sales_count_by_bk_id: 'sales_count_by_bk_id',
    book_id: 'book_id',
    book_title: 'book_title',
    url_name: 'url_name',
    regional_book_title: 'regional_book_title',
    language_id: 'language_id',
    language_id_tmp: 'language_id_tmp',
    type_of_book: 'type_of_book',
    author_id: 'author_id',
    author_name: 'author_name',
    description: 'description',
    download_link: 'download_link',
    cover_image: 'cover_image',
    epub_url: 'epub_url',
    cost: 'cost',
    number_of_page: 'number_of_page',
    genre_id: 'genre_id',
    genre_id_tmp: 'genre_id_tmp',
    genre_name: 'genre_name',
    book_category: 'book_category'
  };

  export type Top_booksScalarFieldEnum = (typeof Top_booksScalarFieldEnum)[keyof typeof Top_booksScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const User_addressScalarFieldEnum: {
    user_id: 'user_id',
    billing_name: 'billing_name',
    billing_address1: 'billing_address1',
    billing_address2: 'billing_address2',
    billing_area_name: 'billing_area_name',
    billing_landmark: 'billing_landmark',
    billing_city: 'billing_city',
    billing_state: 'billing_state',
    billing_pincode: 'billing_pincode',
    billing_mobile_no: 'billing_mobile_no',
    billing_alternate_no: 'billing_alternate_no',
    shipping_name: 'shipping_name',
    shipping_address1: 'shipping_address1',
    shipping_address2: 'shipping_address2',
    shipping_area_name: 'shipping_area_name',
    shipping_landmark: 'shipping_landmark',
    shipping_city: 'shipping_city',
    shipping_state: 'shipping_state',
    shipping_pincode: 'shipping_pincode',
    shipping_mobile_no: 'shipping_mobile_no',
    shipping_alternate_no: 'shipping_alternate_no'
  };

  export type User_addressScalarFieldEnum = (typeof User_addressScalarFieldEnum)[keyof typeof User_addressScalarFieldEnum]


  export const User_devicesScalarFieldEnum: {
    user_id: 'user_id',
    device_id1: 'device_id1',
    device_info1: 'device_info1',
    device_id2: 'device_id2',
    device_info2: 'device_info2',
    device_id3: 'device_id3',
    device_info3: 'device_info3',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_devicesScalarFieldEnum = (typeof User_devicesScalarFieldEnum)[keyof typeof User_devicesScalarFieldEnum]


  export const User_subscription_tblScalarFieldEnum: {
    subscription_id: 'subscription_id',
    user_id: 'user_id',
    user_email_id: 'user_email_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type User_subscription_tblScalarFieldEnum = (typeof User_subscription_tblScalarFieldEnum)[keyof typeof User_subscription_tblScalarFieldEnum]


  export const User_walletScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    balance_inr: 'balance_inr',
    balance_usd: 'balance_usd',
    date: 'date'
  };

  export type User_walletScalarFieldEnum = (typeof User_walletScalarFieldEnum)[keyof typeof User_walletScalarFieldEnum]


  export const User_wallet_transactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    order_id: 'order_id',
    amount: 'amount',
    currency: 'currency',
    transaction_type: 'transaction_type',
    balance_inr: 'balance_inr',
    balance_usd: 'balance_usd',
    date: 'date'
  };

  export type User_wallet_transactionScalarFieldEnum = (typeof User_wallet_transactionScalarFieldEnum)[keyof typeof User_wallet_transactionScalarFieldEnum]


  export const Users_tblScalarFieldEnum: {
    user_id: 'user_id',
    username: 'username',
    password: 'password',
    dob: 'dob',
    gender: 'gender',
    phone: 'phone',
    language_id: 'language_id',
    genre_ids: 'genre_ids',
    address: 'address',
    city: 'city',
    zipcode: 'zipcode',
    country: 'country',
    user_type: 'user_type',
    created_at: 'created_at',
    email: 'email',
    secret_code: 'secret_code',
    channel: 'channel',
    profile_img_url: 'profile_img_url'
  };

  export type Users_tblScalarFieldEnum = (typeof Users_tblScalarFieldEnum)[keyof typeof Users_tblScalarFieldEnum]


  export const Wallet_order_tblScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    user_id: 'user_id',
    cart_type: 'cart_type',
    currency: 'currency',
    subtotal: 'subtotal',
    service_tax: 'service_tax',
    net_total: 'net_total',
    discount: 'discount'
  };

  export type Wallet_order_tblScalarFieldEnum = (typeof Wallet_order_tblScalarFieldEnum)[keyof typeof Wallet_order_tblScalarFieldEnum]


  export const Wallet_transaction_typeScalarFieldEnum: {
    transaction_type: 'transaction_type',
    transaction_value: 'transaction_value'
  };

  export type Wallet_transaction_typeScalarFieldEnum = (typeof Wallet_transaction_typeScalarFieldEnum)[keyof typeof Wallet_transaction_typeScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    user_id: 'user_id',
    date_created: 'date_created'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type amazon_booksWhereInput = {
    AND?: Enumerable<amazon_booksWhereInput>
    OR?: Enumerable<amazon_booksWhereInput>
    NOT?: Enumerable<amazon_booksWhereInput>
    id?: IntFilter | number
    activate?: IntNullableFilter | number | null
    reference_id?: StringFilter | string
    print_book_isbn?: StringNullableFilter | string | null
    eisbn?: StringNullableFilter | string | null
    imprint?: StringNullableFilter | string | null
    title?: StringFilter | string
    author?: StringFilter | string
    editors?: StringNullableFilter | string | null
    illustrators?: StringNullableFilter | string | null
    contributors?: StringNullableFilter | string | null
    translators?: StringNullableFilter | string | null
    photographers?: StringNullableFilter | string | null
    language?: StringFilter | string
    digital_list_price_usd?: FloatFilter | number
    digital_list_price_inr?: FloatFilter | number
    release_date?: DateTimeFilter | Date | string
    publishing_date?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    bisac?: StringNullableFilter | string | null
    bic?: StringNullableFilter | string | null
    territory?: StringNullableFilter | string | null
    exclude_territory?: StringNullableFilter | string | null
    adult_flag?: StringNullableFilter | string | null
    edition?: IntNullableFilter | number | null
    series_title?: StringNullableFilter | string | null
    series_number?: IntNullableFilter | number | null
    volume?: IntNullableFilter | number | null
    keywords?: StringNullableFilter | string | null
    asin?: StringFilter | string
    amazon_url?: StringNullableFilter | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntFilter | number
    status?: IntNullableFilter | number | null
    ku_enabled?: IntNullableFilter | number | null
    ku_activation_date?: DateTimeNullableFilter | Date | string | null
    ku_us_enabled?: IntNullableFilter | number | null
    ku_uk_enabled?: IntNullableFilter | number | null
  }

  export type amazon_booksOrderByWithRelationInput = {
    id?: SortOrder
    activate?: SortOrder
    reference_id?: SortOrder
    print_book_isbn?: SortOrder
    eisbn?: SortOrder
    imprint?: SortOrder
    title?: SortOrder
    author?: SortOrder
    editors?: SortOrder
    illustrators?: SortOrder
    contributors?: SortOrder
    translators?: SortOrder
    photographers?: SortOrder
    language?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    release_date?: SortOrder
    publishing_date?: SortOrder
    description?: SortOrder
    bisac?: SortOrder
    bic?: SortOrder
    territory?: SortOrder
    exclude_territory?: SortOrder
    adult_flag?: SortOrder
    edition?: SortOrder
    series_title?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    keywords?: SortOrder
    asin?: SortOrder
    amazon_url?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_activation_date?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type amazon_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type amazon_booksOrderByWithAggregationInput = {
    id?: SortOrder
    activate?: SortOrder
    reference_id?: SortOrder
    print_book_isbn?: SortOrder
    eisbn?: SortOrder
    imprint?: SortOrder
    title?: SortOrder
    author?: SortOrder
    editors?: SortOrder
    illustrators?: SortOrder
    contributors?: SortOrder
    translators?: SortOrder
    photographers?: SortOrder
    language?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    release_date?: SortOrder
    publishing_date?: SortOrder
    description?: SortOrder
    bisac?: SortOrder
    bic?: SortOrder
    territory?: SortOrder
    exclude_territory?: SortOrder
    adult_flag?: SortOrder
    edition?: SortOrder
    series_title?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    keywords?: SortOrder
    asin?: SortOrder
    amazon_url?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_activation_date?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
    _count?: amazon_booksCountOrderByAggregateInput
    _avg?: amazon_booksAvgOrderByAggregateInput
    _max?: amazon_booksMaxOrderByAggregateInput
    _min?: amazon_booksMinOrderByAggregateInput
    _sum?: amazon_booksSumOrderByAggregateInput
  }

  export type amazon_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<amazon_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<amazon_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<amazon_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    activate?: IntNullableWithAggregatesFilter | number | null
    reference_id?: StringWithAggregatesFilter | string
    print_book_isbn?: StringNullableWithAggregatesFilter | string | null
    eisbn?: StringNullableWithAggregatesFilter | string | null
    imprint?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    author?: StringWithAggregatesFilter | string
    editors?: StringNullableWithAggregatesFilter | string | null
    illustrators?: StringNullableWithAggregatesFilter | string | null
    contributors?: StringNullableWithAggregatesFilter | string | null
    translators?: StringNullableWithAggregatesFilter | string | null
    photographers?: StringNullableWithAggregatesFilter | string | null
    language?: StringWithAggregatesFilter | string
    digital_list_price_usd?: FloatWithAggregatesFilter | number
    digital_list_price_inr?: FloatWithAggregatesFilter | number
    release_date?: DateTimeWithAggregatesFilter | Date | string
    publishing_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    bisac?: StringNullableWithAggregatesFilter | string | null
    bic?: StringNullableWithAggregatesFilter | string | null
    territory?: StringNullableWithAggregatesFilter | string | null
    exclude_territory?: StringNullableWithAggregatesFilter | string | null
    adult_flag?: StringNullableWithAggregatesFilter | string | null
    edition?: IntNullableWithAggregatesFilter | number | null
    series_title?: StringNullableWithAggregatesFilter | string | null
    series_number?: IntNullableWithAggregatesFilter | number | null
    volume?: IntNullableWithAggregatesFilter | number | null
    keywords?: StringNullableWithAggregatesFilter | string | null
    asin?: StringWithAggregatesFilter | string
    amazon_url?: StringNullableWithAggregatesFilter | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntWithAggregatesFilter | number
    status?: IntNullableWithAggregatesFilter | number | null
    ku_enabled?: IntNullableWithAggregatesFilter | number | null
    ku_activation_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ku_us_enabled?: IntNullableWithAggregatesFilter | number | null
    ku_uk_enabled?: IntNullableWithAggregatesFilter | number | null
  }

  export type amazon_transactionsWhereInput = {
    AND?: Enumerable<amazon_transactionsWhereInput>
    OR?: Enumerable<amazon_transactionsWhereInput>
    NOT?: Enumerable<amazon_transactionsWhereInput>
    id?: IntFilter | number
    invoice_date?: DateTimeFilter | Date | string
    original_invoice_date?: DateTimeNullableFilter | Date | string | null
    asin?: StringFilter | string
    physical_isbn10?: StringFilter | string
    physical_isbn13?: StringFilter | string
    digital_isbn?: StringFilter | string
    title?: StringFilter | string
    author?: StringFilter | string
    units_purchased?: IntFilter | number
    units_refunded?: IntFilter | number
    net_units?: IntFilter | number
    net_units_mtd?: IntFilter | number
    adjustments_made?: IntFilter | number
    list_price?: FloatFilter | number
    list_price_currency?: StringFilter | string
    publisher_price?: FloatFilter | number
    publisher_price_currency?: StringFilter | string
    discount_percentage?: IntFilter | number
    payment_amount?: FloatFilter | number
    payment_currency?: StringFilter | string
    program_type?: StringFilter | string
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    user_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntFilter | number
    currency_exchange?: FloatFilter | number
    inr_value?: FloatFilter | number
    tax_value?: FloatNullableFilter | number | null
    final_royalty_value?: FloatFilter | number
    status?: StringFilter | string
  }

  export type amazon_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    invoice_date?: SortOrder
    original_invoice_date?: SortOrder
    asin?: SortOrder
    physical_isbn10?: SortOrder
    physical_isbn13?: SortOrder
    digital_isbn?: SortOrder
    title?: SortOrder
    author?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    list_price_currency?: SortOrder
    publisher_price?: SortOrder
    publisher_price_currency?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    payment_currency?: SortOrder
    program_type?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
    status?: SortOrder
  }

  export type amazon_transactionsWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type amazon_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_date?: SortOrder
    original_invoice_date?: SortOrder
    asin?: SortOrder
    physical_isbn10?: SortOrder
    physical_isbn13?: SortOrder
    digital_isbn?: SortOrder
    title?: SortOrder
    author?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    list_price_currency?: SortOrder
    publisher_price?: SortOrder
    publisher_price_currency?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    payment_currency?: SortOrder
    program_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
    status?: SortOrder
    _count?: amazon_transactionsCountOrderByAggregateInput
    _avg?: amazon_transactionsAvgOrderByAggregateInput
    _max?: amazon_transactionsMaxOrderByAggregateInput
    _min?: amazon_transactionsMinOrderByAggregateInput
    _sum?: amazon_transactionsSumOrderByAggregateInput
  }

  export type amazon_transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<amazon_transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<amazon_transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<amazon_transactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    invoice_date?: DateTimeWithAggregatesFilter | Date | string
    original_invoice_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    asin?: StringWithAggregatesFilter | string
    physical_isbn10?: StringWithAggregatesFilter | string
    physical_isbn13?: StringWithAggregatesFilter | string
    digital_isbn?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    author?: StringWithAggregatesFilter | string
    units_purchased?: IntWithAggregatesFilter | number
    units_refunded?: IntWithAggregatesFilter | number
    net_units?: IntWithAggregatesFilter | number
    net_units_mtd?: IntWithAggregatesFilter | number
    adjustments_made?: IntWithAggregatesFilter | number
    list_price?: FloatWithAggregatesFilter | number
    list_price_currency?: StringWithAggregatesFilter | string
    publisher_price?: FloatWithAggregatesFilter | number
    publisher_price_currency?: StringWithAggregatesFilter | string
    discount_percentage?: IntWithAggregatesFilter | number
    payment_amount?: FloatWithAggregatesFilter | number
    payment_currency?: StringWithAggregatesFilter | string
    program_type?: StringWithAggregatesFilter | string
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntWithAggregatesFilter | number
    currency_exchange?: FloatWithAggregatesFilter | number
    inr_value?: FloatWithAggregatesFilter | number
    tax_value?: FloatNullableWithAggregatesFilter | number | null
    final_royalty_value?: FloatWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
  }

  export type audible_booksWhereInput = {
    AND?: Enumerable<audible_booksWhereInput>
    OR?: Enumerable<audible_booksWhereInput>
    NOT?: Enumerable<audible_booksWhereInput>
    id?: IntFilter | number
    product_id?: StringNullableFilter | string | null
    audible_asin?: StringNullableFilter | string | null
    amazon_asin?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    authors?: StringNullableFilter | string | null
    narrators?: StringNullableFilter | string | null
    first_online_date?: DateTimeNullableFilter | Date | string | null
    language_id?: IntNullableFilter | number | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
  }

  export type audible_booksOrderByWithRelationInput = {
    id?: SortOrder
    product_id?: SortOrder
    audible_asin?: SortOrder
    amazon_asin?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    narrators?: SortOrder
    first_online_date?: SortOrder
    language_id?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type audible_booksOrderByWithAggregationInput = {
    id?: SortOrder
    product_id?: SortOrder
    audible_asin?: SortOrder
    amazon_asin?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    narrators?: SortOrder
    first_online_date?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    _count?: audible_booksCountOrderByAggregateInput
    _avg?: audible_booksAvgOrderByAggregateInput
    _max?: audible_booksMaxOrderByAggregateInput
    _min?: audible_booksMinOrderByAggregateInput
    _sum?: audible_booksSumOrderByAggregateInput
  }

  export type audible_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<audible_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<audible_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<audible_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    product_id?: StringNullableWithAggregatesFilter | string | null
    audible_asin?: StringNullableWithAggregatesFilter | string | null
    amazon_asin?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    authors?: StringNullableWithAggregatesFilter | string | null
    narrators?: StringNullableWithAggregatesFilter | string | null
    first_online_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
  }

  export type audible_transactionsWhereInput = {
    AND?: Enumerable<audible_transactionsWhereInput>
    OR?: Enumerable<audible_transactionsWhereInput>
    NOT?: Enumerable<audible_transactionsWhereInput>
    id?: IntFilter | number
    royalty_earner?: StringNullableFilter | string | null
    parent_product_id?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    author?: StringNullableFilter | string | null
    isbn?: StringNullableFilter | string | null
    provider_product_id?: StringNullableFilter | string | null
    market_place?: StringNullableFilter | string | null
    offer?: StringNullableFilter | string | null
    royalty_rate?: StringNullableFilter | string | null
    alc_qty?: IntNullableFilter | number | null
    alc_net_sales?: FloatNullableFilter | number | null
    alc_royalty?: FloatNullableFilter | number | null
    al_qty?: IntNullableFilter | number | null
    al_net_sales?: FloatNullableFilter | number | null
    al_royalty?: FloatNullableFilter | number | null
    alop_qty?: IntNullableFilter | number | null
    alop_net_sales?: FloatNullableFilter | number | null
    alop_royalty?: FloatNullableFilter | number | null
    total_qty?: IntNullableFilter | number | null
    total_net_sales?: FloatNullableFilter | number | null
    total_royalty?: FloatNullableFilter | number | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    language_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    user_id?: IntNullableFilter | number | null
    final_royalty_value?: FloatNullableFilter | number | null
    transaction_date?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
  }

  export type audible_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    royalty_earner?: SortOrder
    parent_product_id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    provider_product_id?: SortOrder
    market_place?: SortOrder
    offer?: SortOrder
    royalty_rate?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type audible_transactionsWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type audible_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    royalty_earner?: SortOrder
    parent_product_id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    provider_product_id?: SortOrder
    market_place?: SortOrder
    offer?: SortOrder
    royalty_rate?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
    _count?: audible_transactionsCountOrderByAggregateInput
    _avg?: audible_transactionsAvgOrderByAggregateInput
    _max?: audible_transactionsMaxOrderByAggregateInput
    _min?: audible_transactionsMinOrderByAggregateInput
    _sum?: audible_transactionsSumOrderByAggregateInput
  }

  export type audible_transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<audible_transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<audible_transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<audible_transactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    royalty_earner?: StringNullableWithAggregatesFilter | string | null
    parent_product_id?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    author?: StringNullableWithAggregatesFilter | string | null
    isbn?: StringNullableWithAggregatesFilter | string | null
    provider_product_id?: StringNullableWithAggregatesFilter | string | null
    market_place?: StringNullableWithAggregatesFilter | string | null
    offer?: StringNullableWithAggregatesFilter | string | null
    royalty_rate?: StringNullableWithAggregatesFilter | string | null
    alc_qty?: IntNullableWithAggregatesFilter | number | null
    alc_net_sales?: FloatNullableWithAggregatesFilter | number | null
    alc_royalty?: FloatNullableWithAggregatesFilter | number | null
    al_qty?: IntNullableWithAggregatesFilter | number | null
    al_net_sales?: FloatNullableWithAggregatesFilter | number | null
    al_royalty?: FloatNullableWithAggregatesFilter | number | null
    alop_qty?: IntNullableWithAggregatesFilter | number | null
    alop_net_sales?: FloatNullableWithAggregatesFilter | number | null
    alop_royalty?: FloatNullableWithAggregatesFilter | number | null
    total_qty?: IntNullableWithAggregatesFilter | number | null
    total_net_sales?: FloatNullableWithAggregatesFilter | number | null
    total_royalty?: FloatNullableWithAggregatesFilter | number | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    user_id?: IntNullableWithAggregatesFilter | number | null
    final_royalty_value?: FloatNullableWithAggregatesFilter | number | null
    transaction_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: StringNullableWithAggregatesFilter | string | null
  }

  export type audio_book_detailsWhereInput = {
    AND?: Enumerable<audio_book_detailsWhereInput>
    OR?: Enumerable<audio_book_detailsWhereInput>
    NOT?: Enumerable<audio_book_detailsWhereInput>
    id?: IntFilter | number
    book_id?: IntNullableFilter | number | null
    chapter_id?: IntNullableFilter | number | null
    chapter_name?: StringNullableFilter | string | null
    chapter_name_english?: StringNullableFilter | string | null
    chapter_url?: StringNullableFilter | string | null
    chapter_duration?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
  }

  export type audio_book_detailsOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_url?: SortOrder
    chapter_duration?: SortOrder
    created_at?: SortOrder
  }

  export type audio_book_detailsWhereUniqueInput = {
    id?: number
  }

  export type audio_book_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_url?: SortOrder
    chapter_duration?: SortOrder
    created_at?: SortOrder
    _count?: audio_book_detailsCountOrderByAggregateInput
    _avg?: audio_book_detailsAvgOrderByAggregateInput
    _max?: audio_book_detailsMaxOrderByAggregateInput
    _min?: audio_book_detailsMinOrderByAggregateInput
    _sum?: audio_book_detailsSumOrderByAggregateInput
  }

  export type audio_book_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<audio_book_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<audio_book_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<audio_book_detailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntNullableWithAggregatesFilter | number | null
    chapter_id?: IntNullableWithAggregatesFilter | number | null
    chapter_name?: StringNullableWithAggregatesFilter | string | null
    chapter_name_english?: StringNullableWithAggregatesFilter | string | null
    chapter_url?: StringNullableWithAggregatesFilter | string | null
    chapter_duration?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type author_gift_booksWhereInput = {
    AND?: Enumerable<author_gift_booksWhereInput>
    OR?: Enumerable<author_gift_booksWhereInput>
    NOT?: Enumerable<author_gift_booksWhereInput>
    id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    user_id?: IntFilter | number
    date?: DateTimeNullableFilter | Date | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    bookId?: IntFilter | number
    user?: XOR<Users_tblRelationFilter, users_tblWhereInput>
  }

  export type author_gift_booksOrderByWithRelationInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    book?: book_tblOrderByWithRelationInput
    bookId?: SortOrder
    user?: users_tblOrderByWithRelationInput
  }

  export type author_gift_booksWhereUniqueInput = {
    id?: number
    user_id?: number
  }

  export type author_gift_booksOrderByWithAggregationInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    bookId?: SortOrder
    _count?: author_gift_booksCountOrderByAggregateInput
    _avg?: author_gift_booksAvgOrderByAggregateInput
    _max?: author_gift_booksMaxOrderByAggregateInput
    _min?: author_gift_booksMinOrderByAggregateInput
    _sum?: author_gift_booksSumOrderByAggregateInput
  }

  export type author_gift_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<author_gift_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<author_gift_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<author_gift_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: IntWithAggregatesFilter | number
    date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    bookId?: IntWithAggregatesFilter | number
  }

  export type author_languageWhereInput = {
    AND?: Enumerable<author_languageWhereInput>
    OR?: Enumerable<author_languageWhereInput>
    NOT?: Enumerable<author_languageWhereInput>
    id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    language?: XOR<Language_tblRelationFilter, language_tblWhereInput>
    language_id?: IntFilter | number
    display_name1?: StringNullableFilter | string | null
    display_name2?: StringNullableFilter | string | null
    regional_author_name?: StringNullableFilter | string | null
  }

  export type author_languageOrderByWithRelationInput = {
    id?: SortOrder
    author_id?: SortOrder
    language?: language_tblOrderByWithRelationInput
    language_id?: SortOrder
    display_name1?: SortOrder
    display_name2?: SortOrder
    regional_author_name?: SortOrder
  }

  export type author_languageWhereUniqueInput = {
    id?: number
    language_id?: number
  }

  export type author_languageOrderByWithAggregationInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    display_name1?: SortOrder
    display_name2?: SortOrder
    regional_author_name?: SortOrder
    _count?: author_languageCountOrderByAggregateInput
    _avg?: author_languageAvgOrderByAggregateInput
    _max?: author_languageMaxOrderByAggregateInput
    _min?: author_languageMinOrderByAggregateInput
    _sum?: author_languageSumOrderByAggregateInput
  }

  export type author_languageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<author_languageScalarWhereWithAggregatesInput>
    OR?: Enumerable<author_languageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<author_languageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntWithAggregatesFilter | number
    display_name1?: StringNullableWithAggregatesFilter | string | null
    display_name2?: StringNullableWithAggregatesFilter | string | null
    regional_author_name?: StringNullableWithAggregatesFilter | string | null
  }

  export type author_royalty_detailsWhereInput = {
    AND?: Enumerable<author_royalty_detailsWhereInput>
    OR?: Enumerable<author_royalty_detailsWhereInput>
    NOT?: Enumerable<author_royalty_detailsWhereInput>
    id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    author_id?: IntNullableFilter | number | null
    pustaka?: FloatNullableFilter | number | null
    amazon?: FloatNullableFilter | number | null
    kobo?: FloatNullableFilter | number | null
    scribd?: FloatNullableFilter | number | null
    google?: FloatNullableFilter | number | null
    overdrive?: FloatNullableFilter | number | null
    storytel?: FloatNullableFilter | number | null
    audible?: FloatNullableFilter | number | null
    settlement_date?: DateTimeNullableFilter | Date | string | null
    bank_transaction_details?: StringNullableFilter | string | null
  }

  export type author_royalty_detailsOrderByWithRelationInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    settlement_date?: SortOrder
    bank_transaction_details?: SortOrder
  }

  export type author_royalty_detailsWhereUniqueInput = {
    id?: number
  }

  export type author_royalty_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    settlement_date?: SortOrder
    bank_transaction_details?: SortOrder
    _count?: author_royalty_detailsCountOrderByAggregateInput
    _avg?: author_royalty_detailsAvgOrderByAggregateInput
    _max?: author_royalty_detailsMaxOrderByAggregateInput
    _min?: author_royalty_detailsMinOrderByAggregateInput
    _sum?: author_royalty_detailsSumOrderByAggregateInput
  }

  export type author_royalty_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<author_royalty_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<author_royalty_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<author_royalty_detailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    author_id?: IntNullableWithAggregatesFilter | number | null
    pustaka?: FloatNullableWithAggregatesFilter | number | null
    amazon?: FloatNullableWithAggregatesFilter | number | null
    kobo?: FloatNullableWithAggregatesFilter | number | null
    scribd?: FloatNullableWithAggregatesFilter | number | null
    google?: FloatNullableWithAggregatesFilter | number | null
    overdrive?: FloatNullableWithAggregatesFilter | number | null
    storytel?: FloatNullableWithAggregatesFilter | number | null
    audible?: FloatNullableWithAggregatesFilter | number | null
    settlement_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    bank_transaction_details?: StringNullableWithAggregatesFilter | string | null
  }

  export type author_tblWhereInput = {
    AND?: Enumerable<author_tblWhereInput>
    OR?: Enumerable<author_tblWhereInput>
    NOT?: Enumerable<author_tblWhereInput>
    author_id?: IntFilter | number
    author_name?: StringFilter | string
    url_name?: StringNullableFilter | string | null
    author_type?: IntNullableFilter | number | null
    author_image?: StringNullableFilter | string | null
    copy_right_owner_name?: StringFilter | string
    relationship?: StringFilter | string
    mobile?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    fb_url?: StringNullableFilter | string | null
    twitter_url?: StringNullableFilter | string | null
    blog_url?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    status?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    activated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: IntFilter | number
    gender?: StringFilter | string
    copyright_owner?: IntNullableFilter | number | null
    user_id?: IntFilter | number
    narrator_id?: IntNullableFilter | number | null
    amazon_link?: StringNullableFilter | string | null
    pratilipi_link?: StringNullableFilter | string | null
    audible_link?: StringNullableFilter | string | null
    odilo_link?: StringNullableFilter | string | null
    scribd_link?: StringNullableFilter | string | null
    googlebooks_link?: StringNullableFilter | string | null
    storytel_link?: StringNullableFilter | string | null
    overdrive_link?: StringNullableFilter | string | null
    pinterest_link?: StringNullableFilter | string | null
    agreement_details?: StringNullableFilter | string | null
    agreement_ebook_count?: IntNullableFilter | number | null
    agreement_audiobook_count?: IntNullableFilter | number | null
    agreement_paperback_count?: IntNullableFilter | number | null
  }

  export type author_tblOrderByWithRelationInput = {
    author_id?: SortOrder
    author_name?: SortOrder
    url_name?: SortOrder
    author_type?: SortOrder
    author_image?: SortOrder
    copy_right_owner_name?: SortOrder
    relationship?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    fb_url?: SortOrder
    twitter_url?: SortOrder
    blog_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    gender?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    amazon_link?: SortOrder
    pratilipi_link?: SortOrder
    audible_link?: SortOrder
    odilo_link?: SortOrder
    scribd_link?: SortOrder
    googlebooks_link?: SortOrder
    storytel_link?: SortOrder
    overdrive_link?: SortOrder
    pinterest_link?: SortOrder
    agreement_details?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type author_tblWhereUniqueInput = {
    author_id?: number
  }

  export type author_tblOrderByWithAggregationInput = {
    author_id?: SortOrder
    author_name?: SortOrder
    url_name?: SortOrder
    author_type?: SortOrder
    author_image?: SortOrder
    copy_right_owner_name?: SortOrder
    relationship?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    fb_url?: SortOrder
    twitter_url?: SortOrder
    blog_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    gender?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    amazon_link?: SortOrder
    pratilipi_link?: SortOrder
    audible_link?: SortOrder
    odilo_link?: SortOrder
    scribd_link?: SortOrder
    googlebooks_link?: SortOrder
    storytel_link?: SortOrder
    overdrive_link?: SortOrder
    pinterest_link?: SortOrder
    agreement_details?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
    _count?: author_tblCountOrderByAggregateInput
    _avg?: author_tblAvgOrderByAggregateInput
    _max?: author_tblMaxOrderByAggregateInput
    _min?: author_tblMinOrderByAggregateInput
    _sum?: author_tblSumOrderByAggregateInput
  }

  export type author_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<author_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<author_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<author_tblScalarWhereWithAggregatesInput>
    author_id?: IntWithAggregatesFilter | number
    author_name?: StringWithAggregatesFilter | string
    url_name?: StringNullableWithAggregatesFilter | string | null
    author_type?: IntNullableWithAggregatesFilter | number | null
    author_image?: StringNullableWithAggregatesFilter | string | null
    copy_right_owner_name?: StringWithAggregatesFilter | string
    relationship?: StringWithAggregatesFilter | string
    mobile?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    fb_url?: StringNullableWithAggregatesFilter | string | null
    twitter_url?: StringNullableWithAggregatesFilter | string | null
    blog_url?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    status?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    activated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: IntWithAggregatesFilter | number
    gender?: StringWithAggregatesFilter | string
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    user_id?: IntWithAggregatesFilter | number
    narrator_id?: IntNullableWithAggregatesFilter | number | null
    amazon_link?: StringNullableWithAggregatesFilter | string | null
    pratilipi_link?: StringNullableWithAggregatesFilter | string | null
    audible_link?: StringNullableWithAggregatesFilter | string | null
    odilo_link?: StringNullableWithAggregatesFilter | string | null
    scribd_link?: StringNullableWithAggregatesFilter | string | null
    googlebooks_link?: StringNullableWithAggregatesFilter | string | null
    storytel_link?: StringNullableWithAggregatesFilter | string | null
    overdrive_link?: StringNullableWithAggregatesFilter | string | null
    pinterest_link?: StringNullableWithAggregatesFilter | string | null
    agreement_details?: StringNullableWithAggregatesFilter | string | null
    agreement_ebook_count?: IntNullableWithAggregatesFilter | number | null
    agreement_audiobook_count?: IntNullableWithAggregatesFilter | number | null
    agreement_paperback_count?: IntNullableWithAggregatesFilter | number | null
  }

  export type author_transactionWhereInput = {
    AND?: Enumerable<author_transactionWhereInput>
    OR?: Enumerable<author_transactionWhereInput>
    NOT?: Enumerable<author_transactionWhereInput>
    id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
    order_date?: DateTimeNullableFilter | Date | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    order_type?: StringFilter | string
    copy_right_seller?: IntFilter | number
    copy_right_lender?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    currency?: StringNullableFilter | string | null
    book_final_royalty_value_inr?: FloatFilter | number
    book_final_royalty_value_usd?: FloatFilter | number
    discount_provided?: FloatFilter | number
    usd_exchange_rate?: FloatFilter | number
    converted_book_final_royalty_value_inr?: FloatFilter | number
    exchange_rate_comments?: StringFilter | string
    selling_royalty_percentage?: FloatFilter | number
    lending_royalty_percentage?: FloatFilter | number
    pay_status?: StringFilter | string
    comments?: StringFilter | string
  }

  export type author_transactionOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    order_date?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    order_type?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    currency?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    exchange_rate_comments?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
    pay_status?: SortOrder
    comments?: SortOrder
  }

  export type author_transactionWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type author_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    order_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    order_type?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    currency?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    exchange_rate_comments?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
    pay_status?: SortOrder
    comments?: SortOrder
    _count?: author_transactionCountOrderByAggregateInput
    _avg?: author_transactionAvgOrderByAggregateInput
    _max?: author_transactionMaxOrderByAggregateInput
    _min?: author_transactionMinOrderByAggregateInput
    _sum?: author_transactionSumOrderByAggregateInput
  }

  export type author_transactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<author_transactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<author_transactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<author_transactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
    order_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    order_type?: StringWithAggregatesFilter | string
    copy_right_seller?: IntWithAggregatesFilter | number
    copy_right_lender?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    currency?: StringNullableWithAggregatesFilter | string | null
    book_final_royalty_value_inr?: FloatWithAggregatesFilter | number
    book_final_royalty_value_usd?: FloatWithAggregatesFilter | number
    discount_provided?: FloatWithAggregatesFilter | number
    usd_exchange_rate?: FloatWithAggregatesFilter | number
    converted_book_final_royalty_value_inr?: FloatWithAggregatesFilter | number
    exchange_rate_comments?: StringWithAggregatesFilter | string
    selling_royalty_percentage?: FloatWithAggregatesFilter | number
    lending_royalty_percentage?: FloatWithAggregatesFilter | number
    pay_status?: StringWithAggregatesFilter | string
    comments?: StringWithAggregatesFilter | string
  }

  export type blog_commentsWhereInput = {
    AND?: Enumerable<blog_commentsWhereInput>
    OR?: Enumerable<blog_commentsWhereInput>
    NOT?: Enumerable<blog_commentsWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    user_name?: StringFilter | string
    blog_name?: StringFilter | string
    comments?: StringFilter | string
    email_id?: StringNullableFilter | string | null
    status?: IntFilter | number
    date_created?: DateTimeFilter | Date | string
  }

  export type blog_commentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    blog_name?: SortOrder
    comments?: SortOrder
    email_id?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type blog_commentsWhereUniqueInput = {
    id?: number
  }

  export type blog_commentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    blog_name?: SortOrder
    comments?: SortOrder
    email_id?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    _count?: blog_commentsCountOrderByAggregateInput
    _avg?: blog_commentsAvgOrderByAggregateInput
    _max?: blog_commentsMaxOrderByAggregateInput
    _min?: blog_commentsMinOrderByAggregateInput
    _sum?: blog_commentsSumOrderByAggregateInput
  }

  export type blog_commentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    user_name?: StringWithAggregatesFilter | string
    blog_name?: StringWithAggregatesFilter | string
    comments?: StringWithAggregatesFilter | string
    email_id?: StringNullableWithAggregatesFilter | string | null
    status?: IntWithAggregatesFilter | number
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type book_tblWhereInput = {
    AND?: Enumerable<book_tblWhereInput>
    OR?: Enumerable<book_tblWhereInput>
    NOT?: Enumerable<book_tblWhereInput>
    book_id?: IntFilter | number
    author_name?: IntFilter | number
    book_title?: StringFilter | string
    url_name?: StringNullableFilter | string | null
    regional_book_title?: StringFilter | string
    language_tbl_relation?: XOR<Language_tblRelationFilter, language_tblWhereInput>
    language?: IntFilter | number
    isbn_number?: StringNullableFilter | string | null
    cover_image?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    cost?: IntFilter | number
    number_of_page?: IntNullableFilter | number | null
    genre?: XOR<Genre_details_tblRelationFilter, genre_details_tblWhereInput>
    genre_id?: IntFilter | number
    book_category?: StringFilter | string
    type_of_book?: IntFilter | number
    publisher?: StringNullableFilter | string | null
    download_link?: StringFilter | string
    epub_url?: StringFilter | string
    royalty?: StringNullableFilter | string | null
    copyright_owner?: IntNullableFilter | number | null
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    activated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: IntFilter | number
    book_cost_international?: FloatFilter | number
    narrator_id?: IntNullableFilter | number | null
    rental_cost_inr?: IntNullableFilter | number | null
    rental_cost_usd?: FloatNullableFilter | number | null
    paper_back_flag?: IntNullableFilter | number | null
    paper_back_inr?: FloatNullableFilter | number | null
    paper_back_royalty?: StringNullableFilter | string | null
    paper_back_readiness_flag?: IntNullableFilter | number | null
    book_id_mapping?: IntNullableFilter | number | null
    agreement_flag?: IntNullableFilter | number | null
    paper_back_pages?: IntNullableFilter | number | null
    paper_back_weight?: FloatNullableFilter | number | null
    paper_back_copyright_owner?: IntNullableFilter | number | null
    paper_back_isbn?: StringNullableFilter | string | null
    paper_back_remarks?: StringNullableFilter | string | null
    mintbook_cost?: IntNullableFilter | number | null
    amazonBookId?: XOR<Amazon_booksRelationFilter, amazon_booksWhereInput> | null
    scribdBookId?: XOR<Scribd_booksRelationFilter, scribd_booksWhereInput> | null
    googleBookId?: XOR<Google_booksRelationFilter, google_booksWhereInput> | null
    storytelBookId?: XOR<Storytel_booksRelationFilter, storytel_booksWhereInput> | null
    overdriveBookId?: XOR<Overdrive_booksRelationFilter, overdrive_booksWhereInput> | null
    audibleBookId?: XOR<Audible_booksRelationFilter, audible_booksWhereInput> | null
    giftBooks?: Author_gift_booksListRelationFilter
    amazon_transactions?: XOR<Amazon_transactionsRelationFilter, amazon_transactionsWhereInput> | null
    audible_transactions?: XOR<Audible_transactionsRelationFilter, audible_transactionsWhereInput> | null
    author_transaction?: XOR<Author_transactionRelationFilter, author_transactionWhereInput> | null
    google_transactions?: XOR<Google_transactionsRelationFilter, google_transactionsWhereInput> | null
    kobo_transaction?: XOR<Kobo_transactionRelationFilter, kobo_transactionWhereInput> | null
    overdrive_transactions?: XOR<Overdrive_transactionsRelationFilter, overdrive_transactionsWhereInput> | null
    scribd_transaction?: XOR<Scribd_transactionRelationFilter, scribd_transactionWhereInput> | null
    storytel_transactions?: XOR<Storytel_transactionsRelationFilter, storytel_transactionsWhereInput> | null
  }

  export type book_tblOrderByWithRelationInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_tbl_relation?: language_tblOrderByWithRelationInput
    language?: SortOrder
    isbn_number?: SortOrder
    cover_image?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre?: genre_details_tblOrderByWithRelationInput
    genre_id?: SortOrder
    book_category?: SortOrder
    type_of_book?: SortOrder
    publisher?: SortOrder
    download_link?: SortOrder
    epub_url?: SortOrder
    royalty?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_royalty?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    paper_back_isbn?: SortOrder
    paper_back_remarks?: SortOrder
    mintbook_cost?: SortOrder
    amazonBookId?: amazon_booksOrderByWithRelationInput
    scribdBookId?: scribd_booksOrderByWithRelationInput
    googleBookId?: google_booksOrderByWithRelationInput
    storytelBookId?: storytel_booksOrderByWithRelationInput
    overdriveBookId?: overdrive_booksOrderByWithRelationInput
    audibleBookId?: audible_booksOrderByWithRelationInput
    giftBooks?: author_gift_booksOrderByRelationAggregateInput
    amazon_transactions?: amazon_transactionsOrderByWithRelationInput
    audible_transactions?: audible_transactionsOrderByWithRelationInput
    author_transaction?: author_transactionOrderByWithRelationInput
    google_transactions?: google_transactionsOrderByWithRelationInput
    kobo_transaction?: kobo_transactionOrderByWithRelationInput
    overdrive_transactions?: overdrive_transactionsOrderByWithRelationInput
    scribd_transaction?: scribd_transactionOrderByWithRelationInput
    storytel_transactions?: storytel_transactionsOrderByWithRelationInput
  }

  export type book_tblWhereUniqueInput = {
    book_id?: number
    language?: number
    genre_id?: number
  }

  export type book_tblOrderByWithAggregationInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    isbn_number?: SortOrder
    cover_image?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    type_of_book?: SortOrder
    publisher?: SortOrder
    download_link?: SortOrder
    epub_url?: SortOrder
    royalty?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_royalty?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    paper_back_isbn?: SortOrder
    paper_back_remarks?: SortOrder
    mintbook_cost?: SortOrder
    _count?: book_tblCountOrderByAggregateInput
    _avg?: book_tblAvgOrderByAggregateInput
    _max?: book_tblMaxOrderByAggregateInput
    _min?: book_tblMinOrderByAggregateInput
    _sum?: book_tblSumOrderByAggregateInput
  }

  export type book_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<book_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<book_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<book_tblScalarWhereWithAggregatesInput>
    book_id?: IntWithAggregatesFilter | number
    author_name?: IntWithAggregatesFilter | number
    book_title?: StringWithAggregatesFilter | string
    url_name?: StringNullableWithAggregatesFilter | string | null
    regional_book_title?: StringWithAggregatesFilter | string
    language?: IntWithAggregatesFilter | number
    isbn_number?: StringNullableWithAggregatesFilter | string | null
    cover_image?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    cost?: IntWithAggregatesFilter | number
    number_of_page?: IntNullableWithAggregatesFilter | number | null
    genre_id?: IntWithAggregatesFilter | number
    book_category?: StringWithAggregatesFilter | string
    type_of_book?: IntWithAggregatesFilter | number
    publisher?: StringNullableWithAggregatesFilter | string | null
    download_link?: StringWithAggregatesFilter | string
    epub_url?: StringWithAggregatesFilter | string
    royalty?: StringNullableWithAggregatesFilter | string | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    status?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    activated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: IntWithAggregatesFilter | number
    book_cost_international?: FloatWithAggregatesFilter | number
    narrator_id?: IntNullableWithAggregatesFilter | number | null
    rental_cost_inr?: IntNullableWithAggregatesFilter | number | null
    rental_cost_usd?: FloatNullableWithAggregatesFilter | number | null
    paper_back_flag?: IntNullableWithAggregatesFilter | number | null
    paper_back_inr?: FloatNullableWithAggregatesFilter | number | null
    paper_back_royalty?: StringNullableWithAggregatesFilter | string | null
    paper_back_readiness_flag?: IntNullableWithAggregatesFilter | number | null
    book_id_mapping?: IntNullableWithAggregatesFilter | number | null
    agreement_flag?: IntNullableWithAggregatesFilter | number | null
    paper_back_pages?: IntNullableWithAggregatesFilter | number | null
    paper_back_weight?: FloatNullableWithAggregatesFilter | number | null
    paper_back_copyright_owner?: IntNullableWithAggregatesFilter | number | null
    paper_back_isbn?: StringNullableWithAggregatesFilter | string | null
    paper_back_remarks?: StringNullableWithAggregatesFilter | string | null
    mintbook_cost?: IntNullableWithAggregatesFilter | number | null
  }

  export type book_typesWhereInput = {
    AND?: Enumerable<book_typesWhereInput>
    OR?: Enumerable<book_typesWhereInput>
    NOT?: Enumerable<book_typesWhereInput>
    book_type_id?: IntFilter | number
    type_name?: StringFilter | string
    url_name?: StringFilter | string
    status?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    image_url?: StringNullableFilter | string | null
  }

  export type book_typesOrderByWithRelationInput = {
    book_type_id?: SortOrder
    type_name?: SortOrder
    url_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type book_typesWhereUniqueInput = {
    book_type_id?: number
  }

  export type book_typesOrderByWithAggregationInput = {
    book_type_id?: SortOrder
    type_name?: SortOrder
    url_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
    _count?: book_typesCountOrderByAggregateInput
    _avg?: book_typesAvgOrderByAggregateInput
    _max?: book_typesMaxOrderByAggregateInput
    _min?: book_typesMinOrderByAggregateInput
    _sum?: book_typesSumOrderByAggregateInput
  }

  export type book_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<book_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<book_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<book_typesScalarWhereWithAggregatesInput>
    book_type_id?: IntWithAggregatesFilter | number
    type_name?: StringWithAggregatesFilter | string
    url_name?: StringWithAggregatesFilter | string
    status?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    image_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type books_metadataWhereInput = {
    AND?: Enumerable<books_metadataWhereInput>
    OR?: Enumerable<books_metadataWhereInput>
    NOT?: Enumerable<books_metadataWhereInput>
    id?: IntFilter | number
    book_id?: IntFilter | number
    description?: BoolFilter | boolean
    type_of_book?: IntFilter | number
    content_type?: StringFilter | string
    hard_copy_type?: StringFilter | string
    soft_copy_type?: StringFilter | string
    final_page_number?: IntFilter | number
    allocated_date?: DateTimeNullableFilter | Date | string | null
    start_date?: DateTimeNullableFilter | Date | string | null
    completion_date?: DateTimeNullableFilter | Date | string | null
    payment_date?: DateTimeFilter | Date | string
    settled_page_number?: IntFilter | number
    payment_status?: IntFilter | number
    assigned_by?: IntFilter | number
    assigned_to?: IntFilter | number
    price_per_page?: FloatFilter | number
    initial_page_number?: IntNullableFilter | number | null
    general_file_path?: StringFilter | string
    url_title?: StringFilter | string
    unique_key?: StringFilter | string
    pustaka_cover_status?: IntFilter | number
    general_cover_status?: IntFilter | number
    general_epub_status?: IntFilter | number
    pustaka_epub_status?: IntFilter | number
    amazon_epub_status?: IntFilter | number
    pustaka_flippdf_status?: IntFilter | number
    pustaka_word_status?: IntFilter | number
    priority?: StringFilter | string
    current_state?: IntNullableFilter | number | null
    remarks?: StringNullableFilter | string | null
  }

  export type books_metadataOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    description?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    final_page_number?: SortOrder
    allocated_date?: SortOrder
    start_date?: SortOrder
    completion_date?: SortOrder
    payment_date?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    general_file_path?: SortOrder
    url_title?: SortOrder
    unique_key?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    priority?: SortOrder
    current_state?: SortOrder
    remarks?: SortOrder
  }

  export type books_metadataWhereUniqueInput = {
    id?: number
  }

  export type books_metadataOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    description?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    final_page_number?: SortOrder
    allocated_date?: SortOrder
    start_date?: SortOrder
    completion_date?: SortOrder
    payment_date?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    general_file_path?: SortOrder
    url_title?: SortOrder
    unique_key?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    priority?: SortOrder
    current_state?: SortOrder
    remarks?: SortOrder
    _count?: books_metadataCountOrderByAggregateInput
    _avg?: books_metadataAvgOrderByAggregateInput
    _max?: books_metadataMaxOrderByAggregateInput
    _min?: books_metadataMinOrderByAggregateInput
    _sum?: books_metadataSumOrderByAggregateInput
  }

  export type books_metadataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<books_metadataScalarWhereWithAggregatesInput>
    OR?: Enumerable<books_metadataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<books_metadataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntWithAggregatesFilter | number
    description?: BoolWithAggregatesFilter | boolean
    type_of_book?: IntWithAggregatesFilter | number
    content_type?: StringWithAggregatesFilter | string
    hard_copy_type?: StringWithAggregatesFilter | string
    soft_copy_type?: StringWithAggregatesFilter | string
    final_page_number?: IntWithAggregatesFilter | number
    allocated_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    start_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    completion_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    payment_date?: DateTimeWithAggregatesFilter | Date | string
    settled_page_number?: IntWithAggregatesFilter | number
    payment_status?: IntWithAggregatesFilter | number
    assigned_by?: IntWithAggregatesFilter | number
    assigned_to?: IntWithAggregatesFilter | number
    price_per_page?: FloatWithAggregatesFilter | number
    initial_page_number?: IntNullableWithAggregatesFilter | number | null
    general_file_path?: StringWithAggregatesFilter | string
    url_title?: StringWithAggregatesFilter | string
    unique_key?: StringWithAggregatesFilter | string
    pustaka_cover_status?: IntWithAggregatesFilter | number
    general_cover_status?: IntWithAggregatesFilter | number
    general_epub_status?: IntWithAggregatesFilter | number
    pustaka_epub_status?: IntWithAggregatesFilter | number
    amazon_epub_status?: IntWithAggregatesFilter | number
    pustaka_flippdf_status?: IntWithAggregatesFilter | number
    pustaka_word_status?: IntWithAggregatesFilter | number
    priority?: StringWithAggregatesFilter | string
    current_state?: IntNullableWithAggregatesFilter | number | null
    remarks?: StringNullableWithAggregatesFilter | string | null
  }

  export type books_processingWhereInput = {
    AND?: Enumerable<books_processingWhereInput>
    OR?: Enumerable<books_processingWhereInput>
    NOT?: Enumerable<books_processingWhereInput>
    id?: IntFilter | number
    book_id?: IntNullableFilter | number | null
    stage_id?: IntNullableFilter | number | null
    type_of_book?: StringNullableFilter | string | null
    content_type?: StringNullableFilter | string | null
    hard_copy_type?: StringNullableFilter | string | null
    soft_copy_type?: StringNullableFilter | string | null
    initial_page_number?: IntNullableFilter | number | null
    pustaka_cover_status?: IntNullableFilter | number | null
    pustaka_epub_status?: IntNullableFilter | number | null
    pustaka_flippdf_status?: IntNullableFilter | number | null
    priority?: StringNullableFilter | string | null
    date_created?: DateTimeNullableFilter | Date | string | null
    completed?: IntNullableFilter | number | null
    rework?: IntNullableFilter | number | null
  }

  export type books_processingOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_processingWhereUniqueInput = {
    id?: number
  }

  export type books_processingOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
    _count?: books_processingCountOrderByAggregateInput
    _avg?: books_processingAvgOrderByAggregateInput
    _max?: books_processingMaxOrderByAggregateInput
    _min?: books_processingMinOrderByAggregateInput
    _sum?: books_processingSumOrderByAggregateInput
  }

  export type books_processingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<books_processingScalarWhereWithAggregatesInput>
    OR?: Enumerable<books_processingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<books_processingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntNullableWithAggregatesFilter | number | null
    stage_id?: IntNullableWithAggregatesFilter | number | null
    type_of_book?: StringNullableWithAggregatesFilter | string | null
    content_type?: StringNullableWithAggregatesFilter | string | null
    hard_copy_type?: StringNullableWithAggregatesFilter | string | null
    soft_copy_type?: StringNullableWithAggregatesFilter | string | null
    initial_page_number?: IntNullableWithAggregatesFilter | number | null
    pustaka_cover_status?: IntNullableWithAggregatesFilter | number | null
    pustaka_epub_status?: IntNullableWithAggregatesFilter | number | null
    pustaka_flippdf_status?: IntNullableWithAggregatesFilter | number | null
    priority?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    completed?: IntNullableWithAggregatesFilter | number | null
    rework?: IntNullableWithAggregatesFilter | number | null
  }

  export type books_progressWhereInput = {
    AND?: Enumerable<books_progressWhereInput>
    OR?: Enumerable<books_progressWhereInput>
    NOT?: Enumerable<books_progressWhereInput>
    id?: IntFilter | number
    book_id?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    stage?: IntNullableFilter | number | null
    startdate?: DateTimeNullableFilter | Date | string | null
    enddate?: DateTimeNullableFilter | Date | string | null
    on_hold_startdate?: DateTimeNullableFilter | Date | string | null
    on_hold_enddate?: DateTimeNullableFilter | Date | string | null
    remarks?: StringNullableFilter | string | null
  }

  export type books_progressOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
  }

  export type books_progressWhereUniqueInput = {
    id?: number
  }

  export type books_progressOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    _count?: books_progressCountOrderByAggregateInput
    _avg?: books_progressAvgOrderByAggregateInput
    _max?: books_progressMaxOrderByAggregateInput
    _min?: books_progressMinOrderByAggregateInput
    _sum?: books_progressSumOrderByAggregateInput
  }

  export type books_progressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<books_progressScalarWhereWithAggregatesInput>
    OR?: Enumerable<books_progressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<books_progressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
    stage?: IntNullableWithAggregatesFilter | number | null
    startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    on_hold_startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    on_hold_enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    remarks?: StringNullableWithAggregatesFilter | string | null
  }

  export type contact_usWhereInput = {
    AND?: Enumerable<contact_usWhereInput>
    OR?: Enumerable<contact_usWhereInput>
    NOT?: Enumerable<contact_usWhereInput>
    id?: IntFilter | number
    user_id?: IntNullableFilter | number | null
    subject?: StringNullableFilter | string | null
    message?: StringNullableFilter | string | null
    date_created?: DateTimeNullableFilter | Date | string | null
  }

  export type contact_usOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type contact_usWhereUniqueInput = {
    id?: number
  }

  export type contact_usOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
    _count?: contact_usCountOrderByAggregateInput
    _avg?: contact_usAvgOrderByAggregateInput
    _max?: contact_usMaxOrderByAggregateInput
    _min?: contact_usMinOrderByAggregateInput
    _sum?: contact_usSumOrderByAggregateInput
  }

  export type contact_usScalarWhereWithAggregatesInput = {
    AND?: Enumerable<contact_usScalarWhereWithAggregatesInput>
    OR?: Enumerable<contact_usScalarWhereWithAggregatesInput>
    NOT?: Enumerable<contact_usScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    subject?: StringNullableWithAggregatesFilter | string | null
    message?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type copyright_mappingWhereInput = {
    AND?: Enumerable<copyright_mappingWhereInput>
    OR?: Enumerable<copyright_mappingWhereInput>
    NOT?: Enumerable<copyright_mappingWhereInput>
    id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    author_id?: IntNullableFilter | number | null
    date_created?: DateTimeNullableFilter | Date | string | null
  }

  export type copyright_mappingOrderByWithRelationInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    date_created?: SortOrder
  }

  export type copyright_mappingWhereUniqueInput = {
    id?: number
  }

  export type copyright_mappingOrderByWithAggregationInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    date_created?: SortOrder
    _count?: copyright_mappingCountOrderByAggregateInput
    _avg?: copyright_mappingAvgOrderByAggregateInput
    _max?: copyright_mappingMaxOrderByAggregateInput
    _min?: copyright_mappingMinOrderByAggregateInput
    _sum?: copyright_mappingSumOrderByAggregateInput
  }

  export type copyright_mappingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<copyright_mappingScalarWhereWithAggregatesInput>
    OR?: Enumerable<copyright_mappingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<copyright_mappingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    author_id?: IntNullableWithAggregatesFilter | number | null
    date_created?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type episode_book_detailsWhereInput = {
    AND?: Enumerable<episode_book_detailsWhereInput>
    OR?: Enumerable<episode_book_detailsWhereInput>
    NOT?: Enumerable<episode_book_detailsWhereInput>
    id?: IntFilter | number
    episode_book_id?: IntNullableFilter | number | null
    chapter_name?: StringNullableFilter | string | null
    chapter_name_english?: StringNullableFilter | string | null
    chapter_epub_url?: StringNullableFilter | string | null
    chapter_num_pages?: IntNullableFilter | number | null
    chapter_status?: IntNullableFilter | number | null
    chapter_activated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type episode_book_detailsOrderByWithRelationInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_epub_url?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
    chapter_activated_at?: SortOrder
  }

  export type episode_book_detailsWhereUniqueInput = {
    id?: number
  }

  export type episode_book_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_epub_url?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
    chapter_activated_at?: SortOrder
    _count?: episode_book_detailsCountOrderByAggregateInput
    _avg?: episode_book_detailsAvgOrderByAggregateInput
    _max?: episode_book_detailsMaxOrderByAggregateInput
    _min?: episode_book_detailsMinOrderByAggregateInput
    _sum?: episode_book_detailsSumOrderByAggregateInput
  }

  export type episode_book_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<episode_book_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<episode_book_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<episode_book_detailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    episode_book_id?: IntNullableWithAggregatesFilter | number | null
    chapter_name?: StringNullableWithAggregatesFilter | string | null
    chapter_name_english?: StringNullableWithAggregatesFilter | string | null
    chapter_epub_url?: StringNullableWithAggregatesFilter | string | null
    chapter_num_pages?: IntNullableWithAggregatesFilter | number | null
    chapter_status?: IntNullableWithAggregatesFilter | number | null
    chapter_activated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type episode_book_tblWhereInput = {
    AND?: Enumerable<episode_book_tblWhereInput>
    OR?: Enumerable<episode_book_tblWhereInput>
    NOT?: Enumerable<episode_book_tblWhereInput>
    episode_book_id?: IntFilter | number
    book_title?: StringNullableFilter | string | null
    author_id?: IntNullableFilter | number | null
    url_name?: StringNullableFilter | string | null
    cover_image?: StringNullableFilter | string | null
    regional_book_title?: StringNullableFilter | string | null
    language?: IntNullableFilter | number | null
    type_of_book?: IntNullableFilter | number | null
    genre_id?: IntNullableFilter | number | null
    book_category?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    status?: IntNullableFilter | number | null
    day_of_chapter?: StringNullableFilter | string | null
    activated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type episode_book_tblOrderByWithRelationInput = {
    episode_book_id?: SortOrder
    book_title?: SortOrder
    author_id?: SortOrder
    url_name?: SortOrder
    cover_image?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    day_of_chapter?: SortOrder
    activated_at?: SortOrder
  }

  export type episode_book_tblWhereUniqueInput = {
    episode_book_id?: number
  }

  export type episode_book_tblOrderByWithAggregationInput = {
    episode_book_id?: SortOrder
    book_title?: SortOrder
    author_id?: SortOrder
    url_name?: SortOrder
    cover_image?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    day_of_chapter?: SortOrder
    activated_at?: SortOrder
    _count?: episode_book_tblCountOrderByAggregateInput
    _avg?: episode_book_tblAvgOrderByAggregateInput
    _max?: episode_book_tblMaxOrderByAggregateInput
    _min?: episode_book_tblMinOrderByAggregateInput
    _sum?: episode_book_tblSumOrderByAggregateInput
  }

  export type episode_book_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<episode_book_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<episode_book_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<episode_book_tblScalarWhereWithAggregatesInput>
    episode_book_id?: IntWithAggregatesFilter | number
    book_title?: StringNullableWithAggregatesFilter | string | null
    author_id?: IntNullableWithAggregatesFilter | number | null
    url_name?: StringNullableWithAggregatesFilter | string | null
    cover_image?: StringNullableWithAggregatesFilter | string | null
    regional_book_title?: StringNullableWithAggregatesFilter | string | null
    language?: IntNullableWithAggregatesFilter | number | null
    type_of_book?: IntNullableWithAggregatesFilter | number | null
    genre_id?: IntNullableWithAggregatesFilter | number | null
    book_category?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    status?: IntNullableWithAggregatesFilter | number | null
    day_of_chapter?: StringNullableWithAggregatesFilter | string | null
    activated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type fixed_royaltyWhereInput = {
    AND?: Enumerable<fixed_royaltyWhereInput>
    OR?: Enumerable<fixed_royaltyWhereInput>
    NOT?: Enumerable<fixed_royaltyWhereInput>
    id?: IntFilter | number
    transaction_date?: DateTimeNullableFilter | Date | string | null
    user_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    fixed_royalty_value?: IntNullableFilter | number | null
    author_id?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
  }

  export type fixed_royaltyOrderByWithRelationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltyWhereUniqueInput = {
    id?: number
  }

  export type fixed_royaltyOrderByWithAggregationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
    _count?: fixed_royaltyCountOrderByAggregateInput
    _avg?: fixed_royaltyAvgOrderByAggregateInput
    _max?: fixed_royaltyMaxOrderByAggregateInput
    _min?: fixed_royaltyMinOrderByAggregateInput
    _sum?: fixed_royaltySumOrderByAggregateInput
  }

  export type fixed_royaltyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fixed_royaltyScalarWhereWithAggregatesInput>
    OR?: Enumerable<fixed_royaltyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fixed_royaltyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    transaction_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    fixed_royalty_value?: IntNullableWithAggregatesFilter | number | null
    author_id?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
  }

  export type free_book_subscriptionWhereInput = {
    AND?: Enumerable<free_book_subscriptionWhereInput>
    OR?: Enumerable<free_book_subscriptionWhereInput>
    NOT?: Enumerable<free_book_subscriptionWhereInput>
    seq_id?: IntFilter | number
    user_id?: BigIntFilter | bigint | number
    book_id?: BigIntFilter | bigint | number
    date_subscribed?: DateTimeFilter | Date | string
    comments?: StringFilter | string
  }

  export type free_book_subscriptionOrderByWithRelationInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_subscribed?: SortOrder
    comments?: SortOrder
  }

  export type free_book_subscriptionWhereUniqueInput = {
    seq_id?: number
  }

  export type free_book_subscriptionOrderByWithAggregationInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_subscribed?: SortOrder
    comments?: SortOrder
    _count?: free_book_subscriptionCountOrderByAggregateInput
    _avg?: free_book_subscriptionAvgOrderByAggregateInput
    _max?: free_book_subscriptionMaxOrderByAggregateInput
    _min?: free_book_subscriptionMinOrderByAggregateInput
    _sum?: free_book_subscriptionSumOrderByAggregateInput
  }

  export type free_book_subscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<free_book_subscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<free_book_subscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<free_book_subscriptionScalarWhereWithAggregatesInput>
    seq_id?: IntWithAggregatesFilter | number
    user_id?: BigIntWithAggregatesFilter | bigint | number
    book_id?: BigIntWithAggregatesFilter | bigint | number
    date_subscribed?: DateTimeWithAggregatesFilter | Date | string
    comments?: StringWithAggregatesFilter | string
  }

  export type genre_details_tblWhereInput = {
    AND?: Enumerable<genre_details_tblWhereInput>
    OR?: Enumerable<genre_details_tblWhereInput>
    NOT?: Enumerable<genre_details_tblWhereInput>
    genre_id?: IntFilter | number
    admin_id?: IntFilter | number
    genre_name?: StringFilter | string
    url_name?: StringFilter | string
    lang_0?: StringNullableFilter | string | null
    lang_1?: StringFilter | string
    lang_2?: StringFilter | string
    lang_3?: StringFilter | string
    lang_4?: StringFilter | string
    lang_5?: StringNullableFilter | string | null
    status?: IntFilter | number
    bisac_code?: StringNullableFilter | string | null
    image_url?: StringNullableFilter | string | null
    books?: Book_tblListRelationFilter
  }

  export type genre_details_tblOrderByWithRelationInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    genre_name?: SortOrder
    url_name?: SortOrder
    lang_0?: SortOrder
    lang_1?: SortOrder
    lang_2?: SortOrder
    lang_3?: SortOrder
    lang_4?: SortOrder
    lang_5?: SortOrder
    status?: SortOrder
    bisac_code?: SortOrder
    image_url?: SortOrder
    books?: book_tblOrderByRelationAggregateInput
  }

  export type genre_details_tblWhereUniqueInput = {
    genre_id?: number
  }

  export type genre_details_tblOrderByWithAggregationInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    genre_name?: SortOrder
    url_name?: SortOrder
    lang_0?: SortOrder
    lang_1?: SortOrder
    lang_2?: SortOrder
    lang_3?: SortOrder
    lang_4?: SortOrder
    lang_5?: SortOrder
    status?: SortOrder
    bisac_code?: SortOrder
    image_url?: SortOrder
    _count?: genre_details_tblCountOrderByAggregateInput
    _avg?: genre_details_tblAvgOrderByAggregateInput
    _max?: genre_details_tblMaxOrderByAggregateInput
    _min?: genre_details_tblMinOrderByAggregateInput
    _sum?: genre_details_tblSumOrderByAggregateInput
  }

  export type genre_details_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<genre_details_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<genre_details_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<genre_details_tblScalarWhereWithAggregatesInput>
    genre_id?: IntWithAggregatesFilter | number
    admin_id?: IntWithAggregatesFilter | number
    genre_name?: StringWithAggregatesFilter | string
    url_name?: StringWithAggregatesFilter | string
    lang_0?: StringNullableWithAggregatesFilter | string | null
    lang_1?: StringWithAggregatesFilter | string
    lang_2?: StringWithAggregatesFilter | string
    lang_3?: StringWithAggregatesFilter | string
    lang_4?: StringWithAggregatesFilter | string
    lang_5?: StringNullableWithAggregatesFilter | string | null
    status?: IntWithAggregatesFilter | number
    bisac_code?: StringNullableWithAggregatesFilter | string | null
    image_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type google_booksWhereInput = {
    AND?: Enumerable<google_booksWhereInput>
    OR?: Enumerable<google_booksWhereInput>
    NOT?: Enumerable<google_booksWhereInput>
    id?: IntFilter | number
    identifier?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    label?: StringNullableFilter | string | null
    play_store_link?: StringNullableFilter | string | null
    enable_for_sale?: BoolNullableFilter | boolean | null
    title?: StringNullableFilter | string | null
    subtitle?: StringNullableFilter | string | null
    book_format?: StringNullableFilter | string | null
    related_identifier?: StringNullableFilter | string | null
    contributor?: StringNullableFilter | string | null
    biographical_note?: StringNullableFilter | string | null
    language?: StringNullableFilter | string | null
    subject_code?: StringNullableFilter | string | null
    age_group?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    publication_date?: StringNullableFilter | string | null
    page_count?: IntNullableFilter | number | null
    series_name?: StringNullableFilter | string | null
    volume_in_series?: IntNullableFilter | number | null
    preview_type?: StringNullableFilter | string | null
    preview_territories?: StringNullableFilter | string | null
    buy_link_text?: StringNullableFilter | string | null
    buy_link?: StringNullableFilter | string | null
    publisher_name?: StringNullableFilter | string | null
    publisher_website?: StringNullableFilter | string | null
    show_photos_preview?: BoolNullableFilter | boolean | null
    pdf_download?: BoolNullableFilter | boolean | null
    on_sale_date?: StringNullableFilter | string | null
    drm_enabled?: BoolNullableFilter | boolean | null
    show_photos_ebook?: BoolNullableFilter | boolean | null
    include_scanned_pages?: BoolNullableFilter | boolean | null
    mature_audiences?: BoolNullableFilter | boolean | null
    copy_paste_percentage?: StringNullableFilter | string | null
    enable_school_use?: BoolNullableFilter | boolean | null
    school_list_price_60?: FloatNullableFilter | number | null
    school_list_price_180?: FloatNullableFilter | number | null
    school_list_price_360?: FloatNullableFilter | number | null
    school_use_countries?: StringNullableFilter | string | null
    duration?: DateTimeNullableFilter | Date | string | null
    preview_length_minutes?: IntNullableFilter | number | null
    preview_length_percentage?: IntNullableFilter | number | null
    abridged_version?: StringNullableFilter | string | null
    inr_price_including_tax?: FloatNullableFilter | number | null
    inr_countries_including_tax?: StringNullableFilter | string | null
    usd_price_including_tax?: FloatNullableFilter | number | null
    usd_countries_including_tax?: StringNullableFilter | string | null
    inr_price_excluding_tax?: FloatNullableFilter | number | null
    inr_countries_excluding_tax?: StringNullableFilter | string | null
    usd_price_excluding_tax?: FloatNullableFilter | number | null
    usd_countries_excluding_tax?: StringNullableFilter | string | null
    eur_price_including_tax?: IntNullableFilter | number | null
    eur_price_excluding_tax?: IntNullableFilter | number | null
    eur_countries_including_tax?: StringNullableFilter | string | null
    eur_countries_excluding_tax?: StringNullableFilter | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntNullableFilter | number | null
    publish_date?: DateTimeNullableFilter | Date | string | null
  }

  export type google_booksOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    status?: SortOrder
    label?: SortOrder
    play_store_link?: SortOrder
    enable_for_sale?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    book_format?: SortOrder
    related_identifier?: SortOrder
    contributor?: SortOrder
    biographical_note?: SortOrder
    language?: SortOrder
    subject_code?: SortOrder
    age_group?: SortOrder
    description?: SortOrder
    publication_date?: SortOrder
    page_count?: SortOrder
    series_name?: SortOrder
    volume_in_series?: SortOrder
    preview_type?: SortOrder
    preview_territories?: SortOrder
    buy_link_text?: SortOrder
    buy_link?: SortOrder
    publisher_name?: SortOrder
    publisher_website?: SortOrder
    show_photos_preview?: SortOrder
    pdf_download?: SortOrder
    on_sale_date?: SortOrder
    drm_enabled?: SortOrder
    show_photos_ebook?: SortOrder
    include_scanned_pages?: SortOrder
    mature_audiences?: SortOrder
    copy_paste_percentage?: SortOrder
    enable_school_use?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    school_use_countries?: SortOrder
    duration?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    abridged_version?: SortOrder
    inr_price_including_tax?: SortOrder
    inr_countries_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    usd_countries_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    inr_countries_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    usd_countries_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    eur_countries_including_tax?: SortOrder
    eur_countries_excluding_tax?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    publish_date?: SortOrder
  }

  export type google_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type google_booksOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    status?: SortOrder
    label?: SortOrder
    play_store_link?: SortOrder
    enable_for_sale?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    book_format?: SortOrder
    related_identifier?: SortOrder
    contributor?: SortOrder
    biographical_note?: SortOrder
    language?: SortOrder
    subject_code?: SortOrder
    age_group?: SortOrder
    description?: SortOrder
    publication_date?: SortOrder
    page_count?: SortOrder
    series_name?: SortOrder
    volume_in_series?: SortOrder
    preview_type?: SortOrder
    preview_territories?: SortOrder
    buy_link_text?: SortOrder
    buy_link?: SortOrder
    publisher_name?: SortOrder
    publisher_website?: SortOrder
    show_photos_preview?: SortOrder
    pdf_download?: SortOrder
    on_sale_date?: SortOrder
    drm_enabled?: SortOrder
    show_photos_ebook?: SortOrder
    include_scanned_pages?: SortOrder
    mature_audiences?: SortOrder
    copy_paste_percentage?: SortOrder
    enable_school_use?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    school_use_countries?: SortOrder
    duration?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    abridged_version?: SortOrder
    inr_price_including_tax?: SortOrder
    inr_countries_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    usd_countries_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    inr_countries_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    usd_countries_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    eur_countries_including_tax?: SortOrder
    eur_countries_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    publish_date?: SortOrder
    _count?: google_booksCountOrderByAggregateInput
    _avg?: google_booksAvgOrderByAggregateInput
    _max?: google_booksMaxOrderByAggregateInput
    _min?: google_booksMinOrderByAggregateInput
    _sum?: google_booksSumOrderByAggregateInput
  }

  export type google_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<google_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<google_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<google_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    identifier?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    label?: StringNullableWithAggregatesFilter | string | null
    play_store_link?: StringNullableWithAggregatesFilter | string | null
    enable_for_sale?: BoolNullableWithAggregatesFilter | boolean | null
    title?: StringNullableWithAggregatesFilter | string | null
    subtitle?: StringNullableWithAggregatesFilter | string | null
    book_format?: StringNullableWithAggregatesFilter | string | null
    related_identifier?: StringNullableWithAggregatesFilter | string | null
    contributor?: StringNullableWithAggregatesFilter | string | null
    biographical_note?: StringNullableWithAggregatesFilter | string | null
    language?: StringNullableWithAggregatesFilter | string | null
    subject_code?: StringNullableWithAggregatesFilter | string | null
    age_group?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    publication_date?: StringNullableWithAggregatesFilter | string | null
    page_count?: IntNullableWithAggregatesFilter | number | null
    series_name?: StringNullableWithAggregatesFilter | string | null
    volume_in_series?: IntNullableWithAggregatesFilter | number | null
    preview_type?: StringNullableWithAggregatesFilter | string | null
    preview_territories?: StringNullableWithAggregatesFilter | string | null
    buy_link_text?: StringNullableWithAggregatesFilter | string | null
    buy_link?: StringNullableWithAggregatesFilter | string | null
    publisher_name?: StringNullableWithAggregatesFilter | string | null
    publisher_website?: StringNullableWithAggregatesFilter | string | null
    show_photos_preview?: BoolNullableWithAggregatesFilter | boolean | null
    pdf_download?: BoolNullableWithAggregatesFilter | boolean | null
    on_sale_date?: StringNullableWithAggregatesFilter | string | null
    drm_enabled?: BoolNullableWithAggregatesFilter | boolean | null
    show_photos_ebook?: BoolNullableWithAggregatesFilter | boolean | null
    include_scanned_pages?: BoolNullableWithAggregatesFilter | boolean | null
    mature_audiences?: BoolNullableWithAggregatesFilter | boolean | null
    copy_paste_percentage?: StringNullableWithAggregatesFilter | string | null
    enable_school_use?: BoolNullableWithAggregatesFilter | boolean | null
    school_list_price_60?: FloatNullableWithAggregatesFilter | number | null
    school_list_price_180?: FloatNullableWithAggregatesFilter | number | null
    school_list_price_360?: FloatNullableWithAggregatesFilter | number | null
    school_use_countries?: StringNullableWithAggregatesFilter | string | null
    duration?: DateTimeNullableWithAggregatesFilter | Date | string | null
    preview_length_minutes?: IntNullableWithAggregatesFilter | number | null
    preview_length_percentage?: IntNullableWithAggregatesFilter | number | null
    abridged_version?: StringNullableWithAggregatesFilter | string | null
    inr_price_including_tax?: FloatNullableWithAggregatesFilter | number | null
    inr_countries_including_tax?: StringNullableWithAggregatesFilter | string | null
    usd_price_including_tax?: FloatNullableWithAggregatesFilter | number | null
    usd_countries_including_tax?: StringNullableWithAggregatesFilter | string | null
    inr_price_excluding_tax?: FloatNullableWithAggregatesFilter | number | null
    inr_countries_excluding_tax?: StringNullableWithAggregatesFilter | string | null
    usd_price_excluding_tax?: FloatNullableWithAggregatesFilter | number | null
    usd_countries_excluding_tax?: StringNullableWithAggregatesFilter | string | null
    eur_price_including_tax?: IntNullableWithAggregatesFilter | number | null
    eur_price_excluding_tax?: IntNullableWithAggregatesFilter | number | null
    eur_countries_including_tax?: StringNullableWithAggregatesFilter | string | null
    eur_countries_excluding_tax?: StringNullableWithAggregatesFilter | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    publish_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type google_transactionsWhereInput = {
    AND?: Enumerable<google_transactionsWhereInput>
    OR?: Enumerable<google_transactionsWhereInput>
    NOT?: Enumerable<google_transactionsWhereInput>
    id?: IntFilter | number
    earnings_date?: DateTimeFilter | Date | string
    transaction_date?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    product?: StringFilter | string
    type?: StringFilter | string
    preorder?: StringFilter | string
    qty?: IntFilter | number
    primary_isbn?: StringFilter | string
    imprint_name?: StringFilter | string
    title?: StringFilter | string
    author?: StringFilter | string
    original_list_price_currency?: StringFilter | string
    original_list_price?: FloatFilter | number
    list_price_currency?: StringFilter | string
    list_price_tax_inclusive?: FloatFilter | number
    list_price_tax_exclusive?: FloatFilter | number
    country_of_sale?: StringFilter | string
    publisher_revenue_percentage?: StringFilter | string
    publisher_revenue?: FloatFilter | number
    earnings_currency?: StringFilter | string
    earnings_amount?: FloatFilter | number
    currency_conversion_rate?: FloatFilter | number
    line_of_business?: StringFilter | string
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    language_id?: IntFilter | number
    currency_exchange?: FloatFilter | number
    inr_value?: FloatFilter | number
    final_royalty_value?: FloatFilter | number
    user_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
  }

  export type google_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    earnings_date?: SortOrder
    transaction_date?: SortOrder
    unique_id?: SortOrder
    product?: SortOrder
    type?: SortOrder
    preorder?: SortOrder
    qty?: SortOrder
    primary_isbn?: SortOrder
    imprint_name?: SortOrder
    title?: SortOrder
    author?: SortOrder
    original_list_price_currency?: SortOrder
    original_list_price?: SortOrder
    list_price_currency?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    country_of_sale?: SortOrder
    publisher_revenue_percentage?: SortOrder
    publisher_revenue?: SortOrder
    earnings_currency?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    line_of_business?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type google_transactionsWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type google_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    earnings_date?: SortOrder
    transaction_date?: SortOrder
    unique_id?: SortOrder
    product?: SortOrder
    type?: SortOrder
    preorder?: SortOrder
    qty?: SortOrder
    primary_isbn?: SortOrder
    imprint_name?: SortOrder
    title?: SortOrder
    author?: SortOrder
    original_list_price_currency?: SortOrder
    original_list_price?: SortOrder
    list_price_currency?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    country_of_sale?: SortOrder
    publisher_revenue_percentage?: SortOrder
    publisher_revenue?: SortOrder
    earnings_currency?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    line_of_business?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    _count?: google_transactionsCountOrderByAggregateInput
    _avg?: google_transactionsAvgOrderByAggregateInput
    _max?: google_transactionsMaxOrderByAggregateInput
    _min?: google_transactionsMinOrderByAggregateInput
    _sum?: google_transactionsSumOrderByAggregateInput
  }

  export type google_transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<google_transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<google_transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<google_transactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    earnings_date?: DateTimeWithAggregatesFilter | Date | string
    transaction_date?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    product?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    preorder?: StringWithAggregatesFilter | string
    qty?: IntWithAggregatesFilter | number
    primary_isbn?: StringWithAggregatesFilter | string
    imprint_name?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    author?: StringWithAggregatesFilter | string
    original_list_price_currency?: StringWithAggregatesFilter | string
    original_list_price?: FloatWithAggregatesFilter | number
    list_price_currency?: StringWithAggregatesFilter | string
    list_price_tax_inclusive?: FloatWithAggregatesFilter | number
    list_price_tax_exclusive?: FloatWithAggregatesFilter | number
    country_of_sale?: StringWithAggregatesFilter | string
    publisher_revenue_percentage?: StringWithAggregatesFilter | string
    publisher_revenue?: FloatWithAggregatesFilter | number
    earnings_currency?: StringWithAggregatesFilter | string
    earnings_amount?: FloatWithAggregatesFilter | number
    currency_conversion_rate?: FloatWithAggregatesFilter | number
    line_of_business?: StringWithAggregatesFilter | string
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    language_id?: IntWithAggregatesFilter | number
    currency_exchange?: FloatWithAggregatesFilter | number
    inr_value?: FloatWithAggregatesFilter | number
    final_royalty_value?: FloatWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
  }

  export type kobo_transactionWhereInput = {
    AND?: Enumerable<kobo_transactionWhereInput>
    OR?: Enumerable<kobo_transactionWhereInput>
    NOT?: Enumerable<kobo_transactionWhereInput>
    id?: IntFilter | number
    transaction_date?: DateTimeFilter | Date | string
    country?: StringFilter | string
    state?: StringNullableFilter | string | null
    zipcode?: StringNullableFilter | string | null
    content_type?: StringNullableFilter | string | null
    quantity?: IntNullableFilter | number | null
    refund_reason?: StringNullableFilter | string | null
    dealID?: StringNullableFilter | string | null
    publisher_name?: StringNullableFilter | string | null
    imprint?: StringNullableFilter | string | null
    eISBN?: StringFilter | string
    author_name?: StringFilter | string
    book_title?: StringFilter | string
    list_price?: IntFilter | number
    tax_excluded?: FloatNullableFilter | number | null
    COGS_percentage?: FloatFilter | number
    COGS_amount?: FloatNullableFilter | number | null
    list_price_currency?: StringFilter | string
    foreign_exchange?: FloatFilter | number
    COGS_payable?: FloatFilter | number
    COGS_based_lp?: FloatNullableFilter | number | null
    COGS_based_lp_excluded_tax?: FloatNullableFilter | number | null
    COGS_based_lp_currency?: FloatNullableFilter | number | null
    COGS_adjustment?: FloatNullableFilter | number | null
    net_due?: FloatFilter | number
    payable_currency?: StringFilter | string
    total_tax?: FloatNullableFilter | number | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    paid_inr?: FloatFilter | number
    user_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    status?: StringFilter | string
  }

  export type kobo_transactionOrderByWithRelationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    country?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    content_type?: SortOrder
    quantity?: SortOrder
    refund_reason?: SortOrder
    dealID?: SortOrder
    publisher_name?: SortOrder
    imprint?: SortOrder
    eISBN?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    list_price_currency?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    payable_currency?: SortOrder
    total_tax?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type kobo_transactionWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type kobo_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    country?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    content_type?: SortOrder
    quantity?: SortOrder
    refund_reason?: SortOrder
    dealID?: SortOrder
    publisher_name?: SortOrder
    imprint?: SortOrder
    eISBN?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    list_price_currency?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    payable_currency?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    _count?: kobo_transactionCountOrderByAggregateInput
    _avg?: kobo_transactionAvgOrderByAggregateInput
    _max?: kobo_transactionMaxOrderByAggregateInput
    _min?: kobo_transactionMinOrderByAggregateInput
    _sum?: kobo_transactionSumOrderByAggregateInput
  }

  export type kobo_transactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<kobo_transactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<kobo_transactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<kobo_transactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    transaction_date?: DateTimeWithAggregatesFilter | Date | string
    country?: StringWithAggregatesFilter | string
    state?: StringNullableWithAggregatesFilter | string | null
    zipcode?: StringNullableWithAggregatesFilter | string | null
    content_type?: StringNullableWithAggregatesFilter | string | null
    quantity?: IntNullableWithAggregatesFilter | number | null
    refund_reason?: StringNullableWithAggregatesFilter | string | null
    dealID?: StringNullableWithAggregatesFilter | string | null
    publisher_name?: StringNullableWithAggregatesFilter | string | null
    imprint?: StringNullableWithAggregatesFilter | string | null
    eISBN?: StringWithAggregatesFilter | string
    author_name?: StringWithAggregatesFilter | string
    book_title?: StringWithAggregatesFilter | string
    list_price?: IntWithAggregatesFilter | number
    tax_excluded?: FloatNullableWithAggregatesFilter | number | null
    COGS_percentage?: FloatWithAggregatesFilter | number
    COGS_amount?: FloatNullableWithAggregatesFilter | number | null
    list_price_currency?: StringWithAggregatesFilter | string
    foreign_exchange?: FloatWithAggregatesFilter | number
    COGS_payable?: FloatWithAggregatesFilter | number
    COGS_based_lp?: FloatNullableWithAggregatesFilter | number | null
    COGS_based_lp_excluded_tax?: FloatNullableWithAggregatesFilter | number | null
    COGS_based_lp_currency?: FloatNullableWithAggregatesFilter | number | null
    COGS_adjustment?: FloatNullableWithAggregatesFilter | number | null
    net_due?: FloatWithAggregatesFilter | number
    payable_currency?: StringWithAggregatesFilter | string
    total_tax?: FloatNullableWithAggregatesFilter | number | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    paid_inr?: FloatWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
  }

  export type language_tblWhereInput = {
    AND?: Enumerable<language_tblWhereInput>
    OR?: Enumerable<language_tblWhereInput>
    NOT?: Enumerable<language_tblWhereInput>
    language_id?: IntFilter | number
    admin_id?: IntFilter | number
    language_name?: StringFilter | string
    regional_language_name?: StringFilter | string
    url_name?: StringNullableFilter | string | null
    image_url?: StringNullableFilter | string | null
    status?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    books?: Book_tblListRelationFilter
    authorLanguages?: Author_languageListRelationFilter
  }

  export type language_tblOrderByWithRelationInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    language_name?: SortOrder
    regional_language_name?: SortOrder
    url_name?: SortOrder
    image_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    books?: book_tblOrderByRelationAggregateInput
    authorLanguages?: author_languageOrderByRelationAggregateInput
  }

  export type language_tblWhereUniqueInput = {
    language_id?: number
  }

  export type language_tblOrderByWithAggregationInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    language_name?: SortOrder
    regional_language_name?: SortOrder
    url_name?: SortOrder
    image_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: language_tblCountOrderByAggregateInput
    _avg?: language_tblAvgOrderByAggregateInput
    _max?: language_tblMaxOrderByAggregateInput
    _min?: language_tblMinOrderByAggregateInput
    _sum?: language_tblSumOrderByAggregateInput
  }

  export type language_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<language_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<language_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<language_tblScalarWhereWithAggregatesInput>
    language_id?: IntWithAggregatesFilter | number
    admin_id?: IntWithAggregatesFilter | number
    language_name?: StringWithAggregatesFilter | string
    regional_language_name?: StringWithAggregatesFilter | string
    url_name?: StringNullableWithAggregatesFilter | string | null
    image_url?: StringNullableWithAggregatesFilter | string | null
    status?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ledger_head_tblWhereInput = {
    AND?: Enumerable<ledger_head_tblWhereInput>
    OR?: Enumerable<ledger_head_tblWhereInput>
    NOT?: Enumerable<ledger_head_tblWhereInput>
    id?: IntFilter | number
    ledger_head_name?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type ledger_head_tblOrderByWithRelationInput = {
    id?: SortOrder
    ledger_head_name?: SortOrder
    date_created?: SortOrder
  }

  export type ledger_head_tblWhereUniqueInput = {
    id?: number
  }

  export type ledger_head_tblOrderByWithAggregationInput = {
    id?: SortOrder
    ledger_head_name?: SortOrder
    date_created?: SortOrder
    _count?: ledger_head_tblCountOrderByAggregateInput
    _avg?: ledger_head_tblAvgOrderByAggregateInput
    _max?: ledger_head_tblMaxOrderByAggregateInput
    _min?: ledger_head_tblMinOrderByAggregateInput
    _sum?: ledger_head_tblSumOrderByAggregateInput
  }

  export type ledger_head_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ledger_head_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<ledger_head_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ledger_head_tblScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ledger_head_name?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type narrator_tblWhereInput = {
    AND?: Enumerable<narrator_tblWhereInput>
    OR?: Enumerable<narrator_tblWhereInput>
    NOT?: Enumerable<narrator_tblWhereInput>
    narrator_id?: IntFilter | number
    narrator_name?: StringNullableFilter | string | null
    narrator_url?: StringNullableFilter | string | null
    narrator_image?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    status?: IntNullableFilter | number | null
    user_id?: IntNullableFilter | number | null
    image_alt_text?: StringNullableFilter | string | null
    image_title_text?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
  }

  export type narrator_tblOrderByWithRelationInput = {
    narrator_id?: SortOrder
    narrator_name?: SortOrder
    narrator_url?: SortOrder
    narrator_image?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    image_alt_text?: SortOrder
    image_title_text?: SortOrder
    created_at?: SortOrder
  }

  export type narrator_tblWhereUniqueInput = {
    narrator_id?: number
  }

  export type narrator_tblOrderByWithAggregationInput = {
    narrator_id?: SortOrder
    narrator_name?: SortOrder
    narrator_url?: SortOrder
    narrator_image?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    image_alt_text?: SortOrder
    image_title_text?: SortOrder
    created_at?: SortOrder
    _count?: narrator_tblCountOrderByAggregateInput
    _avg?: narrator_tblAvgOrderByAggregateInput
    _max?: narrator_tblMaxOrderByAggregateInput
    _min?: narrator_tblMinOrderByAggregateInput
    _sum?: narrator_tblSumOrderByAggregateInput
  }

  export type narrator_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<narrator_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<narrator_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<narrator_tblScalarWhereWithAggregatesInput>
    narrator_id?: IntWithAggregatesFilter | number
    narrator_name?: StringNullableWithAggregatesFilter | string | null
    narrator_url?: StringNullableWithAggregatesFilter | string | null
    narrator_image?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    status?: IntNullableWithAggregatesFilter | number | null
    user_id?: IntNullableWithAggregatesFilter | number | null
    image_alt_text?: StringNullableWithAggregatesFilter | string | null
    image_title_text?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type offline_paymentWhereInput = {
    AND?: Enumerable<offline_paymentWhereInput>
    OR?: Enumerable<offline_paymentWhereInput>
    NOT?: Enumerable<offline_paymentWhereInput>
    id?: IntFilter | number
    cart_type?: IntFilter | number
    cart_items?: StringFilter | string
    user_id?: IntFilter | number
    amount?: IntFilter | number
    currency?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    status?: IntFilter | number
  }

  export type offline_paymentOrderByWithRelationInput = {
    id?: SortOrder
    cart_type?: SortOrder
    cart_items?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date_created?: SortOrder
    status?: SortOrder
  }

  export type offline_paymentWhereUniqueInput = {
    id?: number
  }

  export type offline_paymentOrderByWithAggregationInput = {
    id?: SortOrder
    cart_type?: SortOrder
    cart_items?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date_created?: SortOrder
    status?: SortOrder
    _count?: offline_paymentCountOrderByAggregateInput
    _avg?: offline_paymentAvgOrderByAggregateInput
    _max?: offline_paymentMaxOrderByAggregateInput
    _min?: offline_paymentMinOrderByAggregateInput
    _sum?: offline_paymentSumOrderByAggregateInput
  }

  export type offline_paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<offline_paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<offline_paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<offline_paymentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cart_type?: IntWithAggregatesFilter | number
    cart_items?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
    amount?: IntWithAggregatesFilter | number
    currency?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
    status?: IntWithAggregatesFilter | number
  }

  export type orderWhereInput = {
    AND?: Enumerable<orderWhereInput>
    OR?: Enumerable<orderWhereInput>
    NOT?: Enumerable<orderWhereInput>
    id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
    tracking_id?: StringFilter | string
    bank_ref_no?: IntFilter | number
    order_status?: StringFilter | string
    failure_message?: StringNullableFilter | string | null
    payment_mode?: StringNullableFilter | string | null
    card_name?: StringNullableFilter | string | null
    status_code?: StringNullableFilter | string | null
    status_message?: StringNullableFilter | string | null
    currency?: StringFilter | string
    amount?: FloatFilter | number
    channel?: StringNullableFilter | string | null
    billing_name?: StringNullableFilter | string | null
    billing_address?: StringNullableFilter | string | null
    billing_city?: StringNullableFilter | string | null
    billing_state?: StringNullableFilter | string | null
    billing_zip?: StringNullableFilter | string | null
    billing_country?: StringNullableFilter | string | null
    billing_tel?: StringNullableFilter | string | null
    billing_email?: StringNullableFilter | string | null
    delivery_name?: StringNullableFilter | string | null
    delivery_address?: StringNullableFilter | string | null
    delivery_city?: StringNullableFilter | string | null
    delivery_state?: StringNullableFilter | string | null
    delivery_zip?: StringNullableFilter | string | null
    delivery_country?: StringNullableFilter | string | null
    delivery_tel?: StringNullableFilter | string | null
    user_id?: IntFilter | number
    cart_type?: StringFilter | string
    subtotal?: FloatFilter | number
    service_tax?: FloatFilter | number
    net_revenue?: FloatNullableFilter | number | null
    net_total?: FloatFilter | number
    date_created?: DateTimeFilter | Date | string
    coupon_id?: StringNullableFilter | string | null
    coupon_discount_amt?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    tracking_id?: SortOrder
    bank_ref_no?: SortOrder
    order_status?: SortOrder
    failure_message?: SortOrder
    payment_mode?: SortOrder
    card_name?: SortOrder
    status_code?: SortOrder
    status_message?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    billing_name?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    billing_tel?: SortOrder
    billing_email?: SortOrder
    delivery_name?: SortOrder
    delivery_address?: SortOrder
    delivery_city?: SortOrder
    delivery_state?: SortOrder
    delivery_zip?: SortOrder
    delivery_country?: SortOrder
    delivery_tel?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    date_created?: SortOrder
    coupon_id?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type orderWhereUniqueInput = {
    id?: number
  }

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    tracking_id?: SortOrder
    bank_ref_no?: SortOrder
    order_status?: SortOrder
    failure_message?: SortOrder
    payment_mode?: SortOrder
    card_name?: SortOrder
    status_code?: SortOrder
    status_message?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    billing_name?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    billing_tel?: SortOrder
    billing_email?: SortOrder
    delivery_name?: SortOrder
    delivery_address?: SortOrder
    delivery_city?: SortOrder
    delivery_state?: SortOrder
    delivery_zip?: SortOrder
    delivery_country?: SortOrder
    delivery_tel?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    date_created?: SortOrder
    coupon_id?: SortOrder
    coupon_discount_amt?: SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<orderScalarWhereWithAggregatesInput>
    OR?: Enumerable<orderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<orderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
    tracking_id?: StringWithAggregatesFilter | string
    bank_ref_no?: IntWithAggregatesFilter | number
    order_status?: StringWithAggregatesFilter | string
    failure_message?: StringNullableWithAggregatesFilter | string | null
    payment_mode?: StringNullableWithAggregatesFilter | string | null
    card_name?: StringNullableWithAggregatesFilter | string | null
    status_code?: StringNullableWithAggregatesFilter | string | null
    status_message?: StringNullableWithAggregatesFilter | string | null
    currency?: StringWithAggregatesFilter | string
    amount?: FloatWithAggregatesFilter | number
    channel?: StringNullableWithAggregatesFilter | string | null
    billing_name?: StringNullableWithAggregatesFilter | string | null
    billing_address?: StringNullableWithAggregatesFilter | string | null
    billing_city?: StringNullableWithAggregatesFilter | string | null
    billing_state?: StringNullableWithAggregatesFilter | string | null
    billing_zip?: StringNullableWithAggregatesFilter | string | null
    billing_country?: StringNullableWithAggregatesFilter | string | null
    billing_tel?: StringNullableWithAggregatesFilter | string | null
    billing_email?: StringNullableWithAggregatesFilter | string | null
    delivery_name?: StringNullableWithAggregatesFilter | string | null
    delivery_address?: StringNullableWithAggregatesFilter | string | null
    delivery_city?: StringNullableWithAggregatesFilter | string | null
    delivery_state?: StringNullableWithAggregatesFilter | string | null
    delivery_zip?: StringNullableWithAggregatesFilter | string | null
    delivery_country?: StringNullableWithAggregatesFilter | string | null
    delivery_tel?: StringNullableWithAggregatesFilter | string | null
    user_id?: IntWithAggregatesFilter | number
    cart_type?: StringWithAggregatesFilter | string
    subtotal?: FloatWithAggregatesFilter | number
    service_tax?: FloatWithAggregatesFilter | number
    net_revenue?: FloatNullableWithAggregatesFilter | number | null
    net_total?: FloatWithAggregatesFilter | number
    date_created?: DateTimeWithAggregatesFilter | Date | string
    coupon_id?: StringNullableWithAggregatesFilter | string | null
    coupon_discount_amt?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type order_book_detailsWhereInput = {
    AND?: Enumerable<order_book_detailsWhereInput>
    OR?: Enumerable<order_book_detailsWhereInput>
    NOT?: Enumerable<order_book_detailsWhereInput>
    book_order_id?: IntFilter | number
    order_id?: IntFilter | number
    user_id?: IntFilter | number
    book_id?: IntFilter | number
    book_cost?: FloatNullableFilter | number | null
    order_type?: IntFilter | number
    start_date?: DateTimeNullableFilter | Date | string | null
    end_date?: DateTimeNullableFilter | Date | string | null
    order_date?: StringFilter | string
    rent_plan?: IntFilter | number
    author_id?: IntFilter | number
    language_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    channel?: StringNullableFilter | string | null
    status?: IntFilter | number
    date_created?: DateTimeFilter | Date | string
    user_ip?: StringNullableFilter | string | null
  }

  export type order_book_detailsOrderByWithRelationInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    order_date?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    user_ip?: SortOrder
  }

  export type order_book_detailsWhereUniqueInput = {
    book_order_id?: number
  }

  export type order_book_detailsOrderByWithAggregationInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    order_date?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    user_ip?: SortOrder
    _count?: order_book_detailsCountOrderByAggregateInput
    _avg?: order_book_detailsAvgOrderByAggregateInput
    _max?: order_book_detailsMaxOrderByAggregateInput
    _min?: order_book_detailsMinOrderByAggregateInput
    _sum?: order_book_detailsSumOrderByAggregateInput
  }

  export type order_book_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<order_book_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<order_book_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<order_book_detailsScalarWhereWithAggregatesInput>
    book_order_id?: IntWithAggregatesFilter | number
    order_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    book_id?: IntWithAggregatesFilter | number
    book_cost?: FloatNullableWithAggregatesFilter | number | null
    order_type?: IntWithAggregatesFilter | number
    start_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    order_date?: StringWithAggregatesFilter | string
    rent_plan?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    language_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    channel?: StringNullableWithAggregatesFilter | string | null
    status?: IntWithAggregatesFilter | number
    date_created?: DateTimeWithAggregatesFilter | Date | string
    user_ip?: StringNullableWithAggregatesFilter | string | null
  }

  export type overdrive_booksWhereInput = {
    AND?: Enumerable<overdrive_booksWhereInput>
    OR?: Enumerable<overdrive_booksWhereInput>
    NOT?: Enumerable<overdrive_booksWhereInput>
    id?: IntFilter | number
    overdrive_id?: IntFilter | number
    catalogue_id?: BigIntFilter | bigint | number
    isbn?: BigIntFilter | bigint | number
    physical_isbn?: StringNullableFilter | string | null
    title?: StringFilter | string
    subtitle?: StringNullableFilter | string | null
    edition?: IntNullableFilter | number | null
    series?: IntNullableFilter | number | null
    publisher?: StringFilter | string
    imprint?: StringNullableFilter | string | null
    creators?: StringFilter | string
    subject?: StringFilter | string
    format?: StringFilter | string
    filesize?: IntFilter | number
    whs_usd?: FloatFilter | number
    whs_usddiscount?: IntFilter | number
    lib_usd?: FloatFilter | number
    lib_usddiscount?: IntFilter | number
    onsale_date?: DateTimeFilter | Date | string
    pub_date?: DateTimeNullableFilter | Date | string | null
    status?: StringFilter | string
    sample_link?: StringFilter | string
    readbox_enabled?: StringNullableFilter | string | null
    special_features?: StringNullableFilter | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntFilter | number
    type_of_book?: IntNullableFilter | number | null
  }

  export type overdrive_booksOrderByWithRelationInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    physical_isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    creators?: SortOrder
    subject?: SortOrder
    format?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    onsale_date?: SortOrder
    pub_date?: SortOrder
    status?: SortOrder
    sample_link?: SortOrder
    readbox_enabled?: SortOrder
    special_features?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type overdrive_booksOrderByWithAggregationInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    physical_isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    creators?: SortOrder
    subject?: SortOrder
    format?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    onsale_date?: SortOrder
    pub_date?: SortOrder
    status?: SortOrder
    sample_link?: SortOrder
    readbox_enabled?: SortOrder
    special_features?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    _count?: overdrive_booksCountOrderByAggregateInput
    _avg?: overdrive_booksAvgOrderByAggregateInput
    _max?: overdrive_booksMaxOrderByAggregateInput
    _min?: overdrive_booksMinOrderByAggregateInput
    _sum?: overdrive_booksSumOrderByAggregateInput
  }

  export type overdrive_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<overdrive_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<overdrive_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<overdrive_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    overdrive_id?: IntWithAggregatesFilter | number
    catalogue_id?: BigIntWithAggregatesFilter | bigint | number
    isbn?: BigIntWithAggregatesFilter | bigint | number
    physical_isbn?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    subtitle?: StringNullableWithAggregatesFilter | string | null
    edition?: IntNullableWithAggregatesFilter | number | null
    series?: IntNullableWithAggregatesFilter | number | null
    publisher?: StringWithAggregatesFilter | string
    imprint?: StringNullableWithAggregatesFilter | string | null
    creators?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    format?: StringWithAggregatesFilter | string
    filesize?: IntWithAggregatesFilter | number
    whs_usd?: FloatWithAggregatesFilter | number
    whs_usddiscount?: IntWithAggregatesFilter | number
    lib_usd?: FloatWithAggregatesFilter | number
    lib_usddiscount?: IntWithAggregatesFilter | number
    onsale_date?: DateTimeWithAggregatesFilter | Date | string
    pub_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: StringWithAggregatesFilter | string
    sample_link?: StringWithAggregatesFilter | string
    readbox_enabled?: StringNullableWithAggregatesFilter | string | null
    special_features?: StringNullableWithAggregatesFilter | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntWithAggregatesFilter | number
    type_of_book?: IntNullableWithAggregatesFilter | number | null
  }

  export type overdrive_transactionsWhereInput = {
    AND?: Enumerable<overdrive_transactionsWhereInput>
    OR?: Enumerable<overdrive_transactionsWhereInput>
    NOT?: Enumerable<overdrive_transactionsWhereInput>
    id?: IntFilter | number
    transaction_date?: DateTimeFilter | Date | string
    overdrive_id?: IntFilter | number
    isbn?: IntFilter | number
    title?: StringFilter | string
    subtitle?: StringFilter | string
    author?: StringFilter | string
    retailer?: StringFilter | string
    country_of_sale?: StringFilter | string
    format?: StringFilter | string
    srp_usd?: FloatFilter | number
    discount?: IntFilter | number
    amt_owed_usd?: IntFilter | number
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    language_id?: IntFilter | number
    exchange_rate?: IntFilter | number
    inr_value?: FloatFilter | number
    final_royalty_value?: FloatFilter | number
    user_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    status?: StringFilter | string
  }

  export type overdrive_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    author?: SortOrder
    retailer?: SortOrder
    country_of_sale?: SortOrder
    format?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type overdrive_transactionsWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type overdrive_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    author?: SortOrder
    retailer?: SortOrder
    country_of_sale?: SortOrder
    format?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    _count?: overdrive_transactionsCountOrderByAggregateInput
    _avg?: overdrive_transactionsAvgOrderByAggregateInput
    _max?: overdrive_transactionsMaxOrderByAggregateInput
    _min?: overdrive_transactionsMinOrderByAggregateInput
    _sum?: overdrive_transactionsSumOrderByAggregateInput
  }

  export type overdrive_transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<overdrive_transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<overdrive_transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<overdrive_transactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    transaction_date?: DateTimeWithAggregatesFilter | Date | string
    overdrive_id?: IntWithAggregatesFilter | number
    isbn?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    subtitle?: StringWithAggregatesFilter | string
    author?: StringWithAggregatesFilter | string
    retailer?: StringWithAggregatesFilter | string
    country_of_sale?: StringWithAggregatesFilter | string
    format?: StringWithAggregatesFilter | string
    srp_usd?: FloatWithAggregatesFilter | number
    discount?: IntWithAggregatesFilter | number
    amt_owed_usd?: IntWithAggregatesFilter | number
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    language_id?: IntWithAggregatesFilter | number
    exchange_rate?: IntWithAggregatesFilter | number
    inr_value?: FloatWithAggregatesFilter | number
    final_royalty_value?: FloatWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
  }

  export type payout_sessionWhereInput = {
    AND?: Enumerable<payout_sessionWhereInput>
    OR?: Enumerable<payout_sessionWhereInput>
    NOT?: Enumerable<payout_sessionWhereInput>
    session_id?: IntFilter | number
    session_data?: StringFilter | string
    user_id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
  }

  export type payout_sessionOrderByWithRelationInput = {
    session_id?: SortOrder
    session_data?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type payout_sessionWhereUniqueInput = {
    session_id?: number
  }

  export type payout_sessionOrderByWithAggregationInput = {
    session_id?: SortOrder
    session_data?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    _count?: payout_sessionCountOrderByAggregateInput
    _avg?: payout_sessionAvgOrderByAggregateInput
    _max?: payout_sessionMaxOrderByAggregateInput
    _min?: payout_sessionMinOrderByAggregateInput
    _sum?: payout_sessionSumOrderByAggregateInput
  }

  export type payout_sessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<payout_sessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<payout_sessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<payout_sessionScalarWhereWithAggregatesInput>
    session_id?: IntWithAggregatesFilter | number
    session_data?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
  }

  export type plan_tblWhereInput = {
    AND?: Enumerable<plan_tblWhereInput>
    OR?: Enumerable<plan_tblWhereInput>
    NOT?: Enumerable<plan_tblWhereInput>
    plan_id?: IntFilter | number
    plan_name?: StringFilter | string
    plan_display_name?: StringNullableFilter | string | null
    plan_url_name?: StringNullableFilter | string | null
    plan_type?: IntNullableFilter | number | null
    plan_image?: StringFilter | string
    plan_cost?: FloatFilter | number
    plan_caption?: StringNullableFilter | string | null
    plan_cost_international?: FloatFilter | number
    validity_days?: IntFilter | number
    book_validity_days?: IntFilter | number
    available_books?: IntFilter | number
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeFilter | Date | string
    status?: IntFilter | number
  }

  export type plan_tblOrderByWithRelationInput = {
    plan_id?: SortOrder
    plan_name?: SortOrder
    plan_display_name?: SortOrder
    plan_url_name?: SortOrder
    plan_type?: SortOrder
    plan_image?: SortOrder
    plan_cost?: SortOrder
    plan_caption?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    plan_intro_date?: SortOrder
    status?: SortOrder
  }

  export type plan_tblWhereUniqueInput = {
    plan_id?: number
  }

  export type plan_tblOrderByWithAggregationInput = {
    plan_id?: SortOrder
    plan_name?: SortOrder
    plan_display_name?: SortOrder
    plan_url_name?: SortOrder
    plan_type?: SortOrder
    plan_image?: SortOrder
    plan_cost?: SortOrder
    plan_caption?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    plan_intro_date?: SortOrder
    status?: SortOrder
    _count?: plan_tblCountOrderByAggregateInput
    _avg?: plan_tblAvgOrderByAggregateInput
    _max?: plan_tblMaxOrderByAggregateInput
    _min?: plan_tblMinOrderByAggregateInput
    _sum?: plan_tblSumOrderByAggregateInput
  }

  export type plan_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plan_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<plan_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plan_tblScalarWhereWithAggregatesInput>
    plan_id?: IntWithAggregatesFilter | number
    plan_name?: StringWithAggregatesFilter | string
    plan_display_name?: StringNullableWithAggregatesFilter | string | null
    plan_url_name?: StringNullableWithAggregatesFilter | string | null
    plan_type?: IntNullableWithAggregatesFilter | number | null
    plan_image?: StringWithAggregatesFilter | string
    plan_cost?: FloatWithAggregatesFilter | number
    plan_caption?: StringNullableWithAggregatesFilter | string | null
    plan_cost_international?: FloatWithAggregatesFilter | number
    validity_days?: IntWithAggregatesFilter | number
    book_validity_days?: IntWithAggregatesFilter | number
    available_books?: IntWithAggregatesFilter | number
    discount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeWithAggregatesFilter | Date | string
    status?: IntWithAggregatesFilter | number
  }

  export type pod_cost_notificationWhereInput = {
    AND?: Enumerable<pod_cost_notificationWhereInput>
    OR?: Enumerable<pod_cost_notificationWhereInput>
    NOT?: Enumerable<pod_cost_notificationWhereInput>
    id?: IntFilter | number
    user_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    date_created?: DateTimeNullableFilter | Date | string | null
    mail_status?: IntNullableFilter | number | null
  }

  export type pod_cost_notificationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_created?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_cost_notificationWhereUniqueInput = {
    id?: number
  }

  export type pod_cost_notificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_created?: SortOrder
    mail_status?: SortOrder
    _count?: pod_cost_notificationCountOrderByAggregateInput
    _avg?: pod_cost_notificationAvgOrderByAggregateInput
    _max?: pod_cost_notificationMaxOrderByAggregateInput
    _min?: pod_cost_notificationMinOrderByAggregateInput
    _sum?: pod_cost_notificationSumOrderByAggregateInput
  }

  export type pod_cost_notificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pod_cost_notificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<pod_cost_notificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pod_cost_notificationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntNullableWithAggregatesFilter | number | null
    date_created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    mail_status?: IntNullableWithAggregatesFilter | number | null
  }

  export type pod_orderWhereInput = {
    AND?: Enumerable<pod_orderWhereInput>
    OR?: Enumerable<pod_orderWhereInput>
    NOT?: Enumerable<pod_orderWhereInput>
    id?: IntFilter | number
    order_id?: IntNullableFilter | number | null
    user_id?: StringNullableFilter | string | null
    shipping_charges?: IntNullableFilter | number | null
    discount?: IntNullableFilter | number | null
    order_status?: IntNullableFilter | number | null
    split_flag?: IntNullableFilter | number | null
    tracking_id?: StringNullableFilter | string | null
    tracking_url?: StringNullableFilter | string | null
    order_date?: DateTimeNullableFilter | Date | string | null
  }

  export type pod_orderOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    order_date?: SortOrder
  }

  export type pod_orderWhereUniqueInput = {
    id?: number
  }

  export type pod_orderOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    order_date?: SortOrder
    _count?: pod_orderCountOrderByAggregateInput
    _avg?: pod_orderAvgOrderByAggregateInput
    _max?: pod_orderMaxOrderByAggregateInput
    _min?: pod_orderMinOrderByAggregateInput
    _sum?: pod_orderSumOrderByAggregateInput
  }

  export type pod_orderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pod_orderScalarWhereWithAggregatesInput>
    OR?: Enumerable<pod_orderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pod_orderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: StringNullableWithAggregatesFilter | string | null
    shipping_charges?: IntNullableWithAggregatesFilter | number | null
    discount?: IntNullableWithAggregatesFilter | number | null
    order_status?: IntNullableWithAggregatesFilter | number | null
    split_flag?: IntNullableWithAggregatesFilter | number | null
    tracking_id?: StringNullableWithAggregatesFilter | string | null
    tracking_url?: StringNullableWithAggregatesFilter | string | null
    order_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type pod_order_detailsWhereInput = {
    AND?: Enumerable<pod_order_detailsWhereInput>
    OR?: Enumerable<pod_order_detailsWhereInput>
    NOT?: Enumerable<pod_order_detailsWhereInput>
    id?: IntFilter | number
    order_id?: IntNullableFilter | number | null
    user_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    quantity?: IntNullableFilter | number | null
    wrapper_type?: IntNullableFilter | number | null
    personalised_message?: StringNullableFilter | string | null
    tracking_id?: StringNullableFilter | string | null
    tracking_url?: StringNullableFilter | string | null
    status?: IntNullableFilter | number | null
    price?: IntNullableFilter | number | null
    order_date?: DateTimeNullableFilter | Date | string | null
  }

  export type pod_order_detailsOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    personalised_message?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    status?: SortOrder
    price?: SortOrder
    order_date?: SortOrder
  }

  export type pod_order_detailsWhereUniqueInput = {
    id?: number
  }

  export type pod_order_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    personalised_message?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    status?: SortOrder
    price?: SortOrder
    order_date?: SortOrder
    _count?: pod_order_detailsCountOrderByAggregateInput
    _avg?: pod_order_detailsAvgOrderByAggregateInput
    _max?: pod_order_detailsMaxOrderByAggregateInput
    _min?: pod_order_detailsMinOrderByAggregateInput
    _sum?: pod_order_detailsSumOrderByAggregateInput
  }

  export type pod_order_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pod_order_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<pod_order_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pod_order_detailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntNullableWithAggregatesFilter | number | null
    wrapper_type?: IntNullableWithAggregatesFilter | number | null
    personalised_message?: StringNullableWithAggregatesFilter | string | null
    tracking_id?: StringNullableWithAggregatesFilter | string | null
    tracking_url?: StringNullableWithAggregatesFilter | string | null
    status?: IntNullableWithAggregatesFilter | number | null
    price?: IntNullableWithAggregatesFilter | number | null
    order_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type pod_processingWhereInput = {
    AND?: Enumerable<pod_processingWhereInput>
    OR?: Enumerable<pod_processingWhereInput>
    NOT?: Enumerable<pod_processingWhereInput>
    id?: IntFilter | number
    book_id?: IntNullableFilter | number | null
    stage_id?: IntNullableFilter | number | null
    content_type?: StringNullableFilter | string | null
    word_page_number?: IntNullableFilter | number | null
    pod_estimation_pages?: IntNullableFilter | number | null
    cover_status?: IntNullableFilter | number | null
    priority?: StringNullableFilter | string | null
    date_created?: DateTimeNullableFilter | Date | string | null
    completed?: IntNullableFilter | number | null
    rework?: IntNullableFilter | number | null
  }

  export type pod_processingOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    content_type?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_processingWhereUniqueInput = {
    id?: number
  }

  export type pod_processingOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    content_type?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
    _count?: pod_processingCountOrderByAggregateInput
    _avg?: pod_processingAvgOrderByAggregateInput
    _max?: pod_processingMaxOrderByAggregateInput
    _min?: pod_processingMinOrderByAggregateInput
    _sum?: pod_processingSumOrderByAggregateInput
  }

  export type pod_processingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pod_processingScalarWhereWithAggregatesInput>
    OR?: Enumerable<pod_processingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pod_processingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntNullableWithAggregatesFilter | number | null
    stage_id?: IntNullableWithAggregatesFilter | number | null
    content_type?: StringNullableWithAggregatesFilter | string | null
    word_page_number?: IntNullableWithAggregatesFilter | number | null
    pod_estimation_pages?: IntNullableWithAggregatesFilter | number | null
    cover_status?: IntNullableWithAggregatesFilter | number | null
    priority?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    completed?: IntNullableWithAggregatesFilter | number | null
    rework?: IntNullableWithAggregatesFilter | number | null
  }

  export type pod_progressWhereInput = {
    AND?: Enumerable<pod_progressWhereInput>
    OR?: Enumerable<pod_progressWhereInput>
    NOT?: Enumerable<pod_progressWhereInput>
    id?: IntFilter | number
    book_id?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    stage?: IntNullableFilter | number | null
    startdate?: DateTimeNullableFilter | Date | string | null
    enddate?: DateTimeNullableFilter | Date | string | null
    on_hold_startdate?: DateTimeNullableFilter | Date | string | null
    on_hold_enddate?: DateTimeNullableFilter | Date | string | null
    remarks?: StringNullableFilter | string | null
    pause_startdate?: DateTimeNullableFilter | Date | string | null
    pause_enddate?: DateTimeNullableFilter | Date | string | null
  }

  export type pod_progressOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    pause_startdate?: SortOrder
    pause_enddate?: SortOrder
  }

  export type pod_progressWhereUniqueInput = {
    id?: number
  }

  export type pod_progressOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    pause_startdate?: SortOrder
    pause_enddate?: SortOrder
    _count?: pod_progressCountOrderByAggregateInput
    _avg?: pod_progressAvgOrderByAggregateInput
    _max?: pod_progressMaxOrderByAggregateInput
    _min?: pod_progressMinOrderByAggregateInput
    _sum?: pod_progressSumOrderByAggregateInput
  }

  export type pod_progressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pod_progressScalarWhereWithAggregatesInput>
    OR?: Enumerable<pod_progressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pod_progressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
    stage?: IntNullableWithAggregatesFilter | number | null
    startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    on_hold_startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    on_hold_enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    remarks?: StringNullableWithAggregatesFilter | string | null
    pause_startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    pause_enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type publisher_tblWhereInput = {
    AND?: Enumerable<publisher_tblWhereInput>
    OR?: Enumerable<publisher_tblWhereInput>
    NOT?: Enumerable<publisher_tblWhereInput>
    publisher_id?: IntFilter | number
    publisher_name?: StringNullableFilter | string | null
    publisher_url_name?: StringNullableFilter | string | null
    publisher_regional_name?: StringNullableFilter | string | null
    publisher_image?: StringNullableFilter | string | null
    publisher_description?: StringNullableFilter | string | null
    email_id?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    bank_acc_no?: StringNullableFilter | string | null
    bank_acc_name?: StringNullableFilter | string | null
    bank_acc_type?: StringNullableFilter | string | null
    ifsc_code?: StringNullableFilter | string | null
    pan_number?: StringNullableFilter | string | null
    copyright_owner?: StringNullableFilter | string | null
    bonus_percentage?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    tds_flag?: IntNullableFilter | number | null
  }

  export type publisher_tblOrderByWithRelationInput = {
    publisher_id?: SortOrder
    publisher_name?: SortOrder
    publisher_url_name?: SortOrder
    publisher_regional_name?: SortOrder
    publisher_image?: SortOrder
    publisher_description?: SortOrder
    email_id?: SortOrder
    mobile?: SortOrder
    address?: SortOrder
    bank_acc_no?: SortOrder
    bank_acc_name?: SortOrder
    bank_acc_type?: SortOrder
    ifsc_code?: SortOrder
    pan_number?: SortOrder
    copyright_owner?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    tds_flag?: SortOrder
  }

  export type publisher_tblWhereUniqueInput = {
    publisher_id?: number
  }

  export type publisher_tblOrderByWithAggregationInput = {
    publisher_id?: SortOrder
    publisher_name?: SortOrder
    publisher_url_name?: SortOrder
    publisher_regional_name?: SortOrder
    publisher_image?: SortOrder
    publisher_description?: SortOrder
    email_id?: SortOrder
    mobile?: SortOrder
    address?: SortOrder
    bank_acc_no?: SortOrder
    bank_acc_name?: SortOrder
    bank_acc_type?: SortOrder
    ifsc_code?: SortOrder
    pan_number?: SortOrder
    copyright_owner?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    tds_flag?: SortOrder
    _count?: publisher_tblCountOrderByAggregateInput
    _avg?: publisher_tblAvgOrderByAggregateInput
    _max?: publisher_tblMaxOrderByAggregateInput
    _min?: publisher_tblMinOrderByAggregateInput
    _sum?: publisher_tblSumOrderByAggregateInput
  }

  export type publisher_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<publisher_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<publisher_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<publisher_tblScalarWhereWithAggregatesInput>
    publisher_id?: IntWithAggregatesFilter | number
    publisher_name?: StringNullableWithAggregatesFilter | string | null
    publisher_url_name?: StringNullableWithAggregatesFilter | string | null
    publisher_regional_name?: StringNullableWithAggregatesFilter | string | null
    publisher_image?: StringNullableWithAggregatesFilter | string | null
    publisher_description?: StringNullableWithAggregatesFilter | string | null
    email_id?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    bank_acc_no?: StringNullableWithAggregatesFilter | string | null
    bank_acc_name?: StringNullableWithAggregatesFilter | string | null
    bank_acc_type?: StringNullableWithAggregatesFilter | string | null
    ifsc_code?: StringNullableWithAggregatesFilter | string | null
    pan_number?: StringNullableWithAggregatesFilter | string | null
    copyright_owner?: StringNullableWithAggregatesFilter | string | null
    bonus_percentage?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tds_flag?: IntNullableWithAggregatesFilter | number | null
  }

  export type rating_reviewWhereInput = {
    AND?: Enumerable<rating_reviewWhereInput>
    OR?: Enumerable<rating_reviewWhereInput>
    NOT?: Enumerable<rating_reviewWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    user_id?: IntFilter | number
    book_id?: IntFilter | number
    comment?: StringFilter | string
    rating?: IntFilter | number
    status?: IntFilter | number
    date_created?: DateTimeFilter | Date | string
  }

  export type rating_reviewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type rating_reviewWhereUniqueInput = {
    id?: number
  }

  export type rating_reviewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    _count?: rating_reviewCountOrderByAggregateInput
    _avg?: rating_reviewAvgOrderByAggregateInput
    _max?: rating_reviewMaxOrderByAggregateInput
    _min?: rating_reviewMinOrderByAggregateInput
    _sum?: rating_reviewSumOrderByAggregateInput
  }

  export type rating_reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rating_reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<rating_reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rating_reviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
    book_id?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type razorpay_requestsWhereInput = {
    AND?: Enumerable<razorpay_requestsWhereInput>
    OR?: Enumerable<razorpay_requestsWhereInput>
    NOT?: Enumerable<razorpay_requestsWhereInput>
    id?: IntFilter | number
    user_id?: IntNullableFilter | number | null
    plan_id?: IntNullableFilter | number | null
    razorpay_payload?: StringNullableFilter | string | null
    created?: DateTimeNullableFilter | Date | string | null
  }

  export type razorpay_requestsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_payload?: SortOrder
    created?: SortOrder
  }

  export type razorpay_requestsWhereUniqueInput = {
    id?: number
  }

  export type razorpay_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_payload?: SortOrder
    created?: SortOrder
    _count?: razorpay_requestsCountOrderByAggregateInput
    _avg?: razorpay_requestsAvgOrderByAggregateInput
    _max?: razorpay_requestsMaxOrderByAggregateInput
    _min?: razorpay_requestsMinOrderByAggregateInput
    _sum?: razorpay_requestsSumOrderByAggregateInput
  }

  export type razorpay_requestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<razorpay_requestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<razorpay_requestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<razorpay_requestsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    plan_id?: IntNullableWithAggregatesFilter | number | null
    razorpay_payload?: StringNullableWithAggregatesFilter | string | null
    created?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type royalty_settlementWhereInput = {
    AND?: Enumerable<royalty_settlementWhereInput>
    OR?: Enumerable<royalty_settlementWhereInput>
    NOT?: Enumerable<royalty_settlementWhereInput>
    id?: IntFilter | number
    copy_right_owner_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    settlement_date?: DateTimeFilter | Date | string
    settlement_amount?: FloatFilter | number
    tds_amount?: FloatNullableFilter | number | null
    payment_type?: StringFilter | string
    bank_transaction_details?: StringFilter | string
    comments?: StringFilter | string
    pustaka?: FloatNullableFilter | number | null
    amazon?: FloatNullableFilter | number | null
    kobo?: FloatNullableFilter | number | null
    scribd?: FloatNullableFilter | number | null
    google?: FloatNullableFilter | number | null
    overdrive?: FloatNullableFilter | number | null
    storytel?: FloatNullableFilter | number | null
    audible?: FloatNullableFilter | number | null
    bonus_value?: FloatNullableFilter | number | null
  }

  export type royalty_settlementOrderByWithRelationInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_date?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    payment_type?: SortOrder
    bank_transaction_details?: SortOrder
    comments?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type royalty_settlementWhereUniqueInput = {
    id?: number
  }

  export type royalty_settlementOrderByWithAggregationInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_date?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    payment_type?: SortOrder
    bank_transaction_details?: SortOrder
    comments?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
    _count?: royalty_settlementCountOrderByAggregateInput
    _avg?: royalty_settlementAvgOrderByAggregateInput
    _max?: royalty_settlementMaxOrderByAggregateInput
    _min?: royalty_settlementMinOrderByAggregateInput
    _sum?: royalty_settlementSumOrderByAggregateInput
  }

  export type royalty_settlementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<royalty_settlementScalarWhereWithAggregatesInput>
    OR?: Enumerable<royalty_settlementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<royalty_settlementScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    copy_right_owner_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    settlement_date?: DateTimeWithAggregatesFilter | Date | string
    settlement_amount?: FloatWithAggregatesFilter | number
    tds_amount?: FloatNullableWithAggregatesFilter | number | null
    payment_type?: StringWithAggregatesFilter | string
    bank_transaction_details?: StringWithAggregatesFilter | string
    comments?: StringWithAggregatesFilter | string
    pustaka?: FloatNullableWithAggregatesFilter | number | null
    amazon?: FloatNullableWithAggregatesFilter | number | null
    kobo?: FloatNullableWithAggregatesFilter | number | null
    scribd?: FloatNullableWithAggregatesFilter | number | null
    google?: FloatNullableWithAggregatesFilter | number | null
    overdrive?: FloatNullableWithAggregatesFilter | number | null
    storytel?: FloatNullableWithAggregatesFilter | number | null
    audible?: FloatNullableWithAggregatesFilter | number | null
    bonus_value?: FloatNullableWithAggregatesFilter | number | null
  }

  export type sales_consolidationWhereInput = {
    AND?: Enumerable<sales_consolidationWhereInput>
    OR?: Enumerable<sales_consolidationWhereInput>
    NOT?: Enumerable<sales_consolidationWhereInput>
    id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    month_year?: DateTimeNullableFilter | Date | string | null
    genre_id?: IntNullableFilter | number | null
    language_id?: IntNullableFilter | number | null
    type_of_book?: IntNullableFilter | number | null
    book_cost?: IntNullableFilter | number | null
    downloads?: IntFilter | number
  }

  export type sales_consolidationOrderByWithRelationInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    month_year?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type sales_consolidationWhereUniqueInput = {
    id?: number
  }

  export type sales_consolidationOrderByWithAggregationInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    month_year?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
    _count?: sales_consolidationCountOrderByAggregateInput
    _avg?: sales_consolidationAvgOrderByAggregateInput
    _max?: sales_consolidationMaxOrderByAggregateInput
    _min?: sales_consolidationMinOrderByAggregateInput
    _sum?: sales_consolidationSumOrderByAggregateInput
  }

  export type sales_consolidationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sales_consolidationScalarWhereWithAggregatesInput>
    OR?: Enumerable<sales_consolidationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sales_consolidationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntNullableWithAggregatesFilter | number | null
    month_year?: DateTimeNullableWithAggregatesFilter | Date | string | null
    genre_id?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    type_of_book?: IntNullableWithAggregatesFilter | number | null
    book_cost?: IntNullableWithAggregatesFilter | number | null
    downloads?: IntWithAggregatesFilter | number
  }

  export type scribd_booksWhereInput = {
    AND?: Enumerable<scribd_booksWhereInput>
    OR?: Enumerable<scribd_booksWhereInput>
    NOT?: Enumerable<scribd_booksWhereInput>
    id?: IntFilter | number
    updated_at?: DateTimeFilter | Date | string
    import_id?: IntFilter | number
    doc_id?: IntFilter | number
    identifier?: StringFilter | string
    title?: StringFilter | string
    published?: BoolFilter | boolean
    in_subscription?: BoolFilter | boolean
    product_page_url?: StringNullableFilter | string | null
    imprints?: StringNullableFilter | string | null
    status?: StringFilter | string
    publisher_tools_config_id?: IntNullableFilter | number | null
    metadata_status?: StringNullableFilter | string | null
    conversion_status?: StringNullableFilter | string | null
    product_page_pending?: StringNullableFilter | string | null
    subscription_pending?: StringNullableFilter | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntFilter | number
    duplicate_flag?: IntNullableFilter | number | null
  }

  export type scribd_booksOrderByWithRelationInput = {
    id?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    identifier?: SortOrder
    title?: SortOrder
    published?: SortOrder
    in_subscription?: SortOrder
    product_page_url?: SortOrder
    imprints?: SortOrder
    status?: SortOrder
    publisher_tools_config_id?: SortOrder
    metadata_status?: SortOrder
    conversion_status?: SortOrder
    product_page_pending?: SortOrder
    subscription_pending?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type scribd_booksOrderByWithAggregationInput = {
    id?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    identifier?: SortOrder
    title?: SortOrder
    published?: SortOrder
    in_subscription?: SortOrder
    product_page_url?: SortOrder
    imprints?: SortOrder
    status?: SortOrder
    publisher_tools_config_id?: SortOrder
    metadata_status?: SortOrder
    conversion_status?: SortOrder
    product_page_pending?: SortOrder
    subscription_pending?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
    _count?: scribd_booksCountOrderByAggregateInput
    _avg?: scribd_booksAvgOrderByAggregateInput
    _max?: scribd_booksMaxOrderByAggregateInput
    _min?: scribd_booksMinOrderByAggregateInput
    _sum?: scribd_booksSumOrderByAggregateInput
  }

  export type scribd_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<scribd_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<scribd_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<scribd_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    import_id?: IntWithAggregatesFilter | number
    doc_id?: IntWithAggregatesFilter | number
    identifier?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    in_subscription?: BoolWithAggregatesFilter | boolean
    product_page_url?: StringNullableWithAggregatesFilter | string | null
    imprints?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    publisher_tools_config_id?: IntNullableWithAggregatesFilter | number | null
    metadata_status?: StringNullableWithAggregatesFilter | string | null
    conversion_status?: StringNullableWithAggregatesFilter | string | null
    product_page_pending?: StringNullableWithAggregatesFilter | string | null
    subscription_pending?: StringNullableWithAggregatesFilter | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntWithAggregatesFilter | number
    duplicate_flag?: IntNullableWithAggregatesFilter | number | null
  }

  export type scribd_transactionWhereInput = {
    AND?: Enumerable<scribd_transactionWhereInput>
    OR?: Enumerable<scribd_transactionWhereInput>
    NOT?: Enumerable<scribd_transactionWhereInput>
    S_No?: IntFilter | number
    Payout_month?: DateTimeFilter | Date | string
    Publisher?: StringFilter | string
    Amount_owed_for_this_interaction?: FloatFilter | number
    Amount_owed_currency?: StringFilter | string
    Price_in_original_currency?: FloatFilter | number
    Digital_list_price?: FloatFilter | number
    Original_currency?: StringFilter | string
    Price_type?: StringFilter | string
    ISBN?: BigIntFilter | bigint | number
    Title?: StringFilter | string
    Authors?: StringFilter | string
    Imprints?: StringFilter | string
    Viewed?: StringFilter | string
    Payout_type?: StringFilter | string
    Start_date_of_interaction?: DateTimeFilter | Date | string
    Last_date_of_interaction?: DateTimeFilter | Date | string
    Country_of_reader?: StringFilter | string
    Unique_interaction_ID?: StringFilter | string
    ISO_Country_Code?: StringFilter | string
    Threshold_Date?: DateTimeFilter | Date | string
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntFilter | number
    language_id?: IntNullableFilter | number | null
    converted_inr?: FloatFilter | number
    user_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    status?: StringFilter | string
    exchange_rate?: FloatFilter | number
    converted_inr_full?: FloatNullableFilter | number | null
  }

  export type scribd_transactionOrderByWithRelationInput = {
    S_No?: SortOrder
    Payout_month?: SortOrder
    Publisher?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Amount_owed_currency?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    Original_currency?: SortOrder
    Price_type?: SortOrder
    ISBN?: SortOrder
    Title?: SortOrder
    Authors?: SortOrder
    Imprints?: SortOrder
    Viewed?: SortOrder
    Payout_type?: SortOrder
    Start_date_of_interaction?: SortOrder
    Last_date_of_interaction?: SortOrder
    Country_of_reader?: SortOrder
    Unique_interaction_ID?: SortOrder
    ISO_Country_Code?: SortOrder
    Threshold_Date?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type scribd_transactionWhereUniqueInput = {
    S_No?: number
    book_id?: number
  }

  export type scribd_transactionOrderByWithAggregationInput = {
    S_No?: SortOrder
    Payout_month?: SortOrder
    Publisher?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Amount_owed_currency?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    Original_currency?: SortOrder
    Price_type?: SortOrder
    ISBN?: SortOrder
    Title?: SortOrder
    Authors?: SortOrder
    Imprints?: SortOrder
    Viewed?: SortOrder
    Payout_type?: SortOrder
    Start_date_of_interaction?: SortOrder
    Last_date_of_interaction?: SortOrder
    Country_of_reader?: SortOrder
    Unique_interaction_ID?: SortOrder
    ISO_Country_Code?: SortOrder
    Threshold_Date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
    _count?: scribd_transactionCountOrderByAggregateInput
    _avg?: scribd_transactionAvgOrderByAggregateInput
    _max?: scribd_transactionMaxOrderByAggregateInput
    _min?: scribd_transactionMinOrderByAggregateInput
    _sum?: scribd_transactionSumOrderByAggregateInput
  }

  export type scribd_transactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<scribd_transactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<scribd_transactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<scribd_transactionScalarWhereWithAggregatesInput>
    S_No?: IntWithAggregatesFilter | number
    Payout_month?: DateTimeWithAggregatesFilter | Date | string
    Publisher?: StringWithAggregatesFilter | string
    Amount_owed_for_this_interaction?: FloatWithAggregatesFilter | number
    Amount_owed_currency?: StringWithAggregatesFilter | string
    Price_in_original_currency?: FloatWithAggregatesFilter | number
    Digital_list_price?: FloatWithAggregatesFilter | number
    Original_currency?: StringWithAggregatesFilter | string
    Price_type?: StringWithAggregatesFilter | string
    ISBN?: BigIntWithAggregatesFilter | bigint | number
    Title?: StringWithAggregatesFilter | string
    Authors?: StringWithAggregatesFilter | string
    Imprints?: StringWithAggregatesFilter | string
    Viewed?: StringWithAggregatesFilter | string
    Payout_type?: StringWithAggregatesFilter | string
    Start_date_of_interaction?: DateTimeWithAggregatesFilter | Date | string
    Last_date_of_interaction?: DateTimeWithAggregatesFilter | Date | string
    Country_of_reader?: StringWithAggregatesFilter | string
    Unique_interaction_ID?: StringWithAggregatesFilter | string
    ISO_Country_Code?: StringWithAggregatesFilter | string
    Threshold_Date?: DateTimeWithAggregatesFilter | Date | string
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    language_id?: IntNullableWithAggregatesFilter | number | null
    converted_inr?: FloatWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
    exchange_rate?: FloatWithAggregatesFilter | number
    converted_inr_full?: FloatNullableWithAggregatesFilter | number | null
  }

  export type storytel_booksWhereInput = {
    AND?: Enumerable<storytel_booksWhereInput>
    OR?: Enumerable<storytel_booksWhereInput>
    NOT?: Enumerable<storytel_booksWhereInput>
    id?: IntFilter | number
    storytel_book_id?: StringNullableFilter | string | null
    isbn?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    author_name?: StringNullableFilter | string | null
    narrator?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    publication_date?: DateTimeNullableFilter | Date | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    copyright_owner?: IntNullableFilter | number | null
    language_id?: IntNullableFilter | number | null
    genre_id?: IntNullableFilter | number | null
    type_of_book?: IntNullableFilter | number | null
  }

  export type storytel_booksOrderByWithRelationInput = {
    id?: SortOrder
    storytel_book_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    author_name?: SortOrder
    narrator?: SortOrder
    category?: SortOrder
    publication_date?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type storytel_booksWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type storytel_booksOrderByWithAggregationInput = {
    id?: SortOrder
    storytel_book_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    author_name?: SortOrder
    narrator?: SortOrder
    category?: SortOrder
    publication_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
    _count?: storytel_booksCountOrderByAggregateInput
    _avg?: storytel_booksAvgOrderByAggregateInput
    _max?: storytel_booksMaxOrderByAggregateInput
    _min?: storytel_booksMinOrderByAggregateInput
    _sum?: storytel_booksSumOrderByAggregateInput
  }

  export type storytel_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<storytel_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<storytel_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<storytel_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    storytel_book_id?: StringNullableWithAggregatesFilter | string | null
    isbn?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    author_name?: StringNullableWithAggregatesFilter | string | null
    narrator?: StringNullableWithAggregatesFilter | string | null
    category?: StringNullableWithAggregatesFilter | string | null
    publication_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    genre_id?: IntNullableWithAggregatesFilter | number | null
    type_of_book?: IntNullableWithAggregatesFilter | number | null
  }

  export type storytel_transactionsWhereInput = {
    AND?: Enumerable<storytel_transactionsWhereInput>
    OR?: Enumerable<storytel_transactionsWhereInput>
    NOT?: Enumerable<storytel_transactionsWhereInput>
    id?: IntFilter | number
    author?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    isbn?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    price_model?: StringNullableFilter | string | null
    no_of_units?: FloatNullableFilter | number | null
    net_receipts_per_hour_local?: FloatNullableFilter | number | null
    ecb_exchange_rate?: StringNullableFilter | string | null
    net_receipts_per_hour_inr?: FloatNullableFilter | number | null
    book_length_in_hours?: FloatNullableFilter | number | null
    price_per_unit?: FloatNullableFilter | number | null
    remuneration_eur?: FloatNullableFilter | number | null
    remuneration_inr?: FloatNullableFilter | number | null
    publisher?: StringNullableFilter | string | null
    imprint?: StringNullableFilter | string | null
    consumption_dates?: StringNullableFilter | string | null
    book_type?: StringNullableFilter | string | null
    book?: XOR<Book_tblRelationFilter, book_tblWhereInput>
    book_id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    language_id?: IntNullableFilter | number | null
    user_id?: BigIntNullableFilter | bigint | number | null
    copyright_owner?: IntNullableFilter | number | null
    final_royalty_value?: FloatNullableFilter | number | null
    transaction_date?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
  }

  export type storytel_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    author?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    country?: SortOrder
    price_model?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    ecb_exchange_rate?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    consumption_dates?: SortOrder
    book_type?: SortOrder
    book?: book_tblOrderByWithRelationInput
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type storytel_transactionsWhereUniqueInput = {
    id?: number
    book_id?: number
  }

  export type storytel_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    author?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    country?: SortOrder
    price_model?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    ecb_exchange_rate?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    consumption_dates?: SortOrder
    book_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
    _count?: storytel_transactionsCountOrderByAggregateInput
    _avg?: storytel_transactionsAvgOrderByAggregateInput
    _max?: storytel_transactionsMaxOrderByAggregateInput
    _min?: storytel_transactionsMinOrderByAggregateInput
    _sum?: storytel_transactionsSumOrderByAggregateInput
  }

  export type storytel_transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<storytel_transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<storytel_transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<storytel_transactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    author?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    isbn?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    price_model?: StringNullableWithAggregatesFilter | string | null
    no_of_units?: FloatNullableWithAggregatesFilter | number | null
    net_receipts_per_hour_local?: FloatNullableWithAggregatesFilter | number | null
    ecb_exchange_rate?: StringNullableWithAggregatesFilter | string | null
    net_receipts_per_hour_inr?: FloatNullableWithAggregatesFilter | number | null
    book_length_in_hours?: FloatNullableWithAggregatesFilter | number | null
    price_per_unit?: FloatNullableWithAggregatesFilter | number | null
    remuneration_eur?: FloatNullableWithAggregatesFilter | number | null
    remuneration_inr?: FloatNullableWithAggregatesFilter | number | null
    publisher?: StringNullableWithAggregatesFilter | string | null
    imprint?: StringNullableWithAggregatesFilter | string | null
    consumption_dates?: StringNullableWithAggregatesFilter | string | null
    book_type?: StringNullableWithAggregatesFilter | string | null
    book_id?: IntWithAggregatesFilter | number
    author_id?: IntNullableWithAggregatesFilter | number | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: BigIntNullableWithAggregatesFilter | bigint | number | null
    copyright_owner?: IntNullableWithAggregatesFilter | number | null
    final_royalty_value?: FloatNullableWithAggregatesFilter | number | null
    transaction_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: StringNullableWithAggregatesFilter | string | null
  }

  export type subscribe_newsletterWhereInput = {
    AND?: Enumerable<subscribe_newsletterWhereInput>
    OR?: Enumerable<subscribe_newsletterWhereInput>
    NOT?: Enumerable<subscribe_newsletterWhereInput>
    id?: IntFilter | number
    email_id?: StringNullableFilter | string | null
    subscribe_date?: DateTimeNullableFilter | Date | string | null
  }

  export type subscribe_newsletterOrderByWithRelationInput = {
    id?: SortOrder
    email_id?: SortOrder
    subscribe_date?: SortOrder
  }

  export type subscribe_newsletterWhereUniqueInput = {
    id?: number
  }

  export type subscribe_newsletterOrderByWithAggregationInput = {
    id?: SortOrder
    email_id?: SortOrder
    subscribe_date?: SortOrder
    _count?: subscribe_newsletterCountOrderByAggregateInput
    _avg?: subscribe_newsletterAvgOrderByAggregateInput
    _max?: subscribe_newsletterMaxOrderByAggregateInput
    _min?: subscribe_newsletterMinOrderByAggregateInput
    _sum?: subscribe_newsletterSumOrderByAggregateInput
  }

  export type subscribe_newsletterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subscribe_newsletterScalarWhereWithAggregatesInput>
    OR?: Enumerable<subscribe_newsletterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subscribe_newsletterScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email_id?: StringNullableWithAggregatesFilter | string | null
    subscribe_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type subscriptionWhereInput = {
    AND?: Enumerable<subscriptionWhereInput>
    OR?: Enumerable<subscriptionWhereInput>
    NOT?: Enumerable<subscriptionWhereInput>
    id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
    user_id?: IntFilter | number
    subscription_id?: IntFilter | number
    plan_type?: IntNullableFilter | number | null
    number_of_days?: IntFilter | number
    start_date?: DateTimeNullableFilter | Date | string | null
    end_date?: DateTimeFilter | Date | string
    total_books_applicable?: IntFilter | number
    date_inserted?: DateTimeFilter | Date | string
    status?: IntFilter | number
  }

  export type subscriptionOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_books_applicable?: SortOrder
    date_inserted?: SortOrder
    status?: SortOrder
  }

  export type subscriptionWhereUniqueInput = {
    id?: number
  }

  export type subscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_books_applicable?: SortOrder
    date_inserted?: SortOrder
    status?: SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _avg?: subscriptionAvgOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
    _sum?: subscriptionSumOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<subscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subscriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
    user_id?: IntWithAggregatesFilter | number
    subscription_id?: IntWithAggregatesFilter | number
    plan_type?: IntNullableWithAggregatesFilter | number | null
    number_of_days?: IntWithAggregatesFilter | number
    start_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end_date?: DateTimeWithAggregatesFilter | Date | string
    total_books_applicable?: IntWithAggregatesFilter | number
    date_inserted?: DateTimeWithAggregatesFilter | Date | string
    status?: IntWithAggregatesFilter | number
  }

  export type today_dealsWhereInput = {
    AND?: Enumerable<today_dealsWhereInput>
    OR?: Enumerable<today_dealsWhereInput>
    NOT?: Enumerable<today_dealsWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    book_id?: IntFilter | number
    language_id?: IntNullableFilter | number | null
    discount?: IntFilter | number
    status?: StringFilter | string
    type?: StringFilter | string
  }

  export type today_dealsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type today_dealsWhereUniqueInput = {
    id?: number
  }

  export type today_dealsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    _count?: today_dealsCountOrderByAggregateInput
    _avg?: today_dealsAvgOrderByAggregateInput
    _max?: today_dealsMaxOrderByAggregateInput
    _min?: today_dealsMinOrderByAggregateInput
    _sum?: today_dealsSumOrderByAggregateInput
  }

  export type today_dealsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<today_dealsScalarWhereWithAggregatesInput>
    OR?: Enumerable<today_dealsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<today_dealsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    book_id?: IntWithAggregatesFilter | number
    language_id?: IntNullableWithAggregatesFilter | number | null
    discount?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
  }

  export type top_booksWhereInput = {
    AND?: Enumerable<top_booksWhereInput>
    OR?: Enumerable<top_booksWhereInput>
    NOT?: Enumerable<top_booksWhereInput>
    id?: IntFilter | number
    purpose?: StringNullableFilter | string | null
    sales_count_by_bk_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    book_title?: StringNullableFilter | string | null
    url_name?: StringNullableFilter | string | null
    regional_book_title?: StringNullableFilter | string | null
    language_id?: IntNullableFilter | number | null
    language_id_tmp?: IntNullableFilter | number | null
    type_of_book?: IntNullableFilter | number | null
    author_id?: IntNullableFilter | number | null
    author_name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    download_link?: StringNullableFilter | string | null
    cover_image?: StringNullableFilter | string | null
    epub_url?: StringNullableFilter | string | null
    cost?: IntNullableFilter | number | null
    number_of_page?: IntNullableFilter | number | null
    genre_id?: IntNullableFilter | number | null
    genre_id_tmp?: IntNullableFilter | number | null
    genre_name?: StringNullableFilter | string | null
    book_category?: StringNullableFilter | string | null
  }

  export type top_booksOrderByWithRelationInput = {
    id?: SortOrder
    purpose?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    description?: SortOrder
    download_link?: SortOrder
    cover_image?: SortOrder
    epub_url?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
    genre_name?: SortOrder
    book_category?: SortOrder
  }

  export type top_booksWhereUniqueInput = {
    id?: number
  }

  export type top_booksOrderByWithAggregationInput = {
    id?: SortOrder
    purpose?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    description?: SortOrder
    download_link?: SortOrder
    cover_image?: SortOrder
    epub_url?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
    genre_name?: SortOrder
    book_category?: SortOrder
    _count?: top_booksCountOrderByAggregateInput
    _avg?: top_booksAvgOrderByAggregateInput
    _max?: top_booksMaxOrderByAggregateInput
    _min?: top_booksMinOrderByAggregateInput
    _sum?: top_booksSumOrderByAggregateInput
  }

  export type top_booksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<top_booksScalarWhereWithAggregatesInput>
    OR?: Enumerable<top_booksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<top_booksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    purpose?: StringNullableWithAggregatesFilter | string | null
    sales_count_by_bk_id?: IntNullableWithAggregatesFilter | number | null
    book_id?: IntNullableWithAggregatesFilter | number | null
    book_title?: StringNullableWithAggregatesFilter | string | null
    url_name?: StringNullableWithAggregatesFilter | string | null
    regional_book_title?: StringNullableWithAggregatesFilter | string | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    language_id_tmp?: IntNullableWithAggregatesFilter | number | null
    type_of_book?: IntNullableWithAggregatesFilter | number | null
    author_id?: IntNullableWithAggregatesFilter | number | null
    author_name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    download_link?: StringNullableWithAggregatesFilter | string | null
    cover_image?: StringNullableWithAggregatesFilter | string | null
    epub_url?: StringNullableWithAggregatesFilter | string | null
    cost?: IntNullableWithAggregatesFilter | number | null
    number_of_page?: IntNullableWithAggregatesFilter | number | null
    genre_id?: IntNullableWithAggregatesFilter | number | null
    genre_id_tmp?: IntNullableWithAggregatesFilter | number | null
    genre_name?: StringNullableWithAggregatesFilter | string | null
    book_category?: StringNullableWithAggregatesFilter | string | null
  }

  export type user_addressWhereInput = {
    AND?: Enumerable<user_addressWhereInput>
    OR?: Enumerable<user_addressWhereInput>
    NOT?: Enumerable<user_addressWhereInput>
    user_id?: IntFilter | number
    billing_name?: StringNullableFilter | string | null
    billing_address1?: StringNullableFilter | string | null
    billing_address2?: StringNullableFilter | string | null
    billing_area_name?: StringNullableFilter | string | null
    billing_landmark?: StringNullableFilter | string | null
    billing_city?: StringNullableFilter | string | null
    billing_state?: StringNullableFilter | string | null
    billing_pincode?: StringNullableFilter | string | null
    billing_mobile_no?: StringNullableFilter | string | null
    billing_alternate_no?: StringNullableFilter | string | null
    shipping_name?: StringNullableFilter | string | null
    shipping_address1?: StringNullableFilter | string | null
    shipping_address2?: StringNullableFilter | string | null
    shipping_area_name?: StringNullableFilter | string | null
    shipping_landmark?: StringNullableFilter | string | null
    shipping_city?: StringNullableFilter | string | null
    shipping_state?: StringNullableFilter | string | null
    shipping_pincode?: StringNullableFilter | string | null
    shipping_mobile_no?: StringNullableFilter | string | null
    shipping_alternate_no?: StringNullableFilter | string | null
  }

  export type user_addressOrderByWithRelationInput = {
    user_id?: SortOrder
    billing_name?: SortOrder
    billing_address1?: SortOrder
    billing_address2?: SortOrder
    billing_area_name?: SortOrder
    billing_landmark?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_pincode?: SortOrder
    billing_mobile_no?: SortOrder
    billing_alternate_no?: SortOrder
    shipping_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_area_name?: SortOrder
    shipping_landmark?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_pincode?: SortOrder
    shipping_mobile_no?: SortOrder
    shipping_alternate_no?: SortOrder
  }

  export type user_addressWhereUniqueInput = {
    user_id?: number
  }

  export type user_addressOrderByWithAggregationInput = {
    user_id?: SortOrder
    billing_name?: SortOrder
    billing_address1?: SortOrder
    billing_address2?: SortOrder
    billing_area_name?: SortOrder
    billing_landmark?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_pincode?: SortOrder
    billing_mobile_no?: SortOrder
    billing_alternate_no?: SortOrder
    shipping_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_area_name?: SortOrder
    shipping_landmark?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_pincode?: SortOrder
    shipping_mobile_no?: SortOrder
    shipping_alternate_no?: SortOrder
    _count?: user_addressCountOrderByAggregateInput
    _avg?: user_addressAvgOrderByAggregateInput
    _max?: user_addressMaxOrderByAggregateInput
    _min?: user_addressMinOrderByAggregateInput
    _sum?: user_addressSumOrderByAggregateInput
  }

  export type user_addressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_addressScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_addressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_addressScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    billing_name?: StringNullableWithAggregatesFilter | string | null
    billing_address1?: StringNullableWithAggregatesFilter | string | null
    billing_address2?: StringNullableWithAggregatesFilter | string | null
    billing_area_name?: StringNullableWithAggregatesFilter | string | null
    billing_landmark?: StringNullableWithAggregatesFilter | string | null
    billing_city?: StringNullableWithAggregatesFilter | string | null
    billing_state?: StringNullableWithAggregatesFilter | string | null
    billing_pincode?: StringNullableWithAggregatesFilter | string | null
    billing_mobile_no?: StringNullableWithAggregatesFilter | string | null
    billing_alternate_no?: StringNullableWithAggregatesFilter | string | null
    shipping_name?: StringNullableWithAggregatesFilter | string | null
    shipping_address1?: StringNullableWithAggregatesFilter | string | null
    shipping_address2?: StringNullableWithAggregatesFilter | string | null
    shipping_area_name?: StringNullableWithAggregatesFilter | string | null
    shipping_landmark?: StringNullableWithAggregatesFilter | string | null
    shipping_city?: StringNullableWithAggregatesFilter | string | null
    shipping_state?: StringNullableWithAggregatesFilter | string | null
    shipping_pincode?: StringNullableWithAggregatesFilter | string | null
    shipping_mobile_no?: StringNullableWithAggregatesFilter | string | null
    shipping_alternate_no?: StringNullableWithAggregatesFilter | string | null
  }

  export type user_devicesWhereInput = {
    AND?: Enumerable<user_devicesWhereInput>
    OR?: Enumerable<user_devicesWhereInput>
    NOT?: Enumerable<user_devicesWhereInput>
    user_id?: IntFilter | number
    device_id1?: StringFilter | string
    device_info1?: StringFilter | string
    device_id2?: StringFilter | string
    device_info2?: StringFilter | string
    device_id3?: StringFilter | string
    device_info3?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type user_devicesOrderByWithRelationInput = {
    user_id?: SortOrder
    device_id1?: SortOrder
    device_info1?: SortOrder
    device_id2?: SortOrder
    device_info2?: SortOrder
    device_id3?: SortOrder
    device_info3?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesWhereUniqueInput = {
    user_id?: number
  }

  export type user_devicesOrderByWithAggregationInput = {
    user_id?: SortOrder
    device_id1?: SortOrder
    device_info1?: SortOrder
    device_id2?: SortOrder
    device_info2?: SortOrder
    device_id3?: SortOrder
    device_info3?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_devicesCountOrderByAggregateInput
    _avg?: user_devicesAvgOrderByAggregateInput
    _max?: user_devicesMaxOrderByAggregateInput
    _min?: user_devicesMinOrderByAggregateInput
    _sum?: user_devicesSumOrderByAggregateInput
  }

  export type user_devicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_devicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_devicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_devicesScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    device_id1?: StringWithAggregatesFilter | string
    device_info1?: StringWithAggregatesFilter | string
    device_id2?: StringWithAggregatesFilter | string
    device_info2?: StringWithAggregatesFilter | string
    device_id3?: StringWithAggregatesFilter | string
    device_info3?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type user_subscription_tblWhereInput = {
    AND?: Enumerable<user_subscription_tblWhereInput>
    OR?: Enumerable<user_subscription_tblWhereInput>
    NOT?: Enumerable<user_subscription_tblWhereInput>
    subscription_id?: IntFilter | number
    user_id?: IntFilter | number
    user_email_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: IntFilter | number
    updated_by?: IntFilter | number
  }

  export type user_subscription_tblOrderByWithRelationInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    user_email_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_subscription_tblWhereUniqueInput = {
    subscription_id?: number
  }

  export type user_subscription_tblOrderByWithAggregationInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    user_email_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: user_subscription_tblCountOrderByAggregateInput
    _avg?: user_subscription_tblAvgOrderByAggregateInput
    _max?: user_subscription_tblMaxOrderByAggregateInput
    _min?: user_subscription_tblMinOrderByAggregateInput
    _sum?: user_subscription_tblSumOrderByAggregateInput
  }

  export type user_subscription_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_subscription_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_subscription_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_subscription_tblScalarWhereWithAggregatesInput>
    subscription_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    user_email_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: IntWithAggregatesFilter | number
    updated_by?: IntWithAggregatesFilter | number
  }

  export type user_walletWhereInput = {
    AND?: Enumerable<user_walletWhereInput>
    OR?: Enumerable<user_walletWhereInput>
    NOT?: Enumerable<user_walletWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    balance_inr?: FloatFilter | number
    balance_usd?: FloatFilter | number
    date?: DateTimeFilter | Date | string
  }

  export type user_walletOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_walletWhereUniqueInput = {
    id?: number
  }

  export type user_walletOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
    _count?: user_walletCountOrderByAggregateInput
    _avg?: user_walletAvgOrderByAggregateInput
    _max?: user_walletMaxOrderByAggregateInput
    _min?: user_walletMinOrderByAggregateInput
    _sum?: user_walletSumOrderByAggregateInput
  }

  export type user_walletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_walletScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_walletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_walletScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    balance_inr?: FloatWithAggregatesFilter | number
    balance_usd?: FloatWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type user_wallet_transactionWhereInput = {
    AND?: Enumerable<user_wallet_transactionWhereInput>
    OR?: Enumerable<user_wallet_transactionWhereInput>
    NOT?: Enumerable<user_wallet_transactionWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
    amount?: FloatFilter | number
    currency?: StringFilter | string
    transaction_type?: IntFilter | number
    balance_inr?: FloatFilter | number
    balance_usd?: FloatFilter | number
    date?: DateTimeFilter | Date | string
  }

  export type user_wallet_transactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_wallet_transactionWhereUniqueInput = {
    id?: number
  }

  export type user_wallet_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
    _count?: user_wallet_transactionCountOrderByAggregateInput
    _avg?: user_wallet_transactionAvgOrderByAggregateInput
    _max?: user_wallet_transactionMaxOrderByAggregateInput
    _min?: user_wallet_transactionMinOrderByAggregateInput
    _sum?: user_wallet_transactionSumOrderByAggregateInput
  }

  export type user_wallet_transactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_wallet_transactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_wallet_transactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_wallet_transactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
    amount?: FloatWithAggregatesFilter | number
    currency?: StringWithAggregatesFilter | string
    transaction_type?: IntWithAggregatesFilter | number
    balance_inr?: FloatWithAggregatesFilter | number
    balance_usd?: FloatWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type users_tblWhereInput = {
    AND?: Enumerable<users_tblWhereInput>
    OR?: Enumerable<users_tblWhereInput>
    NOT?: Enumerable<users_tblWhereInput>
    user_id?: IntFilter | number
    username?: StringFilter | string
    password?: StringFilter | string
    dob?: DateTimeNullableFilter | Date | string | null
    gender?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    language_id?: IntNullableFilter | number | null
    genre_ids?: StringNullableFilter | string | null
    address?: StringFilter | string
    city?: StringNullableFilter | string | null
    zipcode?: IntFilter | number
    country?: StringFilter | string
    user_type?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    email?: StringFilter | string
    secret_code?: StringNullableFilter | string | null
    channel?: StringNullableFilter | string | null
    profile_img_url?: StringNullableFilter | string | null
    giftBooks?: Author_gift_booksListRelationFilter
  }

  export type users_tblOrderByWithRelationInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    language_id?: SortOrder
    genre_ids?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    user_type?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    secret_code?: SortOrder
    channel?: SortOrder
    profile_img_url?: SortOrder
    giftBooks?: author_gift_booksOrderByRelationAggregateInput
  }

  export type users_tblWhereUniqueInput = {
    user_id?: number
  }

  export type users_tblOrderByWithAggregationInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    language_id?: SortOrder
    genre_ids?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    user_type?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    secret_code?: SortOrder
    channel?: SortOrder
    profile_img_url?: SortOrder
    _count?: users_tblCountOrderByAggregateInput
    _avg?: users_tblAvgOrderByAggregateInput
    _max?: users_tblMaxOrderByAggregateInput
    _min?: users_tblMinOrderByAggregateInput
    _sum?: users_tblSumOrderByAggregateInput
  }

  export type users_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<users_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<users_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<users_tblScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    dob?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gender?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    language_id?: IntNullableWithAggregatesFilter | number | null
    genre_ids?: StringNullableWithAggregatesFilter | string | null
    address?: StringWithAggregatesFilter | string
    city?: StringNullableWithAggregatesFilter | string | null
    zipcode?: IntWithAggregatesFilter | number
    country?: StringWithAggregatesFilter | string
    user_type?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    secret_code?: StringNullableWithAggregatesFilter | string | null
    channel?: StringNullableWithAggregatesFilter | string | null
    profile_img_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type wallet_order_tblWhereInput = {
    AND?: Enumerable<wallet_order_tblWhereInput>
    OR?: Enumerable<wallet_order_tblWhereInput>
    NOT?: Enumerable<wallet_order_tblWhereInput>
    id?: IntFilter | number
    order_id?: BigIntFilter | bigint | number
    user_id?: IntFilter | number
    cart_type?: StringFilter | string
    currency?: StringFilter | string
    subtotal?: IntFilter | number
    service_tax?: IntFilter | number
    net_total?: IntFilter | number
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_order_tblWhereUniqueInput = {
    id?: number
  }

  export type wallet_order_tblOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
    _count?: wallet_order_tblCountOrderByAggregateInput
    _avg?: wallet_order_tblAvgOrderByAggregateInput
    _max?: wallet_order_tblMaxOrderByAggregateInput
    _min?: wallet_order_tblMinOrderByAggregateInput
    _sum?: wallet_order_tblSumOrderByAggregateInput
  }

  export type wallet_order_tblScalarWhereWithAggregatesInput = {
    AND?: Enumerable<wallet_order_tblScalarWhereWithAggregatesInput>
    OR?: Enumerable<wallet_order_tblScalarWhereWithAggregatesInput>
    NOT?: Enumerable<wallet_order_tblScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: BigIntWithAggregatesFilter | bigint | number
    user_id?: IntWithAggregatesFilter | number
    cart_type?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
    subtotal?: IntWithAggregatesFilter | number
    service_tax?: IntWithAggregatesFilter | number
    net_total?: IntWithAggregatesFilter | number
    discount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type wallet_transaction_typeWhereInput = {
    AND?: Enumerable<wallet_transaction_typeWhereInput>
    OR?: Enumerable<wallet_transaction_typeWhereInput>
    NOT?: Enumerable<wallet_transaction_typeWhereInput>
    transaction_type?: IntFilter | number
    transaction_value?: StringFilter | string
  }

  export type wallet_transaction_typeOrderByWithRelationInput = {
    transaction_type?: SortOrder
    transaction_value?: SortOrder
  }

  export type wallet_transaction_typeWhereUniqueInput = {
    transaction_type?: number
  }

  export type wallet_transaction_typeOrderByWithAggregationInput = {
    transaction_type?: SortOrder
    transaction_value?: SortOrder
    _count?: wallet_transaction_typeCountOrderByAggregateInput
    _avg?: wallet_transaction_typeAvgOrderByAggregateInput
    _max?: wallet_transaction_typeMaxOrderByAggregateInput
    _min?: wallet_transaction_typeMinOrderByAggregateInput
    _sum?: wallet_transaction_typeSumOrderByAggregateInput
  }

  export type wallet_transaction_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<wallet_transaction_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<wallet_transaction_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<wallet_transaction_typeScalarWhereWithAggregatesInput>
    transaction_type?: IntWithAggregatesFilter | number
    transaction_value?: StringWithAggregatesFilter | string
  }

  export type wishlistWhereInput = {
    AND?: Enumerable<wishlistWhereInput>
    OR?: Enumerable<wishlistWhereInput>
    NOT?: Enumerable<wishlistWhereInput>
    id?: IntFilter | number
    book_id?: IntFilter | number
    user_id?: IntFilter | number
    date_created?: DateTimeFilter | Date | string
  }

  export type wishlistOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type wishlistWhereUniqueInput = {
    id?: number
  }

  export type wishlistOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
    _count?: wishlistCountOrderByAggregateInput
    _avg?: wishlistAvgOrderByAggregateInput
    _max?: wishlistMaxOrderByAggregateInput
    _min?: wishlistMinOrderByAggregateInput
    _sum?: wishlistSumOrderByAggregateInput
  }

  export type wishlistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    OR?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<wishlistScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    book_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type amazon_booksCreateInput = {
    activate?: number | null
    reference_id: string
    print_book_isbn?: string | null
    eisbn?: string | null
    imprint?: string | null
    title: string
    author: string
    editors?: string | null
    illustrators?: string | null
    contributors?: string | null
    translators?: string | null
    photographers?: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date | string
    publishing_date?: Date | string | null
    description?: string | null
    bisac?: string | null
    bic?: string | null
    territory?: string | null
    exclude_territory?: string | null
    adult_flag?: string | null
    edition?: number | null
    series_title?: string | null
    series_number?: number | null
    volume?: number | null
    keywords?: string | null
    asin: string
    amazon_url?: string | null
    book: book_tblCreateNestedOneWithoutAmazonBookIdInput
    author_id: number
    copyright_owner?: number | null
    language_id: number
    status?: number | null
    ku_enabled?: number | null
    ku_activation_date?: Date | string | null
    ku_us_enabled?: number | null
    ku_uk_enabled?: number | null
  }

  export type amazon_booksUncheckedCreateInput = {
    id?: number
    activate?: number | null
    reference_id: string
    print_book_isbn?: string | null
    eisbn?: string | null
    imprint?: string | null
    title: string
    author: string
    editors?: string | null
    illustrators?: string | null
    contributors?: string | null
    translators?: string | null
    photographers?: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date | string
    publishing_date?: Date | string | null
    description?: string | null
    bisac?: string | null
    bic?: string | null
    territory?: string | null
    exclude_territory?: string | null
    adult_flag?: string | null
    edition?: number | null
    series_title?: string | null
    series_number?: number | null
    volume?: number | null
    keywords?: string | null
    asin: string
    amazon_url?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    status?: number | null
    ku_enabled?: number | null
    ku_activation_date?: Date | string | null
    ku_us_enabled?: number | null
    ku_uk_enabled?: number | null
  }

  export type amazon_booksUpdateInput = {
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_tblUpdateOneRequiredWithoutAmazonBookIdNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type amazon_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type amazon_booksCreateManyInput = {
    id?: number
    activate?: number | null
    reference_id: string
    print_book_isbn?: string | null
    eisbn?: string | null
    imprint?: string | null
    title: string
    author: string
    editors?: string | null
    illustrators?: string | null
    contributors?: string | null
    translators?: string | null
    photographers?: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date | string
    publishing_date?: Date | string | null
    description?: string | null
    bisac?: string | null
    bic?: string | null
    territory?: string | null
    exclude_territory?: string | null
    adult_flag?: string | null
    edition?: number | null
    series_title?: string | null
    series_number?: number | null
    volume?: number | null
    keywords?: string | null
    asin: string
    amazon_url?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    status?: number | null
    ku_enabled?: number | null
    ku_activation_date?: Date | string | null
    ku_us_enabled?: number | null
    ku_uk_enabled?: number | null
  }

  export type amazon_booksUpdateManyMutationInput = {
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type amazon_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type amazon_transactionsCreateInput = {
    invoice_date: Date | string
    original_invoice_date?: Date | string | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    book: book_tblCreateNestedOneWithoutAmazon_transactionsInput
    author_id: number
    user_id?: number | null
    copyright_owner?: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value?: number | null
    final_royalty_value: number
    status: string
  }

  export type amazon_transactionsUncheckedCreateInput = {
    id?: number
    invoice_date: Date | string
    original_invoice_date?: Date | string | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    book_id: number
    author_id: number
    user_id?: number | null
    copyright_owner?: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value?: number | null
    final_royalty_value: number
    status: string
  }

  export type amazon_transactionsUpdateInput = {
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    book?: book_tblUpdateOneRequiredWithoutAmazon_transactionsNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type amazon_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type amazon_transactionsCreateManyInput = {
    id?: number
    invoice_date: Date | string
    original_invoice_date?: Date | string | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    book_id: number
    author_id: number
    user_id?: number | null
    copyright_owner?: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value?: number | null
    final_royalty_value: number
    status: string
  }

  export type amazon_transactionsUpdateManyMutationInput = {
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type amazon_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type audible_booksCreateInput = {
    product_id?: string | null
    audible_asin?: string | null
    amazon_asin?: string | null
    title?: string | null
    authors?: string | null
    narrators?: string | null
    first_online_date?: Date | string | null
    language_id?: number | null
    book: book_tblCreateNestedOneWithoutAudibleBookIdInput
    author_id?: number | null
    copyright_owner?: number | null
  }

  export type audible_booksUncheckedCreateInput = {
    id?: number
    product_id?: string | null
    audible_asin?: string | null
    amazon_asin?: string | null
    title?: string | null
    authors?: string | null
    narrators?: string | null
    first_online_date?: Date | string | null
    language_id?: number | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
  }

  export type audible_booksUpdateInput = {
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    book?: book_tblUpdateOneRequiredWithoutAudibleBookIdNestedInput
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_booksCreateManyInput = {
    id?: number
    product_id?: string | null
    audible_asin?: string | null
    amazon_asin?: string | null
    title?: string | null
    authors?: string | null
    narrators?: string | null
    first_online_date?: Date | string | null
    language_id?: number | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
  }

  export type audible_booksUpdateManyMutationInput = {
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_transactionsCreateInput = {
    royalty_earner?: string | null
    parent_product_id?: string | null
    name?: string | null
    author?: string | null
    isbn?: string | null
    provider_product_id?: string | null
    market_place?: string | null
    offer?: string | null
    royalty_rate?: string | null
    alc_qty?: number | null
    alc_net_sales?: number | null
    alc_royalty?: number | null
    al_qty?: number | null
    al_net_sales?: number | null
    al_royalty?: number | null
    alop_qty?: number | null
    alop_net_sales?: number | null
    alop_royalty?: number | null
    total_qty?: number | null
    total_net_sales?: number | null
    total_royalty?: number | null
    book: book_tblCreateNestedOneWithoutAudible_transactionsInput
    author_id?: number | null
    language_id?: number | null
    copyright_owner?: number | null
    user_id?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type audible_transactionsUncheckedCreateInput = {
    id?: number
    royalty_earner?: string | null
    parent_product_id?: string | null
    name?: string | null
    author?: string | null
    isbn?: string | null
    provider_product_id?: string | null
    market_place?: string | null
    offer?: string | null
    royalty_rate?: string | null
    alc_qty?: number | null
    alc_net_sales?: number | null
    alc_royalty?: number | null
    al_qty?: number | null
    al_net_sales?: number | null
    al_royalty?: number | null
    alop_qty?: number | null
    alop_net_sales?: number | null
    alop_royalty?: number | null
    total_qty?: number | null
    total_net_sales?: number | null
    total_royalty?: number | null
    book_id: number
    author_id?: number | null
    language_id?: number | null
    copyright_owner?: number | null
    user_id?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type audible_transactionsUpdateInput = {
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    book?: book_tblUpdateOneRequiredWithoutAudible_transactionsNestedInput
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audible_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audible_transactionsCreateManyInput = {
    id?: number
    royalty_earner?: string | null
    parent_product_id?: string | null
    name?: string | null
    author?: string | null
    isbn?: string | null
    provider_product_id?: string | null
    market_place?: string | null
    offer?: string | null
    royalty_rate?: string | null
    alc_qty?: number | null
    alc_net_sales?: number | null
    alc_royalty?: number | null
    al_qty?: number | null
    al_net_sales?: number | null
    al_royalty?: number | null
    alop_qty?: number | null
    alop_net_sales?: number | null
    alop_royalty?: number | null
    total_qty?: number | null
    total_net_sales?: number | null
    total_royalty?: number | null
    book_id: number
    author_id?: number | null
    language_id?: number | null
    copyright_owner?: number | null
    user_id?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type audible_transactionsUpdateManyMutationInput = {
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audible_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audio_book_detailsCreateInput = {
    book_id?: number | null
    chapter_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_url?: string | null
    chapter_duration?: string | null
    created_at?: Date | string | null
  }

  export type audio_book_detailsUncheckedCreateInput = {
    id?: number
    book_id?: number | null
    chapter_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_url?: string | null
    chapter_duration?: string | null
    created_at?: Date | string | null
  }

  export type audio_book_detailsUpdateInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_duration?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audio_book_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_duration?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audio_book_detailsCreateManyInput = {
    id?: number
    book_id?: number | null
    chapter_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_url?: string | null
    chapter_duration?: string | null
    created_at?: Date | string | null
  }

  export type audio_book_detailsUpdateManyMutationInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_duration?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audio_book_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_duration?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type author_gift_booksCreateInput = {
    author_id?: number | null
    book_id?: number | null
    date?: Date | string | null
    book: book_tblCreateNestedOneWithoutGiftBooksInput
    user: users_tblCreateNestedOneWithoutGiftBooksInput
  }

  export type author_gift_booksUncheckedCreateInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    user_id: number
    date?: Date | string | null
    bookId: number
  }

  export type author_gift_booksUpdateInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: book_tblUpdateOneRequiredWithoutGiftBooksNestedInput
    user?: users_tblUpdateOneRequiredWithoutGiftBooksNestedInput
  }

  export type author_gift_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
  }

  export type author_gift_booksCreateManyInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    user_id: number
    date?: Date | string | null
    bookId: number
  }

  export type author_gift_booksUpdateManyMutationInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type author_gift_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
  }

  export type author_languageCreateInput = {
    author_id?: number | null
    language: language_tblCreateNestedOneWithoutAuthorLanguagesInput
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type author_languageUncheckedCreateInput = {
    id?: number
    author_id?: number | null
    language_id: number
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type author_languageUpdateInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language?: language_tblUpdateOneRequiredWithoutAuthorLanguagesNestedInput
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_languageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_languageCreateManyInput = {
    id?: number
    author_id?: number | null
    language_id: number
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type author_languageUpdateManyMutationInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_languageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_royalty_detailsCreateInput = {
    copyright_owner?: number | null
    author_id?: number | null
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    settlement_date?: Date | string | null
    bank_transaction_details?: string | null
  }

  export type author_royalty_detailsUncheckedCreateInput = {
    id?: number
    copyright_owner?: number | null
    author_id?: number | null
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    settlement_date?: Date | string | null
    bank_transaction_details?: string | null
  }

  export type author_royalty_detailsUpdateInput = {
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    settlement_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank_transaction_details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_royalty_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    settlement_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank_transaction_details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_royalty_detailsCreateManyInput = {
    id?: number
    copyright_owner?: number | null
    author_id?: number | null
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    settlement_date?: Date | string | null
    bank_transaction_details?: string | null
  }

  export type author_royalty_detailsUpdateManyMutationInput = {
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    settlement_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank_transaction_details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_royalty_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    settlement_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank_transaction_details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_tblCreateInput = {
    author_name: string
    url_name?: string | null
    author_type?: number | null
    author_image?: string | null
    copy_right_owner_name: string
    relationship: string
    mobile?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    fb_url?: string | null
    twitter_url?: string | null
    blog_url?: string | null
    description?: string | null
    status?: number
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    gender: string
    copyright_owner?: number | null
    user_id: number
    narrator_id?: number | null
    amazon_link?: string | null
    pratilipi_link?: string | null
    audible_link?: string | null
    odilo_link?: string | null
    scribd_link?: string | null
    googlebooks_link?: string | null
    storytel_link?: string | null
    overdrive_link?: string | null
    pinterest_link?: string | null
    agreement_details?: string | null
    agreement_ebook_count?: number | null
    agreement_audiobook_count?: number | null
    agreement_paperback_count?: number | null
  }

  export type author_tblUncheckedCreateInput = {
    author_id?: number
    author_name: string
    url_name?: string | null
    author_type?: number | null
    author_image?: string | null
    copy_right_owner_name: string
    relationship: string
    mobile?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    fb_url?: string | null
    twitter_url?: string | null
    blog_url?: string | null
    description?: string | null
    status?: number
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    gender: string
    copyright_owner?: number | null
    user_id: number
    narrator_id?: number | null
    amazon_link?: string | null
    pratilipi_link?: string | null
    audible_link?: string | null
    odilo_link?: string | null
    scribd_link?: string | null
    googlebooks_link?: string | null
    storytel_link?: string | null
    overdrive_link?: string | null
    pinterest_link?: string | null
    agreement_details?: string | null
    agreement_ebook_count?: number | null
    agreement_audiobook_count?: number | null
    agreement_paperback_count?: number | null
  }

  export type author_tblUpdateInput = {
    author_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    author_type?: NullableIntFieldUpdateOperationsInput | number | null
    author_image?: NullableStringFieldUpdateOperationsInput | string | null
    copy_right_owner_name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fb_url?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_url?: NullableStringFieldUpdateOperationsInput | string | null
    blog_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    amazon_link?: NullableStringFieldUpdateOperationsInput | string | null
    pratilipi_link?: NullableStringFieldUpdateOperationsInput | string | null
    audible_link?: NullableStringFieldUpdateOperationsInput | string | null
    odilo_link?: NullableStringFieldUpdateOperationsInput | string | null
    scribd_link?: NullableStringFieldUpdateOperationsInput | string | null
    googlebooks_link?: NullableStringFieldUpdateOperationsInput | string | null
    storytel_link?: NullableStringFieldUpdateOperationsInput | string | null
    overdrive_link?: NullableStringFieldUpdateOperationsInput | string | null
    pinterest_link?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_details?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_ebook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_audiobook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_paperback_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type author_tblUncheckedUpdateInput = {
    author_id?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    author_type?: NullableIntFieldUpdateOperationsInput | number | null
    author_image?: NullableStringFieldUpdateOperationsInput | string | null
    copy_right_owner_name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fb_url?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_url?: NullableStringFieldUpdateOperationsInput | string | null
    blog_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    amazon_link?: NullableStringFieldUpdateOperationsInput | string | null
    pratilipi_link?: NullableStringFieldUpdateOperationsInput | string | null
    audible_link?: NullableStringFieldUpdateOperationsInput | string | null
    odilo_link?: NullableStringFieldUpdateOperationsInput | string | null
    scribd_link?: NullableStringFieldUpdateOperationsInput | string | null
    googlebooks_link?: NullableStringFieldUpdateOperationsInput | string | null
    storytel_link?: NullableStringFieldUpdateOperationsInput | string | null
    overdrive_link?: NullableStringFieldUpdateOperationsInput | string | null
    pinterest_link?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_details?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_ebook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_audiobook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_paperback_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type author_tblCreateManyInput = {
    author_id?: number
    author_name: string
    url_name?: string | null
    author_type?: number | null
    author_image?: string | null
    copy_right_owner_name: string
    relationship: string
    mobile?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    fb_url?: string | null
    twitter_url?: string | null
    blog_url?: string | null
    description?: string | null
    status?: number
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    gender: string
    copyright_owner?: number | null
    user_id: number
    narrator_id?: number | null
    amazon_link?: string | null
    pratilipi_link?: string | null
    audible_link?: string | null
    odilo_link?: string | null
    scribd_link?: string | null
    googlebooks_link?: string | null
    storytel_link?: string | null
    overdrive_link?: string | null
    pinterest_link?: string | null
    agreement_details?: string | null
    agreement_ebook_count?: number | null
    agreement_audiobook_count?: number | null
    agreement_paperback_count?: number | null
  }

  export type author_tblUpdateManyMutationInput = {
    author_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    author_type?: NullableIntFieldUpdateOperationsInput | number | null
    author_image?: NullableStringFieldUpdateOperationsInput | string | null
    copy_right_owner_name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fb_url?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_url?: NullableStringFieldUpdateOperationsInput | string | null
    blog_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    amazon_link?: NullableStringFieldUpdateOperationsInput | string | null
    pratilipi_link?: NullableStringFieldUpdateOperationsInput | string | null
    audible_link?: NullableStringFieldUpdateOperationsInput | string | null
    odilo_link?: NullableStringFieldUpdateOperationsInput | string | null
    scribd_link?: NullableStringFieldUpdateOperationsInput | string | null
    googlebooks_link?: NullableStringFieldUpdateOperationsInput | string | null
    storytel_link?: NullableStringFieldUpdateOperationsInput | string | null
    overdrive_link?: NullableStringFieldUpdateOperationsInput | string | null
    pinterest_link?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_details?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_ebook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_audiobook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_paperback_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type author_tblUncheckedUpdateManyInput = {
    author_id?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    author_type?: NullableIntFieldUpdateOperationsInput | number | null
    author_image?: NullableStringFieldUpdateOperationsInput | string | null
    copy_right_owner_name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fb_url?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_url?: NullableStringFieldUpdateOperationsInput | string | null
    blog_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    amazon_link?: NullableStringFieldUpdateOperationsInput | string | null
    pratilipi_link?: NullableStringFieldUpdateOperationsInput | string | null
    audible_link?: NullableStringFieldUpdateOperationsInput | string | null
    odilo_link?: NullableStringFieldUpdateOperationsInput | string | null
    scribd_link?: NullableStringFieldUpdateOperationsInput | string | null
    googlebooks_link?: NullableStringFieldUpdateOperationsInput | string | null
    storytel_link?: NullableStringFieldUpdateOperationsInput | string | null
    overdrive_link?: NullableStringFieldUpdateOperationsInput | string | null
    pinterest_link?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_details?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_ebook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_audiobook_count?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_paperback_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type author_transactionCreateInput = {
    order_id: bigint | number
    order_date?: Date | string | null
    book: book_tblCreateNestedOneWithoutAuthor_transactionInput
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner?: number | null
    currency?: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
  }

  export type author_transactionUncheckedCreateInput = {
    id?: number
    order_id: bigint | number
    order_date?: Date | string | null
    book_id: number
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner?: number | null
    currency?: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
  }

  export type author_transactionUpdateInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: book_tblUpdateOneRequiredWithoutAuthor_transactionNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type author_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type author_transactionCreateManyInput = {
    id?: number
    order_id: bigint | number
    order_date?: Date | string | null
    book_id: number
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner?: number | null
    currency?: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
  }

  export type author_transactionUpdateManyMutationInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type author_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type blog_commentsCreateInput = {
    user_id: number
    user_name: string
    blog_name: string
    comments: string
    email_id?: string | null
    status: number
    date_created?: Date | string
  }

  export type blog_commentsUncheckedCreateInput = {
    id?: number
    user_id: number
    user_name: string
    blog_name: string
    comments: string
    email_id?: string | null
    status: number
    date_created?: Date | string
  }

  export type blog_commentsUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    blog_name?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    blog_name?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_commentsCreateManyInput = {
    id?: number
    user_id: number
    user_name: string
    blog_name: string
    comments: string
    email_id?: string | null
    status: number
    date_created?: Date | string
  }

  export type blog_commentsUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    blog_name?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    blog_name?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_tblCreateInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblUpdateInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateManyInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
  }

  export type book_tblUpdateManyMutationInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type book_tblUncheckedUpdateManyInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type book_typesCreateInput = {
    type_name: string
    url_name: string
    status?: number
    created_at: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type book_typesUncheckedCreateInput = {
    book_type_id?: number
    type_name: string
    url_name: string
    status?: number
    created_at: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type book_typesUpdateInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_typesUncheckedUpdateInput = {
    book_type_id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_typesCreateManyInput = {
    book_type_id?: number
    type_name: string
    url_name: string
    status?: number
    created_at: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type book_typesUpdateManyMutationInput = {
    type_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_typesUncheckedUpdateManyInput = {
    book_type_id?: IntFieldUpdateOperationsInput | number
    type_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_metadataCreateInput = {
    book_id: number
    description: boolean
    type_of_book?: number
    content_type: string
    hard_copy_type: string
    soft_copy_type: string
    final_page_number: number
    allocated_date?: Date | string | null
    start_date?: Date | string | null
    completion_date?: Date | string | null
    payment_date: Date | string
    settled_page_number: number
    payment_status?: number
    assigned_by: number
    assigned_to: number
    price_per_page: number
    initial_page_number?: number | null
    general_file_path: string
    url_title: string
    unique_key: string
    pustaka_cover_status?: number
    general_cover_status?: number
    general_epub_status?: number
    pustaka_epub_status?: number
    amazon_epub_status?: number
    pustaka_flippdf_status?: number
    pustaka_word_status?: number
    priority: string
    current_state?: number | null
    remarks?: string | null
  }

  export type books_metadataUncheckedCreateInput = {
    id?: number
    book_id: number
    description: boolean
    type_of_book?: number
    content_type: string
    hard_copy_type: string
    soft_copy_type: string
    final_page_number: number
    allocated_date?: Date | string | null
    start_date?: Date | string | null
    completion_date?: Date | string | null
    payment_date: Date | string
    settled_page_number: number
    payment_status?: number
    assigned_by: number
    assigned_to: number
    price_per_page: number
    initial_page_number?: number | null
    general_file_path: string
    url_title: string
    unique_key: string
    pustaka_cover_status?: number
    general_cover_status?: number
    general_epub_status?: number
    pustaka_epub_status?: number
    amazon_epub_status?: number
    pustaka_flippdf_status?: number
    pustaka_word_status?: number
    priority: string
    current_state?: number | null
    remarks?: string | null
  }

  export type books_metadataUpdateInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    description?: BoolFieldUpdateOperationsInput | boolean
    type_of_book?: IntFieldUpdateOperationsInput | number
    content_type?: StringFieldUpdateOperationsInput | string
    hard_copy_type?: StringFieldUpdateOperationsInput | string
    soft_copy_type?: StringFieldUpdateOperationsInput | string
    final_page_number?: IntFieldUpdateOperationsInput | number
    allocated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settled_page_number?: IntFieldUpdateOperationsInput | number
    payment_status?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: IntFieldUpdateOperationsInput | number
    price_per_page?: FloatFieldUpdateOperationsInput | number
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    general_file_path?: StringFieldUpdateOperationsInput | string
    url_title?: StringFieldUpdateOperationsInput | string
    unique_key?: StringFieldUpdateOperationsInput | string
    pustaka_cover_status?: IntFieldUpdateOperationsInput | number
    general_cover_status?: IntFieldUpdateOperationsInput | number
    general_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_epub_status?: IntFieldUpdateOperationsInput | number
    amazon_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_flippdf_status?: IntFieldUpdateOperationsInput | number
    pustaka_word_status?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    current_state?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_metadataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    description?: BoolFieldUpdateOperationsInput | boolean
    type_of_book?: IntFieldUpdateOperationsInput | number
    content_type?: StringFieldUpdateOperationsInput | string
    hard_copy_type?: StringFieldUpdateOperationsInput | string
    soft_copy_type?: StringFieldUpdateOperationsInput | string
    final_page_number?: IntFieldUpdateOperationsInput | number
    allocated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settled_page_number?: IntFieldUpdateOperationsInput | number
    payment_status?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: IntFieldUpdateOperationsInput | number
    price_per_page?: FloatFieldUpdateOperationsInput | number
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    general_file_path?: StringFieldUpdateOperationsInput | string
    url_title?: StringFieldUpdateOperationsInput | string
    unique_key?: StringFieldUpdateOperationsInput | string
    pustaka_cover_status?: IntFieldUpdateOperationsInput | number
    general_cover_status?: IntFieldUpdateOperationsInput | number
    general_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_epub_status?: IntFieldUpdateOperationsInput | number
    amazon_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_flippdf_status?: IntFieldUpdateOperationsInput | number
    pustaka_word_status?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    current_state?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_metadataCreateManyInput = {
    id?: number
    book_id: number
    description: boolean
    type_of_book?: number
    content_type: string
    hard_copy_type: string
    soft_copy_type: string
    final_page_number: number
    allocated_date?: Date | string | null
    start_date?: Date | string | null
    completion_date?: Date | string | null
    payment_date: Date | string
    settled_page_number: number
    payment_status?: number
    assigned_by: number
    assigned_to: number
    price_per_page: number
    initial_page_number?: number | null
    general_file_path: string
    url_title: string
    unique_key: string
    pustaka_cover_status?: number
    general_cover_status?: number
    general_epub_status?: number
    pustaka_epub_status?: number
    amazon_epub_status?: number
    pustaka_flippdf_status?: number
    pustaka_word_status?: number
    priority: string
    current_state?: number | null
    remarks?: string | null
  }

  export type books_metadataUpdateManyMutationInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    description?: BoolFieldUpdateOperationsInput | boolean
    type_of_book?: IntFieldUpdateOperationsInput | number
    content_type?: StringFieldUpdateOperationsInput | string
    hard_copy_type?: StringFieldUpdateOperationsInput | string
    soft_copy_type?: StringFieldUpdateOperationsInput | string
    final_page_number?: IntFieldUpdateOperationsInput | number
    allocated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settled_page_number?: IntFieldUpdateOperationsInput | number
    payment_status?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: IntFieldUpdateOperationsInput | number
    price_per_page?: FloatFieldUpdateOperationsInput | number
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    general_file_path?: StringFieldUpdateOperationsInput | string
    url_title?: StringFieldUpdateOperationsInput | string
    unique_key?: StringFieldUpdateOperationsInput | string
    pustaka_cover_status?: IntFieldUpdateOperationsInput | number
    general_cover_status?: IntFieldUpdateOperationsInput | number
    general_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_epub_status?: IntFieldUpdateOperationsInput | number
    amazon_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_flippdf_status?: IntFieldUpdateOperationsInput | number
    pustaka_word_status?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    current_state?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_metadataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    description?: BoolFieldUpdateOperationsInput | boolean
    type_of_book?: IntFieldUpdateOperationsInput | number
    content_type?: StringFieldUpdateOperationsInput | string
    hard_copy_type?: StringFieldUpdateOperationsInput | string
    soft_copy_type?: StringFieldUpdateOperationsInput | string
    final_page_number?: IntFieldUpdateOperationsInput | number
    allocated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settled_page_number?: IntFieldUpdateOperationsInput | number
    payment_status?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: IntFieldUpdateOperationsInput | number
    price_per_page?: FloatFieldUpdateOperationsInput | number
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    general_file_path?: StringFieldUpdateOperationsInput | string
    url_title?: StringFieldUpdateOperationsInput | string
    unique_key?: StringFieldUpdateOperationsInput | string
    pustaka_cover_status?: IntFieldUpdateOperationsInput | number
    general_cover_status?: IntFieldUpdateOperationsInput | number
    general_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_epub_status?: IntFieldUpdateOperationsInput | number
    amazon_epub_status?: IntFieldUpdateOperationsInput | number
    pustaka_flippdf_status?: IntFieldUpdateOperationsInput | number
    pustaka_word_status?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    current_state?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_processingCreateInput = {
    book_id?: number | null
    stage_id?: number | null
    type_of_book?: string | null
    content_type?: string | null
    hard_copy_type?: string | null
    soft_copy_type?: string | null
    initial_page_number?: number | null
    pustaka_cover_status?: number | null
    pustaka_epub_status?: number | null
    pustaka_flippdf_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type books_processingUncheckedCreateInput = {
    id?: number
    book_id?: number | null
    stage_id?: number | null
    type_of_book?: string | null
    content_type?: string | null
    hard_copy_type?: string | null
    soft_copy_type?: string | null
    initial_page_number?: number | null
    pustaka_cover_status?: number | null
    pustaka_epub_status?: number | null
    pustaka_flippdf_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type books_processingUpdateInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    hard_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    soft_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_epub_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_flippdf_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type books_processingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    hard_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    soft_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_epub_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_flippdf_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type books_processingCreateManyInput = {
    id?: number
    book_id?: number | null
    stage_id?: number | null
    type_of_book?: string | null
    content_type?: string | null
    hard_copy_type?: string | null
    soft_copy_type?: string | null
    initial_page_number?: number | null
    pustaka_cover_status?: number | null
    pustaka_epub_status?: number | null
    pustaka_flippdf_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type books_processingUpdateManyMutationInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    hard_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    soft_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_epub_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_flippdf_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type books_processingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    hard_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    soft_copy_type?: NullableStringFieldUpdateOperationsInput | string | null
    initial_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_epub_status?: NullableIntFieldUpdateOperationsInput | number | null
    pustaka_flippdf_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type books_progressCreateInput = {
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
  }

  export type books_progressUncheckedCreateInput = {
    id?: number
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
  }

  export type books_progressUpdateInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_progressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_progressCreateManyInput = {
    id?: number
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
  }

  export type books_progressUpdateManyMutationInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type books_progressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contact_usCreateInput = {
    user_id?: number | null
    subject?: string | null
    message?: string | null
    date_created?: Date | string | null
  }

  export type contact_usUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    subject?: string | null
    message?: string | null
    date_created?: Date | string | null
  }

  export type contact_usUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_usUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_usCreateManyInput = {
    id?: number
    user_id?: number | null
    subject?: string | null
    message?: string | null
    date_created?: Date | string | null
  }

  export type contact_usUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contact_usUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type copyright_mappingCreateInput = {
    copyright_owner?: number | null
    author_id?: number | null
    date_created?: Date | string | null
  }

  export type copyright_mappingUncheckedCreateInput = {
    id?: number
    copyright_owner?: number | null
    author_id?: number | null
    date_created?: Date | string | null
  }

  export type copyright_mappingUpdateInput = {
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type copyright_mappingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type copyright_mappingCreateManyInput = {
    id?: number
    copyright_owner?: number | null
    author_id?: number | null
    date_created?: Date | string | null
  }

  export type copyright_mappingUpdateManyMutationInput = {
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type copyright_mappingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_detailsCreateInput = {
    episode_book_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_epub_url?: string | null
    chapter_num_pages?: number | null
    chapter_status?: number | null
    chapter_activated_at?: Date | string | null
  }

  export type episode_book_detailsUncheckedCreateInput = {
    id?: number
    episode_book_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_epub_url?: string | null
    chapter_num_pages?: number | null
    chapter_status?: number | null
    chapter_activated_at?: Date | string | null
  }

  export type episode_book_detailsUpdateInput = {
    episode_book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_num_pages?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_status?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    episode_book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_num_pages?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_status?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_detailsCreateManyInput = {
    id?: number
    episode_book_id?: number | null
    chapter_name?: string | null
    chapter_name_english?: string | null
    chapter_epub_url?: string | null
    chapter_num_pages?: number | null
    chapter_status?: number | null
    chapter_activated_at?: Date | string | null
  }

  export type episode_book_detailsUpdateManyMutationInput = {
    episode_book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_num_pages?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_status?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    episode_book_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_name?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_name_english?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    chapter_num_pages?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_status?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_tblCreateInput = {
    book_title?: string | null
    author_id?: number | null
    url_name?: string | null
    cover_image?: string | null
    regional_book_title?: string | null
    language?: number | null
    type_of_book?: number | null
    genre_id?: number | null
    book_category?: string | null
    description?: string | null
    status?: number | null
    day_of_chapter?: string | null
    activated_at?: Date | string | null
  }

  export type episode_book_tblUncheckedCreateInput = {
    episode_book_id?: number
    book_title?: string | null
    author_id?: number | null
    url_name?: string | null
    cover_image?: string | null
    regional_book_title?: string | null
    language?: number | null
    type_of_book?: number | null
    genre_id?: number | null
    book_category?: string | null
    description?: string | null
    status?: number | null
    day_of_chapter?: string | null
    activated_at?: Date | string | null
  }

  export type episode_book_tblUpdateInput = {
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    day_of_chapter?: NullableStringFieldUpdateOperationsInput | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_tblUncheckedUpdateInput = {
    episode_book_id?: IntFieldUpdateOperationsInput | number
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    day_of_chapter?: NullableStringFieldUpdateOperationsInput | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_tblCreateManyInput = {
    episode_book_id?: number
    book_title?: string | null
    author_id?: number | null
    url_name?: string | null
    cover_image?: string | null
    regional_book_title?: string | null
    language?: number | null
    type_of_book?: number | null
    genre_id?: number | null
    book_category?: string | null
    description?: string | null
    status?: number | null
    day_of_chapter?: string | null
    activated_at?: Date | string | null
  }

  export type episode_book_tblUpdateManyMutationInput = {
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    day_of_chapter?: NullableStringFieldUpdateOperationsInput | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type episode_book_tblUncheckedUpdateManyInput = {
    episode_book_id?: IntFieldUpdateOperationsInput | number
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    day_of_chapter?: NullableStringFieldUpdateOperationsInput | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fixed_royaltyCreateInput = {
    transaction_date?: Date | string | null
    user_id?: number | null
    copyright_owner?: number | null
    fixed_royalty_value?: number | null
    author_id?: number | null
    status?: number | null
  }

  export type fixed_royaltyUncheckedCreateInput = {
    id?: number
    transaction_date?: Date | string | null
    user_id?: number | null
    copyright_owner?: number | null
    fixed_royalty_value?: number | null
    author_id?: number | null
    status?: number | null
  }

  export type fixed_royaltyUpdateInput = {
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_royalty_value?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fixed_royaltyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_royalty_value?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fixed_royaltyCreateManyInput = {
    id?: number
    transaction_date?: Date | string | null
    user_id?: number | null
    copyright_owner?: number | null
    fixed_royalty_value?: number | null
    author_id?: number | null
    status?: number | null
  }

  export type fixed_royaltyUpdateManyMutationInput = {
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_royalty_value?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fixed_royaltyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_royalty_value?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type free_book_subscriptionCreateInput = {
    user_id: bigint | number
    book_id: bigint | number
    date_subscribed?: Date | string
    comments: string
  }

  export type free_book_subscriptionUncheckedCreateInput = {
    seq_id?: number
    user_id: bigint | number
    book_id: bigint | number
    date_subscribed?: Date | string
    comments: string
  }

  export type free_book_subscriptionUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    book_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_subscribed?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type free_book_subscriptionUncheckedUpdateInput = {
    seq_id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    book_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_subscribed?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type free_book_subscriptionCreateManyInput = {
    seq_id?: number
    user_id: bigint | number
    book_id: bigint | number
    date_subscribed?: Date | string
    comments: string
  }

  export type free_book_subscriptionUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    book_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_subscribed?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type free_book_subscriptionUncheckedUpdateManyInput = {
    seq_id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    book_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_subscribed?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type genre_details_tblCreateInput = {
    admin_id: number
    genre_name: string
    url_name: string
    lang_0?: string | null
    lang_1?: string
    lang_2?: string
    lang_3?: string
    lang_4?: string
    lang_5?: string | null
    status?: number
    bisac_code?: string | null
    image_url?: string | null
    books?: book_tblCreateNestedManyWithoutGenreInput
  }

  export type genre_details_tblUncheckedCreateInput = {
    genre_id?: number
    admin_id: number
    genre_name: string
    url_name: string
    lang_0?: string | null
    lang_1?: string
    lang_2?: string
    lang_3?: string
    lang_4?: string
    lang_5?: string | null
    status?: number
    bisac_code?: string | null
    image_url?: string | null
    books?: book_tblUncheckedCreateNestedManyWithoutGenreInput
  }

  export type genre_details_tblUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    books?: book_tblUpdateManyWithoutGenreNestedInput
  }

  export type genre_details_tblUncheckedUpdateInput = {
    genre_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    books?: book_tblUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type genre_details_tblCreateManyInput = {
    genre_id?: number
    admin_id: number
    genre_name: string
    url_name: string
    lang_0?: string | null
    lang_1?: string
    lang_2?: string
    lang_3?: string
    lang_4?: string
    lang_5?: string | null
    status?: number
    bisac_code?: string | null
    image_url?: string | null
  }

  export type genre_details_tblUpdateManyMutationInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type genre_details_tblUncheckedUpdateManyInput = {
    genre_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type google_booksCreateInput = {
    identifier?: string | null
    status?: string | null
    label?: string | null
    play_store_link?: string | null
    enable_for_sale?: boolean | null
    title?: string | null
    subtitle?: string | null
    book_format?: string | null
    related_identifier?: string | null
    contributor?: string | null
    biographical_note?: string | null
    language?: string | null
    subject_code?: string | null
    age_group?: string | null
    description?: string | null
    publication_date?: string | null
    page_count?: number | null
    series_name?: string | null
    volume_in_series?: number | null
    preview_type?: string | null
    preview_territories?: string | null
    buy_link_text?: string | null
    buy_link?: string | null
    publisher_name?: string | null
    publisher_website?: string | null
    show_photos_preview?: boolean | null
    pdf_download?: boolean | null
    on_sale_date?: string | null
    drm_enabled?: boolean | null
    show_photos_ebook?: boolean | null
    include_scanned_pages?: boolean | null
    mature_audiences?: boolean | null
    copy_paste_percentage?: string | null
    enable_school_use?: boolean | null
    school_list_price_60?: number | null
    school_list_price_180?: number | null
    school_list_price_360?: number | null
    school_use_countries?: string | null
    duration?: Date | string | null
    preview_length_minutes?: number | null
    preview_length_percentage?: number | null
    abridged_version?: string | null
    inr_price_including_tax?: number | null
    inr_countries_including_tax?: string | null
    usd_price_including_tax?: number | null
    usd_countries_including_tax?: string | null
    inr_price_excluding_tax?: number | null
    inr_countries_excluding_tax?: string | null
    usd_price_excluding_tax?: number | null
    usd_countries_excluding_tax?: string | null
    eur_price_including_tax?: number | null
    eur_price_excluding_tax?: number | null
    eur_countries_including_tax?: string | null
    eur_countries_excluding_tax?: string | null
    book: book_tblCreateNestedOneWithoutGoogleBookIdInput
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    publish_date?: Date | string | null
  }

  export type google_booksUncheckedCreateInput = {
    id?: number
    identifier?: string | null
    status?: string | null
    label?: string | null
    play_store_link?: string | null
    enable_for_sale?: boolean | null
    title?: string | null
    subtitle?: string | null
    book_format?: string | null
    related_identifier?: string | null
    contributor?: string | null
    biographical_note?: string | null
    language?: string | null
    subject_code?: string | null
    age_group?: string | null
    description?: string | null
    publication_date?: string | null
    page_count?: number | null
    series_name?: string | null
    volume_in_series?: number | null
    preview_type?: string | null
    preview_territories?: string | null
    buy_link_text?: string | null
    buy_link?: string | null
    publisher_name?: string | null
    publisher_website?: string | null
    show_photos_preview?: boolean | null
    pdf_download?: boolean | null
    on_sale_date?: string | null
    drm_enabled?: boolean | null
    show_photos_ebook?: boolean | null
    include_scanned_pages?: boolean | null
    mature_audiences?: boolean | null
    copy_paste_percentage?: string | null
    enable_school_use?: boolean | null
    school_list_price_60?: number | null
    school_list_price_180?: number | null
    school_list_price_360?: number | null
    school_use_countries?: string | null
    duration?: Date | string | null
    preview_length_minutes?: number | null
    preview_length_percentage?: number | null
    abridged_version?: string | null
    inr_price_including_tax?: number | null
    inr_countries_including_tax?: string | null
    usd_price_including_tax?: number | null
    usd_countries_including_tax?: string | null
    inr_price_excluding_tax?: number | null
    inr_countries_excluding_tax?: string | null
    usd_price_excluding_tax?: number | null
    usd_countries_excluding_tax?: string | null
    eur_price_including_tax?: number | null
    eur_price_excluding_tax?: number | null
    eur_countries_including_tax?: string | null
    eur_countries_excluding_tax?: string | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    publish_date?: Date | string | null
  }

  export type google_booksUpdateInput = {
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_tblUpdateOneRequiredWithoutGoogleBookIdNestedInput
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_booksCreateManyInput = {
    id?: number
    identifier?: string | null
    status?: string | null
    label?: string | null
    play_store_link?: string | null
    enable_for_sale?: boolean | null
    title?: string | null
    subtitle?: string | null
    book_format?: string | null
    related_identifier?: string | null
    contributor?: string | null
    biographical_note?: string | null
    language?: string | null
    subject_code?: string | null
    age_group?: string | null
    description?: string | null
    publication_date?: string | null
    page_count?: number | null
    series_name?: string | null
    volume_in_series?: number | null
    preview_type?: string | null
    preview_territories?: string | null
    buy_link_text?: string | null
    buy_link?: string | null
    publisher_name?: string | null
    publisher_website?: string | null
    show_photos_preview?: boolean | null
    pdf_download?: boolean | null
    on_sale_date?: string | null
    drm_enabled?: boolean | null
    show_photos_ebook?: boolean | null
    include_scanned_pages?: boolean | null
    mature_audiences?: boolean | null
    copy_paste_percentage?: string | null
    enable_school_use?: boolean | null
    school_list_price_60?: number | null
    school_list_price_180?: number | null
    school_list_price_360?: number | null
    school_use_countries?: string | null
    duration?: Date | string | null
    preview_length_minutes?: number | null
    preview_length_percentage?: number | null
    abridged_version?: string | null
    inr_price_including_tax?: number | null
    inr_countries_including_tax?: string | null
    usd_price_including_tax?: number | null
    usd_countries_including_tax?: string | null
    inr_price_excluding_tax?: number | null
    inr_countries_excluding_tax?: string | null
    usd_price_excluding_tax?: number | null
    usd_countries_excluding_tax?: string | null
    eur_price_including_tax?: number | null
    eur_price_excluding_tax?: number | null
    eur_countries_including_tax?: string | null
    eur_countries_excluding_tax?: string | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    publish_date?: Date | string | null
  }

  export type google_booksUpdateManyMutationInput = {
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_transactionsCreateInput = {
    earnings_date: Date | string
    transaction_date: Date | string
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    book: book_tblCreateNestedOneWithoutGoogle_transactionsInput
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status?: string | null
  }

  export type google_transactionsUncheckedCreateInput = {
    id?: number
    earnings_date: Date | string
    transaction_date: Date | string
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    book_id: number
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status?: string | null
  }

  export type google_transactionsUpdateInput = {
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    book?: book_tblUpdateOneRequiredWithoutGoogle_transactionsNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type google_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type google_transactionsCreateManyInput = {
    id?: number
    earnings_date: Date | string
    transaction_date: Date | string
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    book_id: number
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status?: string | null
  }

  export type google_transactionsUpdateManyMutationInput = {
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type google_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kobo_transactionCreateInput = {
    transaction_date: Date | string
    country: string
    state?: string | null
    zipcode?: string | null
    content_type?: string | null
    quantity?: number | null
    refund_reason?: string | null
    dealID?: string | null
    publisher_name?: string | null
    imprint?: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded?: number | null
    COGS_percentage: number
    COGS_amount?: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp?: number | null
    COGS_based_lp_excluded_tax?: number | null
    COGS_based_lp_currency?: number | null
    COGS_adjustment?: number | null
    net_due: number
    payable_currency: string
    total_tax?: number | null
    book: book_tblCreateNestedOneWithoutKobo_transactionInput
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type kobo_transactionUncheckedCreateInput = {
    id?: number
    transaction_date: Date | string
    country: string
    state?: string | null
    zipcode?: string | null
    content_type?: string | null
    quantity?: number | null
    refund_reason?: string | null
    dealID?: string | null
    publisher_name?: string | null
    imprint?: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded?: number | null
    COGS_percentage: number
    COGS_amount?: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp?: number | null
    COGS_based_lp_excluded_tax?: number | null
    COGS_based_lp_currency?: number | null
    COGS_adjustment?: number | null
    net_due: number
    payable_currency: string
    total_tax?: number | null
    book_id: number
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type kobo_transactionUpdateInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    book?: book_tblUpdateOneRequiredWithoutKobo_transactionNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type kobo_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type kobo_transactionCreateManyInput = {
    id?: number
    transaction_date: Date | string
    country: string
    state?: string | null
    zipcode?: string | null
    content_type?: string | null
    quantity?: number | null
    refund_reason?: string | null
    dealID?: string | null
    publisher_name?: string | null
    imprint?: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded?: number | null
    COGS_percentage: number
    COGS_amount?: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp?: number | null
    COGS_based_lp_excluded_tax?: number | null
    COGS_based_lp_currency?: number | null
    COGS_adjustment?: number | null
    net_due: number
    payable_currency: string
    total_tax?: number | null
    book_id: number
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type kobo_transactionUpdateManyMutationInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type kobo_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type language_tblCreateInput = {
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    books?: book_tblCreateNestedManyWithoutLanguage_tbl_relationInput
    authorLanguages?: author_languageCreateNestedManyWithoutLanguageInput
  }

  export type language_tblUncheckedCreateInput = {
    language_id?: number
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    books?: book_tblUncheckedCreateNestedManyWithoutLanguage_tbl_relationInput
    authorLanguages?: author_languageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type language_tblUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: book_tblUpdateManyWithoutLanguage_tbl_relationNestedInput
    authorLanguages?: author_languageUpdateManyWithoutLanguageNestedInput
  }

  export type language_tblUncheckedUpdateInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: book_tblUncheckedUpdateManyWithoutLanguage_tbl_relationNestedInput
    authorLanguages?: author_languageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type language_tblCreateManyInput = {
    language_id?: number
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
  }

  export type language_tblUpdateManyMutationInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type language_tblUncheckedUpdateManyInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ledger_head_tblCreateInput = {
    ledger_head_name: string
    date_created: Date | string
  }

  export type ledger_head_tblUncheckedCreateInput = {
    id?: number
    ledger_head_name: string
    date_created: Date | string
  }

  export type ledger_head_tblUpdateInput = {
    ledger_head_name?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ledger_head_tblUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledger_head_name?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ledger_head_tblCreateManyInput = {
    id?: number
    ledger_head_name: string
    date_created: Date | string
  }

  export type ledger_head_tblUpdateManyMutationInput = {
    ledger_head_name?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ledger_head_tblUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ledger_head_name?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type narrator_tblCreateInput = {
    narrator_name?: string | null
    narrator_url?: string | null
    narrator_image?: string | null
    mobile?: string | null
    email?: string | null
    description?: string | null
    status?: number | null
    user_id?: number | null
    image_alt_text?: string | null
    image_title_text?: string | null
    created_at?: Date | string | null
  }

  export type narrator_tblUncheckedCreateInput = {
    narrator_id?: number
    narrator_name?: string | null
    narrator_url?: string | null
    narrator_image?: string | null
    mobile?: string | null
    email?: string | null
    description?: string | null
    status?: number | null
    user_id?: number | null
    image_alt_text?: string | null
    image_title_text?: string | null
    created_at?: Date | string | null
  }

  export type narrator_tblUpdateInput = {
    narrator_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_url?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    image_title_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type narrator_tblUncheckedUpdateInput = {
    narrator_id?: IntFieldUpdateOperationsInput | number
    narrator_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_url?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    image_title_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type narrator_tblCreateManyInput = {
    narrator_id?: number
    narrator_name?: string | null
    narrator_url?: string | null
    narrator_image?: string | null
    mobile?: string | null
    email?: string | null
    description?: string | null
    status?: number | null
    user_id?: number | null
    image_alt_text?: string | null
    image_title_text?: string | null
    created_at?: Date | string | null
  }

  export type narrator_tblUpdateManyMutationInput = {
    narrator_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_url?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    image_title_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type narrator_tblUncheckedUpdateManyInput = {
    narrator_id?: IntFieldUpdateOperationsInput | number
    narrator_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_url?: NullableStringFieldUpdateOperationsInput | string | null
    narrator_image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    image_title_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offline_paymentCreateInput = {
    cart_type: number
    cart_items: string
    user_id: number
    amount: number
    currency: string
    date_created: Date | string
    status?: number
  }

  export type offline_paymentUncheckedCreateInput = {
    id?: number
    cart_type: number
    cart_items: string
    user_id: number
    amount: number
    currency: string
    date_created: Date | string
    status?: number
  }

  export type offline_paymentUpdateInput = {
    cart_type?: IntFieldUpdateOperationsInput | number
    cart_items?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type offline_paymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cart_type?: IntFieldUpdateOperationsInput | number
    cart_items?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type offline_paymentCreateManyInput = {
    id?: number
    cart_type: number
    cart_items: string
    user_id: number
    amount: number
    currency: string
    date_created: Date | string
    status?: number
  }

  export type offline_paymentUpdateManyMutationInput = {
    cart_type?: IntFieldUpdateOperationsInput | number
    cart_items?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type offline_paymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cart_type?: IntFieldUpdateOperationsInput | number
    cart_items?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type orderCreateInput = {
    order_id: bigint | number
    tracking_id: string
    bank_ref_no: number
    order_status: string
    failure_message?: string | null
    payment_mode?: string | null
    card_name?: string | null
    status_code?: string | null
    status_message?: string | null
    currency: string
    amount: number
    channel?: string | null
    billing_name?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_zip?: string | null
    billing_country?: string | null
    billing_tel?: string | null
    billing_email?: string | null
    delivery_name?: string | null
    delivery_address?: string | null
    delivery_city?: string | null
    delivery_state?: string | null
    delivery_zip?: string | null
    delivery_country?: string | null
    delivery_tel?: string | null
    user_id: number
    cart_type: string
    subtotal: number
    service_tax: number
    net_revenue?: number | null
    net_total: number
    date_created?: Date | string
    coupon_id?: string | null
    coupon_discount_amt?: Decimal | DecimalJsLike | number | string | null
  }

  export type orderUncheckedCreateInput = {
    id?: number
    order_id: bigint | number
    tracking_id: string
    bank_ref_no: number
    order_status: string
    failure_message?: string | null
    payment_mode?: string | null
    card_name?: string | null
    status_code?: string | null
    status_message?: string | null
    currency: string
    amount: number
    channel?: string | null
    billing_name?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_zip?: string | null
    billing_country?: string | null
    billing_tel?: string | null
    billing_email?: string | null
    delivery_name?: string | null
    delivery_address?: string | null
    delivery_city?: string | null
    delivery_state?: string | null
    delivery_zip?: string | null
    delivery_country?: string | null
    delivery_tel?: string | null
    user_id: number
    cart_type: string
    subtotal: number
    service_tax: number
    net_revenue?: number | null
    net_total: number
    date_created?: Date | string
    coupon_id?: string | null
    coupon_discount_amt?: Decimal | DecimalJsLike | number | string | null
  }

  export type orderUpdateInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tracking_id?: StringFieldUpdateOperationsInput | string
    bank_ref_no?: IntFieldUpdateOperationsInput | number
    order_status?: StringFieldUpdateOperationsInput | string
    failure_message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_mode?: NullableStringFieldUpdateOperationsInput | string | null
    card_name?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableStringFieldUpdateOperationsInput | string | null
    status_message?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_tel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_email?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_city?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_state?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_zip?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_country?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_tel?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    service_tax?: FloatFieldUpdateOperationsInput | number
    net_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    net_total?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_discount_amt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tracking_id?: StringFieldUpdateOperationsInput | string
    bank_ref_no?: IntFieldUpdateOperationsInput | number
    order_status?: StringFieldUpdateOperationsInput | string
    failure_message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_mode?: NullableStringFieldUpdateOperationsInput | string | null
    card_name?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableStringFieldUpdateOperationsInput | string | null
    status_message?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_tel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_email?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_city?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_state?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_zip?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_country?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_tel?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    service_tax?: FloatFieldUpdateOperationsInput | number
    net_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    net_total?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_discount_amt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type orderCreateManyInput = {
    id?: number
    order_id: bigint | number
    tracking_id: string
    bank_ref_no: number
    order_status: string
    failure_message?: string | null
    payment_mode?: string | null
    card_name?: string | null
    status_code?: string | null
    status_message?: string | null
    currency: string
    amount: number
    channel?: string | null
    billing_name?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_zip?: string | null
    billing_country?: string | null
    billing_tel?: string | null
    billing_email?: string | null
    delivery_name?: string | null
    delivery_address?: string | null
    delivery_city?: string | null
    delivery_state?: string | null
    delivery_zip?: string | null
    delivery_country?: string | null
    delivery_tel?: string | null
    user_id: number
    cart_type: string
    subtotal: number
    service_tax: number
    net_revenue?: number | null
    net_total: number
    date_created?: Date | string
    coupon_id?: string | null
    coupon_discount_amt?: Decimal | DecimalJsLike | number | string | null
  }

  export type orderUpdateManyMutationInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tracking_id?: StringFieldUpdateOperationsInput | string
    bank_ref_no?: IntFieldUpdateOperationsInput | number
    order_status?: StringFieldUpdateOperationsInput | string
    failure_message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_mode?: NullableStringFieldUpdateOperationsInput | string | null
    card_name?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableStringFieldUpdateOperationsInput | string | null
    status_message?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_tel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_email?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_city?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_state?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_zip?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_country?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_tel?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    service_tax?: FloatFieldUpdateOperationsInput | number
    net_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    net_total?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_discount_amt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tracking_id?: StringFieldUpdateOperationsInput | string
    bank_ref_no?: IntFieldUpdateOperationsInput | number
    order_status?: StringFieldUpdateOperationsInput | string
    failure_message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_mode?: NullableStringFieldUpdateOperationsInput | string | null
    card_name?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableStringFieldUpdateOperationsInput | string | null
    status_message?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_tel?: NullableStringFieldUpdateOperationsInput | string | null
    billing_email?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_city?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_state?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_zip?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_country?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_tel?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    service_tax?: FloatFieldUpdateOperationsInput | number
    net_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    net_total?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_discount_amt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type order_book_detailsCreateInput = {
    order_id: number
    user_id: number
    book_id: number
    book_cost?: number | null
    order_type: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    order_date: string
    rent_plan: number
    author_id: number
    language_id?: number | null
    copyright_owner?: number | null
    channel?: string | null
    status: number
    date_created?: Date | string
    user_ip?: string | null
  }

  export type order_book_detailsUncheckedCreateInput = {
    book_order_id?: number
    order_id: number
    user_id: number
    book_id: number
    book_cost?: number | null
    order_type: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    order_date: string
    rent_plan: number
    author_id: number
    language_id?: number | null
    copyright_owner?: number | null
    channel?: string | null
    status: number
    date_created?: Date | string
    user_ip?: string | null
  }

  export type order_book_detailsUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    book_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    order_type?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_date?: StringFieldUpdateOperationsInput | string
    rent_plan?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    user_ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_book_detailsUncheckedUpdateInput = {
    book_order_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    book_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    order_type?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_date?: StringFieldUpdateOperationsInput | string
    rent_plan?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    user_ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_book_detailsCreateManyInput = {
    book_order_id?: number
    order_id: number
    user_id: number
    book_id: number
    book_cost?: number | null
    order_type: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    order_date: string
    rent_plan: number
    author_id: number
    language_id?: number | null
    copyright_owner?: number | null
    channel?: string | null
    status: number
    date_created?: Date | string
    user_ip?: string | null
  }

  export type order_book_detailsUpdateManyMutationInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    book_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    order_type?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_date?: StringFieldUpdateOperationsInput | string
    rent_plan?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    user_ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_book_detailsUncheckedUpdateManyInput = {
    book_order_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    book_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    order_type?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_date?: StringFieldUpdateOperationsInput | string
    rent_plan?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    user_ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type overdrive_booksCreateInput = {
    overdrive_id: number
    catalogue_id: bigint | number
    isbn: bigint | number
    physical_isbn?: string | null
    title: string
    subtitle?: string | null
    edition?: number | null
    series?: number | null
    publisher: string
    imprint?: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date | string
    pub_date?: Date | string | null
    status: string
    sample_link: string
    readbox_enabled?: string | null
    special_features?: string | null
    book: book_tblCreateNestedOneWithoutOverdriveBookIdInput
    author_id: number
    copyright_owner?: number | null
    language_id: number
    type_of_book?: number | null
  }

  export type overdrive_booksUncheckedCreateInput = {
    id?: number
    overdrive_id: number
    catalogue_id: bigint | number
    isbn: bigint | number
    physical_isbn?: string | null
    title: string
    subtitle?: string | null
    edition?: number | null
    series?: number | null
    publisher: string
    imprint?: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date | string
    pub_date?: Date | string | null
    status: string
    sample_link: string
    readbox_enabled?: string | null
    special_features?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    type_of_book?: number | null
  }

  export type overdrive_booksUpdateInput = {
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_tblUpdateOneRequiredWithoutOverdriveBookIdNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_booksCreateManyInput = {
    id?: number
    overdrive_id: number
    catalogue_id: bigint | number
    isbn: bigint | number
    physical_isbn?: string | null
    title: string
    subtitle?: string | null
    edition?: number | null
    series?: number | null
    publisher: string
    imprint?: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date | string
    pub_date?: Date | string | null
    status: string
    sample_link: string
    readbox_enabled?: string | null
    special_features?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    type_of_book?: number | null
  }

  export type overdrive_booksUpdateManyMutationInput = {
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_transactionsCreateInput = {
    transaction_date: Date | string
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    book: book_tblCreateNestedOneWithoutOverdrive_transactionsInput
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type overdrive_transactionsUncheckedCreateInput = {
    id?: number
    transaction_date: Date | string
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    book_id: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type overdrive_transactionsUpdateInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    book?: book_tblUpdateOneRequiredWithoutOverdrive_transactionsNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type overdrive_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type overdrive_transactionsCreateManyInput = {
    id?: number
    transaction_date: Date | string
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    book_id: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type overdrive_transactionsUpdateManyMutationInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type overdrive_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type payout_sessionCreateInput = {
    session_data: string
    user_id: number
    order_id: bigint | number
  }

  export type payout_sessionUncheckedCreateInput = {
    session_id?: number
    session_data: string
    user_id: number
    order_id: bigint | number
  }

  export type payout_sessionUpdateInput = {
    session_data?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type payout_sessionUncheckedUpdateInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    session_data?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type payout_sessionCreateManyInput = {
    session_id?: number
    session_data: string
    user_id: number
    order_id: bigint | number
  }

  export type payout_sessionUpdateManyMutationInput = {
    session_data?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type payout_sessionUncheckedUpdateManyInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    session_data?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type plan_tblCreateInput = {
    plan_name: string
    plan_display_name?: string | null
    plan_url_name?: string | null
    plan_type?: number | null
    plan_image: string
    plan_cost?: number
    plan_caption?: string | null
    plan_cost_international?: number
    validity_days: number
    book_validity_days: number
    available_books: number
    discount: Decimal | DecimalJsLike | number | string
    plan_intro_date: Date | string
    status?: number
  }

  export type plan_tblUncheckedCreateInput = {
    plan_id?: number
    plan_name: string
    plan_display_name?: string | null
    plan_url_name?: string | null
    plan_type?: number | null
    plan_image: string
    plan_cost?: number
    plan_caption?: string | null
    plan_cost_international?: number
    validity_days: number
    book_validity_days: number
    available_books: number
    discount: Decimal | DecimalJsLike | number | string
    plan_intro_date: Date | string
    status?: number
  }

  export type plan_tblUpdateInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    plan_display_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    plan_image?: StringFieldUpdateOperationsInput | string
    plan_cost?: FloatFieldUpdateOperationsInput | number
    plan_caption?: NullableStringFieldUpdateOperationsInput | string | null
    plan_cost_international?: FloatFieldUpdateOperationsInput | number
    validity_days?: IntFieldUpdateOperationsInput | number
    book_validity_days?: IntFieldUpdateOperationsInput | number
    available_books?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type plan_tblUncheckedUpdateInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    plan_display_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    plan_image?: StringFieldUpdateOperationsInput | string
    plan_cost?: FloatFieldUpdateOperationsInput | number
    plan_caption?: NullableStringFieldUpdateOperationsInput | string | null
    plan_cost_international?: FloatFieldUpdateOperationsInput | number
    validity_days?: IntFieldUpdateOperationsInput | number
    book_validity_days?: IntFieldUpdateOperationsInput | number
    available_books?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type plan_tblCreateManyInput = {
    plan_id?: number
    plan_name: string
    plan_display_name?: string | null
    plan_url_name?: string | null
    plan_type?: number | null
    plan_image: string
    plan_cost?: number
    plan_caption?: string | null
    plan_cost_international?: number
    validity_days: number
    book_validity_days: number
    available_books: number
    discount: Decimal | DecimalJsLike | number | string
    plan_intro_date: Date | string
    status?: number
  }

  export type plan_tblUpdateManyMutationInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    plan_display_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    plan_image?: StringFieldUpdateOperationsInput | string
    plan_cost?: FloatFieldUpdateOperationsInput | number
    plan_caption?: NullableStringFieldUpdateOperationsInput | string | null
    plan_cost_international?: FloatFieldUpdateOperationsInput | number
    validity_days?: IntFieldUpdateOperationsInput | number
    book_validity_days?: IntFieldUpdateOperationsInput | number
    available_books?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type plan_tblUncheckedUpdateManyInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    plan_display_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    plan_image?: StringFieldUpdateOperationsInput | string
    plan_cost?: FloatFieldUpdateOperationsInput | number
    plan_caption?: NullableStringFieldUpdateOperationsInput | string | null
    plan_cost_international?: FloatFieldUpdateOperationsInput | number
    validity_days?: IntFieldUpdateOperationsInput | number
    book_validity_days?: IntFieldUpdateOperationsInput | number
    available_books?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plan_intro_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type pod_cost_notificationCreateInput = {
    user_id?: number | null
    book_id?: number | null
    date_created?: Date | string | null
    mail_status?: number | null
  }

  export type pod_cost_notificationUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    book_id?: number | null
    date_created?: Date | string | null
    mail_status?: number | null
  }

  export type pod_cost_notificationUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_cost_notificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_cost_notificationCreateManyInput = {
    id?: number
    user_id?: number | null
    book_id?: number | null
    date_created?: Date | string | null
    mail_status?: number | null
  }

  export type pod_cost_notificationUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_cost_notificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_orderCreateInput = {
    order_id?: number | null
    user_id?: string | null
    shipping_charges?: number | null
    discount?: number | null
    order_status?: number | null
    split_flag?: number | null
    tracking_id?: string | null
    tracking_url?: string | null
    order_date?: Date | string | null
  }

  export type pod_orderUncheckedCreateInput = {
    id?: number
    order_id?: number | null
    user_id?: string | null
    shipping_charges?: number | null
    discount?: number | null
    order_status?: number | null
    split_flag?: number | null
    tracking_id?: string | null
    tracking_url?: string | null
    order_date?: Date | string | null
  }

  export type pod_orderUpdateInput = {
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_charges?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    order_status?: NullableIntFieldUpdateOperationsInput | number | null
    split_flag?: NullableIntFieldUpdateOperationsInput | number | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_charges?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    order_status?: NullableIntFieldUpdateOperationsInput | number | null
    split_flag?: NullableIntFieldUpdateOperationsInput | number | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_orderCreateManyInput = {
    id?: number
    order_id?: number | null
    user_id?: string | null
    shipping_charges?: number | null
    discount?: number | null
    order_status?: number | null
    split_flag?: number | null
    tracking_id?: string | null
    tracking_url?: string | null
    order_date?: Date | string | null
  }

  export type pod_orderUpdateManyMutationInput = {
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_charges?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    order_status?: NullableIntFieldUpdateOperationsInput | number | null
    split_flag?: NullableIntFieldUpdateOperationsInput | number | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_charges?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableIntFieldUpdateOperationsInput | number | null
    order_status?: NullableIntFieldUpdateOperationsInput | number | null
    split_flag?: NullableIntFieldUpdateOperationsInput | number | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_order_detailsCreateInput = {
    order_id?: number | null
    user_id?: number | null
    book_id?: number | null
    quantity?: number | null
    wrapper_type?: number | null
    personalised_message?: string | null
    tracking_id?: string | null
    tracking_url?: string | null
    status?: number | null
    price?: number | null
    order_date?: Date | string | null
  }

  export type pod_order_detailsUncheckedCreateInput = {
    id?: number
    order_id?: number | null
    user_id?: number | null
    book_id?: number | null
    quantity?: number | null
    wrapper_type?: number | null
    personalised_message?: string | null
    tracking_id?: string | null
    tracking_url?: string | null
    status?: number | null
    price?: number | null
    order_date?: Date | string | null
  }

  export type pod_order_detailsUpdateInput = {
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    wrapper_type?: NullableIntFieldUpdateOperationsInput | number | null
    personalised_message?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_order_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    wrapper_type?: NullableIntFieldUpdateOperationsInput | number | null
    personalised_message?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_order_detailsCreateManyInput = {
    id?: number
    order_id?: number | null
    user_id?: number | null
    book_id?: number | null
    quantity?: number | null
    wrapper_type?: number | null
    personalised_message?: string | null
    tracking_id?: string | null
    tracking_url?: string | null
    status?: number | null
    price?: number | null
    order_date?: Date | string | null
  }

  export type pod_order_detailsUpdateManyMutationInput = {
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    wrapper_type?: NullableIntFieldUpdateOperationsInput | number | null
    personalised_message?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_order_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    wrapper_type?: NullableIntFieldUpdateOperationsInput | number | null
    personalised_message?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_processingCreateInput = {
    book_id?: number | null
    stage_id?: number | null
    content_type?: string | null
    word_page_number?: number | null
    pod_estimation_pages?: number | null
    cover_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type pod_processingUncheckedCreateInput = {
    id?: number
    book_id?: number | null
    stage_id?: number | null
    content_type?: string | null
    word_page_number?: number | null
    pod_estimation_pages?: number | null
    cover_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type pod_processingUpdateInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    word_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pod_estimation_pages?: NullableIntFieldUpdateOperationsInput | number | null
    cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_processingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    word_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pod_estimation_pages?: NullableIntFieldUpdateOperationsInput | number | null
    cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_processingCreateManyInput = {
    id?: number
    book_id?: number | null
    stage_id?: number | null
    content_type?: string | null
    word_page_number?: number | null
    pod_estimation_pages?: number | null
    cover_status?: number | null
    priority?: string | null
    date_created?: Date | string | null
    completed?: number | null
    rework?: number | null
  }

  export type pod_processingUpdateManyMutationInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    word_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pod_estimation_pages?: NullableIntFieldUpdateOperationsInput | number | null
    cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_processingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    word_page_number?: NullableIntFieldUpdateOperationsInput | number | null
    pod_estimation_pages?: NullableIntFieldUpdateOperationsInput | number | null
    cover_status?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableIntFieldUpdateOperationsInput | number | null
    rework?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pod_progressCreateInput = {
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
    pause_startdate?: Date | string | null
    pause_enddate?: Date | string | null
  }

  export type pod_progressUncheckedCreateInput = {
    id?: number
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
    pause_startdate?: Date | string | null
    pause_enddate?: Date | string | null
  }

  export type pod_progressUpdateInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    pause_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_progressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    pause_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_progressCreateManyInput = {
    id?: number
    book_id?: number | null
    status?: number | null
    stage?: number | null
    startdate?: Date | string | null
    enddate?: Date | string | null
    on_hold_startdate?: Date | string | null
    on_hold_enddate?: Date | string | null
    remarks?: string | null
    pause_startdate?: Date | string | null
    pause_enddate?: Date | string | null
  }

  export type pod_progressUpdateManyMutationInput = {
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    pause_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pod_progressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    pause_startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type publisher_tblCreateInput = {
    publisher_name?: string | null
    publisher_url_name?: string | null
    publisher_regional_name?: string | null
    publisher_image?: string | null
    publisher_description?: string | null
    email_id?: string | null
    mobile?: string | null
    address?: string | null
    bank_acc_no?: string | null
    bank_acc_name?: string | null
    bank_acc_type?: string | null
    ifsc_code?: string | null
    pan_number?: string | null
    copyright_owner?: string | null
    bonus_percentage?: number | null
    status?: number | null
    created_at?: Date | string | null
    tds_flag?: number | null
  }

  export type publisher_tblUncheckedCreateInput = {
    publisher_id?: number
    publisher_name?: string | null
    publisher_url_name?: string | null
    publisher_regional_name?: string | null
    publisher_image?: string | null
    publisher_description?: string | null
    email_id?: string | null
    mobile?: string | null
    address?: string | null
    bank_acc_no?: string | null
    bank_acc_name?: string | null
    bank_acc_type?: string | null
    ifsc_code?: string | null
    pan_number?: string | null
    copyright_owner?: string | null
    bonus_percentage?: number | null
    status?: number | null
    created_at?: Date | string | null
    tds_flag?: number | null
  }

  export type publisher_tblUpdateInput = {
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_regional_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_image?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_description?: NullableStringFieldUpdateOperationsInput | string | null
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_no?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_type?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    pan_number?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableStringFieldUpdateOperationsInput | string | null
    bonus_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tds_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publisher_tblUncheckedUpdateInput = {
    publisher_id?: IntFieldUpdateOperationsInput | number
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_regional_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_image?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_description?: NullableStringFieldUpdateOperationsInput | string | null
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_no?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_type?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    pan_number?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableStringFieldUpdateOperationsInput | string | null
    bonus_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tds_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publisher_tblCreateManyInput = {
    publisher_id?: number
    publisher_name?: string | null
    publisher_url_name?: string | null
    publisher_regional_name?: string | null
    publisher_image?: string | null
    publisher_description?: string | null
    email_id?: string | null
    mobile?: string | null
    address?: string | null
    bank_acc_no?: string | null
    bank_acc_name?: string | null
    bank_acc_type?: string | null
    ifsc_code?: string | null
    pan_number?: string | null
    copyright_owner?: string | null
    bonus_percentage?: number | null
    status?: number | null
    created_at?: Date | string | null
    tds_flag?: number | null
  }

  export type publisher_tblUpdateManyMutationInput = {
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_regional_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_image?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_description?: NullableStringFieldUpdateOperationsInput | string | null
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_no?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_type?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    pan_number?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableStringFieldUpdateOperationsInput | string | null
    bonus_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tds_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publisher_tblUncheckedUpdateManyInput = {
    publisher_id?: IntFieldUpdateOperationsInput | number
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_url_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_regional_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_image?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_description?: NullableStringFieldUpdateOperationsInput | string | null
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_no?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_acc_type?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    pan_number?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableStringFieldUpdateOperationsInput | string | null
    bonus_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tds_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rating_reviewCreateInput = {
    name: string
    user_id: number
    book_id: number
    comment: string
    rating: number
    status: number
    date_created?: Date | string
  }

  export type rating_reviewUncheckedCreateInput = {
    id?: number
    name: string
    user_id: number
    book_id: number
    comment: string
    rating: number
    status: number
    date_created?: Date | string
  }

  export type rating_reviewUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_reviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_reviewCreateManyInput = {
    id?: number
    name: string
    user_id: number
    book_id: number
    comment: string
    rating: number
    status: number
    date_created?: Date | string
  }

  export type rating_reviewUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_reviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type razorpay_requestsCreateInput = {
    user_id?: number | null
    plan_id?: number | null
    razorpay_payload?: string | null
    created?: Date | string | null
  }

  export type razorpay_requestsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    plan_id?: number | null
    razorpay_payload?: string | null
    created?: Date | string | null
  }

  export type razorpay_requestsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
    razorpay_payload?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type razorpay_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
    razorpay_payload?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type razorpay_requestsCreateManyInput = {
    id?: number
    user_id?: number | null
    plan_id?: number | null
    razorpay_payload?: string | null
    created?: Date | string | null
  }

  export type razorpay_requestsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
    razorpay_payload?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type razorpay_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
    razorpay_payload?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type royalty_settlementCreateInput = {
    copy_right_owner_id: number
    author_id?: number | null
    settlement_date: Date | string
    settlement_amount: number
    tds_amount?: number | null
    payment_type: string
    bank_transaction_details: string
    comments: string
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    bonus_value?: number | null
  }

  export type royalty_settlementUncheckedCreateInput = {
    id?: number
    copy_right_owner_id: number
    author_id?: number | null
    settlement_date: Date | string
    settlement_amount: number
    tds_amount?: number | null
    payment_type: string
    bank_transaction_details: string
    comments: string
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    bonus_value?: number | null
  }

  export type royalty_settlementUpdateInput = {
    copy_right_owner_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    tds_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_type?: StringFieldUpdateOperationsInput | string
    bank_transaction_details?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type royalty_settlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    copy_right_owner_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    tds_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_type?: StringFieldUpdateOperationsInput | string
    bank_transaction_details?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type royalty_settlementCreateManyInput = {
    id?: number
    copy_right_owner_id: number
    author_id?: number | null
    settlement_date: Date | string
    settlement_amount: number
    tds_amount?: number | null
    payment_type: string
    bank_transaction_details: string
    comments: string
    pustaka?: number | null
    amazon?: number | null
    kobo?: number | null
    scribd?: number | null
    google?: number | null
    overdrive?: number | null
    storytel?: number | null
    audible?: number | null
    bonus_value?: number | null
  }

  export type royalty_settlementUpdateManyMutationInput = {
    copy_right_owner_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    tds_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_type?: StringFieldUpdateOperationsInput | string
    bank_transaction_details?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type royalty_settlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    copy_right_owner_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    tds_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_type?: StringFieldUpdateOperationsInput | string
    bank_transaction_details?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    pustaka?: NullableFloatFieldUpdateOperationsInput | number | null
    amazon?: NullableFloatFieldUpdateOperationsInput | number | null
    kobo?: NullableFloatFieldUpdateOperationsInput | number | null
    scribd?: NullableFloatFieldUpdateOperationsInput | number | null
    google?: NullableFloatFieldUpdateOperationsInput | number | null
    overdrive?: NullableFloatFieldUpdateOperationsInput | number | null
    storytel?: NullableFloatFieldUpdateOperationsInput | number | null
    audible?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sales_consolidationCreateInput = {
    author_id?: number | null
    book_id?: number | null
    month_year?: Date | string | null
    genre_id?: number | null
    language_id?: number | null
    type_of_book?: number | null
    book_cost?: number | null
    downloads: number
  }

  export type sales_consolidationUncheckedCreateInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    month_year?: Date | string | null
    genre_id?: number | null
    language_id?: number | null
    type_of_book?: number | null
    book_cost?: number | null
    downloads: number
  }

  export type sales_consolidationUpdateInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    month_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    book_cost?: NullableIntFieldUpdateOperationsInput | number | null
    downloads?: IntFieldUpdateOperationsInput | number
  }

  export type sales_consolidationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    month_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    book_cost?: NullableIntFieldUpdateOperationsInput | number | null
    downloads?: IntFieldUpdateOperationsInput | number
  }

  export type sales_consolidationCreateManyInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    month_year?: Date | string | null
    genre_id?: number | null
    language_id?: number | null
    type_of_book?: number | null
    book_cost?: number | null
    downloads: number
  }

  export type sales_consolidationUpdateManyMutationInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    month_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    book_cost?: NullableIntFieldUpdateOperationsInput | number | null
    downloads?: IntFieldUpdateOperationsInput | number
  }

  export type sales_consolidationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    month_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    book_cost?: NullableIntFieldUpdateOperationsInput | number | null
    downloads?: IntFieldUpdateOperationsInput | number
  }

  export type scribd_booksCreateInput = {
    updated_at: Date | string
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url?: string | null
    imprints?: string | null
    status: string
    publisher_tools_config_id?: number | null
    metadata_status?: string | null
    conversion_status?: string | null
    product_page_pending?: string | null
    subscription_pending?: string | null
    book: book_tblCreateNestedOneWithoutScribdBookIdInput
    author_id: number
    copyright_owner?: number | null
    language_id: number
    duplicate_flag?: number | null
  }

  export type scribd_booksUncheckedCreateInput = {
    id?: number
    updated_at: Date | string
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url?: string | null
    imprints?: string | null
    status: string
    publisher_tools_config_id?: number | null
    metadata_status?: string | null
    conversion_status?: string | null
    product_page_pending?: string | null
    subscription_pending?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    duplicate_flag?: number | null
  }

  export type scribd_booksUpdateInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_tblUpdateOneRequiredWithoutScribdBookIdNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_booksCreateManyInput = {
    id?: number
    updated_at: Date | string
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url?: string | null
    imprints?: string | null
    status: string
    publisher_tools_config_id?: number | null
    metadata_status?: string | null
    conversion_status?: string | null
    product_page_pending?: string | null
    subscription_pending?: string | null
    book_id: number
    author_id: number
    copyright_owner?: number | null
    language_id: number
    duplicate_flag?: number | null
  }

  export type scribd_booksUpdateManyMutationInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_transactionCreateInput = {
    Payout_month: Date | string
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint | number
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date | string
    Last_date_of_interaction: Date | string
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date | string
    book: book_tblCreateNestedOneWithoutScribd_transactionInput
    author_id: number
    language_id?: number | null
    converted_inr: number
    user_id?: number | null
    copyright_owner?: number | null
    status: string
    exchange_rate: number
    converted_inr_full?: number | null
  }

  export type scribd_transactionUncheckedCreateInput = {
    S_No?: number
    Payout_month: Date | string
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint | number
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date | string
    Last_date_of_interaction: Date | string
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date | string
    book_id: number
    author_id: number
    language_id?: number | null
    converted_inr: number
    user_id?: number | null
    copyright_owner?: number | null
    status: string
    exchange_rate: number
    converted_inr_full?: number | null
  }

  export type scribd_transactionUpdateInput = {
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: book_tblUpdateOneRequiredWithoutScribd_transactionNestedInput
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type scribd_transactionUncheckedUpdateInput = {
    S_No?: IntFieldUpdateOperationsInput | number
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type scribd_transactionCreateManyInput = {
    S_No?: number
    Payout_month: Date | string
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint | number
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date | string
    Last_date_of_interaction: Date | string
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date | string
    book_id: number
    author_id: number
    language_id?: number | null
    converted_inr: number
    user_id?: number | null
    copyright_owner?: number | null
    status: string
    exchange_rate: number
    converted_inr_full?: number | null
  }

  export type scribd_transactionUpdateManyMutationInput = {
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type scribd_transactionUncheckedUpdateManyInput = {
    S_No?: IntFieldUpdateOperationsInput | number
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type storytel_booksCreateInput = {
    storytel_book_id?: string | null
    isbn?: string | null
    title?: string | null
    author_name?: string | null
    narrator?: string | null
    category?: string | null
    publication_date?: Date | string | null
    book: book_tblCreateNestedOneWithoutStorytelBookIdInput
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    genre_id?: number | null
    type_of_book?: number | null
  }

  export type storytel_booksUncheckedCreateInput = {
    id?: number
    storytel_book_id?: string | null
    isbn?: string | null
    title?: string | null
    author_name?: string | null
    narrator?: string | null
    category?: string | null
    publication_date?: Date | string | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    genre_id?: number | null
    type_of_book?: number | null
  }

  export type storytel_booksUpdateInput = {
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: book_tblUpdateOneRequiredWithoutStorytelBookIdNestedInput
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storytel_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storytel_booksCreateManyInput = {
    id?: number
    storytel_book_id?: string | null
    isbn?: string | null
    title?: string | null
    author_name?: string | null
    narrator?: string | null
    category?: string | null
    publication_date?: Date | string | null
    book_id: number
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    genre_id?: number | null
    type_of_book?: number | null
  }

  export type storytel_booksUpdateManyMutationInput = {
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storytel_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storytel_transactionsCreateInput = {
    author?: string | null
    title?: string | null
    isbn?: string | null
    country?: string | null
    price_model?: string | null
    no_of_units?: number | null
    net_receipts_per_hour_local?: number | null
    ecb_exchange_rate?: string | null
    net_receipts_per_hour_inr?: number | null
    book_length_in_hours?: number | null
    price_per_unit?: number | null
    remuneration_eur?: number | null
    remuneration_inr?: number | null
    publisher?: string | null
    imprint?: string | null
    consumption_dates?: string | null
    book_type?: string | null
    book: book_tblCreateNestedOneWithoutStorytel_transactionsInput
    author_id?: number | null
    language_id?: number | null
    user_id?: bigint | number | null
    copyright_owner?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type storytel_transactionsUncheckedCreateInput = {
    id?: number
    author?: string | null
    title?: string | null
    isbn?: string | null
    country?: string | null
    price_model?: string | null
    no_of_units?: number | null
    net_receipts_per_hour_local?: number | null
    ecb_exchange_rate?: string | null
    net_receipts_per_hour_inr?: number | null
    book_length_in_hours?: number | null
    price_per_unit?: number | null
    remuneration_eur?: number | null
    remuneration_inr?: number | null
    publisher?: string | null
    imprint?: string | null
    consumption_dates?: string | null
    book_type?: string | null
    book_id: number
    author_id?: number | null
    language_id?: number | null
    user_id?: bigint | number | null
    copyright_owner?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type storytel_transactionsUpdateInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_tblUpdateOneRequiredWithoutStorytel_transactionsNestedInput
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storytel_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storytel_transactionsCreateManyInput = {
    id?: number
    author?: string | null
    title?: string | null
    isbn?: string | null
    country?: string | null
    price_model?: string | null
    no_of_units?: number | null
    net_receipts_per_hour_local?: number | null
    ecb_exchange_rate?: string | null
    net_receipts_per_hour_inr?: number | null
    book_length_in_hours?: number | null
    price_per_unit?: number | null
    remuneration_eur?: number | null
    remuneration_inr?: number | null
    publisher?: string | null
    imprint?: string | null
    consumption_dates?: string | null
    book_type?: string | null
    book_id: number
    author_id?: number | null
    language_id?: number | null
    user_id?: bigint | number | null
    copyright_owner?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type storytel_transactionsUpdateManyMutationInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storytel_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    book_id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subscribe_newsletterCreateInput = {
    email_id?: string | null
    subscribe_date?: Date | string | null
  }

  export type subscribe_newsletterUncheckedCreateInput = {
    id?: number
    email_id?: string | null
    subscribe_date?: Date | string | null
  }

  export type subscribe_newsletterUpdateInput = {
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribe_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscribe_newsletterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribe_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscribe_newsletterCreateManyInput = {
    id?: number
    email_id?: string | null
    subscribe_date?: Date | string | null
  }

  export type subscribe_newsletterUpdateManyMutationInput = {
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribe_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscribe_newsletterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribe_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionCreateInput = {
    order_id: bigint | number
    user_id: number
    subscription_id: number
    plan_type?: number | null
    number_of_days: number
    start_date?: Date | string | null
    end_date: Date | string
    total_books_applicable: number
    date_inserted?: Date | string
    status?: number
  }

  export type subscriptionUncheckedCreateInput = {
    id?: number
    order_id: bigint | number
    user_id: number
    subscription_id: number
    plan_type?: number | null
    number_of_days: number
    start_date?: Date | string | null
    end_date: Date | string
    total_books_applicable: number
    date_inserted?: Date | string
    status?: number
  }

  export type subscriptionUpdateInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_books_applicable?: IntFieldUpdateOperationsInput | number
    date_inserted?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type subscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_books_applicable?: IntFieldUpdateOperationsInput | number
    date_inserted?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type subscriptionCreateManyInput = {
    id?: number
    order_id: bigint | number
    user_id: number
    subscription_id: number
    plan_type?: number | null
    number_of_days: number
    start_date?: Date | string | null
    end_date: Date | string
    total_books_applicable: number
    date_inserted?: Date | string
    status?: number
  }

  export type subscriptionUpdateManyMutationInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_books_applicable?: IntFieldUpdateOperationsInput | number
    date_inserted?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type subscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_type?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_books_applicable?: IntFieldUpdateOperationsInput | number
    date_inserted?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type today_dealsCreateInput = {
    date: Date | string
    book_id: number
    language_id?: number | null
    discount: number
    status: string
    type: string
  }

  export type today_dealsUncheckedCreateInput = {
    id?: number
    date: Date | string
    book_id: number
    language_id?: number | null
    discount: number
    status: string
    type: string
  }

  export type today_dealsUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type today_dealsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type today_dealsCreateManyInput = {
    id?: number
    date: Date | string
    book_id: number
    language_id?: number | null
    discount: number
    status: string
    type: string
  }

  export type today_dealsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type today_dealsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    book_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type top_booksCreateInput = {
    purpose?: string | null
    sales_count_by_bk_id?: number | null
    book_id?: number | null
    book_title?: string | null
    url_name?: string | null
    regional_book_title?: string | null
    language_id?: number | null
    language_id_tmp?: number | null
    type_of_book?: number | null
    author_id?: number | null
    author_name?: string | null
    description?: string | null
    download_link?: string | null
    cover_image?: string | null
    epub_url?: string | null
    cost?: number | null
    number_of_page?: number | null
    genre_id?: number | null
    genre_id_tmp?: number | null
    genre_name?: string | null
    book_category?: string | null
  }

  export type top_booksUncheckedCreateInput = {
    id?: number
    purpose?: string | null
    sales_count_by_bk_id?: number | null
    book_id?: number | null
    book_title?: string | null
    url_name?: string | null
    regional_book_title?: string | null
    language_id?: number | null
    language_id_tmp?: number | null
    type_of_book?: number | null
    author_id?: number | null
    author_name?: string | null
    description?: string | null
    download_link?: string | null
    cover_image?: string | null
    epub_url?: string | null
    cost?: number | null
    number_of_page?: number | null
    genre_id?: number | null
    genre_id_tmp?: number | null
    genre_name?: string | null
    book_category?: string | null
  }

  export type top_booksUpdateInput = {
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    sales_count_by_bk_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    genre_name?: NullableStringFieldUpdateOperationsInput | string | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type top_booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    sales_count_by_bk_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    genre_name?: NullableStringFieldUpdateOperationsInput | string | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type top_booksCreateManyInput = {
    id?: number
    purpose?: string | null
    sales_count_by_bk_id?: number | null
    book_id?: number | null
    book_title?: string | null
    url_name?: string | null
    regional_book_title?: string | null
    language_id?: number | null
    language_id_tmp?: number | null
    type_of_book?: number | null
    author_id?: number | null
    author_name?: string | null
    description?: string | null
    download_link?: string | null
    cover_image?: string | null
    epub_url?: string | null
    cost?: number | null
    number_of_page?: number | null
    genre_id?: number | null
    genre_id_tmp?: number | null
    genre_name?: string | null
    book_category?: string | null
  }

  export type top_booksUpdateManyMutationInput = {
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    sales_count_by_bk_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    genre_name?: NullableStringFieldUpdateOperationsInput | string | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type top_booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    sales_count_by_bk_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_title?: NullableStringFieldUpdateOperationsInput | string | null
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    epub_url?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id_tmp?: NullableIntFieldUpdateOperationsInput | number | null
    genre_name?: NullableStringFieldUpdateOperationsInput | string | null
    book_category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_addressCreateInput = {
    user_id: number
    billing_name?: string | null
    billing_address1?: string | null
    billing_address2?: string | null
    billing_area_name?: string | null
    billing_landmark?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_pincode?: string | null
    billing_mobile_no?: string | null
    billing_alternate_no?: string | null
    shipping_name?: string | null
    shipping_address1?: string | null
    shipping_address2?: string | null
    shipping_area_name?: string | null
    shipping_landmark?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_pincode?: string | null
    shipping_mobile_no?: string | null
    shipping_alternate_no?: string | null
  }

  export type user_addressUncheckedCreateInput = {
    user_id: number
    billing_name?: string | null
    billing_address1?: string | null
    billing_address2?: string | null
    billing_area_name?: string | null
    billing_landmark?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_pincode?: string | null
    billing_mobile_no?: string | null
    billing_alternate_no?: string | null
    shipping_name?: string | null
    shipping_address1?: string | null
    shipping_address2?: string | null
    shipping_area_name?: string | null
    shipping_landmark?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_pincode?: string | null
    shipping_mobile_no?: string | null
    shipping_alternate_no?: string | null
  }

  export type user_addressUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address1?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    billing_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    billing_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address1?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_addressUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address1?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    billing_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    billing_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address1?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_addressCreateManyInput = {
    user_id: number
    billing_name?: string | null
    billing_address1?: string | null
    billing_address2?: string | null
    billing_area_name?: string | null
    billing_landmark?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_pincode?: string | null
    billing_mobile_no?: string | null
    billing_alternate_no?: string | null
    shipping_name?: string | null
    shipping_address1?: string | null
    shipping_address2?: string | null
    shipping_area_name?: string | null
    shipping_landmark?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_pincode?: string | null
    shipping_mobile_no?: string | null
    shipping_alternate_no?: string | null
  }

  export type user_addressUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address1?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    billing_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    billing_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address1?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_addressUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address1?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    billing_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    billing_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address1?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_area_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_landmark?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_pincode?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_mobile_no?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_alternate_no?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_devicesCreateInput = {
    user_id: number
    device_id1: string
    device_info1: string
    device_id2: string
    device_info2: string
    device_id3: string
    device_info3: string
    created_at: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUncheckedCreateInput = {
    user_id: number
    device_id1: string
    device_info1: string
    device_id2: string
    device_info2: string
    device_id3: string
    device_info3: string
    created_at: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    device_id1?: StringFieldUpdateOperationsInput | string
    device_info1?: StringFieldUpdateOperationsInput | string
    device_id2?: StringFieldUpdateOperationsInput | string
    device_info2?: StringFieldUpdateOperationsInput | string
    device_id3?: StringFieldUpdateOperationsInput | string
    device_info3?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    device_id1?: StringFieldUpdateOperationsInput | string
    device_info1?: StringFieldUpdateOperationsInput | string
    device_id2?: StringFieldUpdateOperationsInput | string
    device_info2?: StringFieldUpdateOperationsInput | string
    device_id3?: StringFieldUpdateOperationsInput | string
    device_info3?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesCreateManyInput = {
    user_id: number
    device_id1: string
    device_info1: string
    device_id2: string
    device_info2: string
    device_id3: string
    device_info3: string
    created_at: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    device_id1?: StringFieldUpdateOperationsInput | string
    device_info1?: StringFieldUpdateOperationsInput | string
    device_id2?: StringFieldUpdateOperationsInput | string
    device_info2?: StringFieldUpdateOperationsInput | string
    device_id3?: StringFieldUpdateOperationsInput | string
    device_info3?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    device_id1?: StringFieldUpdateOperationsInput | string
    device_info1?: StringFieldUpdateOperationsInput | string
    device_id2?: StringFieldUpdateOperationsInput | string
    device_info2?: StringFieldUpdateOperationsInput | string
    device_id3?: StringFieldUpdateOperationsInput | string
    device_info3?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_subscription_tblCreateInput = {
    user_id: number
    user_email_id: string
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by: number
    updated_by: number
  }

  export type user_subscription_tblUncheckedCreateInput = {
    subscription_id?: number
    user_id: number
    user_email_id: string
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by: number
    updated_by: number
  }

  export type user_subscription_tblUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_email_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: IntFieldUpdateOperationsInput | number
  }

  export type user_subscription_tblUncheckedUpdateInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_email_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: IntFieldUpdateOperationsInput | number
  }

  export type user_subscription_tblCreateManyInput = {
    subscription_id?: number
    user_id: number
    user_email_id: string
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by: number
    updated_by: number
  }

  export type user_subscription_tblUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_email_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: IntFieldUpdateOperationsInput | number
  }

  export type user_subscription_tblUncheckedUpdateManyInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_email_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: IntFieldUpdateOperationsInput | number
  }

  export type user_walletCreateInput = {
    user_id: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_walletUncheckedCreateInput = {
    id?: number
    user_id: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_walletUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_walletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_walletCreateManyInput = {
    id?: number
    user_id: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_walletUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_walletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_wallet_transactionCreateInput = {
    user_id: number
    order_id: bigint | number
    amount: number
    currency: string
    transaction_type: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_wallet_transactionUncheckedCreateInput = {
    id?: number
    user_id: number
    order_id: bigint | number
    amount: number
    currency: string
    transaction_type: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_wallet_transactionUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transaction_type?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_wallet_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transaction_type?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_wallet_transactionCreateManyInput = {
    id?: number
    user_id: number
    order_id: bigint | number
    amount: number
    currency: string
    transaction_type: number
    balance_inr: number
    balance_usd: number
    date?: Date | string
  }

  export type user_wallet_transactionUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transaction_type?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_wallet_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transaction_type?: IntFieldUpdateOperationsInput | number
    balance_inr?: FloatFieldUpdateOperationsInput | number
    balance_usd?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_tblCreateInput = {
    username: string
    password: string
    dob?: Date | string | null
    gender?: string | null
    phone?: string | null
    language_id?: number | null
    genre_ids?: string | null
    address: string
    city?: string | null
    zipcode: number
    country: string
    user_type?: string
    created_at?: Date | string
    email: string
    secret_code?: string | null
    channel?: string | null
    profile_img_url?: string | null
    giftBooks?: author_gift_booksCreateNestedManyWithoutUserInput
  }

  export type users_tblUncheckedCreateInput = {
    user_id?: number
    username: string
    password: string
    dob?: Date | string | null
    gender?: string | null
    phone?: string | null
    language_id?: number | null
    genre_ids?: string | null
    address: string
    city?: string | null
    zipcode: number
    country: string
    user_type?: string
    created_at?: Date | string
    email: string
    secret_code?: string | null
    channel?: string | null
    profile_img_url?: string | null
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutUserInput
  }

  export type users_tblUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    giftBooks?: author_gift_booksUpdateManyWithoutUserNestedInput
  }

  export type users_tblUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutUserNestedInput
  }

  export type users_tblCreateManyInput = {
    user_id?: number
    username: string
    password: string
    dob?: Date | string | null
    gender?: string | null
    phone?: string | null
    language_id?: number | null
    genre_ids?: string | null
    address: string
    city?: string | null
    zipcode: number
    country: string
    user_type?: string
    created_at?: Date | string
    email: string
    secret_code?: string | null
    channel?: string | null
    profile_img_url?: string | null
  }

  export type users_tblUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type users_tblUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallet_order_tblCreateInput = {
    order_id: bigint | number
    user_id: number
    cart_type: string
    currency: string
    subtotal: number
    service_tax: number
    net_total: number
    discount: Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblUncheckedCreateInput = {
    id?: number
    order_id: bigint | number
    user_id: number
    cart_type: string
    currency: string
    subtotal: number
    service_tax: number
    net_total: number
    discount: Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblUpdateInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    service_tax?: IntFieldUpdateOperationsInput | number
    net_total?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    service_tax?: IntFieldUpdateOperationsInput | number
    net_total?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblCreateManyInput = {
    id?: number
    order_id: bigint | number
    user_id: number
    cart_type: string
    currency: string
    subtotal: number
    service_tax: number
    net_total: number
    discount: Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblUpdateManyMutationInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    service_tax?: IntFieldUpdateOperationsInput | number
    net_total?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_order_tblUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    cart_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    service_tax?: IntFieldUpdateOperationsInput | number
    net_total?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_transaction_typeCreateInput = {
    transaction_value: string
  }

  export type wallet_transaction_typeUncheckedCreateInput = {
    transaction_type?: number
    transaction_value: string
  }

  export type wallet_transaction_typeUpdateInput = {
    transaction_value?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transaction_typeUncheckedUpdateInput = {
    transaction_type?: IntFieldUpdateOperationsInput | number
    transaction_value?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transaction_typeCreateManyInput = {
    transaction_type?: number
    transaction_value: string
  }

  export type wallet_transaction_typeUpdateManyMutationInput = {
    transaction_value?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transaction_typeUncheckedUpdateManyInput = {
    transaction_type?: IntFieldUpdateOperationsInput | number
    transaction_value?: StringFieldUpdateOperationsInput | string
  }

  export type wishlistCreateInput = {
    book_id: number
    user_id: number
    date_created?: Date | string
  }

  export type wishlistUncheckedCreateInput = {
    id?: number
    book_id: number
    user_id: number
    date_created?: Date | string
  }

  export type wishlistUpdateInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishlistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishlistCreateManyInput = {
    id?: number
    book_id: number
    user_id: number
    date_created?: Date | string
  }

  export type wishlistUpdateManyMutationInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishlistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    book_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type Book_tblRelationFilter = {
    is?: book_tblWhereInput
    isNot?: book_tblWhereInput
  }

  export type amazon_booksCountOrderByAggregateInput = {
    id?: SortOrder
    activate?: SortOrder
    reference_id?: SortOrder
    print_book_isbn?: SortOrder
    eisbn?: SortOrder
    imprint?: SortOrder
    title?: SortOrder
    author?: SortOrder
    editors?: SortOrder
    illustrators?: SortOrder
    contributors?: SortOrder
    translators?: SortOrder
    photographers?: SortOrder
    language?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    release_date?: SortOrder
    publishing_date?: SortOrder
    description?: SortOrder
    bisac?: SortOrder
    bic?: SortOrder
    territory?: SortOrder
    exclude_territory?: SortOrder
    adult_flag?: SortOrder
    edition?: SortOrder
    series_title?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    keywords?: SortOrder
    asin?: SortOrder
    amazon_url?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_activation_date?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type amazon_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    activate?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    edition?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type amazon_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    activate?: SortOrder
    reference_id?: SortOrder
    print_book_isbn?: SortOrder
    eisbn?: SortOrder
    imprint?: SortOrder
    title?: SortOrder
    author?: SortOrder
    editors?: SortOrder
    illustrators?: SortOrder
    contributors?: SortOrder
    translators?: SortOrder
    photographers?: SortOrder
    language?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    release_date?: SortOrder
    publishing_date?: SortOrder
    description?: SortOrder
    bisac?: SortOrder
    bic?: SortOrder
    territory?: SortOrder
    exclude_territory?: SortOrder
    adult_flag?: SortOrder
    edition?: SortOrder
    series_title?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    keywords?: SortOrder
    asin?: SortOrder
    amazon_url?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_activation_date?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type amazon_booksMinOrderByAggregateInput = {
    id?: SortOrder
    activate?: SortOrder
    reference_id?: SortOrder
    print_book_isbn?: SortOrder
    eisbn?: SortOrder
    imprint?: SortOrder
    title?: SortOrder
    author?: SortOrder
    editors?: SortOrder
    illustrators?: SortOrder
    contributors?: SortOrder
    translators?: SortOrder
    photographers?: SortOrder
    language?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    release_date?: SortOrder
    publishing_date?: SortOrder
    description?: SortOrder
    bisac?: SortOrder
    bic?: SortOrder
    territory?: SortOrder
    exclude_territory?: SortOrder
    adult_flag?: SortOrder
    edition?: SortOrder
    series_title?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    keywords?: SortOrder
    asin?: SortOrder
    amazon_url?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_activation_date?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type amazon_booksSumOrderByAggregateInput = {
    id?: SortOrder
    activate?: SortOrder
    digital_list_price_usd?: SortOrder
    digital_list_price_inr?: SortOrder
    edition?: SortOrder
    series_number?: SortOrder
    volume?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    status?: SortOrder
    ku_enabled?: SortOrder
    ku_us_enabled?: SortOrder
    ku_uk_enabled?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type amazon_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_date?: SortOrder
    original_invoice_date?: SortOrder
    asin?: SortOrder
    physical_isbn10?: SortOrder
    physical_isbn13?: SortOrder
    digital_isbn?: SortOrder
    title?: SortOrder
    author?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    list_price_currency?: SortOrder
    publisher_price?: SortOrder
    publisher_price_currency?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    payment_currency?: SortOrder
    program_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
    status?: SortOrder
  }

  export type amazon_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    publisher_price?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type amazon_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_date?: SortOrder
    original_invoice_date?: SortOrder
    asin?: SortOrder
    physical_isbn10?: SortOrder
    physical_isbn13?: SortOrder
    digital_isbn?: SortOrder
    title?: SortOrder
    author?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    list_price_currency?: SortOrder
    publisher_price?: SortOrder
    publisher_price_currency?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    payment_currency?: SortOrder
    program_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
    status?: SortOrder
  }

  export type amazon_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_date?: SortOrder
    original_invoice_date?: SortOrder
    asin?: SortOrder
    physical_isbn10?: SortOrder
    physical_isbn13?: SortOrder
    digital_isbn?: SortOrder
    title?: SortOrder
    author?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    list_price_currency?: SortOrder
    publisher_price?: SortOrder
    publisher_price_currency?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    payment_currency?: SortOrder
    program_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
    status?: SortOrder
  }

  export type amazon_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    units_purchased?: SortOrder
    units_refunded?: SortOrder
    net_units?: SortOrder
    net_units_mtd?: SortOrder
    adjustments_made?: SortOrder
    list_price?: SortOrder
    publisher_price?: SortOrder
    discount_percentage?: SortOrder
    payment_amount?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    tax_value?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type audible_booksCountOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    audible_asin?: SortOrder
    amazon_asin?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    narrators?: SortOrder
    first_online_date?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    audible_asin?: SortOrder
    amazon_asin?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    narrators?: SortOrder
    first_online_date?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_booksMinOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    audible_asin?: SortOrder
    amazon_asin?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    narrators?: SortOrder
    first_online_date?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_booksSumOrderByAggregateInput = {
    id?: SortOrder
    language_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type audible_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    royalty_earner?: SortOrder
    parent_product_id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    provider_product_id?: SortOrder
    market_place?: SortOrder
    offer?: SortOrder
    royalty_rate?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type audible_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type audible_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    royalty_earner?: SortOrder
    parent_product_id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    provider_product_id?: SortOrder
    market_place?: SortOrder
    offer?: SortOrder
    royalty_rate?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type audible_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    royalty_earner?: SortOrder
    parent_product_id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    provider_product_id?: SortOrder
    market_place?: SortOrder
    offer?: SortOrder
    royalty_rate?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type audible_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    alc_qty?: SortOrder
    alc_net_sales?: SortOrder
    alc_royalty?: SortOrder
    al_qty?: SortOrder
    al_net_sales?: SortOrder
    al_royalty?: SortOrder
    alop_qty?: SortOrder
    alop_net_sales?: SortOrder
    alop_royalty?: SortOrder
    total_qty?: SortOrder
    total_net_sales?: SortOrder
    total_royalty?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type audio_book_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_url?: SortOrder
    chapter_duration?: SortOrder
    created_at?: SortOrder
  }

  export type audio_book_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type audio_book_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_url?: SortOrder
    chapter_duration?: SortOrder
    created_at?: SortOrder
  }

  export type audio_book_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_url?: SortOrder
    chapter_duration?: SortOrder
    created_at?: SortOrder
  }

  export type audio_book_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type Users_tblRelationFilter = {
    is?: users_tblWhereInput
    isNot?: users_tblWhereInput
  }

  export type author_gift_booksCountOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    bookId?: SortOrder
  }

  export type author_gift_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    bookId?: SortOrder
  }

  export type author_gift_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    bookId?: SortOrder
  }

  export type author_gift_booksMinOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    bookId?: SortOrder
  }

  export type author_gift_booksSumOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    bookId?: SortOrder
  }

  export type Language_tblRelationFilter = {
    is?: language_tblWhereInput
    isNot?: language_tblWhereInput
  }

  export type author_languageCountOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    display_name1?: SortOrder
    display_name2?: SortOrder
    regional_author_name?: SortOrder
  }

  export type author_languageAvgOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
  }

  export type author_languageMaxOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    display_name1?: SortOrder
    display_name2?: SortOrder
    regional_author_name?: SortOrder
  }

  export type author_languageMinOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    display_name1?: SortOrder
    display_name2?: SortOrder
    regional_author_name?: SortOrder
  }

  export type author_languageSumOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
  }

  export type author_royalty_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    settlement_date?: SortOrder
    bank_transaction_details?: SortOrder
  }

  export type author_royalty_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
  }

  export type author_royalty_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    settlement_date?: SortOrder
    bank_transaction_details?: SortOrder
  }

  export type author_royalty_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    settlement_date?: SortOrder
    bank_transaction_details?: SortOrder
  }

  export type author_royalty_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
  }

  export type author_tblCountOrderByAggregateInput = {
    author_id?: SortOrder
    author_name?: SortOrder
    url_name?: SortOrder
    author_type?: SortOrder
    author_image?: SortOrder
    copy_right_owner_name?: SortOrder
    relationship?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    fb_url?: SortOrder
    twitter_url?: SortOrder
    blog_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    gender?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    amazon_link?: SortOrder
    pratilipi_link?: SortOrder
    audible_link?: SortOrder
    odilo_link?: SortOrder
    scribd_link?: SortOrder
    googlebooks_link?: SortOrder
    storytel_link?: SortOrder
    overdrive_link?: SortOrder
    pinterest_link?: SortOrder
    agreement_details?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type author_tblAvgOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type author_tblMaxOrderByAggregateInput = {
    author_id?: SortOrder
    author_name?: SortOrder
    url_name?: SortOrder
    author_type?: SortOrder
    author_image?: SortOrder
    copy_right_owner_name?: SortOrder
    relationship?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    fb_url?: SortOrder
    twitter_url?: SortOrder
    blog_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    gender?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    amazon_link?: SortOrder
    pratilipi_link?: SortOrder
    audible_link?: SortOrder
    odilo_link?: SortOrder
    scribd_link?: SortOrder
    googlebooks_link?: SortOrder
    storytel_link?: SortOrder
    overdrive_link?: SortOrder
    pinterest_link?: SortOrder
    agreement_details?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type author_tblMinOrderByAggregateInput = {
    author_id?: SortOrder
    author_name?: SortOrder
    url_name?: SortOrder
    author_type?: SortOrder
    author_image?: SortOrder
    copy_right_owner_name?: SortOrder
    relationship?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    fb_url?: SortOrder
    twitter_url?: SortOrder
    blog_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    gender?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    amazon_link?: SortOrder
    pratilipi_link?: SortOrder
    audible_link?: SortOrder
    odilo_link?: SortOrder
    scribd_link?: SortOrder
    googlebooks_link?: SortOrder
    storytel_link?: SortOrder
    overdrive_link?: SortOrder
    pinterest_link?: SortOrder
    agreement_details?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type author_tblSumOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    copyright_owner?: SortOrder
    user_id?: SortOrder
    narrator_id?: SortOrder
    agreement_ebook_count?: SortOrder
    agreement_audiobook_count?: SortOrder
    agreement_paperback_count?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type author_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    order_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    order_type?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    currency?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    exchange_rate_comments?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
    pay_status?: SortOrder
    comments?: SortOrder
  }

  export type author_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
  }

  export type author_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    order_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    order_type?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    currency?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    exchange_rate_comments?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
    pay_status?: SortOrder
    comments?: SortOrder
  }

  export type author_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    order_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    order_type?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    currency?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    exchange_rate_comments?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
    pay_status?: SortOrder
    comments?: SortOrder
  }

  export type author_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copy_right_seller?: SortOrder
    copy_right_lender?: SortOrder
    copyright_owner?: SortOrder
    book_final_royalty_value_inr?: SortOrder
    book_final_royalty_value_usd?: SortOrder
    discount_provided?: SortOrder
    usd_exchange_rate?: SortOrder
    converted_book_final_royalty_value_inr?: SortOrder
    selling_royalty_percentage?: SortOrder
    lending_royalty_percentage?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type blog_commentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    blog_name?: SortOrder
    comments?: SortOrder
    email_id?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type blog_commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
  }

  export type blog_commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    blog_name?: SortOrder
    comments?: SortOrder
    email_id?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type blog_commentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    blog_name?: SortOrder
    comments?: SortOrder
    email_id?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type blog_commentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
  }

  export type Genre_details_tblRelationFilter = {
    is?: genre_details_tblWhereInput
    isNot?: genre_details_tblWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type Amazon_booksRelationFilter = {
    is?: amazon_booksWhereInput | null
    isNot?: amazon_booksWhereInput | null
  }

  export type Scribd_booksRelationFilter = {
    is?: scribd_booksWhereInput | null
    isNot?: scribd_booksWhereInput | null
  }

  export type Google_booksRelationFilter = {
    is?: google_booksWhereInput | null
    isNot?: google_booksWhereInput | null
  }

  export type Storytel_booksRelationFilter = {
    is?: storytel_booksWhereInput | null
    isNot?: storytel_booksWhereInput | null
  }

  export type Overdrive_booksRelationFilter = {
    is?: overdrive_booksWhereInput | null
    isNot?: overdrive_booksWhereInput | null
  }

  export type Audible_booksRelationFilter = {
    is?: audible_booksWhereInput | null
    isNot?: audible_booksWhereInput | null
  }

  export type Author_gift_booksListRelationFilter = {
    every?: author_gift_booksWhereInput
    some?: author_gift_booksWhereInput
    none?: author_gift_booksWhereInput
  }

  export type Amazon_transactionsRelationFilter = {
    is?: amazon_transactionsWhereInput | null
    isNot?: amazon_transactionsWhereInput | null
  }

  export type Audible_transactionsRelationFilter = {
    is?: audible_transactionsWhereInput | null
    isNot?: audible_transactionsWhereInput | null
  }

  export type Author_transactionRelationFilter = {
    is?: author_transactionWhereInput | null
    isNot?: author_transactionWhereInput | null
  }

  export type Google_transactionsRelationFilter = {
    is?: google_transactionsWhereInput | null
    isNot?: google_transactionsWhereInput | null
  }

  export type Kobo_transactionRelationFilter = {
    is?: kobo_transactionWhereInput | null
    isNot?: kobo_transactionWhereInput | null
  }

  export type Overdrive_transactionsRelationFilter = {
    is?: overdrive_transactionsWhereInput | null
    isNot?: overdrive_transactionsWhereInput | null
  }

  export type Scribd_transactionRelationFilter = {
    is?: scribd_transactionWhereInput | null
    isNot?: scribd_transactionWhereInput | null
  }

  export type Storytel_transactionsRelationFilter = {
    is?: storytel_transactionsWhereInput | null
    isNot?: storytel_transactionsWhereInput | null
  }

  export type author_gift_booksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_tblCountOrderByAggregateInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    isbn_number?: SortOrder
    cover_image?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    type_of_book?: SortOrder
    publisher?: SortOrder
    download_link?: SortOrder
    epub_url?: SortOrder
    royalty?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_royalty?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    paper_back_isbn?: SortOrder
    paper_back_remarks?: SortOrder
    mintbook_cost?: SortOrder
  }

  export type book_tblAvgOrderByAggregateInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    language?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
    copyright_owner?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    mintbook_cost?: SortOrder
  }

  export type book_tblMaxOrderByAggregateInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    isbn_number?: SortOrder
    cover_image?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    type_of_book?: SortOrder
    publisher?: SortOrder
    download_link?: SortOrder
    epub_url?: SortOrder
    royalty?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_royalty?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    paper_back_isbn?: SortOrder
    paper_back_remarks?: SortOrder
    mintbook_cost?: SortOrder
  }

  export type book_tblMinOrderByAggregateInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    isbn_number?: SortOrder
    cover_image?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    type_of_book?: SortOrder
    publisher?: SortOrder
    download_link?: SortOrder
    epub_url?: SortOrder
    royalty?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    activated_at?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_royalty?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    paper_back_isbn?: SortOrder
    paper_back_remarks?: SortOrder
    mintbook_cost?: SortOrder
  }

  export type book_tblSumOrderByAggregateInput = {
    book_id?: SortOrder
    author_name?: SortOrder
    language?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
    copyright_owner?: SortOrder
    created_by?: SortOrder
    book_cost_international?: SortOrder
    narrator_id?: SortOrder
    rental_cost_inr?: SortOrder
    rental_cost_usd?: SortOrder
    paper_back_flag?: SortOrder
    paper_back_inr?: SortOrder
    paper_back_readiness_flag?: SortOrder
    book_id_mapping?: SortOrder
    agreement_flag?: SortOrder
    paper_back_pages?: SortOrder
    paper_back_weight?: SortOrder
    paper_back_copyright_owner?: SortOrder
    mintbook_cost?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type book_typesCountOrderByAggregateInput = {
    book_type_id?: SortOrder
    type_name?: SortOrder
    url_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type book_typesAvgOrderByAggregateInput = {
    book_type_id?: SortOrder
    status?: SortOrder
  }

  export type book_typesMaxOrderByAggregateInput = {
    book_type_id?: SortOrder
    type_name?: SortOrder
    url_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type book_typesMinOrderByAggregateInput = {
    book_type_id?: SortOrder
    type_name?: SortOrder
    url_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type book_typesSumOrderByAggregateInput = {
    book_type_id?: SortOrder
    status?: SortOrder
  }

  export type books_metadataCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    description?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    final_page_number?: SortOrder
    allocated_date?: SortOrder
    start_date?: SortOrder
    completion_date?: SortOrder
    payment_date?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    general_file_path?: SortOrder
    url_title?: SortOrder
    unique_key?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    priority?: SortOrder
    current_state?: SortOrder
    remarks?: SortOrder
  }

  export type books_metadataAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    type_of_book?: SortOrder
    final_page_number?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    current_state?: SortOrder
  }

  export type books_metadataMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    description?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    final_page_number?: SortOrder
    allocated_date?: SortOrder
    start_date?: SortOrder
    completion_date?: SortOrder
    payment_date?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    general_file_path?: SortOrder
    url_title?: SortOrder
    unique_key?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    priority?: SortOrder
    current_state?: SortOrder
    remarks?: SortOrder
  }

  export type books_metadataMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    description?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    final_page_number?: SortOrder
    allocated_date?: SortOrder
    start_date?: SortOrder
    completion_date?: SortOrder
    payment_date?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    general_file_path?: SortOrder
    url_title?: SortOrder
    unique_key?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    priority?: SortOrder
    current_state?: SortOrder
    remarks?: SortOrder
  }

  export type books_metadataSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    type_of_book?: SortOrder
    final_page_number?: SortOrder
    settled_page_number?: SortOrder
    payment_status?: SortOrder
    assigned_by?: SortOrder
    assigned_to?: SortOrder
    price_per_page?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    general_cover_status?: SortOrder
    general_epub_status?: SortOrder
    pustaka_epub_status?: SortOrder
    amazon_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    pustaka_word_status?: SortOrder
    current_state?: SortOrder
  }

  export type books_processingCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_processingAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_processingMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_processingMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    type_of_book?: SortOrder
    content_type?: SortOrder
    hard_copy_type?: SortOrder
    soft_copy_type?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_processingSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    initial_page_number?: SortOrder
    pustaka_cover_status?: SortOrder
    pustaka_epub_status?: SortOrder
    pustaka_flippdf_status?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type books_progressCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
  }

  export type books_progressAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
  }

  export type books_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
  }

  export type books_progressMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
  }

  export type books_progressSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
  }

  export type contact_usCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type contact_usAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type contact_usMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type contact_usMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type contact_usSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type copyright_mappingCountOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    date_created?: SortOrder
  }

  export type copyright_mappingAvgOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
  }

  export type copyright_mappingMaxOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    date_created?: SortOrder
  }

  export type copyright_mappingMinOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
    date_created?: SortOrder
  }

  export type copyright_mappingSumOrderByAggregateInput = {
    id?: SortOrder
    copyright_owner?: SortOrder
    author_id?: SortOrder
  }

  export type episode_book_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_epub_url?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
    chapter_activated_at?: SortOrder
  }

  export type episode_book_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
  }

  export type episode_book_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_epub_url?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
    chapter_activated_at?: SortOrder
  }

  export type episode_book_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_name?: SortOrder
    chapter_name_english?: SortOrder
    chapter_epub_url?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
    chapter_activated_at?: SortOrder
  }

  export type episode_book_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    episode_book_id?: SortOrder
    chapter_num_pages?: SortOrder
    chapter_status?: SortOrder
  }

  export type episode_book_tblCountOrderByAggregateInput = {
    episode_book_id?: SortOrder
    book_title?: SortOrder
    author_id?: SortOrder
    url_name?: SortOrder
    cover_image?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    day_of_chapter?: SortOrder
    activated_at?: SortOrder
  }

  export type episode_book_tblAvgOrderByAggregateInput = {
    episode_book_id?: SortOrder
    author_id?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    status?: SortOrder
  }

  export type episode_book_tblMaxOrderByAggregateInput = {
    episode_book_id?: SortOrder
    book_title?: SortOrder
    author_id?: SortOrder
    url_name?: SortOrder
    cover_image?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    day_of_chapter?: SortOrder
    activated_at?: SortOrder
  }

  export type episode_book_tblMinOrderByAggregateInput = {
    episode_book_id?: SortOrder
    book_title?: SortOrder
    author_id?: SortOrder
    url_name?: SortOrder
    cover_image?: SortOrder
    regional_book_title?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    book_category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    day_of_chapter?: SortOrder
    activated_at?: SortOrder
  }

  export type episode_book_tblSumOrderByAggregateInput = {
    episode_book_id?: SortOrder
    author_id?: SortOrder
    language?: SortOrder
    type_of_book?: SortOrder
    genre_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltyCountOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltyAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltyMinOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type fixed_royaltySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    fixed_royalty_value?: SortOrder
    author_id?: SortOrder
    status?: SortOrder
  }

  export type free_book_subscriptionCountOrderByAggregateInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_subscribed?: SortOrder
    comments?: SortOrder
  }

  export type free_book_subscriptionAvgOrderByAggregateInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
  }

  export type free_book_subscriptionMaxOrderByAggregateInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_subscribed?: SortOrder
    comments?: SortOrder
  }

  export type free_book_subscriptionMinOrderByAggregateInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_subscribed?: SortOrder
    comments?: SortOrder
  }

  export type free_book_subscriptionSumOrderByAggregateInput = {
    seq_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
  }

  export type Book_tblListRelationFilter = {
    every?: book_tblWhereInput
    some?: book_tblWhereInput
    none?: book_tblWhereInput
  }

  export type book_tblOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type genre_details_tblCountOrderByAggregateInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    genre_name?: SortOrder
    url_name?: SortOrder
    lang_0?: SortOrder
    lang_1?: SortOrder
    lang_2?: SortOrder
    lang_3?: SortOrder
    lang_4?: SortOrder
    lang_5?: SortOrder
    status?: SortOrder
    bisac_code?: SortOrder
    image_url?: SortOrder
  }

  export type genre_details_tblAvgOrderByAggregateInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
  }

  export type genre_details_tblMaxOrderByAggregateInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    genre_name?: SortOrder
    url_name?: SortOrder
    lang_0?: SortOrder
    lang_1?: SortOrder
    lang_2?: SortOrder
    lang_3?: SortOrder
    lang_4?: SortOrder
    lang_5?: SortOrder
    status?: SortOrder
    bisac_code?: SortOrder
    image_url?: SortOrder
  }

  export type genre_details_tblMinOrderByAggregateInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    genre_name?: SortOrder
    url_name?: SortOrder
    lang_0?: SortOrder
    lang_1?: SortOrder
    lang_2?: SortOrder
    lang_3?: SortOrder
    lang_4?: SortOrder
    lang_5?: SortOrder
    status?: SortOrder
    bisac_code?: SortOrder
    image_url?: SortOrder
  }

  export type genre_details_tblSumOrderByAggregateInput = {
    genre_id?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type google_booksCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    status?: SortOrder
    label?: SortOrder
    play_store_link?: SortOrder
    enable_for_sale?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    book_format?: SortOrder
    related_identifier?: SortOrder
    contributor?: SortOrder
    biographical_note?: SortOrder
    language?: SortOrder
    subject_code?: SortOrder
    age_group?: SortOrder
    description?: SortOrder
    publication_date?: SortOrder
    page_count?: SortOrder
    series_name?: SortOrder
    volume_in_series?: SortOrder
    preview_type?: SortOrder
    preview_territories?: SortOrder
    buy_link_text?: SortOrder
    buy_link?: SortOrder
    publisher_name?: SortOrder
    publisher_website?: SortOrder
    show_photos_preview?: SortOrder
    pdf_download?: SortOrder
    on_sale_date?: SortOrder
    drm_enabled?: SortOrder
    show_photos_ebook?: SortOrder
    include_scanned_pages?: SortOrder
    mature_audiences?: SortOrder
    copy_paste_percentage?: SortOrder
    enable_school_use?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    school_use_countries?: SortOrder
    duration?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    abridged_version?: SortOrder
    inr_price_including_tax?: SortOrder
    inr_countries_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    usd_countries_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    inr_countries_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    usd_countries_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    eur_countries_including_tax?: SortOrder
    eur_countries_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    publish_date?: SortOrder
  }

  export type google_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    page_count?: SortOrder
    volume_in_series?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    inr_price_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
  }

  export type google_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    status?: SortOrder
    label?: SortOrder
    play_store_link?: SortOrder
    enable_for_sale?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    book_format?: SortOrder
    related_identifier?: SortOrder
    contributor?: SortOrder
    biographical_note?: SortOrder
    language?: SortOrder
    subject_code?: SortOrder
    age_group?: SortOrder
    description?: SortOrder
    publication_date?: SortOrder
    page_count?: SortOrder
    series_name?: SortOrder
    volume_in_series?: SortOrder
    preview_type?: SortOrder
    preview_territories?: SortOrder
    buy_link_text?: SortOrder
    buy_link?: SortOrder
    publisher_name?: SortOrder
    publisher_website?: SortOrder
    show_photos_preview?: SortOrder
    pdf_download?: SortOrder
    on_sale_date?: SortOrder
    drm_enabled?: SortOrder
    show_photos_ebook?: SortOrder
    include_scanned_pages?: SortOrder
    mature_audiences?: SortOrder
    copy_paste_percentage?: SortOrder
    enable_school_use?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    school_use_countries?: SortOrder
    duration?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    abridged_version?: SortOrder
    inr_price_including_tax?: SortOrder
    inr_countries_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    usd_countries_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    inr_countries_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    usd_countries_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    eur_countries_including_tax?: SortOrder
    eur_countries_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    publish_date?: SortOrder
  }

  export type google_booksMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    status?: SortOrder
    label?: SortOrder
    play_store_link?: SortOrder
    enable_for_sale?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    book_format?: SortOrder
    related_identifier?: SortOrder
    contributor?: SortOrder
    biographical_note?: SortOrder
    language?: SortOrder
    subject_code?: SortOrder
    age_group?: SortOrder
    description?: SortOrder
    publication_date?: SortOrder
    page_count?: SortOrder
    series_name?: SortOrder
    volume_in_series?: SortOrder
    preview_type?: SortOrder
    preview_territories?: SortOrder
    buy_link_text?: SortOrder
    buy_link?: SortOrder
    publisher_name?: SortOrder
    publisher_website?: SortOrder
    show_photos_preview?: SortOrder
    pdf_download?: SortOrder
    on_sale_date?: SortOrder
    drm_enabled?: SortOrder
    show_photos_ebook?: SortOrder
    include_scanned_pages?: SortOrder
    mature_audiences?: SortOrder
    copy_paste_percentage?: SortOrder
    enable_school_use?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    school_use_countries?: SortOrder
    duration?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    abridged_version?: SortOrder
    inr_price_including_tax?: SortOrder
    inr_countries_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    usd_countries_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    inr_countries_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    usd_countries_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    eur_countries_including_tax?: SortOrder
    eur_countries_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    publish_date?: SortOrder
  }

  export type google_booksSumOrderByAggregateInput = {
    id?: SortOrder
    page_count?: SortOrder
    volume_in_series?: SortOrder
    school_list_price_60?: SortOrder
    school_list_price_180?: SortOrder
    school_list_price_360?: SortOrder
    preview_length_minutes?: SortOrder
    preview_length_percentage?: SortOrder
    inr_price_including_tax?: SortOrder
    usd_price_including_tax?: SortOrder
    inr_price_excluding_tax?: SortOrder
    usd_price_excluding_tax?: SortOrder
    eur_price_including_tax?: SortOrder
    eur_price_excluding_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type google_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    earnings_date?: SortOrder
    transaction_date?: SortOrder
    unique_id?: SortOrder
    product?: SortOrder
    type?: SortOrder
    preorder?: SortOrder
    qty?: SortOrder
    primary_isbn?: SortOrder
    imprint_name?: SortOrder
    title?: SortOrder
    author?: SortOrder
    original_list_price_currency?: SortOrder
    original_list_price?: SortOrder
    list_price_currency?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    country_of_sale?: SortOrder
    publisher_revenue_percentage?: SortOrder
    publisher_revenue?: SortOrder
    earnings_currency?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    line_of_business?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type google_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    original_list_price?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    publisher_revenue?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type google_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    earnings_date?: SortOrder
    transaction_date?: SortOrder
    unique_id?: SortOrder
    product?: SortOrder
    type?: SortOrder
    preorder?: SortOrder
    qty?: SortOrder
    primary_isbn?: SortOrder
    imprint_name?: SortOrder
    title?: SortOrder
    author?: SortOrder
    original_list_price_currency?: SortOrder
    original_list_price?: SortOrder
    list_price_currency?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    country_of_sale?: SortOrder
    publisher_revenue_percentage?: SortOrder
    publisher_revenue?: SortOrder
    earnings_currency?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    line_of_business?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type google_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    earnings_date?: SortOrder
    transaction_date?: SortOrder
    unique_id?: SortOrder
    product?: SortOrder
    type?: SortOrder
    preorder?: SortOrder
    qty?: SortOrder
    primary_isbn?: SortOrder
    imprint_name?: SortOrder
    title?: SortOrder
    author?: SortOrder
    original_list_price_currency?: SortOrder
    original_list_price?: SortOrder
    list_price_currency?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    country_of_sale?: SortOrder
    publisher_revenue_percentage?: SortOrder
    publisher_revenue?: SortOrder
    earnings_currency?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    line_of_business?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type google_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    original_list_price?: SortOrder
    list_price_tax_inclusive?: SortOrder
    list_price_tax_exclusive?: SortOrder
    publisher_revenue?: SortOrder
    earnings_amount?: SortOrder
    currency_conversion_rate?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    currency_exchange?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type kobo_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    country?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    content_type?: SortOrder
    quantity?: SortOrder
    refund_reason?: SortOrder
    dealID?: SortOrder
    publisher_name?: SortOrder
    imprint?: SortOrder
    eISBN?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    list_price_currency?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    payable_currency?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type kobo_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type kobo_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    country?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    content_type?: SortOrder
    quantity?: SortOrder
    refund_reason?: SortOrder
    dealID?: SortOrder
    publisher_name?: SortOrder
    imprint?: SortOrder
    eISBN?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    list_price_currency?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    payable_currency?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type kobo_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    country?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    content_type?: SortOrder
    quantity?: SortOrder
    refund_reason?: SortOrder
    dealID?: SortOrder
    publisher_name?: SortOrder
    imprint?: SortOrder
    eISBN?: SortOrder
    author_name?: SortOrder
    book_title?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    list_price_currency?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    payable_currency?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type kobo_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    list_price?: SortOrder
    tax_excluded?: SortOrder
    COGS_percentage?: SortOrder
    COGS_amount?: SortOrder
    foreign_exchange?: SortOrder
    COGS_payable?: SortOrder
    COGS_based_lp?: SortOrder
    COGS_based_lp_excluded_tax?: SortOrder
    COGS_based_lp_currency?: SortOrder
    COGS_adjustment?: SortOrder
    net_due?: SortOrder
    total_tax?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    paid_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type Author_languageListRelationFilter = {
    every?: author_languageWhereInput
    some?: author_languageWhereInput
    none?: author_languageWhereInput
  }

  export type author_languageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type language_tblCountOrderByAggregateInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    language_name?: SortOrder
    regional_language_name?: SortOrder
    url_name?: SortOrder
    image_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type language_tblAvgOrderByAggregateInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
  }

  export type language_tblMaxOrderByAggregateInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    language_name?: SortOrder
    regional_language_name?: SortOrder
    url_name?: SortOrder
    image_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type language_tblMinOrderByAggregateInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    language_name?: SortOrder
    regional_language_name?: SortOrder
    url_name?: SortOrder
    image_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type language_tblSumOrderByAggregateInput = {
    language_id?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
  }

  export type ledger_head_tblCountOrderByAggregateInput = {
    id?: SortOrder
    ledger_head_name?: SortOrder
    date_created?: SortOrder
  }

  export type ledger_head_tblAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ledger_head_tblMaxOrderByAggregateInput = {
    id?: SortOrder
    ledger_head_name?: SortOrder
    date_created?: SortOrder
  }

  export type ledger_head_tblMinOrderByAggregateInput = {
    id?: SortOrder
    ledger_head_name?: SortOrder
    date_created?: SortOrder
  }

  export type ledger_head_tblSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type narrator_tblCountOrderByAggregateInput = {
    narrator_id?: SortOrder
    narrator_name?: SortOrder
    narrator_url?: SortOrder
    narrator_image?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    image_alt_text?: SortOrder
    image_title_text?: SortOrder
    created_at?: SortOrder
  }

  export type narrator_tblAvgOrderByAggregateInput = {
    narrator_id?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
  }

  export type narrator_tblMaxOrderByAggregateInput = {
    narrator_id?: SortOrder
    narrator_name?: SortOrder
    narrator_url?: SortOrder
    narrator_image?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    image_alt_text?: SortOrder
    image_title_text?: SortOrder
    created_at?: SortOrder
  }

  export type narrator_tblMinOrderByAggregateInput = {
    narrator_id?: SortOrder
    narrator_name?: SortOrder
    narrator_url?: SortOrder
    narrator_image?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    image_alt_text?: SortOrder
    image_title_text?: SortOrder
    created_at?: SortOrder
  }

  export type narrator_tblSumOrderByAggregateInput = {
    narrator_id?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
  }

  export type offline_paymentCountOrderByAggregateInput = {
    id?: SortOrder
    cart_type?: SortOrder
    cart_items?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date_created?: SortOrder
    status?: SortOrder
  }

  export type offline_paymentAvgOrderByAggregateInput = {
    id?: SortOrder
    cart_type?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type offline_paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    cart_type?: SortOrder
    cart_items?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date_created?: SortOrder
    status?: SortOrder
  }

  export type offline_paymentMinOrderByAggregateInput = {
    id?: SortOrder
    cart_type?: SortOrder
    cart_items?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date_created?: SortOrder
    status?: SortOrder
  }

  export type offline_paymentSumOrderByAggregateInput = {
    id?: SortOrder
    cart_type?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    tracking_id?: SortOrder
    bank_ref_no?: SortOrder
    order_status?: SortOrder
    failure_message?: SortOrder
    payment_mode?: SortOrder
    card_name?: SortOrder
    status_code?: SortOrder
    status_message?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    billing_name?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    billing_tel?: SortOrder
    billing_email?: SortOrder
    delivery_name?: SortOrder
    delivery_address?: SortOrder
    delivery_city?: SortOrder
    delivery_state?: SortOrder
    delivery_zip?: SortOrder
    delivery_country?: SortOrder
    delivery_tel?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    date_created?: SortOrder
    coupon_id?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    bank_ref_no?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    tracking_id?: SortOrder
    bank_ref_no?: SortOrder
    order_status?: SortOrder
    failure_message?: SortOrder
    payment_mode?: SortOrder
    card_name?: SortOrder
    status_code?: SortOrder
    status_message?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    billing_name?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    billing_tel?: SortOrder
    billing_email?: SortOrder
    delivery_name?: SortOrder
    delivery_address?: SortOrder
    delivery_city?: SortOrder
    delivery_state?: SortOrder
    delivery_zip?: SortOrder
    delivery_country?: SortOrder
    delivery_tel?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    date_created?: SortOrder
    coupon_id?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    tracking_id?: SortOrder
    bank_ref_no?: SortOrder
    order_status?: SortOrder
    failure_message?: SortOrder
    payment_mode?: SortOrder
    card_name?: SortOrder
    status_code?: SortOrder
    status_message?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    billing_name?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    billing_tel?: SortOrder
    billing_email?: SortOrder
    delivery_name?: SortOrder
    delivery_address?: SortOrder
    delivery_city?: SortOrder
    delivery_state?: SortOrder
    delivery_zip?: SortOrder
    delivery_country?: SortOrder
    delivery_tel?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    date_created?: SortOrder
    coupon_id?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    bank_ref_no?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_revenue?: SortOrder
    net_total?: SortOrder
    coupon_discount_amt?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type order_book_detailsCountOrderByAggregateInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    order_date?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    user_ip?: SortOrder
  }

  export type order_book_detailsAvgOrderByAggregateInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type order_book_detailsMaxOrderByAggregateInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    order_date?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    user_ip?: SortOrder
  }

  export type order_book_detailsMinOrderByAggregateInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    order_date?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
    user_ip?: SortOrder
  }

  export type order_book_detailsSumOrderByAggregateInput = {
    book_order_id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    book_cost?: SortOrder
    order_type?: SortOrder
    rent_plan?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type overdrive_booksCountOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    physical_isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    creators?: SortOrder
    subject?: SortOrder
    format?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    onsale_date?: SortOrder
    pub_date?: SortOrder
    status?: SortOrder
    sample_link?: SortOrder
    readbox_enabled?: SortOrder
    special_features?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    physical_isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    creators?: SortOrder
    subject?: SortOrder
    format?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    onsale_date?: SortOrder
    pub_date?: SortOrder
    status?: SortOrder
    sample_link?: SortOrder
    readbox_enabled?: SortOrder
    special_features?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_booksMinOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    physical_isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    creators?: SortOrder
    subject?: SortOrder
    format?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    onsale_date?: SortOrder
    pub_date?: SortOrder
    status?: SortOrder
    sample_link?: SortOrder
    readbox_enabled?: SortOrder
    special_features?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_booksSumOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    catalogue_id?: SortOrder
    isbn?: SortOrder
    edition?: SortOrder
    series?: SortOrder
    filesize?: SortOrder
    whs_usd?: SortOrder
    whs_usddiscount?: SortOrder
    lib_usd?: SortOrder
    lib_usddiscount?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type overdrive_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    author?: SortOrder
    retailer?: SortOrder
    country_of_sale?: SortOrder
    format?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type overdrive_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type overdrive_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    author?: SortOrder
    retailer?: SortOrder
    country_of_sale?: SortOrder
    format?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type overdrive_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    transaction_date?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    author?: SortOrder
    retailer?: SortOrder
    country_of_sale?: SortOrder
    format?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
  }

  export type overdrive_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    overdrive_id?: SortOrder
    isbn?: SortOrder
    srp_usd?: SortOrder
    discount?: SortOrder
    amt_owed_usd?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    exchange_rate?: SortOrder
    inr_value?: SortOrder
    final_royalty_value?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
  }

  export type payout_sessionCountOrderByAggregateInput = {
    session_id?: SortOrder
    session_data?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type payout_sessionAvgOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type payout_sessionMaxOrderByAggregateInput = {
    session_id?: SortOrder
    session_data?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type payout_sessionMinOrderByAggregateInput = {
    session_id?: SortOrder
    session_data?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type payout_sessionSumOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type plan_tblCountOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_name?: SortOrder
    plan_display_name?: SortOrder
    plan_url_name?: SortOrder
    plan_type?: SortOrder
    plan_image?: SortOrder
    plan_cost?: SortOrder
    plan_caption?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    plan_intro_date?: SortOrder
    status?: SortOrder
  }

  export type plan_tblAvgOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_type?: SortOrder
    plan_cost?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    status?: SortOrder
  }

  export type plan_tblMaxOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_name?: SortOrder
    plan_display_name?: SortOrder
    plan_url_name?: SortOrder
    plan_type?: SortOrder
    plan_image?: SortOrder
    plan_cost?: SortOrder
    plan_caption?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    plan_intro_date?: SortOrder
    status?: SortOrder
  }

  export type plan_tblMinOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_name?: SortOrder
    plan_display_name?: SortOrder
    plan_url_name?: SortOrder
    plan_type?: SortOrder
    plan_image?: SortOrder
    plan_cost?: SortOrder
    plan_caption?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    plan_intro_date?: SortOrder
    status?: SortOrder
  }

  export type plan_tblSumOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_type?: SortOrder
    plan_cost?: SortOrder
    plan_cost_international?: SortOrder
    validity_days?: SortOrder
    book_validity_days?: SortOrder
    available_books?: SortOrder
    discount?: SortOrder
    status?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type pod_cost_notificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_created?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_cost_notificationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_cost_notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_created?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_cost_notificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    date_created?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_cost_notificationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    mail_status?: SortOrder
  }

  export type pod_orderCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    order_date?: SortOrder
  }

  export type pod_orderAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
  }

  export type pod_orderMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    order_date?: SortOrder
  }

  export type pod_orderMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    order_date?: SortOrder
  }

  export type pod_orderSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    shipping_charges?: SortOrder
    discount?: SortOrder
    order_status?: SortOrder
    split_flag?: SortOrder
  }

  export type pod_order_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    personalised_message?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    status?: SortOrder
    price?: SortOrder
    order_date?: SortOrder
  }

  export type pod_order_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    status?: SortOrder
    price?: SortOrder
  }

  export type pod_order_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    personalised_message?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    status?: SortOrder
    price?: SortOrder
    order_date?: SortOrder
  }

  export type pod_order_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    personalised_message?: SortOrder
    tracking_id?: SortOrder
    tracking_url?: SortOrder
    status?: SortOrder
    price?: SortOrder
    order_date?: SortOrder
  }

  export type pod_order_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    quantity?: SortOrder
    wrapper_type?: SortOrder
    status?: SortOrder
    price?: SortOrder
  }

  export type pod_processingCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    content_type?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_processingAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_processingMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    content_type?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_processingMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    content_type?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    priority?: SortOrder
    date_created?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_processingSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    stage_id?: SortOrder
    word_page_number?: SortOrder
    pod_estimation_pages?: SortOrder
    cover_status?: SortOrder
    completed?: SortOrder
    rework?: SortOrder
  }

  export type pod_progressCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    pause_startdate?: SortOrder
    pause_enddate?: SortOrder
  }

  export type pod_progressAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
  }

  export type pod_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    pause_startdate?: SortOrder
    pause_enddate?: SortOrder
  }

  export type pod_progressMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    on_hold_startdate?: SortOrder
    on_hold_enddate?: SortOrder
    remarks?: SortOrder
    pause_startdate?: SortOrder
    pause_enddate?: SortOrder
  }

  export type pod_progressSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    stage?: SortOrder
  }

  export type publisher_tblCountOrderByAggregateInput = {
    publisher_id?: SortOrder
    publisher_name?: SortOrder
    publisher_url_name?: SortOrder
    publisher_regional_name?: SortOrder
    publisher_image?: SortOrder
    publisher_description?: SortOrder
    email_id?: SortOrder
    mobile?: SortOrder
    address?: SortOrder
    bank_acc_no?: SortOrder
    bank_acc_name?: SortOrder
    bank_acc_type?: SortOrder
    ifsc_code?: SortOrder
    pan_number?: SortOrder
    copyright_owner?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    tds_flag?: SortOrder
  }

  export type publisher_tblAvgOrderByAggregateInput = {
    publisher_id?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    tds_flag?: SortOrder
  }

  export type publisher_tblMaxOrderByAggregateInput = {
    publisher_id?: SortOrder
    publisher_name?: SortOrder
    publisher_url_name?: SortOrder
    publisher_regional_name?: SortOrder
    publisher_image?: SortOrder
    publisher_description?: SortOrder
    email_id?: SortOrder
    mobile?: SortOrder
    address?: SortOrder
    bank_acc_no?: SortOrder
    bank_acc_name?: SortOrder
    bank_acc_type?: SortOrder
    ifsc_code?: SortOrder
    pan_number?: SortOrder
    copyright_owner?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    tds_flag?: SortOrder
  }

  export type publisher_tblMinOrderByAggregateInput = {
    publisher_id?: SortOrder
    publisher_name?: SortOrder
    publisher_url_name?: SortOrder
    publisher_regional_name?: SortOrder
    publisher_image?: SortOrder
    publisher_description?: SortOrder
    email_id?: SortOrder
    mobile?: SortOrder
    address?: SortOrder
    bank_acc_no?: SortOrder
    bank_acc_name?: SortOrder
    bank_acc_type?: SortOrder
    ifsc_code?: SortOrder
    pan_number?: SortOrder
    copyright_owner?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    tds_flag?: SortOrder
  }

  export type publisher_tblSumOrderByAggregateInput = {
    publisher_id?: SortOrder
    bonus_percentage?: SortOrder
    status?: SortOrder
    tds_flag?: SortOrder
  }

  export type rating_reviewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type rating_reviewAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    rating?: SortOrder
    status?: SortOrder
  }

  export type rating_reviewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type rating_reviewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    date_created?: SortOrder
  }

  export type rating_reviewSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    rating?: SortOrder
    status?: SortOrder
  }

  export type razorpay_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_payload?: SortOrder
    created?: SortOrder
  }

  export type razorpay_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type razorpay_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_payload?: SortOrder
    created?: SortOrder
  }

  export type razorpay_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_payload?: SortOrder
    created?: SortOrder
  }

  export type razorpay_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type royalty_settlementCountOrderByAggregateInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_date?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    payment_type?: SortOrder
    bank_transaction_details?: SortOrder
    comments?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type royalty_settlementAvgOrderByAggregateInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type royalty_settlementMaxOrderByAggregateInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_date?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    payment_type?: SortOrder
    bank_transaction_details?: SortOrder
    comments?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type royalty_settlementMinOrderByAggregateInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_date?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    payment_type?: SortOrder
    bank_transaction_details?: SortOrder
    comments?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type royalty_settlementSumOrderByAggregateInput = {
    id?: SortOrder
    copy_right_owner_id?: SortOrder
    author_id?: SortOrder
    settlement_amount?: SortOrder
    tds_amount?: SortOrder
    pustaka?: SortOrder
    amazon?: SortOrder
    kobo?: SortOrder
    scribd?: SortOrder
    google?: SortOrder
    overdrive?: SortOrder
    storytel?: SortOrder
    audible?: SortOrder
    bonus_value?: SortOrder
  }

  export type sales_consolidationCountOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    month_year?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type sales_consolidationAvgOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type sales_consolidationMaxOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    month_year?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type sales_consolidationMinOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    month_year?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type sales_consolidationSumOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    book_id?: SortOrder
    genre_id?: SortOrder
    language_id?: SortOrder
    type_of_book?: SortOrder
    book_cost?: SortOrder
    downloads?: SortOrder
  }

  export type scribd_booksCountOrderByAggregateInput = {
    id?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    identifier?: SortOrder
    title?: SortOrder
    published?: SortOrder
    in_subscription?: SortOrder
    product_page_url?: SortOrder
    imprints?: SortOrder
    status?: SortOrder
    publisher_tools_config_id?: SortOrder
    metadata_status?: SortOrder
    conversion_status?: SortOrder
    product_page_pending?: SortOrder
    subscription_pending?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    publisher_tools_config_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    identifier?: SortOrder
    title?: SortOrder
    published?: SortOrder
    in_subscription?: SortOrder
    product_page_url?: SortOrder
    imprints?: SortOrder
    status?: SortOrder
    publisher_tools_config_id?: SortOrder
    metadata_status?: SortOrder
    conversion_status?: SortOrder
    product_page_pending?: SortOrder
    subscription_pending?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_booksMinOrderByAggregateInput = {
    id?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    identifier?: SortOrder
    title?: SortOrder
    published?: SortOrder
    in_subscription?: SortOrder
    product_page_url?: SortOrder
    imprints?: SortOrder
    status?: SortOrder
    publisher_tools_config_id?: SortOrder
    metadata_status?: SortOrder
    conversion_status?: SortOrder
    product_page_pending?: SortOrder
    subscription_pending?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_booksSumOrderByAggregateInput = {
    id?: SortOrder
    import_id?: SortOrder
    doc_id?: SortOrder
    publisher_tools_config_id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    duplicate_flag?: SortOrder
  }

  export type scribd_transactionCountOrderByAggregateInput = {
    S_No?: SortOrder
    Payout_month?: SortOrder
    Publisher?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Amount_owed_currency?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    Original_currency?: SortOrder
    Price_type?: SortOrder
    ISBN?: SortOrder
    Title?: SortOrder
    Authors?: SortOrder
    Imprints?: SortOrder
    Viewed?: SortOrder
    Payout_type?: SortOrder
    Start_date_of_interaction?: SortOrder
    Last_date_of_interaction?: SortOrder
    Country_of_reader?: SortOrder
    Unique_interaction_ID?: SortOrder
    ISO_Country_Code?: SortOrder
    Threshold_Date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type scribd_transactionAvgOrderByAggregateInput = {
    S_No?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    ISBN?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type scribd_transactionMaxOrderByAggregateInput = {
    S_No?: SortOrder
    Payout_month?: SortOrder
    Publisher?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Amount_owed_currency?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    Original_currency?: SortOrder
    Price_type?: SortOrder
    ISBN?: SortOrder
    Title?: SortOrder
    Authors?: SortOrder
    Imprints?: SortOrder
    Viewed?: SortOrder
    Payout_type?: SortOrder
    Start_date_of_interaction?: SortOrder
    Last_date_of_interaction?: SortOrder
    Country_of_reader?: SortOrder
    Unique_interaction_ID?: SortOrder
    ISO_Country_Code?: SortOrder
    Threshold_Date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type scribd_transactionMinOrderByAggregateInput = {
    S_No?: SortOrder
    Payout_month?: SortOrder
    Publisher?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Amount_owed_currency?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    Original_currency?: SortOrder
    Price_type?: SortOrder
    ISBN?: SortOrder
    Title?: SortOrder
    Authors?: SortOrder
    Imprints?: SortOrder
    Viewed?: SortOrder
    Payout_type?: SortOrder
    Start_date_of_interaction?: SortOrder
    Last_date_of_interaction?: SortOrder
    Country_of_reader?: SortOrder
    Unique_interaction_ID?: SortOrder
    ISO_Country_Code?: SortOrder
    Threshold_Date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    status?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type scribd_transactionSumOrderByAggregateInput = {
    S_No?: SortOrder
    Amount_owed_for_this_interaction?: SortOrder
    Price_in_original_currency?: SortOrder
    Digital_list_price?: SortOrder
    ISBN?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    converted_inr?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    exchange_rate?: SortOrder
    converted_inr_full?: SortOrder
  }

  export type storytel_booksCountOrderByAggregateInput = {
    id?: SortOrder
    storytel_book_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    author_name?: SortOrder
    narrator?: SortOrder
    category?: SortOrder
    publication_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type storytel_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type storytel_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    storytel_book_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    author_name?: SortOrder
    narrator?: SortOrder
    category?: SortOrder
    publication_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type storytel_booksMinOrderByAggregateInput = {
    id?: SortOrder
    storytel_book_id?: SortOrder
    isbn?: SortOrder
    title?: SortOrder
    author_name?: SortOrder
    narrator?: SortOrder
    category?: SortOrder
    publication_date?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type storytel_booksSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    copyright_owner?: SortOrder
    language_id?: SortOrder
    genre_id?: SortOrder
    type_of_book?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type storytel_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    country?: SortOrder
    price_model?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    ecb_exchange_rate?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    consumption_dates?: SortOrder
    book_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type storytel_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type storytel_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    country?: SortOrder
    price_model?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    ecb_exchange_rate?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    consumption_dates?: SortOrder
    book_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type storytel_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    country?: SortOrder
    price_model?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    ecb_exchange_rate?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    publisher?: SortOrder
    imprint?: SortOrder
    consumption_dates?: SortOrder
    book_type?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
    transaction_date?: SortOrder
    status?: SortOrder
  }

  export type storytel_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    no_of_units?: SortOrder
    net_receipts_per_hour_local?: SortOrder
    net_receipts_per_hour_inr?: SortOrder
    book_length_in_hours?: SortOrder
    price_per_unit?: SortOrder
    remuneration_eur?: SortOrder
    remuneration_inr?: SortOrder
    book_id?: SortOrder
    author_id?: SortOrder
    language_id?: SortOrder
    user_id?: SortOrder
    copyright_owner?: SortOrder
    final_royalty_value?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type subscribe_newsletterCountOrderByAggregateInput = {
    id?: SortOrder
    email_id?: SortOrder
    subscribe_date?: SortOrder
  }

  export type subscribe_newsletterAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type subscribe_newsletterMaxOrderByAggregateInput = {
    id?: SortOrder
    email_id?: SortOrder
    subscribe_date?: SortOrder
  }

  export type subscribe_newsletterMinOrderByAggregateInput = {
    id?: SortOrder
    email_id?: SortOrder
    subscribe_date?: SortOrder
  }

  export type subscribe_newsletterSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type subscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_books_applicable?: SortOrder
    date_inserted?: SortOrder
    status?: SortOrder
  }

  export type subscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    total_books_applicable?: SortOrder
    status?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_books_applicable?: SortOrder
    date_inserted?: SortOrder
    status?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_books_applicable?: SortOrder
    date_inserted?: SortOrder
    status?: SortOrder
  }

  export type subscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    plan_type?: SortOrder
    number_of_days?: SortOrder
    total_books_applicable?: SortOrder
    status?: SortOrder
  }

  export type today_dealsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type today_dealsAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
  }

  export type today_dealsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type today_dealsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type today_dealsSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    discount?: SortOrder
  }

  export type top_booksCountOrderByAggregateInput = {
    id?: SortOrder
    purpose?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    description?: SortOrder
    download_link?: SortOrder
    cover_image?: SortOrder
    epub_url?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
    genre_name?: SortOrder
    book_category?: SortOrder
  }

  export type top_booksAvgOrderByAggregateInput = {
    id?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
  }

  export type top_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    purpose?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    description?: SortOrder
    download_link?: SortOrder
    cover_image?: SortOrder
    epub_url?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
    genre_name?: SortOrder
    book_category?: SortOrder
  }

  export type top_booksMinOrderByAggregateInput = {
    id?: SortOrder
    purpose?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    book_title?: SortOrder
    url_name?: SortOrder
    regional_book_title?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    description?: SortOrder
    download_link?: SortOrder
    cover_image?: SortOrder
    epub_url?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
    genre_name?: SortOrder
    book_category?: SortOrder
  }

  export type top_booksSumOrderByAggregateInput = {
    id?: SortOrder
    sales_count_by_bk_id?: SortOrder
    book_id?: SortOrder
    language_id?: SortOrder
    language_id_tmp?: SortOrder
    type_of_book?: SortOrder
    author_id?: SortOrder
    cost?: SortOrder
    number_of_page?: SortOrder
    genre_id?: SortOrder
    genre_id_tmp?: SortOrder
  }

  export type user_addressCountOrderByAggregateInput = {
    user_id?: SortOrder
    billing_name?: SortOrder
    billing_address1?: SortOrder
    billing_address2?: SortOrder
    billing_area_name?: SortOrder
    billing_landmark?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_pincode?: SortOrder
    billing_mobile_no?: SortOrder
    billing_alternate_no?: SortOrder
    shipping_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_area_name?: SortOrder
    shipping_landmark?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_pincode?: SortOrder
    shipping_mobile_no?: SortOrder
    shipping_alternate_no?: SortOrder
  }

  export type user_addressAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_addressMaxOrderByAggregateInput = {
    user_id?: SortOrder
    billing_name?: SortOrder
    billing_address1?: SortOrder
    billing_address2?: SortOrder
    billing_area_name?: SortOrder
    billing_landmark?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_pincode?: SortOrder
    billing_mobile_no?: SortOrder
    billing_alternate_no?: SortOrder
    shipping_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_area_name?: SortOrder
    shipping_landmark?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_pincode?: SortOrder
    shipping_mobile_no?: SortOrder
    shipping_alternate_no?: SortOrder
  }

  export type user_addressMinOrderByAggregateInput = {
    user_id?: SortOrder
    billing_name?: SortOrder
    billing_address1?: SortOrder
    billing_address2?: SortOrder
    billing_area_name?: SortOrder
    billing_landmark?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_pincode?: SortOrder
    billing_mobile_no?: SortOrder
    billing_alternate_no?: SortOrder
    shipping_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_area_name?: SortOrder
    shipping_landmark?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_pincode?: SortOrder
    shipping_mobile_no?: SortOrder
    shipping_alternate_no?: SortOrder
  }

  export type user_addressSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_devicesCountOrderByAggregateInput = {
    user_id?: SortOrder
    device_id1?: SortOrder
    device_info1?: SortOrder
    device_id2?: SortOrder
    device_info2?: SortOrder
    device_id3?: SortOrder
    device_info3?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_devicesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    device_id1?: SortOrder
    device_info1?: SortOrder
    device_id2?: SortOrder
    device_info2?: SortOrder
    device_id3?: SortOrder
    device_info3?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesMinOrderByAggregateInput = {
    user_id?: SortOrder
    device_id1?: SortOrder
    device_info1?: SortOrder
    device_id2?: SortOrder
    device_info2?: SortOrder
    device_id3?: SortOrder
    device_info3?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_subscription_tblCountOrderByAggregateInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    user_email_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_subscription_tblAvgOrderByAggregateInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_subscription_tblMaxOrderByAggregateInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    user_email_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_subscription_tblMinOrderByAggregateInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    user_email_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_subscription_tblSumOrderByAggregateInput = {
    subscription_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type user_walletCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_walletAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
  }

  export type user_walletMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_walletMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_walletSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
  }

  export type user_wallet_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_wallet_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
  }

  export type user_wallet_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_wallet_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
    date?: SortOrder
  }

  export type user_wallet_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    transaction_type?: SortOrder
    balance_inr?: SortOrder
    balance_usd?: SortOrder
  }

  export type users_tblCountOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    language_id?: SortOrder
    genre_ids?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    user_type?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    secret_code?: SortOrder
    channel?: SortOrder
    profile_img_url?: SortOrder
  }

  export type users_tblAvgOrderByAggregateInput = {
    user_id?: SortOrder
    language_id?: SortOrder
    zipcode?: SortOrder
  }

  export type users_tblMaxOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    language_id?: SortOrder
    genre_ids?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    user_type?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    secret_code?: SortOrder
    channel?: SortOrder
    profile_img_url?: SortOrder
  }

  export type users_tblMinOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    language_id?: SortOrder
    genre_ids?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    user_type?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    secret_code?: SortOrder
    channel?: SortOrder
    profile_img_url?: SortOrder
  }

  export type users_tblSumOrderByAggregateInput = {
    user_id?: SortOrder
    language_id?: SortOrder
    zipcode?: SortOrder
  }

  export type wallet_order_tblCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_order_tblAvgOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_order_tblMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_order_tblMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    cart_type?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_order_tblSumOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    user_id?: SortOrder
    subtotal?: SortOrder
    service_tax?: SortOrder
    net_total?: SortOrder
    discount?: SortOrder
  }

  export type wallet_transaction_typeCountOrderByAggregateInput = {
    transaction_type?: SortOrder
    transaction_value?: SortOrder
  }

  export type wallet_transaction_typeAvgOrderByAggregateInput = {
    transaction_type?: SortOrder
  }

  export type wallet_transaction_typeMaxOrderByAggregateInput = {
    transaction_type?: SortOrder
    transaction_value?: SortOrder
  }

  export type wallet_transaction_typeMinOrderByAggregateInput = {
    transaction_type?: SortOrder
    transaction_value?: SortOrder
  }

  export type wallet_transaction_typeSumOrderByAggregateInput = {
    transaction_type?: SortOrder
  }

  export type wishlistCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type wishlistAvgOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
  }

  export type wishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type wishlistMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type wishlistSumOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    user_id?: SortOrder
  }

  export type book_tblCreateNestedOneWithoutAmazonBookIdInput = {
    create?: XOR<book_tblCreateWithoutAmazonBookIdInput, book_tblUncheckedCreateWithoutAmazonBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAmazonBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type book_tblUpdateOneRequiredWithoutAmazonBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutAmazonBookIdInput, book_tblUncheckedCreateWithoutAmazonBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAmazonBookIdInput
    upsert?: book_tblUpsertWithoutAmazonBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutAmazonBookIdInput, book_tblUncheckedUpdateWithoutAmazonBookIdInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type book_tblCreateNestedOneWithoutAmazon_transactionsInput = {
    create?: XOR<book_tblCreateWithoutAmazon_transactionsInput, book_tblUncheckedCreateWithoutAmazon_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAmazon_transactionsInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutAmazon_transactionsNestedInput = {
    create?: XOR<book_tblCreateWithoutAmazon_transactionsInput, book_tblUncheckedCreateWithoutAmazon_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAmazon_transactionsInput
    upsert?: book_tblUpsertWithoutAmazon_transactionsInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutAmazon_transactionsInput, book_tblUncheckedUpdateWithoutAmazon_transactionsInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type book_tblCreateNestedOneWithoutAudibleBookIdInput = {
    create?: XOR<book_tblCreateWithoutAudibleBookIdInput, book_tblUncheckedCreateWithoutAudibleBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAudibleBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutAudibleBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutAudibleBookIdInput, book_tblUncheckedCreateWithoutAudibleBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAudibleBookIdInput
    upsert?: book_tblUpsertWithoutAudibleBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutAudibleBookIdInput, book_tblUncheckedUpdateWithoutAudibleBookIdInput>
  }

  export type book_tblCreateNestedOneWithoutAudible_transactionsInput = {
    create?: XOR<book_tblCreateWithoutAudible_transactionsInput, book_tblUncheckedCreateWithoutAudible_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAudible_transactionsInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutAudible_transactionsNestedInput = {
    create?: XOR<book_tblCreateWithoutAudible_transactionsInput, book_tblUncheckedCreateWithoutAudible_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAudible_transactionsInput
    upsert?: book_tblUpsertWithoutAudible_transactionsInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutAudible_transactionsInput, book_tblUncheckedUpdateWithoutAudible_transactionsInput>
  }

  export type book_tblCreateNestedOneWithoutGiftBooksInput = {
    create?: XOR<book_tblCreateWithoutGiftBooksInput, book_tblUncheckedCreateWithoutGiftBooksInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGiftBooksInput
    connect?: book_tblWhereUniqueInput
  }

  export type users_tblCreateNestedOneWithoutGiftBooksInput = {
    create?: XOR<users_tblCreateWithoutGiftBooksInput, users_tblUncheckedCreateWithoutGiftBooksInput>
    connectOrCreate?: users_tblCreateOrConnectWithoutGiftBooksInput
    connect?: users_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutGiftBooksNestedInput = {
    create?: XOR<book_tblCreateWithoutGiftBooksInput, book_tblUncheckedCreateWithoutGiftBooksInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGiftBooksInput
    upsert?: book_tblUpsertWithoutGiftBooksInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutGiftBooksInput, book_tblUncheckedUpdateWithoutGiftBooksInput>
  }

  export type users_tblUpdateOneRequiredWithoutGiftBooksNestedInput = {
    create?: XOR<users_tblCreateWithoutGiftBooksInput, users_tblUncheckedCreateWithoutGiftBooksInput>
    connectOrCreate?: users_tblCreateOrConnectWithoutGiftBooksInput
    upsert?: users_tblUpsertWithoutGiftBooksInput
    connect?: users_tblWhereUniqueInput
    update?: XOR<users_tblUpdateWithoutGiftBooksInput, users_tblUncheckedUpdateWithoutGiftBooksInput>
  }

  export type language_tblCreateNestedOneWithoutAuthorLanguagesInput = {
    create?: XOR<language_tblCreateWithoutAuthorLanguagesInput, language_tblUncheckedCreateWithoutAuthorLanguagesInput>
    connectOrCreate?: language_tblCreateOrConnectWithoutAuthorLanguagesInput
    connect?: language_tblWhereUniqueInput
  }

  export type language_tblUpdateOneRequiredWithoutAuthorLanguagesNestedInput = {
    create?: XOR<language_tblCreateWithoutAuthorLanguagesInput, language_tblUncheckedCreateWithoutAuthorLanguagesInput>
    connectOrCreate?: language_tblCreateOrConnectWithoutAuthorLanguagesInput
    upsert?: language_tblUpsertWithoutAuthorLanguagesInput
    connect?: language_tblWhereUniqueInput
    update?: XOR<language_tblUpdateWithoutAuthorLanguagesInput, language_tblUncheckedUpdateWithoutAuthorLanguagesInput>
  }

  export type book_tblCreateNestedOneWithoutAuthor_transactionInput = {
    create?: XOR<book_tblCreateWithoutAuthor_transactionInput, book_tblUncheckedCreateWithoutAuthor_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAuthor_transactionInput
    connect?: book_tblWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type book_tblUpdateOneRequiredWithoutAuthor_transactionNestedInput = {
    create?: XOR<book_tblCreateWithoutAuthor_transactionInput, book_tblUncheckedCreateWithoutAuthor_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutAuthor_transactionInput
    upsert?: book_tblUpsertWithoutAuthor_transactionInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutAuthor_transactionInput, book_tblUncheckedUpdateWithoutAuthor_transactionInput>
  }

  export type language_tblCreateNestedOneWithoutBooksInput = {
    create?: XOR<language_tblCreateWithoutBooksInput, language_tblUncheckedCreateWithoutBooksInput>
    connectOrCreate?: language_tblCreateOrConnectWithoutBooksInput
    connect?: language_tblWhereUniqueInput
  }

  export type genre_details_tblCreateNestedOneWithoutBooksInput = {
    create?: XOR<genre_details_tblCreateWithoutBooksInput, genre_details_tblUncheckedCreateWithoutBooksInput>
    connectOrCreate?: genre_details_tblCreateOrConnectWithoutBooksInput
    connect?: genre_details_tblWhereUniqueInput
  }

  export type amazon_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_booksCreateOrConnectWithoutBookInput
    connect?: amazon_booksWhereUniqueInput
  }

  export type scribd_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_booksCreateOrConnectWithoutBookInput
    connect?: scribd_booksWhereUniqueInput
  }

  export type google_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_booksCreateOrConnectWithoutBookInput
    connect?: google_booksWhereUniqueInput
  }

  export type storytel_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_booksCreateOrConnectWithoutBookInput
    connect?: storytel_booksWhereUniqueInput
  }

  export type overdrive_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_booksCreateOrConnectWithoutBookInput
    connect?: overdrive_booksWhereUniqueInput
  }

  export type audible_booksCreateNestedOneWithoutBookInput = {
    create?: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_booksCreateOrConnectWithoutBookInput
    connect?: audible_booksWhereUniqueInput
  }

  export type author_gift_booksCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutBookInput>, Enumerable<author_gift_booksUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutBookInput>
    createMany?: author_gift_booksCreateManyBookInputEnvelope
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
  }

  export type amazon_transactionsCreateNestedOneWithoutBookInput = {
    create?: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_transactionsCreateOrConnectWithoutBookInput
    connect?: amazon_transactionsWhereUniqueInput
  }

  export type audible_transactionsCreateNestedOneWithoutBookInput = {
    create?: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_transactionsCreateOrConnectWithoutBookInput
    connect?: audible_transactionsWhereUniqueInput
  }

  export type author_transactionCreateNestedOneWithoutBookInput = {
    create?: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: author_transactionCreateOrConnectWithoutBookInput
    connect?: author_transactionWhereUniqueInput
  }

  export type google_transactionsCreateNestedOneWithoutBookInput = {
    create?: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_transactionsCreateOrConnectWithoutBookInput
    connect?: google_transactionsWhereUniqueInput
  }

  export type kobo_transactionCreateNestedOneWithoutBookInput = {
    create?: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: kobo_transactionCreateOrConnectWithoutBookInput
    connect?: kobo_transactionWhereUniqueInput
  }

  export type overdrive_transactionsCreateNestedOneWithoutBookInput = {
    create?: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_transactionsCreateOrConnectWithoutBookInput
    connect?: overdrive_transactionsWhereUniqueInput
  }

  export type scribd_transactionCreateNestedOneWithoutBookInput = {
    create?: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_transactionCreateOrConnectWithoutBookInput
    connect?: scribd_transactionWhereUniqueInput
  }

  export type storytel_transactionsCreateNestedOneWithoutBookInput = {
    create?: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_transactionsCreateOrConnectWithoutBookInput
    connect?: storytel_transactionsWhereUniqueInput
  }

  export type amazon_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_booksCreateOrConnectWithoutBookInput
    connect?: amazon_booksWhereUniqueInput
  }

  export type scribd_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_booksCreateOrConnectWithoutBookInput
    connect?: scribd_booksWhereUniqueInput
  }

  export type google_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_booksCreateOrConnectWithoutBookInput
    connect?: google_booksWhereUniqueInput
  }

  export type storytel_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_booksCreateOrConnectWithoutBookInput
    connect?: storytel_booksWhereUniqueInput
  }

  export type overdrive_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_booksCreateOrConnectWithoutBookInput
    connect?: overdrive_booksWhereUniqueInput
  }

  export type audible_booksUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_booksCreateOrConnectWithoutBookInput
    connect?: audible_booksWhereUniqueInput
  }

  export type author_gift_booksUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutBookInput>, Enumerable<author_gift_booksUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutBookInput>
    createMany?: author_gift_booksCreateManyBookInputEnvelope
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
  }

  export type amazon_transactionsUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_transactionsCreateOrConnectWithoutBookInput
    connect?: amazon_transactionsWhereUniqueInput
  }

  export type audible_transactionsUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_transactionsCreateOrConnectWithoutBookInput
    connect?: audible_transactionsWhereUniqueInput
  }

  export type author_transactionUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: author_transactionCreateOrConnectWithoutBookInput
    connect?: author_transactionWhereUniqueInput
  }

  export type google_transactionsUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_transactionsCreateOrConnectWithoutBookInput
    connect?: google_transactionsWhereUniqueInput
  }

  export type kobo_transactionUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: kobo_transactionCreateOrConnectWithoutBookInput
    connect?: kobo_transactionWhereUniqueInput
  }

  export type overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_transactionsCreateOrConnectWithoutBookInput
    connect?: overdrive_transactionsWhereUniqueInput
  }

  export type scribd_transactionUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_transactionCreateOrConnectWithoutBookInput
    connect?: scribd_transactionWhereUniqueInput
  }

  export type storytel_transactionsUncheckedCreateNestedOneWithoutBookInput = {
    create?: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_transactionsCreateOrConnectWithoutBookInput
    connect?: storytel_transactionsWhereUniqueInput
  }

  export type language_tblUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<language_tblCreateWithoutBooksInput, language_tblUncheckedCreateWithoutBooksInput>
    connectOrCreate?: language_tblCreateOrConnectWithoutBooksInput
    upsert?: language_tblUpsertWithoutBooksInput
    connect?: language_tblWhereUniqueInput
    update?: XOR<language_tblUpdateWithoutBooksInput, language_tblUncheckedUpdateWithoutBooksInput>
  }

  export type genre_details_tblUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<genre_details_tblCreateWithoutBooksInput, genre_details_tblUncheckedCreateWithoutBooksInput>
    connectOrCreate?: genre_details_tblCreateOrConnectWithoutBooksInput
    upsert?: genre_details_tblUpsertWithoutBooksInput
    connect?: genre_details_tblWhereUniqueInput
    update?: XOR<genre_details_tblUpdateWithoutBooksInput, genre_details_tblUncheckedUpdateWithoutBooksInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type amazon_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_booksCreateOrConnectWithoutBookInput
    upsert?: amazon_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: amazon_booksWhereUniqueInput
    update?: XOR<amazon_booksUpdateWithoutBookInput, amazon_booksUncheckedUpdateWithoutBookInput>
  }

  export type scribd_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_booksCreateOrConnectWithoutBookInput
    upsert?: scribd_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: scribd_booksWhereUniqueInput
    update?: XOR<scribd_booksUpdateWithoutBookInput, scribd_booksUncheckedUpdateWithoutBookInput>
  }

  export type google_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_booksCreateOrConnectWithoutBookInput
    upsert?: google_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: google_booksWhereUniqueInput
    update?: XOR<google_booksUpdateWithoutBookInput, google_booksUncheckedUpdateWithoutBookInput>
  }

  export type storytel_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_booksCreateOrConnectWithoutBookInput
    upsert?: storytel_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: storytel_booksWhereUniqueInput
    update?: XOR<storytel_booksUpdateWithoutBookInput, storytel_booksUncheckedUpdateWithoutBookInput>
  }

  export type overdrive_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_booksCreateOrConnectWithoutBookInput
    upsert?: overdrive_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: overdrive_booksWhereUniqueInput
    update?: XOR<overdrive_booksUpdateWithoutBookInput, overdrive_booksUncheckedUpdateWithoutBookInput>
  }

  export type audible_booksUpdateOneWithoutBookNestedInput = {
    create?: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_booksCreateOrConnectWithoutBookInput
    upsert?: audible_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: audible_booksWhereUniqueInput
    update?: XOR<audible_booksUpdateWithoutBookInput, audible_booksUncheckedUpdateWithoutBookInput>
  }

  export type author_gift_booksUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutBookInput>, Enumerable<author_gift_booksUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<author_gift_booksUpsertWithWhereUniqueWithoutBookInput>
    createMany?: author_gift_booksCreateManyBookInputEnvelope
    set?: Enumerable<author_gift_booksWhereUniqueInput>
    disconnect?: Enumerable<author_gift_booksWhereUniqueInput>
    delete?: Enumerable<author_gift_booksWhereUniqueInput>
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
    update?: Enumerable<author_gift_booksUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<author_gift_booksUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<author_gift_booksScalarWhereInput>
  }

  export type amazon_transactionsUpdateOneWithoutBookNestedInput = {
    create?: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_transactionsCreateOrConnectWithoutBookInput
    upsert?: amazon_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: amazon_transactionsWhereUniqueInput
    update?: XOR<amazon_transactionsUpdateWithoutBookInput, amazon_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type audible_transactionsUpdateOneWithoutBookNestedInput = {
    create?: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_transactionsCreateOrConnectWithoutBookInput
    upsert?: audible_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: audible_transactionsWhereUniqueInput
    update?: XOR<audible_transactionsUpdateWithoutBookInput, audible_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type author_transactionUpdateOneWithoutBookNestedInput = {
    create?: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: author_transactionCreateOrConnectWithoutBookInput
    upsert?: author_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: author_transactionWhereUniqueInput
    update?: XOR<author_transactionUpdateWithoutBookInput, author_transactionUncheckedUpdateWithoutBookInput>
  }

  export type google_transactionsUpdateOneWithoutBookNestedInput = {
    create?: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_transactionsCreateOrConnectWithoutBookInput
    upsert?: google_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: google_transactionsWhereUniqueInput
    update?: XOR<google_transactionsUpdateWithoutBookInput, google_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type kobo_transactionUpdateOneWithoutBookNestedInput = {
    create?: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: kobo_transactionCreateOrConnectWithoutBookInput
    upsert?: kobo_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: kobo_transactionWhereUniqueInput
    update?: XOR<kobo_transactionUpdateWithoutBookInput, kobo_transactionUncheckedUpdateWithoutBookInput>
  }

  export type overdrive_transactionsUpdateOneWithoutBookNestedInput = {
    create?: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_transactionsCreateOrConnectWithoutBookInput
    upsert?: overdrive_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: overdrive_transactionsWhereUniqueInput
    update?: XOR<overdrive_transactionsUpdateWithoutBookInput, overdrive_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type scribd_transactionUpdateOneWithoutBookNestedInput = {
    create?: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_transactionCreateOrConnectWithoutBookInput
    upsert?: scribd_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: scribd_transactionWhereUniqueInput
    update?: XOR<scribd_transactionUpdateWithoutBookInput, scribd_transactionUncheckedUpdateWithoutBookInput>
  }

  export type storytel_transactionsUpdateOneWithoutBookNestedInput = {
    create?: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_transactionsCreateOrConnectWithoutBookInput
    upsert?: storytel_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: storytel_transactionsWhereUniqueInput
    update?: XOR<storytel_transactionsUpdateWithoutBookInput, storytel_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type amazon_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_booksCreateOrConnectWithoutBookInput
    upsert?: amazon_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: amazon_booksWhereUniqueInput
    update?: XOR<amazon_booksUpdateWithoutBookInput, amazon_booksUncheckedUpdateWithoutBookInput>
  }

  export type scribd_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_booksCreateOrConnectWithoutBookInput
    upsert?: scribd_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: scribd_booksWhereUniqueInput
    update?: XOR<scribd_booksUpdateWithoutBookInput, scribd_booksUncheckedUpdateWithoutBookInput>
  }

  export type google_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_booksCreateOrConnectWithoutBookInput
    upsert?: google_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: google_booksWhereUniqueInput
    update?: XOR<google_booksUpdateWithoutBookInput, google_booksUncheckedUpdateWithoutBookInput>
  }

  export type storytel_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_booksCreateOrConnectWithoutBookInput
    upsert?: storytel_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: storytel_booksWhereUniqueInput
    update?: XOR<storytel_booksUpdateWithoutBookInput, storytel_booksUncheckedUpdateWithoutBookInput>
  }

  export type overdrive_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_booksCreateOrConnectWithoutBookInput
    upsert?: overdrive_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: overdrive_booksWhereUniqueInput
    update?: XOR<overdrive_booksUpdateWithoutBookInput, overdrive_booksUncheckedUpdateWithoutBookInput>
  }

  export type audible_booksUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_booksCreateOrConnectWithoutBookInput
    upsert?: audible_booksUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: audible_booksWhereUniqueInput
    update?: XOR<audible_booksUpdateWithoutBookInput, audible_booksUncheckedUpdateWithoutBookInput>
  }

  export type author_gift_booksUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutBookInput>, Enumerable<author_gift_booksUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<author_gift_booksUpsertWithWhereUniqueWithoutBookInput>
    createMany?: author_gift_booksCreateManyBookInputEnvelope
    set?: Enumerable<author_gift_booksWhereUniqueInput>
    disconnect?: Enumerable<author_gift_booksWhereUniqueInput>
    delete?: Enumerable<author_gift_booksWhereUniqueInput>
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
    update?: Enumerable<author_gift_booksUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<author_gift_booksUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<author_gift_booksScalarWhereInput>
  }

  export type amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: amazon_transactionsCreateOrConnectWithoutBookInput
    upsert?: amazon_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: amazon_transactionsWhereUniqueInput
    update?: XOR<amazon_transactionsUpdateWithoutBookInput, amazon_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type audible_transactionsUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: audible_transactionsCreateOrConnectWithoutBookInput
    upsert?: audible_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: audible_transactionsWhereUniqueInput
    update?: XOR<audible_transactionsUpdateWithoutBookInput, audible_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type author_transactionUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: author_transactionCreateOrConnectWithoutBookInput
    upsert?: author_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: author_transactionWhereUniqueInput
    update?: XOR<author_transactionUpdateWithoutBookInput, author_transactionUncheckedUpdateWithoutBookInput>
  }

  export type google_transactionsUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: google_transactionsCreateOrConnectWithoutBookInput
    upsert?: google_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: google_transactionsWhereUniqueInput
    update?: XOR<google_transactionsUpdateWithoutBookInput, google_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type kobo_transactionUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: kobo_transactionCreateOrConnectWithoutBookInput
    upsert?: kobo_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: kobo_transactionWhereUniqueInput
    update?: XOR<kobo_transactionUpdateWithoutBookInput, kobo_transactionUncheckedUpdateWithoutBookInput>
  }

  export type overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: overdrive_transactionsCreateOrConnectWithoutBookInput
    upsert?: overdrive_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: overdrive_transactionsWhereUniqueInput
    update?: XOR<overdrive_transactionsUpdateWithoutBookInput, overdrive_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type scribd_transactionUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
    connectOrCreate?: scribd_transactionCreateOrConnectWithoutBookInput
    upsert?: scribd_transactionUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: scribd_transactionWhereUniqueInput
    update?: XOR<scribd_transactionUpdateWithoutBookInput, scribd_transactionUncheckedUpdateWithoutBookInput>
  }

  export type storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput = {
    create?: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
    connectOrCreate?: storytel_transactionsCreateOrConnectWithoutBookInput
    upsert?: storytel_transactionsUpsertWithoutBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: storytel_transactionsWhereUniqueInput
    update?: XOR<storytel_transactionsUpdateWithoutBookInput, storytel_transactionsUncheckedUpdateWithoutBookInput>
  }

  export type book_tblCreateNestedManyWithoutGenreInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutGenreInput>, Enumerable<book_tblUncheckedCreateWithoutGenreInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutGenreInput>
    createMany?: book_tblCreateManyGenreInputEnvelope
    connect?: Enumerable<book_tblWhereUniqueInput>
  }

  export type book_tblUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutGenreInput>, Enumerable<book_tblUncheckedCreateWithoutGenreInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutGenreInput>
    createMany?: book_tblCreateManyGenreInputEnvelope
    connect?: Enumerable<book_tblWhereUniqueInput>
  }

  export type book_tblUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutGenreInput>, Enumerable<book_tblUncheckedCreateWithoutGenreInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutGenreInput>
    upsert?: Enumerable<book_tblUpsertWithWhereUniqueWithoutGenreInput>
    createMany?: book_tblCreateManyGenreInputEnvelope
    set?: Enumerable<book_tblWhereUniqueInput>
    disconnect?: Enumerable<book_tblWhereUniqueInput>
    delete?: Enumerable<book_tblWhereUniqueInput>
    connect?: Enumerable<book_tblWhereUniqueInput>
    update?: Enumerable<book_tblUpdateWithWhereUniqueWithoutGenreInput>
    updateMany?: Enumerable<book_tblUpdateManyWithWhereWithoutGenreInput>
    deleteMany?: Enumerable<book_tblScalarWhereInput>
  }

  export type book_tblUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutGenreInput>, Enumerable<book_tblUncheckedCreateWithoutGenreInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutGenreInput>
    upsert?: Enumerable<book_tblUpsertWithWhereUniqueWithoutGenreInput>
    createMany?: book_tblCreateManyGenreInputEnvelope
    set?: Enumerable<book_tblWhereUniqueInput>
    disconnect?: Enumerable<book_tblWhereUniqueInput>
    delete?: Enumerable<book_tblWhereUniqueInput>
    connect?: Enumerable<book_tblWhereUniqueInput>
    update?: Enumerable<book_tblUpdateWithWhereUniqueWithoutGenreInput>
    updateMany?: Enumerable<book_tblUpdateManyWithWhereWithoutGenreInput>
    deleteMany?: Enumerable<book_tblScalarWhereInput>
  }

  export type book_tblCreateNestedOneWithoutGoogleBookIdInput = {
    create?: XOR<book_tblCreateWithoutGoogleBookIdInput, book_tblUncheckedCreateWithoutGoogleBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGoogleBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type book_tblUpdateOneRequiredWithoutGoogleBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutGoogleBookIdInput, book_tblUncheckedCreateWithoutGoogleBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGoogleBookIdInput
    upsert?: book_tblUpsertWithoutGoogleBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutGoogleBookIdInput, book_tblUncheckedUpdateWithoutGoogleBookIdInput>
  }

  export type book_tblCreateNestedOneWithoutGoogle_transactionsInput = {
    create?: XOR<book_tblCreateWithoutGoogle_transactionsInput, book_tblUncheckedCreateWithoutGoogle_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGoogle_transactionsInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutGoogle_transactionsNestedInput = {
    create?: XOR<book_tblCreateWithoutGoogle_transactionsInput, book_tblUncheckedCreateWithoutGoogle_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutGoogle_transactionsInput
    upsert?: book_tblUpsertWithoutGoogle_transactionsInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutGoogle_transactionsInput, book_tblUncheckedUpdateWithoutGoogle_transactionsInput>
  }

  export type book_tblCreateNestedOneWithoutKobo_transactionInput = {
    create?: XOR<book_tblCreateWithoutKobo_transactionInput, book_tblUncheckedCreateWithoutKobo_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutKobo_transactionInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutKobo_transactionNestedInput = {
    create?: XOR<book_tblCreateWithoutKobo_transactionInput, book_tblUncheckedCreateWithoutKobo_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutKobo_transactionInput
    upsert?: book_tblUpsertWithoutKobo_transactionInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutKobo_transactionInput, book_tblUncheckedUpdateWithoutKobo_transactionInput>
  }

  export type book_tblCreateNestedManyWithoutLanguage_tbl_relationInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutLanguage_tbl_relationInput>, Enumerable<book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutLanguage_tbl_relationInput>
    createMany?: book_tblCreateManyLanguage_tbl_relationInputEnvelope
    connect?: Enumerable<book_tblWhereUniqueInput>
  }

  export type author_languageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<Enumerable<author_languageCreateWithoutLanguageInput>, Enumerable<author_languageUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<author_languageCreateOrConnectWithoutLanguageInput>
    createMany?: author_languageCreateManyLanguageInputEnvelope
    connect?: Enumerable<author_languageWhereUniqueInput>
  }

  export type book_tblUncheckedCreateNestedManyWithoutLanguage_tbl_relationInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutLanguage_tbl_relationInput>, Enumerable<book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutLanguage_tbl_relationInput>
    createMany?: book_tblCreateManyLanguage_tbl_relationInputEnvelope
    connect?: Enumerable<book_tblWhereUniqueInput>
  }

  export type author_languageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<Enumerable<author_languageCreateWithoutLanguageInput>, Enumerable<author_languageUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<author_languageCreateOrConnectWithoutLanguageInput>
    createMany?: author_languageCreateManyLanguageInputEnvelope
    connect?: Enumerable<author_languageWhereUniqueInput>
  }

  export type book_tblUpdateManyWithoutLanguage_tbl_relationNestedInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutLanguage_tbl_relationInput>, Enumerable<book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutLanguage_tbl_relationInput>
    upsert?: Enumerable<book_tblUpsertWithWhereUniqueWithoutLanguage_tbl_relationInput>
    createMany?: book_tblCreateManyLanguage_tbl_relationInputEnvelope
    set?: Enumerable<book_tblWhereUniqueInput>
    disconnect?: Enumerable<book_tblWhereUniqueInput>
    delete?: Enumerable<book_tblWhereUniqueInput>
    connect?: Enumerable<book_tblWhereUniqueInput>
    update?: Enumerable<book_tblUpdateWithWhereUniqueWithoutLanguage_tbl_relationInput>
    updateMany?: Enumerable<book_tblUpdateManyWithWhereWithoutLanguage_tbl_relationInput>
    deleteMany?: Enumerable<book_tblScalarWhereInput>
  }

  export type author_languageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<Enumerable<author_languageCreateWithoutLanguageInput>, Enumerable<author_languageUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<author_languageCreateOrConnectWithoutLanguageInput>
    upsert?: Enumerable<author_languageUpsertWithWhereUniqueWithoutLanguageInput>
    createMany?: author_languageCreateManyLanguageInputEnvelope
    set?: Enumerable<author_languageWhereUniqueInput>
    disconnect?: Enumerable<author_languageWhereUniqueInput>
    delete?: Enumerable<author_languageWhereUniqueInput>
    connect?: Enumerable<author_languageWhereUniqueInput>
    update?: Enumerable<author_languageUpdateWithWhereUniqueWithoutLanguageInput>
    updateMany?: Enumerable<author_languageUpdateManyWithWhereWithoutLanguageInput>
    deleteMany?: Enumerable<author_languageScalarWhereInput>
  }

  export type book_tblUncheckedUpdateManyWithoutLanguage_tbl_relationNestedInput = {
    create?: XOR<Enumerable<book_tblCreateWithoutLanguage_tbl_relationInput>, Enumerable<book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>>
    connectOrCreate?: Enumerable<book_tblCreateOrConnectWithoutLanguage_tbl_relationInput>
    upsert?: Enumerable<book_tblUpsertWithWhereUniqueWithoutLanguage_tbl_relationInput>
    createMany?: book_tblCreateManyLanguage_tbl_relationInputEnvelope
    set?: Enumerable<book_tblWhereUniqueInput>
    disconnect?: Enumerable<book_tblWhereUniqueInput>
    delete?: Enumerable<book_tblWhereUniqueInput>
    connect?: Enumerable<book_tblWhereUniqueInput>
    update?: Enumerable<book_tblUpdateWithWhereUniqueWithoutLanguage_tbl_relationInput>
    updateMany?: Enumerable<book_tblUpdateManyWithWhereWithoutLanguage_tbl_relationInput>
    deleteMany?: Enumerable<book_tblScalarWhereInput>
  }

  export type author_languageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<Enumerable<author_languageCreateWithoutLanguageInput>, Enumerable<author_languageUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<author_languageCreateOrConnectWithoutLanguageInput>
    upsert?: Enumerable<author_languageUpsertWithWhereUniqueWithoutLanguageInput>
    createMany?: author_languageCreateManyLanguageInputEnvelope
    set?: Enumerable<author_languageWhereUniqueInput>
    disconnect?: Enumerable<author_languageWhereUniqueInput>
    delete?: Enumerable<author_languageWhereUniqueInput>
    connect?: Enumerable<author_languageWhereUniqueInput>
    update?: Enumerable<author_languageUpdateWithWhereUniqueWithoutLanguageInput>
    updateMany?: Enumerable<author_languageUpdateManyWithWhereWithoutLanguageInput>
    deleteMany?: Enumerable<author_languageScalarWhereInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type book_tblCreateNestedOneWithoutOverdriveBookIdInput = {
    create?: XOR<book_tblCreateWithoutOverdriveBookIdInput, book_tblUncheckedCreateWithoutOverdriveBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutOverdriveBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutOverdriveBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutOverdriveBookIdInput, book_tblUncheckedCreateWithoutOverdriveBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutOverdriveBookIdInput
    upsert?: book_tblUpsertWithoutOverdriveBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutOverdriveBookIdInput, book_tblUncheckedUpdateWithoutOverdriveBookIdInput>
  }

  export type book_tblCreateNestedOneWithoutOverdrive_transactionsInput = {
    create?: XOR<book_tblCreateWithoutOverdrive_transactionsInput, book_tblUncheckedCreateWithoutOverdrive_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutOverdrive_transactionsInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutOverdrive_transactionsNestedInput = {
    create?: XOR<book_tblCreateWithoutOverdrive_transactionsInput, book_tblUncheckedCreateWithoutOverdrive_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutOverdrive_transactionsInput
    upsert?: book_tblUpsertWithoutOverdrive_transactionsInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutOverdrive_transactionsInput, book_tblUncheckedUpdateWithoutOverdrive_transactionsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type book_tblCreateNestedOneWithoutScribdBookIdInput = {
    create?: XOR<book_tblCreateWithoutScribdBookIdInput, book_tblUncheckedCreateWithoutScribdBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutScribdBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutScribdBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutScribdBookIdInput, book_tblUncheckedCreateWithoutScribdBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutScribdBookIdInput
    upsert?: book_tblUpsertWithoutScribdBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutScribdBookIdInput, book_tblUncheckedUpdateWithoutScribdBookIdInput>
  }

  export type book_tblCreateNestedOneWithoutScribd_transactionInput = {
    create?: XOR<book_tblCreateWithoutScribd_transactionInput, book_tblUncheckedCreateWithoutScribd_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutScribd_transactionInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutScribd_transactionNestedInput = {
    create?: XOR<book_tblCreateWithoutScribd_transactionInput, book_tblUncheckedCreateWithoutScribd_transactionInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutScribd_transactionInput
    upsert?: book_tblUpsertWithoutScribd_transactionInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutScribd_transactionInput, book_tblUncheckedUpdateWithoutScribd_transactionInput>
  }

  export type book_tblCreateNestedOneWithoutStorytelBookIdInput = {
    create?: XOR<book_tblCreateWithoutStorytelBookIdInput, book_tblUncheckedCreateWithoutStorytelBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutStorytelBookIdInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutStorytelBookIdNestedInput = {
    create?: XOR<book_tblCreateWithoutStorytelBookIdInput, book_tblUncheckedCreateWithoutStorytelBookIdInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutStorytelBookIdInput
    upsert?: book_tblUpsertWithoutStorytelBookIdInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutStorytelBookIdInput, book_tblUncheckedUpdateWithoutStorytelBookIdInput>
  }

  export type book_tblCreateNestedOneWithoutStorytel_transactionsInput = {
    create?: XOR<book_tblCreateWithoutStorytel_transactionsInput, book_tblUncheckedCreateWithoutStorytel_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutStorytel_transactionsInput
    connect?: book_tblWhereUniqueInput
  }

  export type book_tblUpdateOneRequiredWithoutStorytel_transactionsNestedInput = {
    create?: XOR<book_tblCreateWithoutStorytel_transactionsInput, book_tblUncheckedCreateWithoutStorytel_transactionsInput>
    connectOrCreate?: book_tblCreateOrConnectWithoutStorytel_transactionsInput
    upsert?: book_tblUpsertWithoutStorytel_transactionsInput
    connect?: book_tblWhereUniqueInput
    update?: XOR<book_tblUpdateWithoutStorytel_transactionsInput, book_tblUncheckedUpdateWithoutStorytel_transactionsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type author_gift_booksCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutUserInput>, Enumerable<author_gift_booksUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutUserInput>
    createMany?: author_gift_booksCreateManyUserInputEnvelope
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
  }

  export type author_gift_booksUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutUserInput>, Enumerable<author_gift_booksUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutUserInput>
    createMany?: author_gift_booksCreateManyUserInputEnvelope
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
  }

  export type author_gift_booksUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutUserInput>, Enumerable<author_gift_booksUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<author_gift_booksUpsertWithWhereUniqueWithoutUserInput>
    createMany?: author_gift_booksCreateManyUserInputEnvelope
    set?: Enumerable<author_gift_booksWhereUniqueInput>
    disconnect?: Enumerable<author_gift_booksWhereUniqueInput>
    delete?: Enumerable<author_gift_booksWhereUniqueInput>
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
    update?: Enumerable<author_gift_booksUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<author_gift_booksUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<author_gift_booksScalarWhereInput>
  }

  export type author_gift_booksUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<author_gift_booksCreateWithoutUserInput>, Enumerable<author_gift_booksUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<author_gift_booksCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<author_gift_booksUpsertWithWhereUniqueWithoutUserInput>
    createMany?: author_gift_booksCreateManyUserInputEnvelope
    set?: Enumerable<author_gift_booksWhereUniqueInput>
    disconnect?: Enumerable<author_gift_booksWhereUniqueInput>
    delete?: Enumerable<author_gift_booksWhereUniqueInput>
    connect?: Enumerable<author_gift_booksWhereUniqueInput>
    update?: Enumerable<author_gift_booksUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<author_gift_booksUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<author_gift_booksScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type book_tblCreateWithoutAmazonBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutAmazonBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutAmazonBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutAmazonBookIdInput, book_tblUncheckedCreateWithoutAmazonBookIdInput>
  }

  export type book_tblUpsertWithoutAmazonBookIdInput = {
    update: XOR<book_tblUpdateWithoutAmazonBookIdInput, book_tblUncheckedUpdateWithoutAmazonBookIdInput>
    create: XOR<book_tblCreateWithoutAmazonBookIdInput, book_tblUncheckedCreateWithoutAmazonBookIdInput>
  }

  export type book_tblUpdateWithoutAmazonBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutAmazonBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutAmazon_transactionsInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutAmazon_transactionsInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutAmazon_transactionsInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutAmazon_transactionsInput, book_tblUncheckedCreateWithoutAmazon_transactionsInput>
  }

  export type book_tblUpsertWithoutAmazon_transactionsInput = {
    update: XOR<book_tblUpdateWithoutAmazon_transactionsInput, book_tblUncheckedUpdateWithoutAmazon_transactionsInput>
    create: XOR<book_tblCreateWithoutAmazon_transactionsInput, book_tblUncheckedCreateWithoutAmazon_transactionsInput>
  }

  export type book_tblUpdateWithoutAmazon_transactionsInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutAmazon_transactionsInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutAudibleBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutAudibleBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutAudibleBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutAudibleBookIdInput, book_tblUncheckedCreateWithoutAudibleBookIdInput>
  }

  export type book_tblUpsertWithoutAudibleBookIdInput = {
    update: XOR<book_tblUpdateWithoutAudibleBookIdInput, book_tblUncheckedUpdateWithoutAudibleBookIdInput>
    create: XOR<book_tblCreateWithoutAudibleBookIdInput, book_tblUncheckedCreateWithoutAudibleBookIdInput>
  }

  export type book_tblUpdateWithoutAudibleBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutAudibleBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutAudible_transactionsInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutAudible_transactionsInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutAudible_transactionsInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutAudible_transactionsInput, book_tblUncheckedCreateWithoutAudible_transactionsInput>
  }

  export type book_tblUpsertWithoutAudible_transactionsInput = {
    update: XOR<book_tblUpdateWithoutAudible_transactionsInput, book_tblUncheckedUpdateWithoutAudible_transactionsInput>
    create: XOR<book_tblCreateWithoutAudible_transactionsInput, book_tblUncheckedCreateWithoutAudible_transactionsInput>
  }

  export type book_tblUpdateWithoutAudible_transactionsInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutAudible_transactionsInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutGiftBooksInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutGiftBooksInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutGiftBooksInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutGiftBooksInput, book_tblUncheckedCreateWithoutGiftBooksInput>
  }

  export type users_tblCreateWithoutGiftBooksInput = {
    username: string
    password: string
    dob?: Date | string | null
    gender?: string | null
    phone?: string | null
    language_id?: number | null
    genre_ids?: string | null
    address: string
    city?: string | null
    zipcode: number
    country: string
    user_type?: string
    created_at?: Date | string
    email: string
    secret_code?: string | null
    channel?: string | null
    profile_img_url?: string | null
  }

  export type users_tblUncheckedCreateWithoutGiftBooksInput = {
    user_id?: number
    username: string
    password: string
    dob?: Date | string | null
    gender?: string | null
    phone?: string | null
    language_id?: number | null
    genre_ids?: string | null
    address: string
    city?: string | null
    zipcode: number
    country: string
    user_type?: string
    created_at?: Date | string
    email: string
    secret_code?: string | null
    channel?: string | null
    profile_img_url?: string | null
  }

  export type users_tblCreateOrConnectWithoutGiftBooksInput = {
    where: users_tblWhereUniqueInput
    create: XOR<users_tblCreateWithoutGiftBooksInput, users_tblUncheckedCreateWithoutGiftBooksInput>
  }

  export type book_tblUpsertWithoutGiftBooksInput = {
    update: XOR<book_tblUpdateWithoutGiftBooksInput, book_tblUncheckedUpdateWithoutGiftBooksInput>
    create: XOR<book_tblCreateWithoutGiftBooksInput, book_tblUncheckedCreateWithoutGiftBooksInput>
  }

  export type book_tblUpdateWithoutGiftBooksInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutGiftBooksInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type users_tblUpsertWithoutGiftBooksInput = {
    update: XOR<users_tblUpdateWithoutGiftBooksInput, users_tblUncheckedUpdateWithoutGiftBooksInput>
    create: XOR<users_tblCreateWithoutGiftBooksInput, users_tblUncheckedCreateWithoutGiftBooksInput>
  }

  export type users_tblUpdateWithoutGiftBooksInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type users_tblUncheckedUpdateWithoutGiftBooksInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_ids?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    secret_code?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    profile_img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type language_tblCreateWithoutAuthorLanguagesInput = {
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    books?: book_tblCreateNestedManyWithoutLanguage_tbl_relationInput
  }

  export type language_tblUncheckedCreateWithoutAuthorLanguagesInput = {
    language_id?: number
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    books?: book_tblUncheckedCreateNestedManyWithoutLanguage_tbl_relationInput
  }

  export type language_tblCreateOrConnectWithoutAuthorLanguagesInput = {
    where: language_tblWhereUniqueInput
    create: XOR<language_tblCreateWithoutAuthorLanguagesInput, language_tblUncheckedCreateWithoutAuthorLanguagesInput>
  }

  export type language_tblUpsertWithoutAuthorLanguagesInput = {
    update: XOR<language_tblUpdateWithoutAuthorLanguagesInput, language_tblUncheckedUpdateWithoutAuthorLanguagesInput>
    create: XOR<language_tblCreateWithoutAuthorLanguagesInput, language_tblUncheckedCreateWithoutAuthorLanguagesInput>
  }

  export type language_tblUpdateWithoutAuthorLanguagesInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: book_tblUpdateManyWithoutLanguage_tbl_relationNestedInput
  }

  export type language_tblUncheckedUpdateWithoutAuthorLanguagesInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: book_tblUncheckedUpdateManyWithoutLanguage_tbl_relationNestedInput
  }

  export type book_tblCreateWithoutAuthor_transactionInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutAuthor_transactionInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutAuthor_transactionInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutAuthor_transactionInput, book_tblUncheckedCreateWithoutAuthor_transactionInput>
  }

  export type book_tblUpsertWithoutAuthor_transactionInput = {
    update: XOR<book_tblUpdateWithoutAuthor_transactionInput, book_tblUncheckedUpdateWithoutAuthor_transactionInput>
    create: XOR<book_tblCreateWithoutAuthor_transactionInput, book_tblUncheckedCreateWithoutAuthor_transactionInput>
  }

  export type book_tblUpdateWithoutAuthor_transactionInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutAuthor_transactionInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type language_tblCreateWithoutBooksInput = {
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    authorLanguages?: author_languageCreateNestedManyWithoutLanguageInput
  }

  export type language_tblUncheckedCreateWithoutBooksInput = {
    language_id?: number
    admin_id: number
    language_name: string
    regional_language_name: string
    url_name?: string | null
    image_url?: string | null
    status?: number
    created_at: Date | string
    updated_at: Date | string
    authorLanguages?: author_languageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type language_tblCreateOrConnectWithoutBooksInput = {
    where: language_tblWhereUniqueInput
    create: XOR<language_tblCreateWithoutBooksInput, language_tblUncheckedCreateWithoutBooksInput>
  }

  export type genre_details_tblCreateWithoutBooksInput = {
    admin_id: number
    genre_name: string
    url_name: string
    lang_0?: string | null
    lang_1?: string
    lang_2?: string
    lang_3?: string
    lang_4?: string
    lang_5?: string | null
    status?: number
    bisac_code?: string | null
    image_url?: string | null
  }

  export type genre_details_tblUncheckedCreateWithoutBooksInput = {
    genre_id?: number
    admin_id: number
    genre_name: string
    url_name: string
    lang_0?: string | null
    lang_1?: string
    lang_2?: string
    lang_3?: string
    lang_4?: string
    lang_5?: string | null
    status?: number
    bisac_code?: string | null
    image_url?: string | null
  }

  export type genre_details_tblCreateOrConnectWithoutBooksInput = {
    where: genre_details_tblWhereUniqueInput
    create: XOR<genre_details_tblCreateWithoutBooksInput, genre_details_tblUncheckedCreateWithoutBooksInput>
  }

  export type amazon_booksCreateWithoutBookInput = {
    activate?: number | null
    reference_id: string
    print_book_isbn?: string | null
    eisbn?: string | null
    imprint?: string | null
    title: string
    author: string
    editors?: string | null
    illustrators?: string | null
    contributors?: string | null
    translators?: string | null
    photographers?: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date | string
    publishing_date?: Date | string | null
    description?: string | null
    bisac?: string | null
    bic?: string | null
    territory?: string | null
    exclude_territory?: string | null
    adult_flag?: string | null
    edition?: number | null
    series_title?: string | null
    series_number?: number | null
    volume?: number | null
    keywords?: string | null
    asin: string
    amazon_url?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    status?: number | null
    ku_enabled?: number | null
    ku_activation_date?: Date | string | null
    ku_us_enabled?: number | null
    ku_uk_enabled?: number | null
  }

  export type amazon_booksUncheckedCreateWithoutBookInput = {
    id?: number
    activate?: number | null
    reference_id: string
    print_book_isbn?: string | null
    eisbn?: string | null
    imprint?: string | null
    title: string
    author: string
    editors?: string | null
    illustrators?: string | null
    contributors?: string | null
    translators?: string | null
    photographers?: string | null
    language: string
    digital_list_price_usd: number
    digital_list_price_inr: number
    release_date: Date | string
    publishing_date?: Date | string | null
    description?: string | null
    bisac?: string | null
    bic?: string | null
    territory?: string | null
    exclude_territory?: string | null
    adult_flag?: string | null
    edition?: number | null
    series_title?: string | null
    series_number?: number | null
    volume?: number | null
    keywords?: string | null
    asin: string
    amazon_url?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    status?: number | null
    ku_enabled?: number | null
    ku_activation_date?: Date | string | null
    ku_us_enabled?: number | null
    ku_uk_enabled?: number | null
  }

  export type amazon_booksCreateOrConnectWithoutBookInput = {
    where: amazon_booksWhereUniqueInput
    create: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
  }

  export type scribd_booksCreateWithoutBookInput = {
    updated_at: Date | string
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url?: string | null
    imprints?: string | null
    status: string
    publisher_tools_config_id?: number | null
    metadata_status?: string | null
    conversion_status?: string | null
    product_page_pending?: string | null
    subscription_pending?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    duplicate_flag?: number | null
  }

  export type scribd_booksUncheckedCreateWithoutBookInput = {
    id?: number
    updated_at: Date | string
    import_id: number
    doc_id: number
    identifier: string
    title: string
    published: boolean
    in_subscription: boolean
    product_page_url?: string | null
    imprints?: string | null
    status: string
    publisher_tools_config_id?: number | null
    metadata_status?: string | null
    conversion_status?: string | null
    product_page_pending?: string | null
    subscription_pending?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    duplicate_flag?: number | null
  }

  export type scribd_booksCreateOrConnectWithoutBookInput = {
    where: scribd_booksWhereUniqueInput
    create: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
  }

  export type google_booksCreateWithoutBookInput = {
    identifier?: string | null
    status?: string | null
    label?: string | null
    play_store_link?: string | null
    enable_for_sale?: boolean | null
    title?: string | null
    subtitle?: string | null
    book_format?: string | null
    related_identifier?: string | null
    contributor?: string | null
    biographical_note?: string | null
    language?: string | null
    subject_code?: string | null
    age_group?: string | null
    description?: string | null
    publication_date?: string | null
    page_count?: number | null
    series_name?: string | null
    volume_in_series?: number | null
    preview_type?: string | null
    preview_territories?: string | null
    buy_link_text?: string | null
    buy_link?: string | null
    publisher_name?: string | null
    publisher_website?: string | null
    show_photos_preview?: boolean | null
    pdf_download?: boolean | null
    on_sale_date?: string | null
    drm_enabled?: boolean | null
    show_photos_ebook?: boolean | null
    include_scanned_pages?: boolean | null
    mature_audiences?: boolean | null
    copy_paste_percentage?: string | null
    enable_school_use?: boolean | null
    school_list_price_60?: number | null
    school_list_price_180?: number | null
    school_list_price_360?: number | null
    school_use_countries?: string | null
    duration?: Date | string | null
    preview_length_minutes?: number | null
    preview_length_percentage?: number | null
    abridged_version?: string | null
    inr_price_including_tax?: number | null
    inr_countries_including_tax?: string | null
    usd_price_including_tax?: number | null
    usd_countries_including_tax?: string | null
    inr_price_excluding_tax?: number | null
    inr_countries_excluding_tax?: string | null
    usd_price_excluding_tax?: number | null
    usd_countries_excluding_tax?: string | null
    eur_price_including_tax?: number | null
    eur_price_excluding_tax?: number | null
    eur_countries_including_tax?: string | null
    eur_countries_excluding_tax?: string | null
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    publish_date?: Date | string | null
  }

  export type google_booksUncheckedCreateWithoutBookInput = {
    id?: number
    identifier?: string | null
    status?: string | null
    label?: string | null
    play_store_link?: string | null
    enable_for_sale?: boolean | null
    title?: string | null
    subtitle?: string | null
    book_format?: string | null
    related_identifier?: string | null
    contributor?: string | null
    biographical_note?: string | null
    language?: string | null
    subject_code?: string | null
    age_group?: string | null
    description?: string | null
    publication_date?: string | null
    page_count?: number | null
    series_name?: string | null
    volume_in_series?: number | null
    preview_type?: string | null
    preview_territories?: string | null
    buy_link_text?: string | null
    buy_link?: string | null
    publisher_name?: string | null
    publisher_website?: string | null
    show_photos_preview?: boolean | null
    pdf_download?: boolean | null
    on_sale_date?: string | null
    drm_enabled?: boolean | null
    show_photos_ebook?: boolean | null
    include_scanned_pages?: boolean | null
    mature_audiences?: boolean | null
    copy_paste_percentage?: string | null
    enable_school_use?: boolean | null
    school_list_price_60?: number | null
    school_list_price_180?: number | null
    school_list_price_360?: number | null
    school_use_countries?: string | null
    duration?: Date | string | null
    preview_length_minutes?: number | null
    preview_length_percentage?: number | null
    abridged_version?: string | null
    inr_price_including_tax?: number | null
    inr_countries_including_tax?: string | null
    usd_price_including_tax?: number | null
    usd_countries_including_tax?: string | null
    inr_price_excluding_tax?: number | null
    inr_countries_excluding_tax?: string | null
    usd_price_excluding_tax?: number | null
    usd_countries_excluding_tax?: string | null
    eur_price_including_tax?: number | null
    eur_price_excluding_tax?: number | null
    eur_countries_including_tax?: string | null
    eur_countries_excluding_tax?: string | null
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    publish_date?: Date | string | null
  }

  export type google_booksCreateOrConnectWithoutBookInput = {
    where: google_booksWhereUniqueInput
    create: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
  }

  export type storytel_booksCreateWithoutBookInput = {
    storytel_book_id?: string | null
    isbn?: string | null
    title?: string | null
    author_name?: string | null
    narrator?: string | null
    category?: string | null
    publication_date?: Date | string | null
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    genre_id?: number | null
    type_of_book?: number | null
  }

  export type storytel_booksUncheckedCreateWithoutBookInput = {
    id?: number
    storytel_book_id?: string | null
    isbn?: string | null
    title?: string | null
    author_name?: string | null
    narrator?: string | null
    category?: string | null
    publication_date?: Date | string | null
    author_id?: number | null
    copyright_owner?: number | null
    language_id?: number | null
    genre_id?: number | null
    type_of_book?: number | null
  }

  export type storytel_booksCreateOrConnectWithoutBookInput = {
    where: storytel_booksWhereUniqueInput
    create: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
  }

  export type overdrive_booksCreateWithoutBookInput = {
    overdrive_id: number
    catalogue_id: bigint | number
    isbn: bigint | number
    physical_isbn?: string | null
    title: string
    subtitle?: string | null
    edition?: number | null
    series?: number | null
    publisher: string
    imprint?: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date | string
    pub_date?: Date | string | null
    status: string
    sample_link: string
    readbox_enabled?: string | null
    special_features?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    type_of_book?: number | null
  }

  export type overdrive_booksUncheckedCreateWithoutBookInput = {
    id?: number
    overdrive_id: number
    catalogue_id: bigint | number
    isbn: bigint | number
    physical_isbn?: string | null
    title: string
    subtitle?: string | null
    edition?: number | null
    series?: number | null
    publisher: string
    imprint?: string | null
    creators: string
    subject: string
    format: string
    filesize: number
    whs_usd: number
    whs_usddiscount: number
    lib_usd: number
    lib_usddiscount: number
    onsale_date: Date | string
    pub_date?: Date | string | null
    status: string
    sample_link: string
    readbox_enabled?: string | null
    special_features?: string | null
    author_id: number
    copyright_owner?: number | null
    language_id: number
    type_of_book?: number | null
  }

  export type overdrive_booksCreateOrConnectWithoutBookInput = {
    where: overdrive_booksWhereUniqueInput
    create: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
  }

  export type audible_booksCreateWithoutBookInput = {
    product_id?: string | null
    audible_asin?: string | null
    amazon_asin?: string | null
    title?: string | null
    authors?: string | null
    narrators?: string | null
    first_online_date?: Date | string | null
    language_id?: number | null
    author_id?: number | null
    copyright_owner?: number | null
  }

  export type audible_booksUncheckedCreateWithoutBookInput = {
    id?: number
    product_id?: string | null
    audible_asin?: string | null
    amazon_asin?: string | null
    title?: string | null
    authors?: string | null
    narrators?: string | null
    first_online_date?: Date | string | null
    language_id?: number | null
    author_id?: number | null
    copyright_owner?: number | null
  }

  export type audible_booksCreateOrConnectWithoutBookInput = {
    where: audible_booksWhereUniqueInput
    create: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
  }

  export type author_gift_booksCreateWithoutBookInput = {
    author_id?: number | null
    book_id?: number | null
    date?: Date | string | null
    user: users_tblCreateNestedOneWithoutGiftBooksInput
  }

  export type author_gift_booksUncheckedCreateWithoutBookInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    user_id: number
    date?: Date | string | null
  }

  export type author_gift_booksCreateOrConnectWithoutBookInput = {
    where: author_gift_booksWhereUniqueInput
    create: XOR<author_gift_booksCreateWithoutBookInput, author_gift_booksUncheckedCreateWithoutBookInput>
  }

  export type author_gift_booksCreateManyBookInputEnvelope = {
    data: Enumerable<author_gift_booksCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type amazon_transactionsCreateWithoutBookInput = {
    invoice_date: Date | string
    original_invoice_date?: Date | string | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    author_id: number
    user_id?: number | null
    copyright_owner?: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value?: number | null
    final_royalty_value: number
    status: string
  }

  export type amazon_transactionsUncheckedCreateWithoutBookInput = {
    id?: number
    invoice_date: Date | string
    original_invoice_date?: Date | string | null
    asin: string
    physical_isbn10: string
    physical_isbn13: string
    digital_isbn: string
    title: string
    author: string
    units_purchased: number
    units_refunded: number
    net_units: number
    net_units_mtd: number
    adjustments_made: number
    list_price: number
    list_price_currency: string
    publisher_price: number
    publisher_price_currency: string
    discount_percentage: number
    payment_amount: number
    payment_currency: string
    program_type: string
    author_id: number
    user_id?: number | null
    copyright_owner?: number | null
    language_id: number
    currency_exchange: number
    inr_value: number
    tax_value?: number | null
    final_royalty_value: number
    status: string
  }

  export type amazon_transactionsCreateOrConnectWithoutBookInput = {
    where: amazon_transactionsWhereUniqueInput
    create: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
  }

  export type audible_transactionsCreateWithoutBookInput = {
    royalty_earner?: string | null
    parent_product_id?: string | null
    name?: string | null
    author?: string | null
    isbn?: string | null
    provider_product_id?: string | null
    market_place?: string | null
    offer?: string | null
    royalty_rate?: string | null
    alc_qty?: number | null
    alc_net_sales?: number | null
    alc_royalty?: number | null
    al_qty?: number | null
    al_net_sales?: number | null
    al_royalty?: number | null
    alop_qty?: number | null
    alop_net_sales?: number | null
    alop_royalty?: number | null
    total_qty?: number | null
    total_net_sales?: number | null
    total_royalty?: number | null
    author_id?: number | null
    language_id?: number | null
    copyright_owner?: number | null
    user_id?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type audible_transactionsUncheckedCreateWithoutBookInput = {
    id?: number
    royalty_earner?: string | null
    parent_product_id?: string | null
    name?: string | null
    author?: string | null
    isbn?: string | null
    provider_product_id?: string | null
    market_place?: string | null
    offer?: string | null
    royalty_rate?: string | null
    alc_qty?: number | null
    alc_net_sales?: number | null
    alc_royalty?: number | null
    al_qty?: number | null
    al_net_sales?: number | null
    al_royalty?: number | null
    alop_qty?: number | null
    alop_net_sales?: number | null
    alop_royalty?: number | null
    total_qty?: number | null
    total_net_sales?: number | null
    total_royalty?: number | null
    author_id?: number | null
    language_id?: number | null
    copyright_owner?: number | null
    user_id?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type audible_transactionsCreateOrConnectWithoutBookInput = {
    where: audible_transactionsWhereUniqueInput
    create: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
  }

  export type author_transactionCreateWithoutBookInput = {
    order_id: bigint | number
    order_date?: Date | string | null
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner?: number | null
    currency?: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
  }

  export type author_transactionUncheckedCreateWithoutBookInput = {
    id?: number
    order_id: bigint | number
    order_date?: Date | string | null
    author_id: number
    order_type: string
    copy_right_seller: number
    copy_right_lender: number
    copyright_owner?: number | null
    currency?: string | null
    book_final_royalty_value_inr: number
    book_final_royalty_value_usd: number
    discount_provided: number
    usd_exchange_rate: number
    converted_book_final_royalty_value_inr: number
    exchange_rate_comments: string
    selling_royalty_percentage: number
    lending_royalty_percentage: number
    pay_status: string
    comments: string
  }

  export type author_transactionCreateOrConnectWithoutBookInput = {
    where: author_transactionWhereUniqueInput
    create: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
  }

  export type google_transactionsCreateWithoutBookInput = {
    earnings_date: Date | string
    transaction_date: Date | string
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status?: string | null
  }

  export type google_transactionsUncheckedCreateWithoutBookInput = {
    id?: number
    earnings_date: Date | string
    transaction_date: Date | string
    unique_id: string
    product: string
    type: string
    preorder: string
    qty: number
    primary_isbn: string
    imprint_name: string
    title: string
    author: string
    original_list_price_currency: string
    original_list_price: number
    list_price_currency: string
    list_price_tax_inclusive: number
    list_price_tax_exclusive: number
    country_of_sale: string
    publisher_revenue_percentage: string
    publisher_revenue: number
    earnings_currency: string
    earnings_amount: number
    currency_conversion_rate: number
    line_of_business: string
    author_id: number
    language_id: number
    currency_exchange: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status?: string | null
  }

  export type google_transactionsCreateOrConnectWithoutBookInput = {
    where: google_transactionsWhereUniqueInput
    create: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
  }

  export type kobo_transactionCreateWithoutBookInput = {
    transaction_date: Date | string
    country: string
    state?: string | null
    zipcode?: string | null
    content_type?: string | null
    quantity?: number | null
    refund_reason?: string | null
    dealID?: string | null
    publisher_name?: string | null
    imprint?: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded?: number | null
    COGS_percentage: number
    COGS_amount?: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp?: number | null
    COGS_based_lp_excluded_tax?: number | null
    COGS_based_lp_currency?: number | null
    COGS_adjustment?: number | null
    net_due: number
    payable_currency: string
    total_tax?: number | null
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type kobo_transactionUncheckedCreateWithoutBookInput = {
    id?: number
    transaction_date: Date | string
    country: string
    state?: string | null
    zipcode?: string | null
    content_type?: string | null
    quantity?: number | null
    refund_reason?: string | null
    dealID?: string | null
    publisher_name?: string | null
    imprint?: string | null
    eISBN: string
    author_name: string
    book_title: string
    list_price: number
    tax_excluded?: number | null
    COGS_percentage: number
    COGS_amount?: number | null
    list_price_currency: string
    foreign_exchange: number
    COGS_payable: number
    COGS_based_lp?: number | null
    COGS_based_lp_excluded_tax?: number | null
    COGS_based_lp_currency?: number | null
    COGS_adjustment?: number | null
    net_due: number
    payable_currency: string
    total_tax?: number | null
    author_id: number
    paid_inr: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type kobo_transactionCreateOrConnectWithoutBookInput = {
    where: kobo_transactionWhereUniqueInput
    create: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
  }

  export type overdrive_transactionsCreateWithoutBookInput = {
    transaction_date: Date | string
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type overdrive_transactionsUncheckedCreateWithoutBookInput = {
    id?: number
    transaction_date: Date | string
    overdrive_id: number
    isbn: number
    title: string
    subtitle: string
    author: string
    retailer: string
    country_of_sale: string
    format: string
    srp_usd: number
    discount: number
    amt_owed_usd: number
    author_id: number
    language_id: number
    exchange_rate: number
    inr_value: number
    final_royalty_value: number
    user_id: number
    copyright_owner?: number | null
    status: string
  }

  export type overdrive_transactionsCreateOrConnectWithoutBookInput = {
    where: overdrive_transactionsWhereUniqueInput
    create: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
  }

  export type scribd_transactionCreateWithoutBookInput = {
    Payout_month: Date | string
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint | number
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date | string
    Last_date_of_interaction: Date | string
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date | string
    author_id: number
    language_id?: number | null
    converted_inr: number
    user_id?: number | null
    copyright_owner?: number | null
    status: string
    exchange_rate: number
    converted_inr_full?: number | null
  }

  export type scribd_transactionUncheckedCreateWithoutBookInput = {
    S_No?: number
    Payout_month: Date | string
    Publisher: string
    Amount_owed_for_this_interaction: number
    Amount_owed_currency: string
    Price_in_original_currency: number
    Digital_list_price: number
    Original_currency: string
    Price_type: string
    ISBN: bigint | number
    Title: string
    Authors: string
    Imprints: string
    Viewed: string
    Payout_type: string
    Start_date_of_interaction: Date | string
    Last_date_of_interaction: Date | string
    Country_of_reader: string
    Unique_interaction_ID: string
    ISO_Country_Code: string
    Threshold_Date: Date | string
    author_id: number
    language_id?: number | null
    converted_inr: number
    user_id?: number | null
    copyright_owner?: number | null
    status: string
    exchange_rate: number
    converted_inr_full?: number | null
  }

  export type scribd_transactionCreateOrConnectWithoutBookInput = {
    where: scribd_transactionWhereUniqueInput
    create: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
  }

  export type storytel_transactionsCreateWithoutBookInput = {
    author?: string | null
    title?: string | null
    isbn?: string | null
    country?: string | null
    price_model?: string | null
    no_of_units?: number | null
    net_receipts_per_hour_local?: number | null
    ecb_exchange_rate?: string | null
    net_receipts_per_hour_inr?: number | null
    book_length_in_hours?: number | null
    price_per_unit?: number | null
    remuneration_eur?: number | null
    remuneration_inr?: number | null
    publisher?: string | null
    imprint?: string | null
    consumption_dates?: string | null
    book_type?: string | null
    author_id?: number | null
    language_id?: number | null
    user_id?: bigint | number | null
    copyright_owner?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type storytel_transactionsUncheckedCreateWithoutBookInput = {
    id?: number
    author?: string | null
    title?: string | null
    isbn?: string | null
    country?: string | null
    price_model?: string | null
    no_of_units?: number | null
    net_receipts_per_hour_local?: number | null
    ecb_exchange_rate?: string | null
    net_receipts_per_hour_inr?: number | null
    book_length_in_hours?: number | null
    price_per_unit?: number | null
    remuneration_eur?: number | null
    remuneration_inr?: number | null
    publisher?: string | null
    imprint?: string | null
    consumption_dates?: string | null
    book_type?: string | null
    author_id?: number | null
    language_id?: number | null
    user_id?: bigint | number | null
    copyright_owner?: number | null
    final_royalty_value?: number | null
    transaction_date?: Date | string | null
    status?: string | null
  }

  export type storytel_transactionsCreateOrConnectWithoutBookInput = {
    where: storytel_transactionsWhereUniqueInput
    create: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
  }

  export type language_tblUpsertWithoutBooksInput = {
    update: XOR<language_tblUpdateWithoutBooksInput, language_tblUncheckedUpdateWithoutBooksInput>
    create: XOR<language_tblCreateWithoutBooksInput, language_tblUncheckedCreateWithoutBooksInput>
  }

  export type language_tblUpdateWithoutBooksInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authorLanguages?: author_languageUpdateManyWithoutLanguageNestedInput
  }

  export type language_tblUncheckedUpdateWithoutBooksInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    language_name?: StringFieldUpdateOperationsInput | string
    regional_language_name?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authorLanguages?: author_languageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type genre_details_tblUpsertWithoutBooksInput = {
    update: XOR<genre_details_tblUpdateWithoutBooksInput, genre_details_tblUncheckedUpdateWithoutBooksInput>
    create: XOR<genre_details_tblCreateWithoutBooksInput, genre_details_tblUncheckedCreateWithoutBooksInput>
  }

  export type genre_details_tblUpdateWithoutBooksInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type genre_details_tblUncheckedUpdateWithoutBooksInput = {
    genre_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    genre_name?: StringFieldUpdateOperationsInput | string
    url_name?: StringFieldUpdateOperationsInput | string
    lang_0?: NullableStringFieldUpdateOperationsInput | string | null
    lang_1?: StringFieldUpdateOperationsInput | string
    lang_2?: StringFieldUpdateOperationsInput | string
    lang_3?: StringFieldUpdateOperationsInput | string
    lang_4?: StringFieldUpdateOperationsInput | string
    lang_5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    bisac_code?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type amazon_booksUpsertWithoutBookInput = {
    update: XOR<amazon_booksUpdateWithoutBookInput, amazon_booksUncheckedUpdateWithoutBookInput>
    create: XOR<amazon_booksCreateWithoutBookInput, amazon_booksUncheckedCreateWithoutBookInput>
  }

  export type amazon_booksUpdateWithoutBookInput = {
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type amazon_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    activate?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: StringFieldUpdateOperationsInput | string
    print_book_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    eisbn?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    editors?: NullableStringFieldUpdateOperationsInput | string | null
    illustrators?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableStringFieldUpdateOperationsInput | string | null
    translators?: NullableStringFieldUpdateOperationsInput | string | null
    photographers?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    digital_list_price_usd?: FloatFieldUpdateOperationsInput | number
    digital_list_price_inr?: FloatFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    publishing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bisac?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    exclude_territory?: NullableStringFieldUpdateOperationsInput | string | null
    adult_flag?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series_title?: NullableStringFieldUpdateOperationsInput | string | null
    series_number?: NullableIntFieldUpdateOperationsInput | number | null
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    asin?: StringFieldUpdateOperationsInput | string
    amazon_url?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ku_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_activation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ku_us_enabled?: NullableIntFieldUpdateOperationsInput | number | null
    ku_uk_enabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_booksUpsertWithoutBookInput = {
    update: XOR<scribd_booksUpdateWithoutBookInput, scribd_booksUncheckedUpdateWithoutBookInput>
    create: XOR<scribd_booksCreateWithoutBookInput, scribd_booksUncheckedCreateWithoutBookInput>
  }

  export type scribd_booksUpdateWithoutBookInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scribd_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: IntFieldUpdateOperationsInput | number
    doc_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    in_subscription?: BoolFieldUpdateOperationsInput | boolean
    product_page_url?: NullableStringFieldUpdateOperationsInput | string | null
    imprints?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publisher_tools_config_id?: NullableIntFieldUpdateOperationsInput | number | null
    metadata_status?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_status?: NullableStringFieldUpdateOperationsInput | string | null
    product_page_pending?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_pending?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    duplicate_flag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type google_booksUpsertWithoutBookInput = {
    update: XOR<google_booksUpdateWithoutBookInput, google_booksUncheckedUpdateWithoutBookInput>
    create: XOR<google_booksCreateWithoutBookInput, google_booksUncheckedCreateWithoutBookInput>
  }

  export type google_booksUpdateWithoutBookInput = {
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    play_store_link?: NullableStringFieldUpdateOperationsInput | string | null
    enable_for_sale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    book_format?: NullableStringFieldUpdateOperationsInput | string | null
    related_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    contributor?: NullableStringFieldUpdateOperationsInput | string | null
    biographical_note?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: NullableIntFieldUpdateOperationsInput | number | null
    series_name?: NullableStringFieldUpdateOperationsInput | string | null
    volume_in_series?: NullableIntFieldUpdateOperationsInput | number | null
    preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    preview_territories?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link_text?: NullableStringFieldUpdateOperationsInput | string | null
    buy_link?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_website?: NullableStringFieldUpdateOperationsInput | string | null
    show_photos_preview?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pdf_download?: NullableBoolFieldUpdateOperationsInput | boolean | null
    on_sale_date?: NullableStringFieldUpdateOperationsInput | string | null
    drm_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    show_photos_ebook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    include_scanned_pages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mature_audiences?: NullableBoolFieldUpdateOperationsInput | boolean | null
    copy_paste_percentage?: NullableStringFieldUpdateOperationsInput | string | null
    enable_school_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_list_price_60?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_180?: NullableFloatFieldUpdateOperationsInput | number | null
    school_list_price_360?: NullableFloatFieldUpdateOperationsInput | number | null
    school_use_countries?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preview_length_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    preview_length_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    abridged_version?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_including_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    inr_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    inr_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    usd_price_excluding_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    usd_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_price_including_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_price_excluding_tax?: NullableIntFieldUpdateOperationsInput | number | null
    eur_countries_including_tax?: NullableStringFieldUpdateOperationsInput | string | null
    eur_countries_excluding_tax?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storytel_booksUpsertWithoutBookInput = {
    update: XOR<storytel_booksUpdateWithoutBookInput, storytel_booksUncheckedUpdateWithoutBookInput>
    create: XOR<storytel_booksCreateWithoutBookInput, storytel_booksUncheckedCreateWithoutBookInput>
  }

  export type storytel_booksUpdateWithoutBookInput = {
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storytel_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    storytel_book_id?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    narrator?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_booksUpsertWithoutBookInput = {
    update: XOR<overdrive_booksUpdateWithoutBookInput, overdrive_booksUncheckedUpdateWithoutBookInput>
    create: XOR<overdrive_booksCreateWithoutBookInput, overdrive_booksUncheckedCreateWithoutBookInput>
  }

  export type overdrive_booksUpdateWithoutBookInput = {
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type overdrive_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    overdrive_id?: IntFieldUpdateOperationsInput | number
    catalogue_id?: BigIntFieldUpdateOperationsInput | bigint | number
    isbn?: BigIntFieldUpdateOperationsInput | bigint | number
    physical_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableIntFieldUpdateOperationsInput | number | null
    series?: NullableIntFieldUpdateOperationsInput | number | null
    publisher?: StringFieldUpdateOperationsInput | string
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    creators?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filesize?: IntFieldUpdateOperationsInput | number
    whs_usd?: FloatFieldUpdateOperationsInput | number
    whs_usddiscount?: IntFieldUpdateOperationsInput | number
    lib_usd?: FloatFieldUpdateOperationsInput | number
    lib_usddiscount?: IntFieldUpdateOperationsInput | number
    onsale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sample_link?: StringFieldUpdateOperationsInput | string
    readbox_enabled?: NullableStringFieldUpdateOperationsInput | string | null
    special_features?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    type_of_book?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_booksUpsertWithoutBookInput = {
    update: XOR<audible_booksUpdateWithoutBookInput, audible_booksUncheckedUpdateWithoutBookInput>
    create: XOR<audible_booksCreateWithoutBookInput, audible_booksUncheckedCreateWithoutBookInput>
  }

  export type audible_booksUpdateWithoutBookInput = {
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audible_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    audible_asin?: NullableStringFieldUpdateOperationsInput | string | null
    amazon_asin?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    narrators?: NullableStringFieldUpdateOperationsInput | string | null
    first_online_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type author_gift_booksUpsertWithWhereUniqueWithoutBookInput = {
    where: author_gift_booksWhereUniqueInput
    update: XOR<author_gift_booksUpdateWithoutBookInput, author_gift_booksUncheckedUpdateWithoutBookInput>
    create: XOR<author_gift_booksCreateWithoutBookInput, author_gift_booksUncheckedCreateWithoutBookInput>
  }

  export type author_gift_booksUpdateWithWhereUniqueWithoutBookInput = {
    where: author_gift_booksWhereUniqueInput
    data: XOR<author_gift_booksUpdateWithoutBookInput, author_gift_booksUncheckedUpdateWithoutBookInput>
  }

  export type author_gift_booksUpdateManyWithWhereWithoutBookInput = {
    where: author_gift_booksScalarWhereInput
    data: XOR<author_gift_booksUpdateManyMutationInput, author_gift_booksUncheckedUpdateManyWithoutGiftBooksInput>
  }

  export type author_gift_booksScalarWhereInput = {
    AND?: Enumerable<author_gift_booksScalarWhereInput>
    OR?: Enumerable<author_gift_booksScalarWhereInput>
    NOT?: Enumerable<author_gift_booksScalarWhereInput>
    id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    book_id?: IntNullableFilter | number | null
    user_id?: IntFilter | number
    date?: DateTimeNullableFilter | Date | string | null
    bookId?: IntFilter | number
  }

  export type amazon_transactionsUpsertWithoutBookInput = {
    update: XOR<amazon_transactionsUpdateWithoutBookInput, amazon_transactionsUncheckedUpdateWithoutBookInput>
    create: XOR<amazon_transactionsCreateWithoutBookInput, amazon_transactionsUncheckedCreateWithoutBookInput>
  }

  export type amazon_transactionsUpdateWithoutBookInput = {
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type amazon_transactionsUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string
    original_invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asin?: StringFieldUpdateOperationsInput | string
    physical_isbn10?: StringFieldUpdateOperationsInput | string
    physical_isbn13?: StringFieldUpdateOperationsInput | string
    digital_isbn?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    units_purchased?: IntFieldUpdateOperationsInput | number
    units_refunded?: IntFieldUpdateOperationsInput | number
    net_units?: IntFieldUpdateOperationsInput | number
    net_units_mtd?: IntFieldUpdateOperationsInput | number
    adjustments_made?: IntFieldUpdateOperationsInput | number
    list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    publisher_price?: FloatFieldUpdateOperationsInput | number
    publisher_price_currency?: StringFieldUpdateOperationsInput | string
    discount_percentage?: IntFieldUpdateOperationsInput | number
    payment_amount?: FloatFieldUpdateOperationsInput | number
    payment_currency?: StringFieldUpdateOperationsInput | string
    program_type?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    tax_value?: NullableFloatFieldUpdateOperationsInput | number | null
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type audible_transactionsUpsertWithoutBookInput = {
    update: XOR<audible_transactionsUpdateWithoutBookInput, audible_transactionsUncheckedUpdateWithoutBookInput>
    create: XOR<audible_transactionsCreateWithoutBookInput, audible_transactionsUncheckedCreateWithoutBookInput>
  }

  export type audible_transactionsUpdateWithoutBookInput = {
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audible_transactionsUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    royalty_earner?: NullableStringFieldUpdateOperationsInput | string | null
    parent_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    provider_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    market_place?: NullableStringFieldUpdateOperationsInput | string | null
    offer?: NullableStringFieldUpdateOperationsInput | string | null
    royalty_rate?: NullableStringFieldUpdateOperationsInput | string | null
    alc_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alc_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alc_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    al_qty?: NullableIntFieldUpdateOperationsInput | number | null
    al_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    al_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_qty?: NullableIntFieldUpdateOperationsInput | number | null
    alop_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    alop_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    total_qty?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_sales?: NullableFloatFieldUpdateOperationsInput | number | null
    total_royalty?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_transactionUpsertWithoutBookInput = {
    update: XOR<author_transactionUpdateWithoutBookInput, author_transactionUncheckedUpdateWithoutBookInput>
    create: XOR<author_transactionCreateWithoutBookInput, author_transactionUncheckedCreateWithoutBookInput>
  }

  export type author_transactionUpdateWithoutBookInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type author_transactionUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author_id?: IntFieldUpdateOperationsInput | number
    order_type?: StringFieldUpdateOperationsInput | string
    copy_right_seller?: IntFieldUpdateOperationsInput | number
    copy_right_lender?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    book_final_royalty_value_usd?: FloatFieldUpdateOperationsInput | number
    discount_provided?: FloatFieldUpdateOperationsInput | number
    usd_exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_book_final_royalty_value_inr?: FloatFieldUpdateOperationsInput | number
    exchange_rate_comments?: StringFieldUpdateOperationsInput | string
    selling_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    lending_royalty_percentage?: FloatFieldUpdateOperationsInput | number
    pay_status?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type google_transactionsUpsertWithoutBookInput = {
    update: XOR<google_transactionsUpdateWithoutBookInput, google_transactionsUncheckedUpdateWithoutBookInput>
    create: XOR<google_transactionsCreateWithoutBookInput, google_transactionsUncheckedCreateWithoutBookInput>
  }

  export type google_transactionsUpdateWithoutBookInput = {
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type google_transactionsUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    earnings_date?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preorder?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    primary_isbn?: StringFieldUpdateOperationsInput | string
    imprint_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    original_list_price_currency?: StringFieldUpdateOperationsInput | string
    original_list_price?: FloatFieldUpdateOperationsInput | number
    list_price_currency?: StringFieldUpdateOperationsInput | string
    list_price_tax_inclusive?: FloatFieldUpdateOperationsInput | number
    list_price_tax_exclusive?: FloatFieldUpdateOperationsInput | number
    country_of_sale?: StringFieldUpdateOperationsInput | string
    publisher_revenue_percentage?: StringFieldUpdateOperationsInput | string
    publisher_revenue?: FloatFieldUpdateOperationsInput | number
    earnings_currency?: StringFieldUpdateOperationsInput | string
    earnings_amount?: FloatFieldUpdateOperationsInput | number
    currency_conversion_rate?: FloatFieldUpdateOperationsInput | number
    line_of_business?: StringFieldUpdateOperationsInput | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    currency_exchange?: FloatFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kobo_transactionUpsertWithoutBookInput = {
    update: XOR<kobo_transactionUpdateWithoutBookInput, kobo_transactionUncheckedUpdateWithoutBookInput>
    create: XOR<kobo_transactionCreateWithoutBookInput, kobo_transactionUncheckedCreateWithoutBookInput>
  }

  export type kobo_transactionUpdateWithoutBookInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type kobo_transactionUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    dealID?: NullableStringFieldUpdateOperationsInput | string | null
    publisher_name?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    eISBN?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    book_title?: StringFieldUpdateOperationsInput | string
    list_price?: IntFieldUpdateOperationsInput | number
    tax_excluded?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_percentage?: FloatFieldUpdateOperationsInput | number
    COGS_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    list_price_currency?: StringFieldUpdateOperationsInput | string
    foreign_exchange?: FloatFieldUpdateOperationsInput | number
    COGS_payable?: FloatFieldUpdateOperationsInput | number
    COGS_based_lp?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_excluded_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_based_lp_currency?: NullableFloatFieldUpdateOperationsInput | number | null
    COGS_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    net_due?: FloatFieldUpdateOperationsInput | number
    payable_currency?: StringFieldUpdateOperationsInput | string
    total_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: IntFieldUpdateOperationsInput | number
    paid_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type overdrive_transactionsUpsertWithoutBookInput = {
    update: XOR<overdrive_transactionsUpdateWithoutBookInput, overdrive_transactionsUncheckedUpdateWithoutBookInput>
    create: XOR<overdrive_transactionsCreateWithoutBookInput, overdrive_transactionsUncheckedCreateWithoutBookInput>
  }

  export type overdrive_transactionsUpdateWithoutBookInput = {
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type overdrive_transactionsUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    overdrive_id?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    country_of_sale?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    srp_usd?: FloatFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    amt_owed_usd?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    exchange_rate?: IntFieldUpdateOperationsInput | number
    inr_value?: FloatFieldUpdateOperationsInput | number
    final_royalty_value?: FloatFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type scribd_transactionUpsertWithoutBookInput = {
    update: XOR<scribd_transactionUpdateWithoutBookInput, scribd_transactionUncheckedUpdateWithoutBookInput>
    create: XOR<scribd_transactionCreateWithoutBookInput, scribd_transactionUncheckedCreateWithoutBookInput>
  }

  export type scribd_transactionUpdateWithoutBookInput = {
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type scribd_transactionUncheckedUpdateWithoutBookInput = {
    S_No?: IntFieldUpdateOperationsInput | number
    Payout_month?: DateTimeFieldUpdateOperationsInput | Date | string
    Publisher?: StringFieldUpdateOperationsInput | string
    Amount_owed_for_this_interaction?: FloatFieldUpdateOperationsInput | number
    Amount_owed_currency?: StringFieldUpdateOperationsInput | string
    Price_in_original_currency?: FloatFieldUpdateOperationsInput | number
    Digital_list_price?: FloatFieldUpdateOperationsInput | number
    Original_currency?: StringFieldUpdateOperationsInput | string
    Price_type?: StringFieldUpdateOperationsInput | string
    ISBN?: BigIntFieldUpdateOperationsInput | bigint | number
    Title?: StringFieldUpdateOperationsInput | string
    Authors?: StringFieldUpdateOperationsInput | string
    Imprints?: StringFieldUpdateOperationsInput | string
    Viewed?: StringFieldUpdateOperationsInput | string
    Payout_type?: StringFieldUpdateOperationsInput | string
    Start_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Last_date_of_interaction?: DateTimeFieldUpdateOperationsInput | Date | string
    Country_of_reader?: StringFieldUpdateOperationsInput | string
    Unique_interaction_ID?: StringFieldUpdateOperationsInput | string
    ISO_Country_Code?: StringFieldUpdateOperationsInput | string
    Threshold_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: IntFieldUpdateOperationsInput | number
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    converted_inr?: FloatFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    exchange_rate?: FloatFieldUpdateOperationsInput | number
    converted_inr_full?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type storytel_transactionsUpsertWithoutBookInput = {
    update: XOR<storytel_transactionsUpdateWithoutBookInput, storytel_transactionsUncheckedUpdateWithoutBookInput>
    create: XOR<storytel_transactionsCreateWithoutBookInput, storytel_transactionsUncheckedCreateWithoutBookInput>
  }

  export type storytel_transactionsUpdateWithoutBookInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storytel_transactionsUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    price_model?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_units?: NullableFloatFieldUpdateOperationsInput | number | null
    net_receipts_per_hour_local?: NullableFloatFieldUpdateOperationsInput | number | null
    ecb_exchange_rate?: NullableStringFieldUpdateOperationsInput | string | null
    net_receipts_per_hour_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    book_length_in_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_eur?: NullableFloatFieldUpdateOperationsInput | number | null
    remuneration_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    imprint?: NullableStringFieldUpdateOperationsInput | string | null
    consumption_dates?: NullableStringFieldUpdateOperationsInput | string | null
    book_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    language_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    final_royalty_value?: NullableFloatFieldUpdateOperationsInput | number | null
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_tblCreateWithoutGenreInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutGenreInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutGenreInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutGenreInput, book_tblUncheckedCreateWithoutGenreInput>
  }

  export type book_tblCreateManyGenreInputEnvelope = {
    data: Enumerable<book_tblCreateManyGenreInput>
    skipDuplicates?: boolean
  }

  export type book_tblUpsertWithWhereUniqueWithoutGenreInput = {
    where: book_tblWhereUniqueInput
    update: XOR<book_tblUpdateWithoutGenreInput, book_tblUncheckedUpdateWithoutGenreInput>
    create: XOR<book_tblCreateWithoutGenreInput, book_tblUncheckedCreateWithoutGenreInput>
  }

  export type book_tblUpdateWithWhereUniqueWithoutGenreInput = {
    where: book_tblWhereUniqueInput
    data: XOR<book_tblUpdateWithoutGenreInput, book_tblUncheckedUpdateWithoutGenreInput>
  }

  export type book_tblUpdateManyWithWhereWithoutGenreInput = {
    where: book_tblScalarWhereInput
    data: XOR<book_tblUpdateManyMutationInput, book_tblUncheckedUpdateManyWithoutBooksInput>
  }

  export type book_tblScalarWhereInput = {
    AND?: Enumerable<book_tblScalarWhereInput>
    OR?: Enumerable<book_tblScalarWhereInput>
    NOT?: Enumerable<book_tblScalarWhereInput>
    book_id?: IntFilter | number
    author_name?: IntFilter | number
    book_title?: StringFilter | string
    url_name?: StringNullableFilter | string | null
    regional_book_title?: StringFilter | string
    language?: IntFilter | number
    isbn_number?: StringNullableFilter | string | null
    cover_image?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    cost?: IntFilter | number
    number_of_page?: IntNullableFilter | number | null
    genre_id?: IntFilter | number
    book_category?: StringFilter | string
    type_of_book?: IntFilter | number
    publisher?: StringNullableFilter | string | null
    download_link?: StringFilter | string
    epub_url?: StringFilter | string
    royalty?: StringNullableFilter | string | null
    copyright_owner?: IntNullableFilter | number | null
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    activated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: IntFilter | number
    book_cost_international?: FloatFilter | number
    narrator_id?: IntNullableFilter | number | null
    rental_cost_inr?: IntNullableFilter | number | null
    rental_cost_usd?: FloatNullableFilter | number | null
    paper_back_flag?: IntNullableFilter | number | null
    paper_back_inr?: FloatNullableFilter | number | null
    paper_back_royalty?: StringNullableFilter | string | null
    paper_back_readiness_flag?: IntNullableFilter | number | null
    book_id_mapping?: IntNullableFilter | number | null
    agreement_flag?: IntNullableFilter | number | null
    paper_back_pages?: IntNullableFilter | number | null
    paper_back_weight?: FloatNullableFilter | number | null
    paper_back_copyright_owner?: IntNullableFilter | number | null
    paper_back_isbn?: StringNullableFilter | string | null
    paper_back_remarks?: StringNullableFilter | string | null
    mintbook_cost?: IntNullableFilter | number | null
  }

  export type book_tblCreateWithoutGoogleBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutGoogleBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutGoogleBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutGoogleBookIdInput, book_tblUncheckedCreateWithoutGoogleBookIdInput>
  }

  export type book_tblUpsertWithoutGoogleBookIdInput = {
    update: XOR<book_tblUpdateWithoutGoogleBookIdInput, book_tblUncheckedUpdateWithoutGoogleBookIdInput>
    create: XOR<book_tblCreateWithoutGoogleBookIdInput, book_tblUncheckedCreateWithoutGoogleBookIdInput>
  }

  export type book_tblUpdateWithoutGoogleBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutGoogleBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutGoogle_transactionsInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutGoogle_transactionsInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutGoogle_transactionsInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutGoogle_transactionsInput, book_tblUncheckedCreateWithoutGoogle_transactionsInput>
  }

  export type book_tblUpsertWithoutGoogle_transactionsInput = {
    update: XOR<book_tblUpdateWithoutGoogle_transactionsInput, book_tblUncheckedUpdateWithoutGoogle_transactionsInput>
    create: XOR<book_tblCreateWithoutGoogle_transactionsInput, book_tblUncheckedCreateWithoutGoogle_transactionsInput>
  }

  export type book_tblUpdateWithoutGoogle_transactionsInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutGoogle_transactionsInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutKobo_transactionInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutKobo_transactionInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutKobo_transactionInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutKobo_transactionInput, book_tblUncheckedCreateWithoutKobo_transactionInput>
  }

  export type book_tblUpsertWithoutKobo_transactionInput = {
    update: XOR<book_tblUpdateWithoutKobo_transactionInput, book_tblUncheckedUpdateWithoutKobo_transactionInput>
    create: XOR<book_tblCreateWithoutKobo_transactionInput, book_tblUncheckedCreateWithoutKobo_transactionInput>
  }

  export type book_tblUpdateWithoutKobo_transactionInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutKobo_transactionInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutLanguage_tbl_relationInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutLanguage_tbl_relationInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutLanguage_tbl_relationInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutLanguage_tbl_relationInput, book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>
  }

  export type book_tblCreateManyLanguage_tbl_relationInputEnvelope = {
    data: Enumerable<book_tblCreateManyLanguage_tbl_relationInput>
    skipDuplicates?: boolean
  }

  export type author_languageCreateWithoutLanguageInput = {
    author_id?: number | null
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type author_languageUncheckedCreateWithoutLanguageInput = {
    id?: number
    author_id?: number | null
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type author_languageCreateOrConnectWithoutLanguageInput = {
    where: author_languageWhereUniqueInput
    create: XOR<author_languageCreateWithoutLanguageInput, author_languageUncheckedCreateWithoutLanguageInput>
  }

  export type author_languageCreateManyLanguageInputEnvelope = {
    data: Enumerable<author_languageCreateManyLanguageInput>
    skipDuplicates?: boolean
  }

  export type book_tblUpsertWithWhereUniqueWithoutLanguage_tbl_relationInput = {
    where: book_tblWhereUniqueInput
    update: XOR<book_tblUpdateWithoutLanguage_tbl_relationInput, book_tblUncheckedUpdateWithoutLanguage_tbl_relationInput>
    create: XOR<book_tblCreateWithoutLanguage_tbl_relationInput, book_tblUncheckedCreateWithoutLanguage_tbl_relationInput>
  }

  export type book_tblUpdateWithWhereUniqueWithoutLanguage_tbl_relationInput = {
    where: book_tblWhereUniqueInput
    data: XOR<book_tblUpdateWithoutLanguage_tbl_relationInput, book_tblUncheckedUpdateWithoutLanguage_tbl_relationInput>
  }

  export type book_tblUpdateManyWithWhereWithoutLanguage_tbl_relationInput = {
    where: book_tblScalarWhereInput
    data: XOR<book_tblUpdateManyMutationInput, book_tblUncheckedUpdateManyWithoutBooksInput>
  }

  export type author_languageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: author_languageWhereUniqueInput
    update: XOR<author_languageUpdateWithoutLanguageInput, author_languageUncheckedUpdateWithoutLanguageInput>
    create: XOR<author_languageCreateWithoutLanguageInput, author_languageUncheckedCreateWithoutLanguageInput>
  }

  export type author_languageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: author_languageWhereUniqueInput
    data: XOR<author_languageUpdateWithoutLanguageInput, author_languageUncheckedUpdateWithoutLanguageInput>
  }

  export type author_languageUpdateManyWithWhereWithoutLanguageInput = {
    where: author_languageScalarWhereInput
    data: XOR<author_languageUpdateManyMutationInput, author_languageUncheckedUpdateManyWithoutAuthorLanguagesInput>
  }

  export type author_languageScalarWhereInput = {
    AND?: Enumerable<author_languageScalarWhereInput>
    OR?: Enumerable<author_languageScalarWhereInput>
    NOT?: Enumerable<author_languageScalarWhereInput>
    id?: IntFilter | number
    author_id?: IntNullableFilter | number | null
    language_id?: IntFilter | number
    display_name1?: StringNullableFilter | string | null
    display_name2?: StringNullableFilter | string | null
    regional_author_name?: StringNullableFilter | string | null
  }

  export type book_tblCreateWithoutOverdriveBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutOverdriveBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutOverdriveBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutOverdriveBookIdInput, book_tblUncheckedCreateWithoutOverdriveBookIdInput>
  }

  export type book_tblUpsertWithoutOverdriveBookIdInput = {
    update: XOR<book_tblUpdateWithoutOverdriveBookIdInput, book_tblUncheckedUpdateWithoutOverdriveBookIdInput>
    create: XOR<book_tblCreateWithoutOverdriveBookIdInput, book_tblUncheckedCreateWithoutOverdriveBookIdInput>
  }

  export type book_tblUpdateWithoutOverdriveBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutOverdriveBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutOverdrive_transactionsInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutOverdrive_transactionsInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutOverdrive_transactionsInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutOverdrive_transactionsInput, book_tblUncheckedCreateWithoutOverdrive_transactionsInput>
  }

  export type book_tblUpsertWithoutOverdrive_transactionsInput = {
    update: XOR<book_tblUpdateWithoutOverdrive_transactionsInput, book_tblUncheckedUpdateWithoutOverdrive_transactionsInput>
    create: XOR<book_tblCreateWithoutOverdrive_transactionsInput, book_tblUncheckedCreateWithoutOverdrive_transactionsInput>
  }

  export type book_tblUpdateWithoutOverdrive_transactionsInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutOverdrive_transactionsInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutScribdBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutScribdBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutScribdBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutScribdBookIdInput, book_tblUncheckedCreateWithoutScribdBookIdInput>
  }

  export type book_tblUpsertWithoutScribdBookIdInput = {
    update: XOR<book_tblUpdateWithoutScribdBookIdInput, book_tblUncheckedUpdateWithoutScribdBookIdInput>
    create: XOR<book_tblCreateWithoutScribdBookIdInput, book_tblUncheckedCreateWithoutScribdBookIdInput>
  }

  export type book_tblUpdateWithoutScribdBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutScribdBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutScribd_transactionInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutScribd_transactionInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutScribd_transactionInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutScribd_transactionInput, book_tblUncheckedCreateWithoutScribd_transactionInput>
  }

  export type book_tblUpsertWithoutScribd_transactionInput = {
    update: XOR<book_tblUpdateWithoutScribd_transactionInput, book_tblUncheckedUpdateWithoutScribd_transactionInput>
    create: XOR<book_tblCreateWithoutScribd_transactionInput, book_tblUncheckedCreateWithoutScribd_transactionInput>
  }

  export type book_tblUpdateWithoutScribd_transactionInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutScribd_transactionInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutStorytelBookIdInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutStorytelBookIdInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
    storytel_transactions?: storytel_transactionsUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutStorytelBookIdInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutStorytelBookIdInput, book_tblUncheckedCreateWithoutStorytelBookIdInput>
  }

  export type book_tblUpsertWithoutStorytelBookIdInput = {
    update: XOR<book_tblUpdateWithoutStorytelBookIdInput, book_tblUncheckedUpdateWithoutStorytelBookIdInput>
    create: XOR<book_tblCreateWithoutStorytelBookIdInput, book_tblUncheckedCreateWithoutStorytelBookIdInput>
  }

  export type book_tblUpdateWithoutStorytelBookIdInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutStorytelBookIdInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblCreateWithoutStorytel_transactionsInput = {
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language_tbl_relation: language_tblCreateNestedOneWithoutBooksInput
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre: genre_details_tblCreateNestedOneWithoutBooksInput
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksCreateNestedOneWithoutBookInput
    googleBookId?: google_booksCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionCreateNestedOneWithoutBookInput
  }

  export type book_tblUncheckedCreateWithoutStorytel_transactionsInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
    amazonBookId?: amazon_booksUncheckedCreateNestedOneWithoutBookInput
    scribdBookId?: scribd_booksUncheckedCreateNestedOneWithoutBookInput
    googleBookId?: google_booksUncheckedCreateNestedOneWithoutBookInput
    storytelBookId?: storytel_booksUncheckedCreateNestedOneWithoutBookInput
    overdriveBookId?: overdrive_booksUncheckedCreateNestedOneWithoutBookInput
    audibleBookId?: audible_booksUncheckedCreateNestedOneWithoutBookInput
    giftBooks?: author_gift_booksUncheckedCreateNestedManyWithoutBookInput
    amazon_transactions?: amazon_transactionsUncheckedCreateNestedOneWithoutBookInput
    audible_transactions?: audible_transactionsUncheckedCreateNestedOneWithoutBookInput
    author_transaction?: author_transactionUncheckedCreateNestedOneWithoutBookInput
    google_transactions?: google_transactionsUncheckedCreateNestedOneWithoutBookInput
    kobo_transaction?: kobo_transactionUncheckedCreateNestedOneWithoutBookInput
    overdrive_transactions?: overdrive_transactionsUncheckedCreateNestedOneWithoutBookInput
    scribd_transaction?: scribd_transactionUncheckedCreateNestedOneWithoutBookInput
  }

  export type book_tblCreateOrConnectWithoutStorytel_transactionsInput = {
    where: book_tblWhereUniqueInput
    create: XOR<book_tblCreateWithoutStorytel_transactionsInput, book_tblUncheckedCreateWithoutStorytel_transactionsInput>
  }

  export type book_tblUpsertWithoutStorytel_transactionsInput = {
    update: XOR<book_tblUpdateWithoutStorytel_transactionsInput, book_tblUncheckedUpdateWithoutStorytel_transactionsInput>
    create: XOR<book_tblCreateWithoutStorytel_transactionsInput, book_tblUncheckedCreateWithoutStorytel_transactionsInput>
  }

  export type book_tblUpdateWithoutStorytel_transactionsInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutStorytel_transactionsInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
  }

  export type author_gift_booksCreateWithoutUserInput = {
    author_id?: number | null
    book_id?: number | null
    date?: Date | string | null
    book: book_tblCreateNestedOneWithoutGiftBooksInput
  }

  export type author_gift_booksUncheckedCreateWithoutUserInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    date?: Date | string | null
    bookId: number
  }

  export type author_gift_booksCreateOrConnectWithoutUserInput = {
    where: author_gift_booksWhereUniqueInput
    create: XOR<author_gift_booksCreateWithoutUserInput, author_gift_booksUncheckedCreateWithoutUserInput>
  }

  export type author_gift_booksCreateManyUserInputEnvelope = {
    data: Enumerable<author_gift_booksCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type author_gift_booksUpsertWithWhereUniqueWithoutUserInput = {
    where: author_gift_booksWhereUniqueInput
    update: XOR<author_gift_booksUpdateWithoutUserInput, author_gift_booksUncheckedUpdateWithoutUserInput>
    create: XOR<author_gift_booksCreateWithoutUserInput, author_gift_booksUncheckedCreateWithoutUserInput>
  }

  export type author_gift_booksUpdateWithWhereUniqueWithoutUserInput = {
    where: author_gift_booksWhereUniqueInput
    data: XOR<author_gift_booksUpdateWithoutUserInput, author_gift_booksUncheckedUpdateWithoutUserInput>
  }

  export type author_gift_booksUpdateManyWithWhereWithoutUserInput = {
    where: author_gift_booksScalarWhereInput
    data: XOR<author_gift_booksUpdateManyMutationInput, author_gift_booksUncheckedUpdateManyWithoutGiftBooksInput>
  }

  export type author_gift_booksCreateManyBookInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    user_id: number
    date?: Date | string | null
  }

  export type author_gift_booksUpdateWithoutBookInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: users_tblUpdateOneRequiredWithoutGiftBooksNestedInput
  }

  export type author_gift_booksUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type author_gift_booksUncheckedUpdateManyWithoutGiftBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type book_tblCreateManyGenreInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    language: number
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
  }

  export type book_tblUpdateWithoutGenreInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language_tbl_relation?: language_tblUpdateOneRequiredWithoutBooksNestedInput
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutGenreInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateManyWithoutBooksInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    language?: IntFieldUpdateOperationsInput | number
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type book_tblCreateManyLanguage_tbl_relationInput = {
    book_id?: number
    author_name: number
    book_title: string
    url_name?: string | null
    regional_book_title: string
    isbn_number?: string | null
    cover_image?: string | null
    description?: string | null
    cost: number
    number_of_page?: number | null
    genre_id: number
    book_category?: string
    type_of_book: number
    publisher?: string | null
    download_link: string
    epub_url: string
    royalty?: string | null
    copyright_owner?: number | null
    status?: boolean
    created_at?: Date | string
    activated_at?: Date | string | null
    created_by: number
    book_cost_international?: number
    narrator_id?: number | null
    rental_cost_inr?: number | null
    rental_cost_usd?: number | null
    paper_back_flag?: number | null
    paper_back_inr?: number | null
    paper_back_royalty?: string | null
    paper_back_readiness_flag?: number | null
    book_id_mapping?: number | null
    agreement_flag?: number | null
    paper_back_pages?: number | null
    paper_back_weight?: number | null
    paper_back_copyright_owner?: number | null
    paper_back_isbn?: string | null
    paper_back_remarks?: string | null
    mintbook_cost?: number | null
  }

  export type author_languageCreateManyLanguageInput = {
    id?: number
    author_id?: number | null
    display_name1?: string | null
    display_name2?: string | null
    regional_author_name?: string | null
  }

  export type book_tblUpdateWithoutLanguage_tbl_relationInput = {
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: genre_details_tblUpdateOneRequiredWithoutBooksNestedInput
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUpdateOneWithoutBookNestedInput
  }

  export type book_tblUncheckedUpdateWithoutLanguage_tbl_relationInput = {
    book_id?: IntFieldUpdateOperationsInput | number
    author_name?: IntFieldUpdateOperationsInput | number
    book_title?: StringFieldUpdateOperationsInput | string
    url_name?: NullableStringFieldUpdateOperationsInput | string | null
    regional_book_title?: StringFieldUpdateOperationsInput | string
    isbn_number?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: IntFieldUpdateOperationsInput | number
    number_of_page?: NullableIntFieldUpdateOperationsInput | number | null
    genre_id?: IntFieldUpdateOperationsInput | number
    book_category?: StringFieldUpdateOperationsInput | string
    type_of_book?: IntFieldUpdateOperationsInput | number
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    download_link?: StringFieldUpdateOperationsInput | string
    epub_url?: StringFieldUpdateOperationsInput | string
    royalty?: NullableStringFieldUpdateOperationsInput | string | null
    copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    book_cost_international?: FloatFieldUpdateOperationsInput | number
    narrator_id?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_inr?: NullableIntFieldUpdateOperationsInput | number | null
    rental_cost_usd?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_inr?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_royalty?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_readiness_flag?: NullableIntFieldUpdateOperationsInput | number | null
    book_id_mapping?: NullableIntFieldUpdateOperationsInput | number | null
    agreement_flag?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_pages?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    paper_back_copyright_owner?: NullableIntFieldUpdateOperationsInput | number | null
    paper_back_isbn?: NullableStringFieldUpdateOperationsInput | string | null
    paper_back_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    mintbook_cost?: NullableIntFieldUpdateOperationsInput | number | null
    amazonBookId?: amazon_booksUncheckedUpdateOneWithoutBookNestedInput
    scribdBookId?: scribd_booksUncheckedUpdateOneWithoutBookNestedInput
    googleBookId?: google_booksUncheckedUpdateOneWithoutBookNestedInput
    storytelBookId?: storytel_booksUncheckedUpdateOneWithoutBookNestedInput
    overdriveBookId?: overdrive_booksUncheckedUpdateOneWithoutBookNestedInput
    audibleBookId?: audible_booksUncheckedUpdateOneWithoutBookNestedInput
    giftBooks?: author_gift_booksUncheckedUpdateManyWithoutBookNestedInput
    amazon_transactions?: amazon_transactionsUncheckedUpdateOneWithoutBookNestedInput
    audible_transactions?: audible_transactionsUncheckedUpdateOneWithoutBookNestedInput
    author_transaction?: author_transactionUncheckedUpdateOneWithoutBookNestedInput
    google_transactions?: google_transactionsUncheckedUpdateOneWithoutBookNestedInput
    kobo_transaction?: kobo_transactionUncheckedUpdateOneWithoutBookNestedInput
    overdrive_transactions?: overdrive_transactionsUncheckedUpdateOneWithoutBookNestedInput
    scribd_transaction?: scribd_transactionUncheckedUpdateOneWithoutBookNestedInput
    storytel_transactions?: storytel_transactionsUncheckedUpdateOneWithoutBookNestedInput
  }

  export type author_languageUpdateWithoutLanguageInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_languageUncheckedUpdateWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_languageUncheckedUpdateManyWithoutAuthorLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    display_name1?: NullableStringFieldUpdateOperationsInput | string | null
    display_name2?: NullableStringFieldUpdateOperationsInput | string | null
    regional_author_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type author_gift_booksCreateManyUserInput = {
    id?: number
    author_id?: number | null
    book_id?: number | null
    date?: Date | string | null
    bookId: number
  }

  export type author_gift_booksUpdateWithoutUserInput = {
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: book_tblUpdateOneRequiredWithoutGiftBooksNestedInput
  }

  export type author_gift_booksUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    book_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}